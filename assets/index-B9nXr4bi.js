var i0 = Object.defineProperty;
var j1 = xt => {
    throw TypeError(xt)
}
;
var s0 = (xt, Cn, as) => Cn in xt ? i0(xt, Cn, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: as
}) : xt[Cn] = as;
var B1 = (xt, Cn, as) => s0(xt, typeof Cn != "symbol" ? Cn + "" : Cn, as)
  , y1 = (xt, Cn, as) => Cn.has(xt) || j1("Cannot " + as);
var du = (xt, Cn, as) => (y1(xt, Cn, "read from private field"),
as ? as.call(xt) : Cn.get(xt))
  , ip = (xt, Cn, as) => Cn.has(xt) ? j1("Cannot add the same private member more than once") : Cn instanceof WeakSet ? Cn.add(xt) : Cn.set(xt, as)
  , Zu = (xt, Cn, as, cs) => (y1(xt, Cn, "write to private field"),
cs ? cs.call(xt, as) : Cn.set(xt, as),
as)
  , up = (xt, Cn, as) => (y1(xt, Cn, "access private method"),
as);
var f1 = (xt, Cn, as, cs) => ({
    set _(Cs) {
        Zu(xt, Cn, Cs, as)
    },
    get _() {
        return du(xt, Cn, cs)
    }
});
import "../config.js";
function _mergeNamespaces(xt, Cn) {
    for (var as = 0; as < Cn.length; as++) {
        const cs = Cn[as];
        if (typeof cs != "string" && !Array.isArray(cs)) {
            for (const Cs in cs)
                if (Cs !== "default" && !(Cs in xt)) {
                    const Ls = Object.getOwnPropertyDescriptor(cs, Cs);
                    Ls && Object.defineProperty(xt, Cs, Ls.get ? Ls : {
                        enumerable: !0,
                        get: () => cs[Cs]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(xt, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
    const Cn = document.createElement("link").relList;
    if (Cn && Cn.supports && Cn.supports("modulepreload"))
        return;
    for (const Cs of document.querySelectorAll('link[rel="modulepreload"]'))
        cs(Cs);
    new MutationObserver(Cs => {
        for (const Ls of Cs)
            if (Ls.type === "childList")
                for (const Vs of Ls.addedNodes)
                    Vs.tagName === "LINK" && Vs.rel === "modulepreload" && cs(Vs)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function as(Cs) {
        const Ls = {};
        return Cs.integrity && (Ls.integrity = Cs.integrity),
        Cs.referrerPolicy && (Ls.referrerPolicy = Cs.referrerPolicy),
        Cs.crossOrigin === "use-credentials" ? Ls.credentials = "include" : Cs.crossOrigin === "anonymous" ? Ls.credentials = "omit" : Ls.credentials = "same-origin",
        Ls
    }
    function cs(Cs) {
        if (Cs.ep)
            return;
        Cs.ep = !0;
        const Ls = as(Cs);
        fetch(Cs.href, Ls)
    }
}
)();
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(xt) {
    return xt && xt.__esModule && Object.prototype.hasOwnProperty.call(xt, "default") ? xt.default : xt
}
function getAugmentedNamespace(xt) {
    if (xt.__esModule)
        return xt;
    var Cn = xt.default;
    if (typeof Cn == "function") {
        var as = function cs() {
            return this instanceof cs ? Reflect.construct(Cn, arguments, this.constructor) : Cn.apply(this, arguments)
        };
        as.prototype = Cn.prototype
    } else
        as = {};
    return Object.defineProperty(as, "__esModule", {
        value: !0
    }),
    Object.keys(xt).forEach(function(cs) {
        var Cs = Object.getOwnPropertyDescriptor(xt, cs);
        Object.defineProperty(as, cs, Cs.get ? Cs : {
            enumerable: !0,
            get: function() {
                return xt[cs]
            }
        })
    }),
    as
}
var jsxRuntime$1 = {
    exports: {}
}
  , reactJsxRuntime_production_min$1 = {}
  , react = {
    exports: {}
}
  , react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$8 = Symbol.for("react.element")
  , n$9 = Symbol.for("react.portal")
  , p$9 = Symbol.for("react.fragment")
  , q$4 = Symbol.for("react.strict_mode")
  , r$4 = Symbol.for("react.profiler")
  , t$7 = Symbol.for("react.provider")
  , u$a = Symbol.for("react.context")
  , v$3 = Symbol.for("react.forward_ref")
  , w$5 = Symbol.for("react.suspense")
  , x$5 = Symbol.for("react.memo")
  , y$4 = Symbol.for("react.lazy")
  , z$5 = Symbol.iterator;
function A$6(xt) {
    return xt === null || typeof xt != "object" ? null : (xt = z$5 && xt[z$5] || xt["@@iterator"],
    typeof xt == "function" ? xt : null)
}
var B$3 = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , C$8 = Object.assign
  , D$4 = {};
function E$6(xt, Cn, as) {
    this.props = xt,
    this.context = Cn,
    this.refs = D$4,
    this.updater = as || B$3
}
E$6.prototype.isReactComponent = {};
E$6.prototype.setState = function(xt, Cn) {
    if (typeof xt != "object" && typeof xt != "function" && xt != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, xt, Cn, "setState")
}
;
E$6.prototype.forceUpdate = function(xt) {
    this.updater.enqueueForceUpdate(this, xt, "forceUpdate")
}
;
function F$5() {}
F$5.prototype = E$6.prototype;
function G$4(xt, Cn, as) {
    this.props = xt,
    this.context = Cn,
    this.refs = D$4,
    this.updater = as || B$3
}
var H$9 = G$4.prototype = new F$5;
H$9.constructor = G$4;
C$8(H$9, E$6.prototype);
H$9.isPureReactComponent = !0;
var I$5 = Array.isArray
  , J$5 = Object.prototype.hasOwnProperty
  , K$4 = {
    current: null
}
  , L$4 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function M$8(xt, Cn, as) {
    var cs, Cs = {}, Ls = null, Vs = null;
    if (Cn != null)
        for (cs in Cn.ref !== void 0 && (Vs = Cn.ref),
        Cn.key !== void 0 && (Ls = "" + Cn.key),
        Cn)
            J$5.call(Cn, cs) && !L$4.hasOwnProperty(cs) && (Cs[cs] = Cn[cs]);
    var Ws = arguments.length - 2;
    if (Ws === 1)
        Cs.children = as;
    else if (1 < Ws) {
        for (var Xs = Array(Ws), ga = 0; ga < Ws; ga++)
            Xs[ga] = arguments[ga + 2];
        Cs.children = Xs
    }
    if (xt && xt.defaultProps)
        for (cs in Ws = xt.defaultProps,
        Ws)
            Cs[cs] === void 0 && (Cs[cs] = Ws[cs]);
    return {
        $$typeof: l$8,
        type: xt,
        key: Ls,
        ref: Vs,
        props: Cs,
        _owner: K$4.current
    }
}
function N$4(xt, Cn) {
    return {
        $$typeof: l$8,
        type: xt.type,
        key: Cn,
        ref: xt.ref,
        props: xt.props,
        _owner: xt._owner
    }
}
function O$4(xt) {
    return typeof xt == "object" && xt !== null && xt.$$typeof === l$8
}
function escape$2(xt) {
    var Cn = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + xt.replace(/[=:]/g, function(as) {
        return Cn[as]
    })
}
var P$9 = /\/+/g;
function Q$3(xt, Cn) {
    return typeof xt == "object" && xt !== null && xt.key != null ? escape$2("" + xt.key) : Cn.toString(36)
}
function R$3(xt, Cn, as, cs, Cs) {
    var Ls = typeof xt;
    (Ls === "undefined" || Ls === "boolean") && (xt = null);
    var Vs = !1;
    if (xt === null)
        Vs = !0;
    else
        switch (Ls) {
        case "string":
        case "number":
            Vs = !0;
            break;
        case "object":
            switch (xt.$$typeof) {
            case l$8:
            case n$9:
                Vs = !0
            }
        }
    if (Vs)
        return Vs = xt,
        Cs = Cs(Vs),
        xt = cs === "" ? "." + Q$3(Vs, 0) : cs,
        I$5(Cs) ? (as = "",
        xt != null && (as = xt.replace(P$9, "$&/") + "/"),
        R$3(Cs, Cn, as, "", function(ga) {
            return ga
        })) : Cs != null && (O$4(Cs) && (Cs = N$4(Cs, as + (!Cs.key || Vs && Vs.key === Cs.key ? "" : ("" + Cs.key).replace(P$9, "$&/") + "/") + xt)),
        Cn.push(Cs)),
        1;
    if (Vs = 0,
    cs = cs === "" ? "." : cs + ":",
    I$5(xt))
        for (var Ws = 0; Ws < xt.length; Ws++) {
            Ls = xt[Ws];
            var Xs = cs + Q$3(Ls, Ws);
            Vs += R$3(Ls, Cn, as, Xs, Cs)
        }
    else if (Xs = A$6(xt),
    typeof Xs == "function")
        for (xt = Xs.call(xt),
        Ws = 0; !(Ls = xt.next()).done; )
            Ls = Ls.value,
            Xs = cs + Q$3(Ls, Ws++),
            Vs += R$3(Ls, Cn, as, Xs, Cs);
    else if (Ls === "object")
        throw Cn = String(xt),
        Error("Objects are not valid as a React child (found: " + (Cn === "[object Object]" ? "object with keys {" + Object.keys(xt).join(", ") + "}" : Cn) + "). If you meant to render a collection of children, use an array instead.");
    return Vs
}
function S$5(xt, Cn, as) {
    if (xt == null)
        return xt;
    var cs = []
      , Cs = 0;
    return R$3(xt, cs, "", "", function(Ls) {
        return Cn.call(as, Ls, Cs++)
    }),
    cs
}
function T$6(xt) {
    if (xt._status === -1) {
        var Cn = xt._result;
        Cn = Cn(),
        Cn.then(function(as) {
            (xt._status === 0 || xt._status === -1) && (xt._status = 1,
            xt._result = as)
        }, function(as) {
            (xt._status === 0 || xt._status === -1) && (xt._status = 2,
            xt._result = as)
        }),
        xt._status === -1 && (xt._status = 0,
        xt._result = Cn)
    }
    if (xt._status === 1)
        return xt._result.default;
    throw xt._result
}
var U$6 = {
    current: null
}
  , V$5 = {
    transition: null
}
  , W$3 = {
    ReactCurrentDispatcher: U$6,
    ReactCurrentBatchConfig: V$5,
    ReactCurrentOwner: K$4
};
function X$6() {
    throw Error("act(...) is not supported in production builds of React.")
}
react_production_min.Children = {
    map: S$5,
    forEach: function(xt, Cn, as) {
        S$5(xt, function() {
            Cn.apply(this, arguments)
        }, as)
    },
    count: function(xt) {
        var Cn = 0;
        return S$5(xt, function() {
            Cn++
        }),
        Cn
    },
    toArray: function(xt) {
        return S$5(xt, function(Cn) {
            return Cn
        }) || []
    },
    only: function(xt) {
        if (!O$4(xt))
            throw Error("React.Children.only expected to receive a single React element child.");
        return xt
    }
};
react_production_min.Component = E$6;
react_production_min.Fragment = p$9;
react_production_min.Profiler = r$4;
react_production_min.PureComponent = G$4;
react_production_min.StrictMode = q$4;
react_production_min.Suspense = w$5;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$3;
react_production_min.act = X$6;
react_production_min.cloneElement = function(xt, Cn, as) {
    if (xt == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + xt + ".");
    var cs = C$8({}, xt.props)
      , Cs = xt.key
      , Ls = xt.ref
      , Vs = xt._owner;
    if (Cn != null) {
        if (Cn.ref !== void 0 && (Ls = Cn.ref,
        Vs = K$4.current),
        Cn.key !== void 0 && (Cs = "" + Cn.key),
        xt.type && xt.type.defaultProps)
            var Ws = xt.type.defaultProps;
        for (Xs in Cn)
            J$5.call(Cn, Xs) && !L$4.hasOwnProperty(Xs) && (cs[Xs] = Cn[Xs] === void 0 && Ws !== void 0 ? Ws[Xs] : Cn[Xs])
    }
    var Xs = arguments.length - 2;
    if (Xs === 1)
        cs.children = as;
    else if (1 < Xs) {
        Ws = Array(Xs);
        for (var ga = 0; ga < Xs; ga++)
            Ws[ga] = arguments[ga + 2];
        cs.children = Ws
    }
    return {
        $$typeof: l$8,
        type: xt.type,
        key: Cs,
        ref: Ls,
        props: cs,
        _owner: Vs
    }
}
;
react_production_min.createContext = function(xt) {
    return xt = {
        $$typeof: u$a,
        _currentValue: xt,
        _currentValue2: xt,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    xt.Provider = {
        $$typeof: t$7,
        _context: xt
    },
    xt.Consumer = xt
}
;
react_production_min.createElement = M$8;
react_production_min.createFactory = function(xt) {
    var Cn = M$8.bind(null, xt);
    return Cn.type = xt,
    Cn
}
;
react_production_min.createRef = function() {
    return {
        current: null
    }
}
;
react_production_min.forwardRef = function(xt) {
    return {
        $$typeof: v$3,
        render: xt
    }
}
;
react_production_min.isValidElement = O$4;
react_production_min.lazy = function(xt) {
    return {
        $$typeof: y$4,
        _payload: {
            _status: -1,
            _result: xt
        },
        _init: T$6
    }
}
;
react_production_min.memo = function(xt, Cn) {
    return {
        $$typeof: x$5,
        type: xt,
        compare: Cn === void 0 ? null : Cn
    }
}
;
react_production_min.startTransition = function(xt) {
    var Cn = V$5.transition;
    V$5.transition = {};
    try {
        xt()
    } finally {
        V$5.transition = Cn
    }
}
;
react_production_min.unstable_act = X$6;
react_production_min.useCallback = function(xt, Cn) {
    return U$6.current.useCallback(xt, Cn)
}
;
react_production_min.useContext = function(xt) {
    return U$6.current.useContext(xt)
}
;
react_production_min.useDebugValue = function() {}
;
react_production_min.useDeferredValue = function(xt) {
    return U$6.current.useDeferredValue(xt)
}
;
react_production_min.useEffect = function(xt, Cn) {
    return U$6.current.useEffect(xt, Cn)
}
;
react_production_min.useId = function() {
    return U$6.current.useId()
}
;
react_production_min.useImperativeHandle = function(xt, Cn, as) {
    return U$6.current.useImperativeHandle(xt, Cn, as)
}
;
react_production_min.useInsertionEffect = function(xt, Cn) {
    return U$6.current.useInsertionEffect(xt, Cn)
}
;
react_production_min.useLayoutEffect = function(xt, Cn) {
    return U$6.current.useLayoutEffect(xt, Cn)
}
;
react_production_min.useMemo = function(xt, Cn) {
    return U$6.current.useMemo(xt, Cn)
}
;
react_production_min.useReducer = function(xt, Cn, as) {
    return U$6.current.useReducer(xt, Cn, as)
}
;
react_production_min.useRef = function(xt) {
    return U$6.current.useRef(xt)
}
;
react_production_min.useState = function(xt) {
    return U$6.current.useState(xt)
}
;
react_production_min.useSyncExternalStore = function(xt, Cn, as) {
    return U$6.current.useSyncExternalStore(xt, Cn, as)
}
;
react_production_min.useTransition = function() {
    return U$6.current.useTransition()
}
;
react_production_min.version = "18.3.1";
react.exports = react_production_min;
var reactExports = react.exports;
const React__default = getDefaultExportFromCjs(reactExports)
  , t$6 = _mergeNamespaces({
    __proto__: null,
    default: React__default
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$b = reactExports
  , k$3 = Symbol.for("react.element")
  , l$7 = Symbol.for("react.fragment")
  , m$6 = Object.prototype.hasOwnProperty
  , n$8 = f$b.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , p$8 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function q$3(xt, Cn, as) {
    var cs, Cs = {}, Ls = null, Vs = null;
    as !== void 0 && (Ls = "" + as),
    Cn.key !== void 0 && (Ls = "" + Cn.key),
    Cn.ref !== void 0 && (Vs = Cn.ref);
    for (cs in Cn)
        m$6.call(Cn, cs) && !p$8.hasOwnProperty(cs) && (Cs[cs] = Cn[cs]);
    if (xt && xt.defaultProps)
        for (cs in Cn = xt.defaultProps,
        Cn)
            Cs[cs] === void 0 && (Cs[cs] = Cn[cs]);
    return {
        $$typeof: k$3,
        type: xt,
        key: Ls,
        ref: Vs,
        props: Cs,
        _owner: n$8.current
    }
}
reactJsxRuntime_production_min$1.Fragment = l$7;
reactJsxRuntime_production_min$1.jsx = q$3;
reactJsxRuntime_production_min$1.jsxs = q$3;
jsxRuntime$1.exports = reactJsxRuntime_production_min$1;
var jsxRuntimeExports = jsxRuntime$1.exports
  , buffer = {}
  , base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup$1 = []
  , revLookup = []
  , Arr = typeof Uint8Array < "u" ? Uint8Array : Array
  , code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$8 = 0, len = code.length; i$8 < len; ++i$8)
    lookup$1[i$8] = code[i$8],
    revLookup[code.charCodeAt(i$8)] = i$8;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(xt) {
    var Cn = xt.length;
    if (Cn % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
    var as = xt.indexOf("=");
    as === -1 && (as = Cn);
    var cs = as === Cn ? 0 : 4 - as % 4;
    return [as, cs]
}
function byteLength(xt) {
    var Cn = getLens(xt)
      , as = Cn[0]
      , cs = Cn[1];
    return (as + cs) * 3 / 4 - cs
}
function _byteLength(xt, Cn, as) {
    return (Cn + as) * 3 / 4 - as
}
function toByteArray(xt) {
    var Cn, as = getLens(xt), cs = as[0], Cs = as[1], Ls = new Arr(_byteLength(xt, cs, Cs)), Vs = 0, Ws = Cs > 0 ? cs - 4 : cs, Xs;
    for (Xs = 0; Xs < Ws; Xs += 4)
        Cn = revLookup[xt.charCodeAt(Xs)] << 18 | revLookup[xt.charCodeAt(Xs + 1)] << 12 | revLookup[xt.charCodeAt(Xs + 2)] << 6 | revLookup[xt.charCodeAt(Xs + 3)],
        Ls[Vs++] = Cn >> 16 & 255,
        Ls[Vs++] = Cn >> 8 & 255,
        Ls[Vs++] = Cn & 255;
    return Cs === 2 && (Cn = revLookup[xt.charCodeAt(Xs)] << 2 | revLookup[xt.charCodeAt(Xs + 1)] >> 4,
    Ls[Vs++] = Cn & 255),
    Cs === 1 && (Cn = revLookup[xt.charCodeAt(Xs)] << 10 | revLookup[xt.charCodeAt(Xs + 1)] << 4 | revLookup[xt.charCodeAt(Xs + 2)] >> 2,
    Ls[Vs++] = Cn >> 8 & 255,
    Ls[Vs++] = Cn & 255),
    Ls
}
function tripletToBase64(xt) {
    return lookup$1[xt >> 18 & 63] + lookup$1[xt >> 12 & 63] + lookup$1[xt >> 6 & 63] + lookup$1[xt & 63]
}
function encodeChunk(xt, Cn, as) {
    for (var cs, Cs = [], Ls = Cn; Ls < as; Ls += 3)
        cs = (xt[Ls] << 16 & 16711680) + (xt[Ls + 1] << 8 & 65280) + (xt[Ls + 2] & 255),
        Cs.push(tripletToBase64(cs));
    return Cs.join("")
}
function fromByteArray(xt) {
    for (var Cn, as = xt.length, cs = as % 3, Cs = [], Ls = 16383, Vs = 0, Ws = as - cs; Vs < Ws; Vs += Ls)
        Cs.push(encodeChunk(xt, Vs, Vs + Ls > Ws ? Ws : Vs + Ls));
    return cs === 1 ? (Cn = xt[as - 1],
    Cs.push(lookup$1[Cn >> 2] + lookup$1[Cn << 4 & 63] + "==")) : cs === 2 && (Cn = (xt[as - 2] << 8) + xt[as - 1],
    Cs.push(lookup$1[Cn >> 10] + lookup$1[Cn >> 4 & 63] + lookup$1[Cn << 2 & 63] + "=")),
    Cs.join("")
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(xt, Cn, as, cs, Cs) {
    var Ls, Vs, Ws = Cs * 8 - cs - 1, Xs = (1 << Ws) - 1, ga = Xs >> 1, ba = -7, yl = as ? Cs - 1 : 0, xl = as ? -1 : 1, wl = xt[Cn + yl];
    for (yl += xl,
    Ls = wl & (1 << -ba) - 1,
    wl >>= -ba,
    ba += Ws; ba > 0; Ls = Ls * 256 + xt[Cn + yl],
    yl += xl,
    ba -= 8)
        ;
    for (Vs = Ls & (1 << -ba) - 1,
    Ls >>= -ba,
    ba += cs; ba > 0; Vs = Vs * 256 + xt[Cn + yl],
    yl += xl,
    ba -= 8)
        ;
    if (Ls === 0)
        Ls = 1 - ga;
    else {
        if (Ls === Xs)
            return Vs ? NaN : (wl ? -1 : 1) * (1 / 0);
        Vs = Vs + Math.pow(2, cs),
        Ls = Ls - ga
    }
    return (wl ? -1 : 1) * Vs * Math.pow(2, Ls - cs)
}
;
ieee754.write = function(xt, Cn, as, cs, Cs, Ls) {
    var Vs, Ws, Xs, ga = Ls * 8 - Cs - 1, ba = (1 << ga) - 1, yl = ba >> 1, xl = Cs === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, wl = cs ? 0 : Ls - 1, _l = cs ? 1 : -1, El = Cn < 0 || Cn === 0 && 1 / Cn < 0 ? 1 : 0;
    for (Cn = Math.abs(Cn),
    isNaN(Cn) || Cn === 1 / 0 ? (Ws = isNaN(Cn) ? 1 : 0,
    Vs = ba) : (Vs = Math.floor(Math.log(Cn) / Math.LN2),
    Cn * (Xs = Math.pow(2, -Vs)) < 1 && (Vs--,
    Xs *= 2),
    Vs + yl >= 1 ? Cn += xl / Xs : Cn += xl * Math.pow(2, 1 - yl),
    Cn * Xs >= 2 && (Vs++,
    Xs /= 2),
    Vs + yl >= ba ? (Ws = 0,
    Vs = ba) : Vs + yl >= 1 ? (Ws = (Cn * Xs - 1) * Math.pow(2, Cs),
    Vs = Vs + yl) : (Ws = Cn * Math.pow(2, yl - 1) * Math.pow(2, Cs),
    Vs = 0)); Cs >= 8; xt[as + wl] = Ws & 255,
    wl += _l,
    Ws /= 256,
    Cs -= 8)
        ;
    for (Vs = Vs << Cs | Ws,
    ga += Cs; ga > 0; xt[as + wl] = Vs & 255,
    wl += _l,
    Vs /= 256,
    ga -= 8)
        ;
    xt[as + wl - _l] |= El * 128
}
;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(xt) {
    const Cn = base64Js
      , as = ieee754
      , cs = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    xt.Buffer = Ws,
    xt.SlowBuffer = Sl,
    xt.INSPECT_MAX_BYTES = 50;
    const Cs = 2147483647;
    xt.kMaxLength = Cs,
    Ws.TYPED_ARRAY_SUPPORT = Ls(),
    !Ws.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Ls() {
        try {
            const Bl = new Uint8Array(1)
              , Pl = {
                foo: function() {
                    return 42
                }
            };
            return Object.setPrototypeOf(Pl, Uint8Array.prototype),
            Object.setPrototypeOf(Bl, Pl),
            Bl.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(Ws.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (Ws.isBuffer(this))
                return this.buffer
        }
    }),
    Object.defineProperty(Ws.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (Ws.isBuffer(this))
                return this.byteOffset
        }
    });
    function Vs(Bl) {
        if (Bl > Cs)
            throw new RangeError('The value "' + Bl + '" is invalid for option "size"');
        const Pl = new Uint8Array(Bl);
        return Object.setPrototypeOf(Pl, Ws.prototype),
        Pl
    }
    function Ws(Bl, Pl, Al) {
        if (typeof Bl == "number") {
            if (typeof Pl == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
            return yl(Bl)
        }
        return Xs(Bl, Pl, Al)
    }
    Ws.poolSize = 8192;
    function Xs(Bl, Pl, Al) {
        if (typeof Bl == "string")
            return xl(Bl, Pl);
        if (ArrayBuffer.isView(Bl))
            return _l(Bl);
        if (Bl == null)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Bl);
        if (uu(Bl, ArrayBuffer) || Bl && uu(Bl.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (uu(Bl, SharedArrayBuffer) || Bl && uu(Bl.buffer, SharedArrayBuffer)))
            return El(Bl, Pl, Al);
        if (typeof Bl == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type number');
        const Vl = Bl.valueOf && Bl.valueOf();
        if (Vl != null && Vl !== Bl)
            return Ws.from(Vl, Pl, Al);
        const eu = Cl(Bl);
        if (eu)
            return eu;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Bl[Symbol.toPrimitive] == "function")
            return Ws.from(Bl[Symbol.toPrimitive]("string"), Pl, Al);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Bl)
    }
    Ws.from = function(Bl, Pl, Al) {
        return Xs(Bl, Pl, Al)
    }
    ,
    Object.setPrototypeOf(Ws.prototype, Uint8Array.prototype),
    Object.setPrototypeOf(Ws, Uint8Array);
    function ga(Bl) {
        if (typeof Bl != "number")
            throw new TypeError('"size" argument must be of type number');
        if (Bl < 0)
            throw new RangeError('The value "' + Bl + '" is invalid for option "size"')
    }
    function ba(Bl, Pl, Al) {
        return ga(Bl),
        Bl <= 0 ? Vs(Bl) : Pl !== void 0 ? typeof Al == "string" ? Vs(Bl).fill(Pl, Al) : Vs(Bl).fill(Pl) : Vs(Bl)
    }
    Ws.alloc = function(Bl, Pl, Al) {
        return ba(Bl, Pl, Al)
    }
    ;
    function yl(Bl) {
        return ga(Bl),
        Vs(Bl < 0 ? 0 : $l(Bl) | 0)
    }
    Ws.allocUnsafe = function(Bl) {
        return yl(Bl)
    }
    ,
    Ws.allocUnsafeSlow = function(Bl) {
        return yl(Bl)
    }
    ;
    function xl(Bl, Pl) {
        if ((typeof Pl != "string" || Pl === "") && (Pl = "utf8"),
        !Ws.isEncoding(Pl))
            throw new TypeError("Unknown encoding: " + Pl);
        const Al = Tl(Bl, Pl) | 0;
        let Vl = Vs(Al);
        const eu = Vl.write(Bl, Pl);
        return eu !== Al && (Vl = Vl.slice(0, eu)),
        Vl
    }
    function wl(Bl) {
        const Pl = Bl.length < 0 ? 0 : $l(Bl.length) | 0
          , Al = Vs(Pl);
        for (let Vl = 0; Vl < Pl; Vl += 1)
            Al[Vl] = Bl[Vl] & 255;
        return Al
    }
    function _l(Bl) {
        if (uu(Bl, Uint8Array)) {
            const Pl = new Uint8Array(Bl);
            return El(Pl.buffer, Pl.byteOffset, Pl.byteLength)
        }
        return wl(Bl)
    }
    function El(Bl, Pl, Al) {
        if (Pl < 0 || Bl.byteLength < Pl)
            throw new RangeError('"offset" is outside of buffer bounds');
        if (Bl.byteLength < Pl + (Al || 0))
            throw new RangeError('"length" is outside of buffer bounds');
        let Vl;
        return Pl === void 0 && Al === void 0 ? Vl = new Uint8Array(Bl) : Al === void 0 ? Vl = new Uint8Array(Bl,Pl) : Vl = new Uint8Array(Bl,Pl,Al),
        Object.setPrototypeOf(Vl, Ws.prototype),
        Vl
    }
    function Cl(Bl) {
        if (Ws.isBuffer(Bl)) {
            const Pl = $l(Bl.length) | 0
              , Al = Vs(Pl);
            return Al.length === 0 || Bl.copy(Al, 0, 0, Pl),
            Al
        }
        if (Bl.length !== void 0)
            return typeof Bl.length != "number" || gu(Bl.length) ? Vs(0) : wl(Bl);
        if (Bl.type === "Buffer" && Array.isArray(Bl.data))
            return wl(Bl.data)
    }
    function $l(Bl) {
        if (Bl >= Cs)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Cs.toString(16) + " bytes");
        return Bl | 0
    }
    function Sl(Bl) {
        return +Bl != Bl && (Bl = 0),
        Ws.alloc(+Bl)
    }
    Ws.isBuffer = function(Pl) {
        return Pl != null && Pl._isBuffer === !0 && Pl !== Ws.prototype
    }
    ,
    Ws.compare = function(Pl, Al) {
        if (uu(Pl, Uint8Array) && (Pl = Ws.from(Pl, Pl.offset, Pl.byteLength)),
        uu(Al, Uint8Array) && (Al = Ws.from(Al, Al.offset, Al.byteLength)),
        !Ws.isBuffer(Pl) || !Ws.isBuffer(Al))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (Pl === Al)
            return 0;
        let Vl = Pl.length
          , eu = Al.length;
        for (let iu = 0, ou = Math.min(Vl, eu); iu < ou; ++iu)
            if (Pl[iu] !== Al[iu]) {
                Vl = Pl[iu],
                eu = Al[iu];
                break
            }
        return Vl < eu ? -1 : eu < Vl ? 1 : 0
    }
    ,
    Ws.isEncoding = function(Pl) {
        switch (String(Pl).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1
        }
    }
    ,
    Ws.concat = function(Pl, Al) {
        if (!Array.isArray(Pl))
            throw new TypeError('"list" argument must be an Array of Buffers');
        if (Pl.length === 0)
            return Ws.alloc(0);
        let Vl;
        if (Al === void 0)
            for (Al = 0,
            Vl = 0; Vl < Pl.length; ++Vl)
                Al += Pl[Vl].length;
        const eu = Ws.allocUnsafe(Al);
        let iu = 0;
        for (Vl = 0; Vl < Pl.length; ++Vl) {
            let ou = Pl[Vl];
            if (uu(ou, Uint8Array))
                iu + ou.length > eu.length ? (Ws.isBuffer(ou) || (ou = Ws.from(ou)),
                ou.copy(eu, iu)) : Uint8Array.prototype.set.call(eu, ou, iu);
            else if (Ws.isBuffer(ou))
                ou.copy(eu, iu);
            else
                throw new TypeError('"list" argument must be an Array of Buffers');
            iu += ou.length
        }
        return eu
    }
    ;
    function Tl(Bl, Pl) {
        if (Ws.isBuffer(Bl))
            return Bl.length;
        if (ArrayBuffer.isView(Bl) || uu(Bl, ArrayBuffer))
            return Bl.byteLength;
        if (typeof Bl != "string")
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Bl);
        const Al = Bl.length
          , Vl = arguments.length > 2 && arguments[2] === !0;
        if (!Vl && Al === 0)
            return 0;
        let eu = !1;
        for (; ; )
            switch (Pl) {
            case "ascii":
            case "latin1":
            case "binary":
                return Al;
            case "utf8":
            case "utf-8":
                return lp(Bl).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Al * 2;
            case "hex":
                return Al >>> 1;
            case "base64":
                return fp(Bl).length;
            default:
                if (eu)
                    return Vl ? -1 : lp(Bl).length;
                Pl = ("" + Pl).toLowerCase(),
                eu = !0
            }
    }
    Ws.byteLength = Tl;
    function Rl(Bl, Pl, Al) {
        let Vl = !1;
        if ((Pl === void 0 || Pl < 0) && (Pl = 0),
        Pl > this.length || ((Al === void 0 || Al > this.length) && (Al = this.length),
        Al <= 0) || (Al >>>= 0,
        Pl >>>= 0,
        Al <= Pl))
            return "";
        for (Bl || (Bl = "utf8"); ; )
            switch (Bl) {
            case "hex":
                return Yl(this, Pl, Al);
            case "utf8":
            case "utf-8":
                return Wl(this, Pl, Al);
            case "ascii":
                return pu(this, Pl, Al);
            case "latin1":
            case "binary":
                return zl(this, Pl, Al);
            case "base64":
                return Gl(this, Pl, Al);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return lu(this, Pl, Al);
            default:
                if (Vl)
                    throw new TypeError("Unknown encoding: " + Bl);
                Bl = (Bl + "").toLowerCase(),
                Vl = !0
            }
    }
    Ws.prototype._isBuffer = !0;
    function Il(Bl, Pl, Al) {
        const Vl = Bl[Pl];
        Bl[Pl] = Bl[Al],
        Bl[Al] = Vl
    }
    Ws.prototype.swap16 = function() {
        const Pl = this.length;
        if (Pl % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let Al = 0; Al < Pl; Al += 2)
            Il(this, Al, Al + 1);
        return this
    }
    ,
    Ws.prototype.swap32 = function() {
        const Pl = this.length;
        if (Pl % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let Al = 0; Al < Pl; Al += 4)
            Il(this, Al, Al + 3),
            Il(this, Al + 1, Al + 2);
        return this
    }
    ,
    Ws.prototype.swap64 = function() {
        const Pl = this.length;
        if (Pl % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let Al = 0; Al < Pl; Al += 8)
            Il(this, Al, Al + 7),
            Il(this, Al + 1, Al + 6),
            Il(this, Al + 2, Al + 5),
            Il(this, Al + 3, Al + 4);
        return this
    }
    ,
    Ws.prototype.toString = function() {
        const Pl = this.length;
        return Pl === 0 ? "" : arguments.length === 0 ? Wl(this, 0, Pl) : Rl.apply(this, arguments)
    }
    ,
    Ws.prototype.toLocaleString = Ws.prototype.toString,
    Ws.prototype.equals = function(Pl) {
        if (!Ws.isBuffer(Pl))
            throw new TypeError("Argument must be a Buffer");
        return this === Pl ? !0 : Ws.compare(this, Pl) === 0
    }
    ,
    Ws.prototype.inspect = function() {
        let Pl = "";
        const Al = xt.INSPECT_MAX_BYTES;
        return Pl = this.toString("hex", 0, Al).replace(/(.{2})/g, "$1 ").trim(),
        this.length > Al && (Pl += " ... "),
        "<Buffer " + Pl + ">"
    }
    ,
    cs && (Ws.prototype[cs] = Ws.prototype.inspect),
    Ws.prototype.compare = function(Pl, Al, Vl, eu, iu) {
        if (uu(Pl, Uint8Array) && (Pl = Ws.from(Pl, Pl.offset, Pl.byteLength)),
        !Ws.isBuffer(Pl))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Pl);
        if (Al === void 0 && (Al = 0),
        Vl === void 0 && (Vl = Pl ? Pl.length : 0),
        eu === void 0 && (eu = 0),
        iu === void 0 && (iu = this.length),
        Al < 0 || Vl > Pl.length || eu < 0 || iu > this.length)
            throw new RangeError("out of range index");
        if (eu >= iu && Al >= Vl)
            return 0;
        if (eu >= iu)
            return -1;
        if (Al >= Vl)
            return 1;
        if (Al >>>= 0,
        Vl >>>= 0,
        eu >>>= 0,
        iu >>>= 0,
        this === Pl)
            return 0;
        let ou = iu - eu
          , Tu = Vl - Al;
        const Hu = Math.min(ou, Tu)
          , Mu = this.slice(eu, iu)
          , Uu = Pl.slice(Al, Vl);
        for (let Yu = 0; Yu < Hu; ++Yu)
            if (Mu[Yu] !== Uu[Yu]) {
                ou = Mu[Yu],
                Tu = Uu[Yu];
                break
            }
        return ou < Tu ? -1 : Tu < ou ? 1 : 0
    }
    ;
    function Ml(Bl, Pl, Al, Vl, eu) {
        if (Bl.length === 0)
            return -1;
        if (typeof Al == "string" ? (Vl = Al,
        Al = 0) : Al > 2147483647 ? Al = 2147483647 : Al < -2147483648 && (Al = -2147483648),
        Al = +Al,
        gu(Al) && (Al = eu ? 0 : Bl.length - 1),
        Al < 0 && (Al = Bl.length + Al),
        Al >= Bl.length) {
            if (eu)
                return -1;
            Al = Bl.length - 1
        } else if (Al < 0)
            if (eu)
                Al = 0;
            else
                return -1;
        if (typeof Pl == "string" && (Pl = Ws.from(Pl, Vl)),
        Ws.isBuffer(Pl))
            return Pl.length === 0 ? -1 : Nl(Bl, Pl, Al, Vl, eu);
        if (typeof Pl == "number")
            return Pl = Pl & 255,
            typeof Uint8Array.prototype.indexOf == "function" ? eu ? Uint8Array.prototype.indexOf.call(Bl, Pl, Al) : Uint8Array.prototype.lastIndexOf.call(Bl, Pl, Al) : Nl(Bl, [Pl], Al, Vl, eu);
        throw new TypeError("val must be string, number or Buffer")
    }
    function Nl(Bl, Pl, Al, Vl, eu) {
        let iu = 1
          , ou = Bl.length
          , Tu = Pl.length;
        if (Vl !== void 0 && (Vl = String(Vl).toLowerCase(),
        Vl === "ucs2" || Vl === "ucs-2" || Vl === "utf16le" || Vl === "utf-16le")) {
            if (Bl.length < 2 || Pl.length < 2)
                return -1;
            iu = 2,
            ou /= 2,
            Tu /= 2,
            Al /= 2
        }
        function Hu(Uu, Yu) {
            return iu === 1 ? Uu[Yu] : Uu.readUInt16BE(Yu * iu)
        }
        let Mu;
        if (eu) {
            let Uu = -1;
            for (Mu = Al; Mu < ou; Mu++)
                if (Hu(Bl, Mu) === Hu(Pl, Uu === -1 ? 0 : Mu - Uu)) {
                    if (Uu === -1 && (Uu = Mu),
                    Mu - Uu + 1 === Tu)
                        return Uu * iu
                } else
                    Uu !== -1 && (Mu -= Mu - Uu),
                    Uu = -1
        } else
            for (Al + Tu > ou && (Al = ou - Tu),
            Mu = Al; Mu >= 0; Mu--) {
                let Uu = !0;
                for (let Yu = 0; Yu < Tu; Yu++)
                    if (Hu(Bl, Mu + Yu) !== Hu(Pl, Yu)) {
                        Uu = !1;
                        break
                    }
                if (Uu)
                    return Mu
            }
        return -1
    }
    Ws.prototype.includes = function(Pl, Al, Vl) {
        return this.indexOf(Pl, Al, Vl) !== -1
    }
    ,
    Ws.prototype.indexOf = function(Pl, Al, Vl) {
        return Ml(this, Pl, Al, Vl, !0)
    }
    ,
    Ws.prototype.lastIndexOf = function(Pl, Al, Vl) {
        return Ml(this, Pl, Al, Vl, !1)
    }
    ;
    function Ll(Bl, Pl, Al, Vl) {
        Al = Number(Al) || 0;
        const eu = Bl.length - Al;
        Vl ? (Vl = Number(Vl),
        Vl > eu && (Vl = eu)) : Vl = eu;
        const iu = Pl.length;
        Vl > iu / 2 && (Vl = iu / 2);
        let ou;
        for (ou = 0; ou < Vl; ++ou) {
            const Tu = parseInt(Pl.substr(ou * 2, 2), 16);
            if (gu(Tu))
                return ou;
            Bl[Al + ou] = Tu
        }
        return ou
    }
    function Fl(Bl, Pl, Al, Vl) {
        return Lp(lp(Pl, Bl.length - Al), Bl, Al, Vl)
    }
    function Ul(Bl, Pl, Al, Vl) {
        return Lp(qu(Pl), Bl, Al, Vl)
    }
    function Dl(Bl, Pl, Al, Vl) {
        return Lp(fp(Pl), Bl, Al, Vl)
    }
    function Zl(Bl, Pl, Al, Vl) {
        return Lp(hp(Pl, Bl.length - Al), Bl, Al, Vl)
    }
    Ws.prototype.write = function(Pl, Al, Vl, eu) {
        if (Al === void 0)
            eu = "utf8",
            Vl = this.length,
            Al = 0;
        else if (Vl === void 0 && typeof Al == "string")
            eu = Al,
            Vl = this.length,
            Al = 0;
        else if (isFinite(Al))
            Al = Al >>> 0,
            isFinite(Vl) ? (Vl = Vl >>> 0,
            eu === void 0 && (eu = "utf8")) : (eu = Vl,
            Vl = void 0);
        else
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const iu = this.length - Al;
        if ((Vl === void 0 || Vl > iu) && (Vl = iu),
        Pl.length > 0 && (Vl < 0 || Al < 0) || Al > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
        eu || (eu = "utf8");
        let ou = !1;
        for (; ; )
            switch (eu) {
            case "hex":
                return Ll(this, Pl, Al, Vl);
            case "utf8":
            case "utf-8":
                return Fl(this, Pl, Al, Vl);
            case "ascii":
            case "latin1":
            case "binary":
                return Ul(this, Pl, Al, Vl);
            case "base64":
                return Dl(this, Pl, Al, Vl);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Zl(this, Pl, Al, Vl);
            default:
                if (ou)
                    throw new TypeError("Unknown encoding: " + eu);
                eu = ("" + eu).toLowerCase(),
                ou = !0
            }
    }
    ,
    Ws.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    }
    ;
    function Gl(Bl, Pl, Al) {
        return Pl === 0 && Al === Bl.length ? Cn.fromByteArray(Bl) : Cn.fromByteArray(Bl.slice(Pl, Al))
    }
    function Wl(Bl, Pl, Al) {
        Al = Math.min(Bl.length, Al);
        const Vl = [];
        let eu = Pl;
        for (; eu < Al; ) {
            const iu = Bl[eu];
            let ou = null
              , Tu = iu > 239 ? 4 : iu > 223 ? 3 : iu > 191 ? 2 : 1;
            if (eu + Tu <= Al) {
                let Hu, Mu, Uu, Yu;
                switch (Tu) {
                case 1:
                    iu < 128 && (ou = iu);
                    break;
                case 2:
                    Hu = Bl[eu + 1],
                    (Hu & 192) === 128 && (Yu = (iu & 31) << 6 | Hu & 63,
                    Yu > 127 && (ou = Yu));
                    break;
                case 3:
                    Hu = Bl[eu + 1],
                    Mu = Bl[eu + 2],
                    (Hu & 192) === 128 && (Mu & 192) === 128 && (Yu = (iu & 15) << 12 | (Hu & 63) << 6 | Mu & 63,
                    Yu > 2047 && (Yu < 55296 || Yu > 57343) && (ou = Yu));
                    break;
                case 4:
                    Hu = Bl[eu + 1],
                    Mu = Bl[eu + 2],
                    Uu = Bl[eu + 3],
                    (Hu & 192) === 128 && (Mu & 192) === 128 && (Uu & 192) === 128 && (Yu = (iu & 15) << 18 | (Hu & 63) << 12 | (Mu & 63) << 6 | Uu & 63,
                    Yu > 65535 && Yu < 1114112 && (ou = Yu))
                }
            }
            ou === null ? (ou = 65533,
            Tu = 1) : ou > 65535 && (ou -= 65536,
            Vl.push(ou >>> 10 & 1023 | 55296),
            ou = 56320 | ou & 1023),
            Vl.push(ou),
            eu += Tu
        }
        return cu(Vl)
    }
    const Ql = 4096;
    function cu(Bl) {
        const Pl = Bl.length;
        if (Pl <= Ql)
            return String.fromCharCode.apply(String, Bl);
        let Al = ""
          , Vl = 0;
        for (; Vl < Pl; )
            Al += String.fromCharCode.apply(String, Bl.slice(Vl, Vl += Ql));
        return Al
    }
    function pu(Bl, Pl, Al) {
        let Vl = "";
        Al = Math.min(Bl.length, Al);
        for (let eu = Pl; eu < Al; ++eu)
            Vl += String.fromCharCode(Bl[eu] & 127);
        return Vl
    }
    function zl(Bl, Pl, Al) {
        let Vl = "";
        Al = Math.min(Bl.length, Al);
        for (let eu = Pl; eu < Al; ++eu)
            Vl += String.fromCharCode(Bl[eu]);
        return Vl
    }
    function Yl(Bl, Pl, Al) {
        const Vl = Bl.length;
        (!Pl || Pl < 0) && (Pl = 0),
        (!Al || Al < 0 || Al > Vl) && (Al = Vl);
        let eu = "";
        for (let iu = Pl; iu < Al; ++iu)
            eu += Eu[Bl[iu]];
        return eu
    }
    function lu(Bl, Pl, Al) {
        const Vl = Bl.slice(Pl, Al);
        let eu = "";
        for (let iu = 0; iu < Vl.length - 1; iu += 2)
            eu += String.fromCharCode(Vl[iu] + Vl[iu + 1] * 256);
        return eu
    }
    Ws.prototype.slice = function(Pl, Al) {
        const Vl = this.length;
        Pl = ~~Pl,
        Al = Al === void 0 ? Vl : ~~Al,
        Pl < 0 ? (Pl += Vl,
        Pl < 0 && (Pl = 0)) : Pl > Vl && (Pl = Vl),
        Al < 0 ? (Al += Vl,
        Al < 0 && (Al = 0)) : Al > Vl && (Al = Vl),
        Al < Pl && (Al = Pl);
        const eu = this.subarray(Pl, Al);
        return Object.setPrototypeOf(eu, Ws.prototype),
        eu
    }
    ;
    function mu(Bl, Pl, Al) {
        if (Bl % 1 !== 0 || Bl < 0)
            throw new RangeError("offset is not uint");
        if (Bl + Pl > Al)
            throw new RangeError("Trying to access beyond buffer length")
    }
    Ws.prototype.readUintLE = Ws.prototype.readUIntLE = function(Pl, Al, Vl) {
        Pl = Pl >>> 0,
        Al = Al >>> 0,
        Vl || mu(Pl, Al, this.length);
        let eu = this[Pl]
          , iu = 1
          , ou = 0;
        for (; ++ou < Al && (iu *= 256); )
            eu += this[Pl + ou] * iu;
        return eu
    }
    ,
    Ws.prototype.readUintBE = Ws.prototype.readUIntBE = function(Pl, Al, Vl) {
        Pl = Pl >>> 0,
        Al = Al >>> 0,
        Vl || mu(Pl, Al, this.length);
        let eu = this[Pl + --Al]
          , iu = 1;
        for (; Al > 0 && (iu *= 256); )
            eu += this[Pl + --Al] * iu;
        return eu
    }
    ,
    Ws.prototype.readUint8 = Ws.prototype.readUInt8 = function(Pl, Al) {
        return Pl = Pl >>> 0,
        Al || mu(Pl, 1, this.length),
        this[Pl]
    }
    ,
    Ws.prototype.readUint16LE = Ws.prototype.readUInt16LE = function(Pl, Al) {
        return Pl = Pl >>> 0,
        Al || mu(Pl, 2, this.length),
        this[Pl] | this[Pl + 1] << 8
    }
    ,
    Ws.prototype.readUint16BE = Ws.prototype.readUInt16BE = function(Pl, Al) {
        return Pl = Pl >>> 0,
        Al || mu(Pl, 2, this.length),
        this[Pl] << 8 | this[Pl + 1]
    }
    ,
    Ws.prototype.readUint32LE = Ws.prototype.readUInt32LE = function(Pl, Al) {
        return Pl = Pl >>> 0,
        Al || mu(Pl, 4, this.length),
        (this[Pl] | this[Pl + 1] << 8 | this[Pl + 2] << 16) + this[Pl + 3] * 16777216
    }
    ,
    Ws.prototype.readUint32BE = Ws.prototype.readUInt32BE = function(Pl, Al) {
        return Pl = Pl >>> 0,
        Al || mu(Pl, 4, this.length),
        this[Pl] * 16777216 + (this[Pl + 1] << 16 | this[Pl + 2] << 8 | this[Pl + 3])
    }
    ,
    Ws.prototype.readBigUInt64LE = nu(function(Pl) {
        Pl = Pl >>> 0,
        Ru(Pl, "offset");
        const Al = this[Pl]
          , Vl = this[Pl + 7];
        (Al === void 0 || Vl === void 0) && Iu(Pl, this.length - 8);
        const eu = Al + this[++Pl] * 2 ** 8 + this[++Pl] * 2 ** 16 + this[++Pl] * 2 ** 24
          , iu = this[++Pl] + this[++Pl] * 2 ** 8 + this[++Pl] * 2 ** 16 + Vl * 2 ** 24;
        return BigInt(eu) + (BigInt(iu) << BigInt(32))
    }),
    Ws.prototype.readBigUInt64BE = nu(function(Pl) {
        Pl = Pl >>> 0,
        Ru(Pl, "offset");
        const Al = this[Pl]
          , Vl = this[Pl + 7];
        (Al === void 0 || Vl === void 0) && Iu(Pl, this.length - 8);
        const eu = Al * 2 ** 24 + this[++Pl] * 2 ** 16 + this[++Pl] * 2 ** 8 + this[++Pl]
          , iu = this[++Pl] * 2 ** 24 + this[++Pl] * 2 ** 16 + this[++Pl] * 2 ** 8 + Vl;
        return (BigInt(eu) << BigInt(32)) + BigInt(iu)
    }),
    Ws.prototype.readIntLE = function(Pl, Al, Vl) {
        Pl = Pl >>> 0,
        Al = Al >>> 0,
        Vl || mu(Pl, Al, this.length);
        let eu = this[Pl]
          , iu = 1
          , ou = 0;
        for (; ++ou < Al && (iu *= 256); )
            eu += this[Pl + ou] * iu;
        return iu *= 128,
        eu >= iu && (eu -= Math.pow(2, 8 * Al)),
        eu
    }
    ,
    Ws.prototype.readIntBE = function(Pl, Al, Vl) {
        Pl = Pl >>> 0,
        Al = Al >>> 0,
        Vl || mu(Pl, Al, this.length);
        let eu = Al
          , iu = 1
          , ou = this[Pl + --eu];
        for (; eu > 0 && (iu *= 256); )
            ou += this[Pl + --eu] * iu;
        return iu *= 128,
        ou >= iu && (ou -= Math.pow(2, 8 * Al)),
        ou
    }
    ,
    Ws.prototype.readInt8 = function(Pl, Al) {
        return Pl = Pl >>> 0,
        Al || mu(Pl, 1, this.length),
        this[Pl] & 128 ? (255 - this[Pl] + 1) * -1 : this[Pl]
    }
    ,
    Ws.prototype.readInt16LE = function(Pl, Al) {
        Pl = Pl >>> 0,
        Al || mu(Pl, 2, this.length);
        const Vl = this[Pl] | this[Pl + 1] << 8;
        return Vl & 32768 ? Vl | 4294901760 : Vl
    }
    ,
    Ws.prototype.readInt16BE = function(Pl, Al) {
        Pl = Pl >>> 0,
        Al || mu(Pl, 2, this.length);
        const Vl = this[Pl + 1] | this[Pl] << 8;
        return Vl & 32768 ? Vl | 4294901760 : Vl
    }
    ,
    Ws.prototype.readInt32LE = function(Pl, Al) {
        return Pl = Pl >>> 0,
        Al || mu(Pl, 4, this.length),
        this[Pl] | this[Pl + 1] << 8 | this[Pl + 2] << 16 | this[Pl + 3] << 24
    }
    ,
    Ws.prototype.readInt32BE = function(Pl, Al) {
        return Pl = Pl >>> 0,
        Al || mu(Pl, 4, this.length),
        this[Pl] << 24 | this[Pl + 1] << 16 | this[Pl + 2] << 8 | this[Pl + 3]
    }
    ,
    Ws.prototype.readBigInt64LE = nu(function(Pl) {
        Pl = Pl >>> 0,
        Ru(Pl, "offset");
        const Al = this[Pl]
          , Vl = this[Pl + 7];
        (Al === void 0 || Vl === void 0) && Iu(Pl, this.length - 8);
        const eu = this[Pl + 4] + this[Pl + 5] * 2 ** 8 + this[Pl + 6] * 2 ** 16 + (Vl << 24);
        return (BigInt(eu) << BigInt(32)) + BigInt(Al + this[++Pl] * 2 ** 8 + this[++Pl] * 2 ** 16 + this[++Pl] * 2 ** 24)
    }),
    Ws.prototype.readBigInt64BE = nu(function(Pl) {
        Pl = Pl >>> 0,
        Ru(Pl, "offset");
        const Al = this[Pl]
          , Vl = this[Pl + 7];
        (Al === void 0 || Vl === void 0) && Iu(Pl, this.length - 8);
        const eu = (Al << 24) + this[++Pl] * 2 ** 16 + this[++Pl] * 2 ** 8 + this[++Pl];
        return (BigInt(eu) << BigInt(32)) + BigInt(this[++Pl] * 2 ** 24 + this[++Pl] * 2 ** 16 + this[++Pl] * 2 ** 8 + Vl)
    }),
    Ws.prototype.readFloatLE = function(Pl, Al) {
        return Pl = Pl >>> 0,
        Al || mu(Pl, 4, this.length),
        as.read(this, Pl, !0, 23, 4)
    }
    ,
    Ws.prototype.readFloatBE = function(Pl, Al) {
        return Pl = Pl >>> 0,
        Al || mu(Pl, 4, this.length),
        as.read(this, Pl, !1, 23, 4)
    }
    ,
    Ws.prototype.readDoubleLE = function(Pl, Al) {
        return Pl = Pl >>> 0,
        Al || mu(Pl, 8, this.length),
        as.read(this, Pl, !0, 52, 8)
    }
    ,
    Ws.prototype.readDoubleBE = function(Pl, Al) {
        return Pl = Pl >>> 0,
        Al || mu(Pl, 8, this.length),
        as.read(this, Pl, !1, 52, 8)
    }
    ;
    function Cu(Bl, Pl, Al, Vl, eu, iu) {
        if (!Ws.isBuffer(Bl))
            throw new TypeError('"buffer" argument must be a Buffer instance');
        if (Pl > eu || Pl < iu)
            throw new RangeError('"value" argument is out of bounds');
        if (Al + Vl > Bl.length)
            throw new RangeError("Index out of range")
    }
    Ws.prototype.writeUintLE = Ws.prototype.writeUIntLE = function(Pl, Al, Vl, eu) {
        if (Pl = +Pl,
        Al = Al >>> 0,
        Vl = Vl >>> 0,
        !eu) {
            const Tu = Math.pow(2, 8 * Vl) - 1;
            Cu(this, Pl, Al, Vl, Tu, 0)
        }
        let iu = 1
          , ou = 0;
        for (this[Al] = Pl & 255; ++ou < Vl && (iu *= 256); )
            this[Al + ou] = Pl / iu & 255;
        return Al + Vl
    }
    ,
    Ws.prototype.writeUintBE = Ws.prototype.writeUIntBE = function(Pl, Al, Vl, eu) {
        if (Pl = +Pl,
        Al = Al >>> 0,
        Vl = Vl >>> 0,
        !eu) {
            const Tu = Math.pow(2, 8 * Vl) - 1;
            Cu(this, Pl, Al, Vl, Tu, 0)
        }
        let iu = Vl - 1
          , ou = 1;
        for (this[Al + iu] = Pl & 255; --iu >= 0 && (ou *= 256); )
            this[Al + iu] = Pl / ou & 255;
        return Al + Vl
    }
    ,
    Ws.prototype.writeUint8 = Ws.prototype.writeUInt8 = function(Pl, Al, Vl) {
        return Pl = +Pl,
        Al = Al >>> 0,
        Vl || Cu(this, Pl, Al, 1, 255, 0),
        this[Al] = Pl & 255,
        Al + 1
    }
    ,
    Ws.prototype.writeUint16LE = Ws.prototype.writeUInt16LE = function(Pl, Al, Vl) {
        return Pl = +Pl,
        Al = Al >>> 0,
        Vl || Cu(this, Pl, Al, 2, 65535, 0),
        this[Al] = Pl & 255,
        this[Al + 1] = Pl >>> 8,
        Al + 2
    }
    ,
    Ws.prototype.writeUint16BE = Ws.prototype.writeUInt16BE = function(Pl, Al, Vl) {
        return Pl = +Pl,
        Al = Al >>> 0,
        Vl || Cu(this, Pl, Al, 2, 65535, 0),
        this[Al] = Pl >>> 8,
        this[Al + 1] = Pl & 255,
        Al + 2
    }
    ,
    Ws.prototype.writeUint32LE = Ws.prototype.writeUInt32LE = function(Pl, Al, Vl) {
        return Pl = +Pl,
        Al = Al >>> 0,
        Vl || Cu(this, Pl, Al, 4, 4294967295, 0),
        this[Al + 3] = Pl >>> 24,
        this[Al + 2] = Pl >>> 16,
        this[Al + 1] = Pl >>> 8,
        this[Al] = Pl & 255,
        Al + 4
    }
    ,
    Ws.prototype.writeUint32BE = Ws.prototype.writeUInt32BE = function(Pl, Al, Vl) {
        return Pl = +Pl,
        Al = Al >>> 0,
        Vl || Cu(this, Pl, Al, 4, 4294967295, 0),
        this[Al] = Pl >>> 24,
        this[Al + 1] = Pl >>> 16,
        this[Al + 2] = Pl >>> 8,
        this[Al + 3] = Pl & 255,
        Al + 4
    }
    ;
    function ju(Bl, Pl, Al, Vl, eu) {
        xu(Pl, Vl, eu, Bl, Al, 7);
        let iu = Number(Pl & BigInt(4294967295));
        Bl[Al++] = iu,
        iu = iu >> 8,
        Bl[Al++] = iu,
        iu = iu >> 8,
        Bl[Al++] = iu,
        iu = iu >> 8,
        Bl[Al++] = iu;
        let ou = Number(Pl >> BigInt(32) & BigInt(4294967295));
        return Bl[Al++] = ou,
        ou = ou >> 8,
        Bl[Al++] = ou,
        ou = ou >> 8,
        Bl[Al++] = ou,
        ou = ou >> 8,
        Bl[Al++] = ou,
        Al
    }
    function Lu(Bl, Pl, Al, Vl, eu) {
        xu(Pl, Vl, eu, Bl, Al, 7);
        let iu = Number(Pl & BigInt(4294967295));
        Bl[Al + 7] = iu,
        iu = iu >> 8,
        Bl[Al + 6] = iu,
        iu = iu >> 8,
        Bl[Al + 5] = iu,
        iu = iu >> 8,
        Bl[Al + 4] = iu;
        let ou = Number(Pl >> BigInt(32) & BigInt(4294967295));
        return Bl[Al + 3] = ou,
        ou = ou >> 8,
        Bl[Al + 2] = ou,
        ou = ou >> 8,
        Bl[Al + 1] = ou,
        ou = ou >> 8,
        Bl[Al] = ou,
        Al + 8
    }
    Ws.prototype.writeBigUInt64LE = nu(function(Pl, Al=0) {
        return ju(this, Pl, Al, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    Ws.prototype.writeBigUInt64BE = nu(function(Pl, Al=0) {
        return Lu(this, Pl, Al, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    Ws.prototype.writeIntLE = function(Pl, Al, Vl, eu) {
        if (Pl = +Pl,
        Al = Al >>> 0,
        !eu) {
            const Hu = Math.pow(2, 8 * Vl - 1);
            Cu(this, Pl, Al, Vl, Hu - 1, -Hu)
        }
        let iu = 0
          , ou = 1
          , Tu = 0;
        for (this[Al] = Pl & 255; ++iu < Vl && (ou *= 256); )
            Pl < 0 && Tu === 0 && this[Al + iu - 1] !== 0 && (Tu = 1),
            this[Al + iu] = (Pl / ou >> 0) - Tu & 255;
        return Al + Vl
    }
    ,
    Ws.prototype.writeIntBE = function(Pl, Al, Vl, eu) {
        if (Pl = +Pl,
        Al = Al >>> 0,
        !eu) {
            const Hu = Math.pow(2, 8 * Vl - 1);
            Cu(this, Pl, Al, Vl, Hu - 1, -Hu)
        }
        let iu = Vl - 1
          , ou = 1
          , Tu = 0;
        for (this[Al + iu] = Pl & 255; --iu >= 0 && (ou *= 256); )
            Pl < 0 && Tu === 0 && this[Al + iu + 1] !== 0 && (Tu = 1),
            this[Al + iu] = (Pl / ou >> 0) - Tu & 255;
        return Al + Vl
    }
    ,
    Ws.prototype.writeInt8 = function(Pl, Al, Vl) {
        return Pl = +Pl,
        Al = Al >>> 0,
        Vl || Cu(this, Pl, Al, 1, 127, -128),
        Pl < 0 && (Pl = 255 + Pl + 1),
        this[Al] = Pl & 255,
        Al + 1
    }
    ,
    Ws.prototype.writeInt16LE = function(Pl, Al, Vl) {
        return Pl = +Pl,
        Al = Al >>> 0,
        Vl || Cu(this, Pl, Al, 2, 32767, -32768),
        this[Al] = Pl & 255,
        this[Al + 1] = Pl >>> 8,
        Al + 2
    }
    ,
    Ws.prototype.writeInt16BE = function(Pl, Al, Vl) {
        return Pl = +Pl,
        Al = Al >>> 0,
        Vl || Cu(this, Pl, Al, 2, 32767, -32768),
        this[Al] = Pl >>> 8,
        this[Al + 1] = Pl & 255,
        Al + 2
    }
    ,
    Ws.prototype.writeInt32LE = function(Pl, Al, Vl) {
        return Pl = +Pl,
        Al = Al >>> 0,
        Vl || Cu(this, Pl, Al, 4, 2147483647, -2147483648),
        this[Al] = Pl & 255,
        this[Al + 1] = Pl >>> 8,
        this[Al + 2] = Pl >>> 16,
        this[Al + 3] = Pl >>> 24,
        Al + 4
    }
    ,
    Ws.prototype.writeInt32BE = function(Pl, Al, Vl) {
        return Pl = +Pl,
        Al = Al >>> 0,
        Vl || Cu(this, Pl, Al, 4, 2147483647, -2147483648),
        Pl < 0 && (Pl = 4294967295 + Pl + 1),
        this[Al] = Pl >>> 24,
        this[Al + 1] = Pl >>> 16,
        this[Al + 2] = Pl >>> 8,
        this[Al + 3] = Pl & 255,
        Al + 4
    }
    ,
    Ws.prototype.writeBigInt64LE = nu(function(Pl, Al=0) {
        return ju(this, Pl, Al, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }),
    Ws.prototype.writeBigInt64BE = nu(function(Pl, Al=0) {
        return Lu(this, Pl, Al, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });
    function Au(Bl, Pl, Al, Vl, eu, iu) {
        if (Al + Vl > Bl.length)
            throw new RangeError("Index out of range");
        if (Al < 0)
            throw new RangeError("Index out of range")
    }
    function Du(Bl, Pl, Al, Vl, eu) {
        return Pl = +Pl,
        Al = Al >>> 0,
        eu || Au(Bl, Pl, Al, 4),
        as.write(Bl, Pl, Al, Vl, 23, 4),
        Al + 4
    }
    Ws.prototype.writeFloatLE = function(Pl, Al, Vl) {
        return Du(this, Pl, Al, !0, Vl)
    }
    ,
    Ws.prototype.writeFloatBE = function(Pl, Al, Vl) {
        return Du(this, Pl, Al, !1, Vl)
    }
    ;
    function Qu(Bl, Pl, Al, Vl, eu) {
        return Pl = +Pl,
        Al = Al >>> 0,
        eu || Au(Bl, Pl, Al, 8),
        as.write(Bl, Pl, Al, Vl, 52, 8),
        Al + 8
    }
    Ws.prototype.writeDoubleLE = function(Pl, Al, Vl) {
        return Qu(this, Pl, Al, !0, Vl)
    }
    ,
    Ws.prototype.writeDoubleBE = function(Pl, Al, Vl) {
        return Qu(this, Pl, Al, !1, Vl)
    }
    ,
    Ws.prototype.copy = function(Pl, Al, Vl, eu) {
        if (!Ws.isBuffer(Pl))
            throw new TypeError("argument should be a Buffer");
        if (Vl || (Vl = 0),
        !eu && eu !== 0 && (eu = this.length),
        Al >= Pl.length && (Al = Pl.length),
        Al || (Al = 0),
        eu > 0 && eu < Vl && (eu = Vl),
        eu === Vl || Pl.length === 0 || this.length === 0)
            return 0;
        if (Al < 0)
            throw new RangeError("targetStart out of bounds");
        if (Vl < 0 || Vl >= this.length)
            throw new RangeError("Index out of range");
        if (eu < 0)
            throw new RangeError("sourceEnd out of bounds");
        eu > this.length && (eu = this.length),
        Pl.length - Al < eu - Vl && (eu = Pl.length - Al + Vl);
        const iu = eu - Vl;
        return this === Pl && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(Al, Vl, eu) : Uint8Array.prototype.set.call(Pl, this.subarray(Vl, eu), Al),
        iu
    }
    ,
    Ws.prototype.fill = function(Pl, Al, Vl, eu) {
        if (typeof Pl == "string") {
            if (typeof Al == "string" ? (eu = Al,
            Al = 0,
            Vl = this.length) : typeof Vl == "string" && (eu = Vl,
            Vl = this.length),
            eu !== void 0 && typeof eu != "string")
                throw new TypeError("encoding must be a string");
            if (typeof eu == "string" && !Ws.isEncoding(eu))
                throw new TypeError("Unknown encoding: " + eu);
            if (Pl.length === 1) {
                const ou = Pl.charCodeAt(0);
                (eu === "utf8" && ou < 128 || eu === "latin1") && (Pl = ou)
            }
        } else
            typeof Pl == "number" ? Pl = Pl & 255 : typeof Pl == "boolean" && (Pl = Number(Pl));
        if (Al < 0 || this.length < Al || this.length < Vl)
            throw new RangeError("Out of range index");
        if (Vl <= Al)
            return this;
        Al = Al >>> 0,
        Vl = Vl === void 0 ? this.length : Vl >>> 0,
        Pl || (Pl = 0);
        let iu;
        if (typeof Pl == "number")
            for (iu = Al; iu < Vl; ++iu)
                this[iu] = Pl;
        else {
            const ou = Ws.isBuffer(Pl) ? Pl : Ws.from(Pl, eu)
              , Tu = ou.length;
            if (Tu === 0)
                throw new TypeError('The value "' + Pl + '" is invalid for argument "value"');
            for (iu = 0; iu < Vl - Al; ++iu)
                this[iu + Al] = ou[iu % Tu]
        }
        return this
    }
    ;
    const fu = {};
    function yu(Bl, Pl, Al) {
        fu[Bl] = class extends Al {
            constructor() {
                super(),
                Object.defineProperty(this, "message", {
                    value: Pl.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }),
                this.name = `${this.name} [${Bl}]`,
                this.stack,
                delete this.name
            }
            get code() {
                return Bl
            }
            set code(eu) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: eu,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${Bl}]: ${this.message}`
            }
        }
    }
    yu("ERR_BUFFER_OUT_OF_BOUNDS", function(Bl) {
        return Bl ? `${Bl} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError),
    yu("ERR_INVALID_ARG_TYPE", function(Bl, Pl) {
        return `The "${Bl}" argument must be of type number. Received type ${typeof Pl}`
    }, TypeError),
    yu("ERR_OUT_OF_RANGE", function(Bl, Pl, Al) {
        let Vl = `The value of "${Bl}" is out of range.`
          , eu = Al;
        return Number.isInteger(Al) && Math.abs(Al) > 2 ** 32 ? eu = vu(String(Al)) : typeof Al == "bigint" && (eu = String(Al),
        (Al > BigInt(2) ** BigInt(32) || Al < -(BigInt(2) ** BigInt(32))) && (eu = vu(eu)),
        eu += "n"),
        Vl += ` It must be ${Pl}. Received ${eu}`,
        Vl
    }, RangeError);
    function vu(Bl) {
        let Pl = ""
          , Al = Bl.length;
        const Vl = Bl[0] === "-" ? 1 : 0;
        for (; Al >= Vl + 4; Al -= 3)
            Pl = `_${Bl.slice(Al - 3, Al)}${Pl}`;
        return `${Bl.slice(0, Al)}${Pl}`
    }
    function _u(Bl, Pl, Al) {
        Ru(Pl, "offset"),
        (Bl[Pl] === void 0 || Bl[Pl + Al] === void 0) && Iu(Pl, Bl.length - (Al + 1))
    }
    function xu(Bl, Pl, Al, Vl, eu, iu) {
        if (Bl > Al || Bl < Pl) {
            const ou = typeof Pl == "bigint" ? "n" : "";
            let Tu;
            throw Pl === 0 || Pl === BigInt(0) ? Tu = `>= 0${ou} and < 2${ou} ** ${(iu + 1) * 8}${ou}` : Tu = `>= -(2${ou} ** ${(iu + 1) * 8 - 1}${ou}) and < 2 ** ${(iu + 1) * 8 - 1}${ou}`,
            new fu.ERR_OUT_OF_RANGE("value",Tu,Bl)
        }
        _u(Vl, eu, iu)
    }
    function Ru(Bl, Pl) {
        if (typeof Bl != "number")
            throw new fu.ERR_INVALID_ARG_TYPE(Pl,"number",Bl)
    }
    function Iu(Bl, Pl, Al) {
        throw Math.floor(Bl) !== Bl ? (Ru(Bl, Al),
        new fu.ERR_OUT_OF_RANGE("offset","an integer",Bl)) : Pl < 0 ? new fu.ERR_BUFFER_OUT_OF_BOUNDS : new fu.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${Pl}`,Bl)
    }
    const Ku = /[^+/0-9A-Za-z-_]/g;
    function dp(Bl) {
        if (Bl = Bl.split("=")[0],
        Bl = Bl.trim().replace(Ku, ""),
        Bl.length < 2)
            return "";
        for (; Bl.length % 4 !== 0; )
            Bl = Bl + "=";
        return Bl
    }
    function lp(Bl, Pl) {
        Pl = Pl || 1 / 0;
        let Al;
        const Vl = Bl.length;
        let eu = null;
        const iu = [];
        for (let ou = 0; ou < Vl; ++ou) {
            if (Al = Bl.charCodeAt(ou),
            Al > 55295 && Al < 57344) {
                if (!eu) {
                    if (Al > 56319) {
                        (Pl -= 3) > -1 && iu.push(239, 191, 189);
                        continue
                    } else if (ou + 1 === Vl) {
                        (Pl -= 3) > -1 && iu.push(239, 191, 189);
                        continue
                    }
                    eu = Al;
                    continue
                }
                if (Al < 56320) {
                    (Pl -= 3) > -1 && iu.push(239, 191, 189),
                    eu = Al;
                    continue
                }
                Al = (eu - 55296 << 10 | Al - 56320) + 65536
            } else
                eu && (Pl -= 3) > -1 && iu.push(239, 191, 189);
            if (eu = null,
            Al < 128) {
                if ((Pl -= 1) < 0)
                    break;
                iu.push(Al)
            } else if (Al < 2048) {
                if ((Pl -= 2) < 0)
                    break;
                iu.push(Al >> 6 | 192, Al & 63 | 128)
            } else if (Al < 65536) {
                if ((Pl -= 3) < 0)
                    break;
                iu.push(Al >> 12 | 224, Al >> 6 & 63 | 128, Al & 63 | 128)
            } else if (Al < 1114112) {
                if ((Pl -= 4) < 0)
                    break;
                iu.push(Al >> 18 | 240, Al >> 12 & 63 | 128, Al >> 6 & 63 | 128, Al & 63 | 128)
            } else
                throw new Error("Invalid code point")
        }
        return iu
    }
    function qu(Bl) {
        const Pl = [];
        for (let Al = 0; Al < Bl.length; ++Al)
            Pl.push(Bl.charCodeAt(Al) & 255);
        return Pl
    }
    function hp(Bl, Pl) {
        let Al, Vl, eu;
        const iu = [];
        for (let ou = 0; ou < Bl.length && !((Pl -= 2) < 0); ++ou)
            Al = Bl.charCodeAt(ou),
            Vl = Al >> 8,
            eu = Al % 256,
            iu.push(eu),
            iu.push(Vl);
        return iu
    }
    function fp(Bl) {
        return Cn.toByteArray(dp(Bl))
    }
    function Lp(Bl, Pl, Al, Vl) {
        let eu;
        for (eu = 0; eu < Vl && !(eu + Al >= Pl.length || eu >= Bl.length); ++eu)
            Pl[eu + Al] = Bl[eu];
        return eu
    }
    function uu(Bl, Pl) {
        return Bl instanceof Pl || Bl != null && Bl.constructor != null && Bl.constructor.name != null && Bl.constructor.name === Pl.name
    }
    function gu(Bl) {
        return Bl !== Bl
    }
    const Eu = function() {
        const Bl = "0123456789abcdef"
          , Pl = new Array(256);
        for (let Al = 0; Al < 16; ++Al) {
            const Vl = Al * 16;
            for (let eu = 0; eu < 16; ++eu)
                Pl[Vl + eu] = Bl[Al] + Bl[eu]
        }
        return Pl
    }();
    function nu(Bl) {
        return typeof BigInt > "u" ? Kl : Bl
    }
    function Kl() {
        throw new Error("BigInt not supported")
    }
}
)(buffer);
window && !window.Buffer && (window.Buffer = buffer.Buffer);
var client = {}
  , reactDom = {
    exports: {}
}
  , reactDom_production_min = {}
  , scheduler = {
    exports: {}
}
  , scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(xt) {
    function Cn(zl, Yl) {
        var lu = zl.length;
        zl.push(Yl);
        e: for (; 0 < lu; ) {
            var mu = lu - 1 >>> 1
              , Cu = zl[mu];
            if (0 < Cs(Cu, Yl))
                zl[mu] = Yl,
                zl[lu] = Cu,
                lu = mu;
            else
                break e
        }
    }
    function as(zl) {
        return zl.length === 0 ? null : zl[0]
    }
    function cs(zl) {
        if (zl.length === 0)
            return null;
        var Yl = zl[0]
          , lu = zl.pop();
        if (lu !== Yl) {
            zl[0] = lu;
            e: for (var mu = 0, Cu = zl.length, ju = Cu >>> 1; mu < ju; ) {
                var Lu = 2 * (mu + 1) - 1
                  , Au = zl[Lu]
                  , Du = Lu + 1
                  , Qu = zl[Du];
                if (0 > Cs(Au, lu))
                    Du < Cu && 0 > Cs(Qu, Au) ? (zl[mu] = Qu,
                    zl[Du] = lu,
                    mu = Du) : (zl[mu] = Au,
                    zl[Lu] = lu,
                    mu = Lu);
                else if (Du < Cu && 0 > Cs(Qu, lu))
                    zl[mu] = Qu,
                    zl[Du] = lu,
                    mu = Du;
                else
                    break e
            }
        }
        return Yl
    }
    function Cs(zl, Yl) {
        var lu = zl.sortIndex - Yl.sortIndex;
        return lu !== 0 ? lu : zl.id - Yl.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var Ls = performance;
        xt.unstable_now = function() {
            return Ls.now()
        }
    } else {
        var Vs = Date
          , Ws = Vs.now();
        xt.unstable_now = function() {
            return Vs.now() - Ws
        }
    }
    var Xs = []
      , ga = []
      , ba = 1
      , yl = null
      , xl = 3
      , wl = !1
      , _l = !1
      , El = !1
      , Cl = typeof setTimeout == "function" ? setTimeout : null
      , $l = typeof clearTimeout == "function" ? clearTimeout : null
      , Sl = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function Tl(zl) {
        for (var Yl = as(ga); Yl !== null; ) {
            if (Yl.callback === null)
                cs(ga);
            else if (Yl.startTime <= zl)
                cs(ga),
                Yl.sortIndex = Yl.expirationTime,
                Cn(Xs, Yl);
            else
                break;
            Yl = as(ga)
        }
    }
    function Rl(zl) {
        if (El = !1,
        Tl(zl),
        !_l)
            if (as(Xs) !== null)
                _l = !0,
                cu(Il);
            else {
                var Yl = as(ga);
                Yl !== null && pu(Rl, Yl.startTime - zl)
            }
    }
    function Il(zl, Yl) {
        _l = !1,
        El && (El = !1,
        $l(Ll),
        Ll = -1),
        wl = !0;
        var lu = xl;
        try {
            for (Tl(Yl),
            yl = as(Xs); yl !== null && (!(yl.expirationTime > Yl) || zl && !Dl()); ) {
                var mu = yl.callback;
                if (typeof mu == "function") {
                    yl.callback = null,
                    xl = yl.priorityLevel;
                    var Cu = mu(yl.expirationTime <= Yl);
                    Yl = xt.unstable_now(),
                    typeof Cu == "function" ? yl.callback = Cu : yl === as(Xs) && cs(Xs),
                    Tl(Yl)
                } else
                    cs(Xs);
                yl = as(Xs)
            }
            if (yl !== null)
                var ju = !0;
            else {
                var Lu = as(ga);
                Lu !== null && pu(Rl, Lu.startTime - Yl),
                ju = !1
            }
            return ju
        } finally {
            yl = null,
            xl = lu,
            wl = !1
        }
    }
    var Ml = !1
      , Nl = null
      , Ll = -1
      , Fl = 5
      , Ul = -1;
    function Dl() {
        return !(xt.unstable_now() - Ul < Fl)
    }
    function Zl() {
        if (Nl !== null) {
            var zl = xt.unstable_now();
            Ul = zl;
            var Yl = !0;
            try {
                Yl = Nl(!0, zl)
            } finally {
                Yl ? Gl() : (Ml = !1,
                Nl = null)
            }
        } else
            Ml = !1
    }
    var Gl;
    if (typeof Sl == "function")
        Gl = function() {
            Sl(Zl)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var Wl = new MessageChannel
          , Ql = Wl.port2;
        Wl.port1.onmessage = Zl,
        Gl = function() {
            Ql.postMessage(null)
        }
    } else
        Gl = function() {
            Cl(Zl, 0)
        }
        ;
    function cu(zl) {
        Nl = zl,
        Ml || (Ml = !0,
        Gl())
    }
    function pu(zl, Yl) {
        Ll = Cl(function() {
            zl(xt.unstable_now())
        }, Yl)
    }
    xt.unstable_IdlePriority = 5,
    xt.unstable_ImmediatePriority = 1,
    xt.unstable_LowPriority = 4,
    xt.unstable_NormalPriority = 3,
    xt.unstable_Profiling = null,
    xt.unstable_UserBlockingPriority = 2,
    xt.unstable_cancelCallback = function(zl) {
        zl.callback = null
    }
    ,
    xt.unstable_continueExecution = function() {
        _l || wl || (_l = !0,
        cu(Il))
    }
    ,
    xt.unstable_forceFrameRate = function(zl) {
        0 > zl || 125 < zl ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Fl = 0 < zl ? Math.floor(1e3 / zl) : 5
    }
    ,
    xt.unstable_getCurrentPriorityLevel = function() {
        return xl
    }
    ,
    xt.unstable_getFirstCallbackNode = function() {
        return as(Xs)
    }
    ,
    xt.unstable_next = function(zl) {
        switch (xl) {
        case 1:
        case 2:
        case 3:
            var Yl = 3;
            break;
        default:
            Yl = xl
        }
        var lu = xl;
        xl = Yl;
        try {
            return zl()
        } finally {
            xl = lu
        }
    }
    ,
    xt.unstable_pauseExecution = function() {}
    ,
    xt.unstable_requestPaint = function() {}
    ,
    xt.unstable_runWithPriority = function(zl, Yl) {
        switch (zl) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            zl = 3
        }
        var lu = xl;
        xl = zl;
        try {
            return Yl()
        } finally {
            xl = lu
        }
    }
    ,
    xt.unstable_scheduleCallback = function(zl, Yl, lu) {
        var mu = xt.unstable_now();
        switch (typeof lu == "object" && lu !== null ? (lu = lu.delay,
        lu = typeof lu == "number" && 0 < lu ? mu + lu : mu) : lu = mu,
        zl) {
        case 1:
            var Cu = -1;
            break;
        case 2:
            Cu = 250;
            break;
        case 5:
            Cu = 1073741823;
            break;
        case 4:
            Cu = 1e4;
            break;
        default:
            Cu = 5e3
        }
        return Cu = lu + Cu,
        zl = {
            id: ba++,
            callback: Yl,
            priorityLevel: zl,
            startTime: lu,
            expirationTime: Cu,
            sortIndex: -1
        },
        lu > mu ? (zl.sortIndex = lu,
        Cn(ga, zl),
        as(Xs) === null && zl === as(ga) && (El ? ($l(Ll),
        Ll = -1) : El = !0,
        pu(Rl, lu - mu))) : (zl.sortIndex = Cu,
        Cn(Xs, zl),
        _l || wl || (_l = !0,
        cu(Il))),
        zl
    }
    ,
    xt.unstable_shouldYield = Dl,
    xt.unstable_wrapCallback = function(zl) {
        var Yl = xl;
        return function() {
            var lu = xl;
            xl = Yl;
            try {
                return zl.apply(this, arguments)
            } finally {
                xl = lu
            }
        }
    }
}
)(scheduler_production_min);
scheduler.exports = scheduler_production_min;
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa$1 = reactExports
  , ca = schedulerExports;
function p$7(xt) {
    for (var Cn = "https://reactjs.org/docs/error-decoder.html?invariant=" + xt, as = 1; as < arguments.length; as++)
        Cn += "&args[]=" + encodeURIComponent(arguments[as]);
    return "Minified React error #" + xt + "; visit " + Cn + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var da = new Set
  , ea = {};
function fa$1(xt, Cn) {
    ha(xt, Cn),
    ha(xt + "Capture", Cn)
}
function ha(xt, Cn) {
    for (ea[xt] = Cn,
    xt = 0; xt < Cn.length; xt++)
        da.add(Cn[xt])
}
var ia$1 = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , ja$1 = Object.prototype.hasOwnProperty
  , ka$1 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , la = {}
  , ma = {};
function oa$1(xt) {
    return ja$1.call(ma, xt) ? !0 : ja$1.call(la, xt) ? !1 : ka$1.test(xt) ? ma[xt] = !0 : (la[xt] = !0,
    !1)
}
function pa(xt, Cn, as, cs) {
    if (as !== null && as.type === 0)
        return !1;
    switch (typeof Cn) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return cs ? !1 : as !== null ? !as.acceptsBooleans : (xt = xt.toLowerCase().slice(0, 5),
        xt !== "data-" && xt !== "aria-");
    default:
        return !1
    }
}
function qa(xt, Cn, as, cs) {
    if (Cn === null || typeof Cn > "u" || pa(xt, Cn, as, cs))
        return !0;
    if (cs)
        return !1;
    if (as !== null)
        switch (as.type) {
        case 3:
            return !Cn;
        case 4:
            return Cn === !1;
        case 5:
            return isNaN(Cn);
        case 6:
            return isNaN(Cn) || 1 > Cn
        }
    return !1
}
function v$2(xt, Cn, as, cs, Cs, Ls, Vs) {
    this.acceptsBooleans = Cn === 2 || Cn === 3 || Cn === 4,
    this.attributeName = cs,
    this.attributeNamespace = Cs,
    this.mustUseProperty = as,
    this.propertyName = xt,
    this.type = Cn,
    this.sanitizeURL = Ls,
    this.removeEmptyString = Vs
}
var z$4 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(xt) {
    z$4[xt] = new v$2(xt,0,!1,xt,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(xt) {
    var Cn = xt[0];
    z$4[Cn] = new v$2(Cn,1,!1,xt[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(xt) {
    z$4[xt] = new v$2(xt,2,!1,xt.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(xt) {
    z$4[xt] = new v$2(xt,2,!1,xt,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(xt) {
    z$4[xt] = new v$2(xt,3,!1,xt.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(xt) {
    z$4[xt] = new v$2(xt,3,!0,xt,null,!1,!1)
});
["capture", "download"].forEach(function(xt) {
    z$4[xt] = new v$2(xt,4,!1,xt,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(xt) {
    z$4[xt] = new v$2(xt,6,!1,xt,null,!1,!1)
});
["rowSpan", "start"].forEach(function(xt) {
    z$4[xt] = new v$2(xt,5,!1,xt.toLowerCase(),null,!1,!1)
});
var ra$1 = /[\-:]([a-z])/g;
function sa(xt) {
    return xt[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(xt) {
    var Cn = xt.replace(ra$1, sa);
    z$4[Cn] = new v$2(Cn,1,!1,xt,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(xt) {
    var Cn = xt.replace(ra$1, sa);
    z$4[Cn] = new v$2(Cn,1,!1,xt,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(xt) {
    var Cn = xt.replace(ra$1, sa);
    z$4[Cn] = new v$2(Cn,1,!1,xt,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(xt) {
    z$4[xt] = new v$2(xt,1,!1,xt.toLowerCase(),null,!1,!1)
});
z$4.xlinkHref = new v$2("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(xt) {
    z$4[xt] = new v$2(xt,1,!1,xt.toLowerCase(),null,!0,!0)
});
function ta$1(xt, Cn, as, cs) {
    var Cs = z$4.hasOwnProperty(Cn) ? z$4[Cn] : null;
    (Cs !== null ? Cs.type !== 0 : cs || !(2 < Cn.length) || Cn[0] !== "o" && Cn[0] !== "O" || Cn[1] !== "n" && Cn[1] !== "N") && (qa(Cn, as, Cs, cs) && (as = null),
    cs || Cs === null ? oa$1(Cn) && (as === null ? xt.removeAttribute(Cn) : xt.setAttribute(Cn, "" + as)) : Cs.mustUseProperty ? xt[Cs.propertyName] = as === null ? Cs.type === 3 ? !1 : "" : as : (Cn = Cs.attributeName,
    cs = Cs.attributeNamespace,
    as === null ? xt.removeAttribute(Cn) : (Cs = Cs.type,
    as = Cs === 3 || Cs === 4 && as === !0 ? "" : "" + as,
    cs ? xt.setAttributeNS(cs, Cn, as) : xt.setAttribute(Cn, as))))
}
var ua = aa$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , va = Symbol.for("react.element")
  , wa = Symbol.for("react.portal")
  , ya = Symbol.for("react.fragment")
  , za$1 = Symbol.for("react.strict_mode")
  , Aa = Symbol.for("react.profiler")
  , Ba = Symbol.for("react.provider")
  , Ca = Symbol.for("react.context")
  , Da$1 = Symbol.for("react.forward_ref")
  , Ea = Symbol.for("react.suspense")
  , Fa$1 = Symbol.for("react.suspense_list")
  , Ga$1 = Symbol.for("react.memo")
  , Ha$1 = Symbol.for("react.lazy")
  , Ia$1 = Symbol.for("react.offscreen")
  , Ja$1 = Symbol.iterator;
function Ka$1(xt) {
    return xt === null || typeof xt != "object" ? null : (xt = Ja$1 && xt[Ja$1] || xt["@@iterator"],
    typeof xt == "function" ? xt : null)
}
var A$5 = Object.assign, La$1;
function Ma$1(xt) {
    if (La$1 === void 0)
        try {
            throw Error()
        } catch (as) {
            var Cn = as.stack.trim().match(/\n( *(at )?)/);
            La$1 = Cn && Cn[1] || ""
        }
    return `
` + La$1 + xt
}
var Na$1 = !1;
function Oa$1(xt, Cn) {
    if (!xt || Na$1)
        return "";
    Na$1 = !0;
    var as = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (Cn)
            if (Cn = function() {
                throw Error()
            }
            ,
            Object.defineProperty(Cn.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(Cn, [])
                } catch (ga) {
                    var cs = ga
                }
                Reflect.construct(xt, [], Cn)
            } else {
                try {
                    Cn.call()
                } catch (ga) {
                    cs = ga
                }
                xt.call(Cn.prototype)
            }
        else {
            try {
                throw Error()
            } catch (ga) {
                cs = ga
            }
            xt()
        }
    } catch (ga) {
        if (ga && cs && typeof ga.stack == "string") {
            for (var Cs = ga.stack.split(`
`), Ls = cs.stack.split(`
`), Vs = Cs.length - 1, Ws = Ls.length - 1; 1 <= Vs && 0 <= Ws && Cs[Vs] !== Ls[Ws]; )
                Ws--;
            for (; 1 <= Vs && 0 <= Ws; Vs--,
            Ws--)
                if (Cs[Vs] !== Ls[Ws]) {
                    if (Vs !== 1 || Ws !== 1)
                        do
                            if (Vs--,
                            Ws--,
                            0 > Ws || Cs[Vs] !== Ls[Ws]) {
                                var Xs = `
` + Cs[Vs].replace(" at new ", " at ");
                                return xt.displayName && Xs.includes("<anonymous>") && (Xs = Xs.replace("<anonymous>", xt.displayName)),
                                Xs
                            }
                        while (1 <= Vs && 0 <= Ws);
                    break
                }
        }
    } finally {
        Na$1 = !1,
        Error.prepareStackTrace = as
    }
    return (xt = xt ? xt.displayName || xt.name : "") ? Ma$1(xt) : ""
}
function Pa$1(xt) {
    switch (xt.tag) {
    case 5:
        return Ma$1(xt.type);
    case 16:
        return Ma$1("Lazy");
    case 13:
        return Ma$1("Suspense");
    case 19:
        return Ma$1("SuspenseList");
    case 0:
    case 2:
    case 15:
        return xt = Oa$1(xt.type, !1),
        xt;
    case 11:
        return xt = Oa$1(xt.type.render, !1),
        xt;
    case 1:
        return xt = Oa$1(xt.type, !0),
        xt;
    default:
        return ""
    }
}
function Qa$1(xt) {
    if (xt == null)
        return null;
    if (typeof xt == "function")
        return xt.displayName || xt.name || null;
    if (typeof xt == "string")
        return xt;
    switch (xt) {
    case ya:
        return "Fragment";
    case wa:
        return "Portal";
    case Aa:
        return "Profiler";
    case za$1:
        return "StrictMode";
    case Ea:
        return "Suspense";
    case Fa$1:
        return "SuspenseList"
    }
    if (typeof xt == "object")
        switch (xt.$$typeof) {
        case Ca:
            return (xt.displayName || "Context") + ".Consumer";
        case Ba:
            return (xt._context.displayName || "Context") + ".Provider";
        case Da$1:
            var Cn = xt.render;
            return xt = xt.displayName,
            xt || (xt = Cn.displayName || Cn.name || "",
            xt = xt !== "" ? "ForwardRef(" + xt + ")" : "ForwardRef"),
            xt;
        case Ga$1:
            return Cn = xt.displayName || null,
            Cn !== null ? Cn : Qa$1(xt.type) || "Memo";
        case Ha$1:
            Cn = xt._payload,
            xt = xt._init;
            try {
                return Qa$1(xt(Cn))
            } catch {}
        }
    return null
}
function Ra(xt) {
    var Cn = xt.type;
    switch (xt.tag) {
    case 24:
        return "Cache";
    case 9:
        return (Cn.displayName || "Context") + ".Consumer";
    case 10:
        return (Cn._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return xt = Cn.render,
        xt = xt.displayName || xt.name || "",
        Cn.displayName || (xt !== "" ? "ForwardRef(" + xt + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return Cn;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return Qa$1(Cn);
    case 8:
        return Cn === za$1 ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof Cn == "function")
            return Cn.displayName || Cn.name || null;
        if (typeof Cn == "string")
            return Cn
    }
    return null
}
function Sa$1(xt) {
    switch (typeof xt) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return xt;
    case "object":
        return xt;
    default:
        return ""
    }
}
function Ta(xt) {
    var Cn = xt.type;
    return (xt = xt.nodeName) && xt.toLowerCase() === "input" && (Cn === "checkbox" || Cn === "radio")
}
function Ua(xt) {
    var Cn = Ta(xt) ? "checked" : "value"
      , as = Object.getOwnPropertyDescriptor(xt.constructor.prototype, Cn)
      , cs = "" + xt[Cn];
    if (!xt.hasOwnProperty(Cn) && typeof as < "u" && typeof as.get == "function" && typeof as.set == "function") {
        var Cs = as.get
          , Ls = as.set;
        return Object.defineProperty(xt, Cn, {
            configurable: !0,
            get: function() {
                return Cs.call(this)
            },
            set: function(Vs) {
                cs = "" + Vs,
                Ls.call(this, Vs)
            }
        }),
        Object.defineProperty(xt, Cn, {
            enumerable: as.enumerable
        }),
        {
            getValue: function() {
                return cs
            },
            setValue: function(Vs) {
                cs = "" + Vs
            },
            stopTracking: function() {
                xt._valueTracker = null,
                delete xt[Cn]
            }
        }
    }
}
function Va$1(xt) {
    xt._valueTracker || (xt._valueTracker = Ua(xt))
}
function Wa$1(xt) {
    if (!xt)
        return !1;
    var Cn = xt._valueTracker;
    if (!Cn)
        return !0;
    var as = Cn.getValue()
      , cs = "";
    return xt && (cs = Ta(xt) ? xt.checked ? "true" : "false" : xt.value),
    xt = cs,
    xt !== as ? (Cn.setValue(xt),
    !0) : !1
}
function Xa(xt) {
    if (xt = xt || (typeof document < "u" ? document : void 0),
    typeof xt > "u")
        return null;
    try {
        return xt.activeElement || xt.body
    } catch {
        return xt.body
    }
}
function Ya$1(xt, Cn) {
    var as = Cn.checked;
    return A$5({}, Cn, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: as ?? xt._wrapperState.initialChecked
    })
}
function Za$1(xt, Cn) {
    var as = Cn.defaultValue == null ? "" : Cn.defaultValue
      , cs = Cn.checked != null ? Cn.checked : Cn.defaultChecked;
    as = Sa$1(Cn.value != null ? Cn.value : as),
    xt._wrapperState = {
        initialChecked: cs,
        initialValue: as,
        controlled: Cn.type === "checkbox" || Cn.type === "radio" ? Cn.checked != null : Cn.value != null
    }
}
function ab(xt, Cn) {
    Cn = Cn.checked,
    Cn != null && ta$1(xt, "checked", Cn, !1)
}
function bb(xt, Cn) {
    ab(xt, Cn);
    var as = Sa$1(Cn.value)
      , cs = Cn.type;
    if (as != null)
        cs === "number" ? (as === 0 && xt.value === "" || xt.value != as) && (xt.value = "" + as) : xt.value !== "" + as && (xt.value = "" + as);
    else if (cs === "submit" || cs === "reset") {
        xt.removeAttribute("value");
        return
    }
    Cn.hasOwnProperty("value") ? cb(xt, Cn.type, as) : Cn.hasOwnProperty("defaultValue") && cb(xt, Cn.type, Sa$1(Cn.defaultValue)),
    Cn.checked == null && Cn.defaultChecked != null && (xt.defaultChecked = !!Cn.defaultChecked)
}
function db(xt, Cn, as) {
    if (Cn.hasOwnProperty("value") || Cn.hasOwnProperty("defaultValue")) {
        var cs = Cn.type;
        if (!(cs !== "submit" && cs !== "reset" || Cn.value !== void 0 && Cn.value !== null))
            return;
        Cn = "" + xt._wrapperState.initialValue,
        as || Cn === xt.value || (xt.value = Cn),
        xt.defaultValue = Cn
    }
    as = xt.name,
    as !== "" && (xt.name = ""),
    xt.defaultChecked = !!xt._wrapperState.initialChecked,
    as !== "" && (xt.name = as)
}
function cb(xt, Cn, as) {
    (Cn !== "number" || Xa(xt.ownerDocument) !== xt) && (as == null ? xt.defaultValue = "" + xt._wrapperState.initialValue : xt.defaultValue !== "" + as && (xt.defaultValue = "" + as))
}
var eb = Array.isArray;
function fb(xt, Cn, as, cs) {
    if (xt = xt.options,
    Cn) {
        Cn = {};
        for (var Cs = 0; Cs < as.length; Cs++)
            Cn["$" + as[Cs]] = !0;
        for (as = 0; as < xt.length; as++)
            Cs = Cn.hasOwnProperty("$" + xt[as].value),
            xt[as].selected !== Cs && (xt[as].selected = Cs),
            Cs && cs && (xt[as].defaultSelected = !0)
    } else {
        for (as = "" + Sa$1(as),
        Cn = null,
        Cs = 0; Cs < xt.length; Cs++) {
            if (xt[Cs].value === as) {
                xt[Cs].selected = !0,
                cs && (xt[Cs].defaultSelected = !0);
                return
            }
            Cn !== null || xt[Cs].disabled || (Cn = xt[Cs])
        }
        Cn !== null && (Cn.selected = !0)
    }
}
function gb(xt, Cn) {
    if (Cn.dangerouslySetInnerHTML != null)
        throw Error(p$7(91));
    return A$5({}, Cn, {
        value: void 0,
        defaultValue: void 0,
        children: "" + xt._wrapperState.initialValue
    })
}
function hb(xt, Cn) {
    var as = Cn.value;
    if (as == null) {
        if (as = Cn.children,
        Cn = Cn.defaultValue,
        as != null) {
            if (Cn != null)
                throw Error(p$7(92));
            if (eb(as)) {
                if (1 < as.length)
                    throw Error(p$7(93));
                as = as[0]
            }
            Cn = as
        }
        Cn == null && (Cn = ""),
        as = Cn
    }
    xt._wrapperState = {
        initialValue: Sa$1(as)
    }
}
function ib(xt, Cn) {
    var as = Sa$1(Cn.value)
      , cs = Sa$1(Cn.defaultValue);
    as != null && (as = "" + as,
    as !== xt.value && (xt.value = as),
    Cn.defaultValue == null && xt.defaultValue !== as && (xt.defaultValue = as)),
    cs != null && (xt.defaultValue = "" + cs)
}
function jb(xt) {
    var Cn = xt.textContent;
    Cn === xt._wrapperState.initialValue && Cn !== "" && Cn !== null && (xt.value = Cn)
}
function kb(xt) {
    switch (xt) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function lb(xt, Cn) {
    return xt == null || xt === "http://www.w3.org/1999/xhtml" ? kb(Cn) : xt === "http://www.w3.org/2000/svg" && Cn === "foreignObject" ? "http://www.w3.org/1999/xhtml" : xt
}
var mb, nb = function(xt) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(Cn, as, cs, Cs) {
        MSApp.execUnsafeLocalFunction(function() {
            return xt(Cn, as, cs, Cs)
        })
    }
    : xt
}(function(xt, Cn) {
    if (xt.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in xt)
        xt.innerHTML = Cn;
    else {
        for (mb = mb || document.createElement("div"),
        mb.innerHTML = "<svg>" + Cn.valueOf().toString() + "</svg>",
        Cn = mb.firstChild; xt.firstChild; )
            xt.removeChild(xt.firstChild);
        for (; Cn.firstChild; )
            xt.appendChild(Cn.firstChild)
    }
});
function ob(xt, Cn) {
    if (Cn) {
        var as = xt.firstChild;
        if (as && as === xt.lastChild && as.nodeType === 3) {
            as.nodeValue = Cn;
            return
        }
    }
    xt.textContent = Cn
}
var pb = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(xt) {
    qb.forEach(function(Cn) {
        Cn = Cn + xt.charAt(0).toUpperCase() + xt.substring(1),
        pb[Cn] = pb[xt]
    })
});
function rb(xt, Cn, as) {
    return Cn == null || typeof Cn == "boolean" || Cn === "" ? "" : as || typeof Cn != "number" || Cn === 0 || pb.hasOwnProperty(xt) && pb[xt] ? ("" + Cn).trim() : Cn + "px"
}
function sb(xt, Cn) {
    xt = xt.style;
    for (var as in Cn)
        if (Cn.hasOwnProperty(as)) {
            var cs = as.indexOf("--") === 0
              , Cs = rb(as, Cn[as], cs);
            as === "float" && (as = "cssFloat"),
            cs ? xt.setProperty(as, Cs) : xt[as] = Cs
        }
}
var tb = A$5({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function ub(xt, Cn) {
    if (Cn) {
        if (tb[xt] && (Cn.children != null || Cn.dangerouslySetInnerHTML != null))
            throw Error(p$7(137, xt));
        if (Cn.dangerouslySetInnerHTML != null) {
            if (Cn.children != null)
                throw Error(p$7(60));
            if (typeof Cn.dangerouslySetInnerHTML != "object" || !("__html"in Cn.dangerouslySetInnerHTML))
                throw Error(p$7(61))
        }
        if (Cn.style != null && typeof Cn.style != "object")
            throw Error(p$7(62))
    }
}
function vb(xt, Cn) {
    if (xt.indexOf("-") === -1)
        return typeof Cn.is == "string";
    switch (xt) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var wb = null;
function xb(xt) {
    return xt = xt.target || xt.srcElement || window,
    xt.correspondingUseElement && (xt = xt.correspondingUseElement),
    xt.nodeType === 3 ? xt.parentNode : xt
}
var yb = null
  , zb = null
  , Ab = null;
function Bb(xt) {
    if (xt = Cb(xt)) {
        if (typeof yb != "function")
            throw Error(p$7(280));
        var Cn = xt.stateNode;
        Cn && (Cn = Db(Cn),
        yb(xt.stateNode, xt.type, Cn))
    }
}
function Eb(xt) {
    zb ? Ab ? Ab.push(xt) : Ab = [xt] : zb = xt
}
function Fb() {
    if (zb) {
        var xt = zb
          , Cn = Ab;
        if (Ab = zb = null,
        Bb(xt),
        Cn)
            for (xt = 0; xt < Cn.length; xt++)
                Bb(Cn[xt])
    }
}
function Gb(xt, Cn) {
    return xt(Cn)
}
function Hb() {}
var Ib = !1;
function Jb(xt, Cn, as) {
    if (Ib)
        return xt(Cn, as);
    Ib = !0;
    try {
        return Gb(xt, Cn, as)
    } finally {
        Ib = !1,
        (zb !== null || Ab !== null) && (Hb(),
        Fb())
    }
}
function Kb(xt, Cn) {
    var as = xt.stateNode;
    if (as === null)
        return null;
    var cs = Db(as);
    if (cs === null)
        return null;
    as = cs[Cn];
    e: switch (Cn) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (cs = !cs.disabled) || (xt = xt.type,
        cs = !(xt === "button" || xt === "input" || xt === "select" || xt === "textarea")),
        xt = !cs;
        break e;
    default:
        xt = !1
    }
    if (xt)
        return null;
    if (as && typeof as != "function")
        throw Error(p$7(231, Cn, typeof as));
    return as
}
var Lb = !1;
if (ia$1)
    try {
        var Mb = {};
        Object.defineProperty(Mb, "passive", {
            get: function() {
                Lb = !0
            }
        }),
        window.addEventListener("test", Mb, Mb),
        window.removeEventListener("test", Mb, Mb)
    } catch {
        Lb = !1
    }
function Nb(xt, Cn, as, cs, Cs, Ls, Vs, Ws, Xs) {
    var ga = Array.prototype.slice.call(arguments, 3);
    try {
        Cn.apply(as, ga)
    } catch (ba) {
        this.onError(ba)
    }
}
var Ob = !1
  , Pb = null
  , Qb = !1
  , Rb = null
  , Sb = {
    onError: function(xt) {
        Ob = !0,
        Pb = xt
    }
};
function Tb(xt, Cn, as, cs, Cs, Ls, Vs, Ws, Xs) {
    Ob = !1,
    Pb = null,
    Nb.apply(Sb, arguments)
}
function Ub(xt, Cn, as, cs, Cs, Ls, Vs, Ws, Xs) {
    if (Tb.apply(this, arguments),
    Ob) {
        if (Ob) {
            var ga = Pb;
            Ob = !1,
            Pb = null
        } else
            throw Error(p$7(198));
        Qb || (Qb = !0,
        Rb = ga)
    }
}
function Vb(xt) {
    var Cn = xt
      , as = xt;
    if (xt.alternate)
        for (; Cn.return; )
            Cn = Cn.return;
    else {
        xt = Cn;
        do
            Cn = xt,
            Cn.flags & 4098 && (as = Cn.return),
            xt = Cn.return;
        while (xt)
    }
    return Cn.tag === 3 ? as : null
}
function Wb(xt) {
    if (xt.tag === 13) {
        var Cn = xt.memoizedState;
        if (Cn === null && (xt = xt.alternate,
        xt !== null && (Cn = xt.memoizedState)),
        Cn !== null)
            return Cn.dehydrated
    }
    return null
}
function Xb(xt) {
    if (Vb(xt) !== xt)
        throw Error(p$7(188))
}
function Yb(xt) {
    var Cn = xt.alternate;
    if (!Cn) {
        if (Cn = Vb(xt),
        Cn === null)
            throw Error(p$7(188));
        return Cn !== xt ? null : xt
    }
    for (var as = xt, cs = Cn; ; ) {
        var Cs = as.return;
        if (Cs === null)
            break;
        var Ls = Cs.alternate;
        if (Ls === null) {
            if (cs = Cs.return,
            cs !== null) {
                as = cs;
                continue
            }
            break
        }
        if (Cs.child === Ls.child) {
            for (Ls = Cs.child; Ls; ) {
                if (Ls === as)
                    return Xb(Cs),
                    xt;
                if (Ls === cs)
                    return Xb(Cs),
                    Cn;
                Ls = Ls.sibling
            }
            throw Error(p$7(188))
        }
        if (as.return !== cs.return)
            as = Cs,
            cs = Ls;
        else {
            for (var Vs = !1, Ws = Cs.child; Ws; ) {
                if (Ws === as) {
                    Vs = !0,
                    as = Cs,
                    cs = Ls;
                    break
                }
                if (Ws === cs) {
                    Vs = !0,
                    cs = Cs,
                    as = Ls;
                    break
                }
                Ws = Ws.sibling
            }
            if (!Vs) {
                for (Ws = Ls.child; Ws; ) {
                    if (Ws === as) {
                        Vs = !0,
                        as = Ls,
                        cs = Cs;
                        break
                    }
                    if (Ws === cs) {
                        Vs = !0,
                        cs = Ls,
                        as = Cs;
                        break
                    }
                    Ws = Ws.sibling
                }
                if (!Vs)
                    throw Error(p$7(189))
            }
        }
        if (as.alternate !== cs)
            throw Error(p$7(190))
    }
    if (as.tag !== 3)
        throw Error(p$7(188));
    return as.stateNode.current === as ? xt : Cn
}
function Zb(xt) {
    return xt = Yb(xt),
    xt !== null ? $b(xt) : null
}
function $b(xt) {
    if (xt.tag === 5 || xt.tag === 6)
        return xt;
    for (xt = xt.child; xt !== null; ) {
        var Cn = $b(xt);
        if (Cn !== null)
            return Cn;
        xt = xt.sibling
    }
    return null
}
var ac = ca.unstable_scheduleCallback
  , bc$1 = ca.unstable_cancelCallback
  , cc = ca.unstable_shouldYield
  , dc$1 = ca.unstable_requestPaint
  , B$2 = ca.unstable_now
  , ec = ca.unstable_getCurrentPriorityLevel
  , fc$1 = ca.unstable_ImmediatePriority
  , gc$1 = ca.unstable_UserBlockingPriority
  , hc$1 = ca.unstable_NormalPriority
  , ic = ca.unstable_LowPriority
  , jc = ca.unstable_IdlePriority
  , kc$1 = null
  , lc$1 = null;
function mc$1(xt) {
    if (lc$1 && typeof lc$1.onCommitFiberRoot == "function")
        try {
            lc$1.onCommitFiberRoot(kc$1, xt, void 0, (xt.current.flags & 128) === 128)
        } catch {}
}
var oc = Math.clz32 ? Math.clz32 : nc
  , pc$1 = Math.log
  , qc = Math.LN2;
function nc(xt) {
    return xt >>>= 0,
    xt === 0 ? 32 : 31 - (pc$1(xt) / qc | 0) | 0
}
var rc = 64
  , sc$1 = 4194304;
function tc(xt) {
    switch (xt & -xt) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return xt & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return xt & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return xt
    }
}
function uc(xt, Cn) {
    var as = xt.pendingLanes;
    if (as === 0)
        return 0;
    var cs = 0
      , Cs = xt.suspendedLanes
      , Ls = xt.pingedLanes
      , Vs = as & 268435455;
    if (Vs !== 0) {
        var Ws = Vs & ~Cs;
        Ws !== 0 ? cs = tc(Ws) : (Ls &= Vs,
        Ls !== 0 && (cs = tc(Ls)))
    } else
        Vs = as & ~Cs,
        Vs !== 0 ? cs = tc(Vs) : Ls !== 0 && (cs = tc(Ls));
    if (cs === 0)
        return 0;
    if (Cn !== 0 && Cn !== cs && !(Cn & Cs) && (Cs = cs & -cs,
    Ls = Cn & -Cn,
    Cs >= Ls || Cs === 16 && (Ls & 4194240) !== 0))
        return Cn;
    if (cs & 4 && (cs |= as & 16),
    Cn = xt.entangledLanes,
    Cn !== 0)
        for (xt = xt.entanglements,
        Cn &= cs; 0 < Cn; )
            as = 31 - oc(Cn),
            Cs = 1 << as,
            cs |= xt[as],
            Cn &= ~Cs;
    return cs
}
function vc$1(xt, Cn) {
    switch (xt) {
    case 1:
    case 2:
    case 4:
        return Cn + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return Cn + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function wc$1(xt, Cn) {
    for (var as = xt.suspendedLanes, cs = xt.pingedLanes, Cs = xt.expirationTimes, Ls = xt.pendingLanes; 0 < Ls; ) {
        var Vs = 31 - oc(Ls)
          , Ws = 1 << Vs
          , Xs = Cs[Vs];
        Xs === -1 ? (!(Ws & as) || Ws & cs) && (Cs[Vs] = vc$1(Ws, Cn)) : Xs <= Cn && (xt.expiredLanes |= Ws),
        Ls &= ~Ws
    }
}
function xc(xt) {
    return xt = xt.pendingLanes & -1073741825,
    xt !== 0 ? xt : xt & 1073741824 ? 1073741824 : 0
}
function yc$1() {
    var xt = rc;
    return rc <<= 1,
    !(rc & 4194240) && (rc = 64),
    xt
}
function zc(xt) {
    for (var Cn = [], as = 0; 31 > as; as++)
        Cn.push(xt);
    return Cn
}
function Ac$1(xt, Cn, as) {
    xt.pendingLanes |= Cn,
    Cn !== 536870912 && (xt.suspendedLanes = 0,
    xt.pingedLanes = 0),
    xt = xt.eventTimes,
    Cn = 31 - oc(Cn),
    xt[Cn] = as
}
function Bc(xt, Cn) {
    var as = xt.pendingLanes & ~Cn;
    xt.pendingLanes = Cn,
    xt.suspendedLanes = 0,
    xt.pingedLanes = 0,
    xt.expiredLanes &= Cn,
    xt.mutableReadLanes &= Cn,
    xt.entangledLanes &= Cn,
    Cn = xt.entanglements;
    var cs = xt.eventTimes;
    for (xt = xt.expirationTimes; 0 < as; ) {
        var Cs = 31 - oc(as)
          , Ls = 1 << Cs;
        Cn[Cs] = 0,
        cs[Cs] = -1,
        xt[Cs] = -1,
        as &= ~Ls
    }
}
function Cc$1(xt, Cn) {
    var as = xt.entangledLanes |= Cn;
    for (xt = xt.entanglements; as; ) {
        var cs = 31 - oc(as)
          , Cs = 1 << cs;
        Cs & Cn | xt[cs] & Cn && (xt[cs] |= Cn),
        as &= ~Cs
    }
}
var C$7 = 0;
function Dc$1(xt) {
    return xt &= -xt,
    1 < xt ? 4 < xt ? xt & 268435455 ? 16 : 536870912 : 4 : 1
}
var Ec$1, Fc, Gc, Hc$1, Ic$1, Jc = !1, Kc = [], Lc = null, Mc = null, Nc = null, Oc$1 = new Map, Pc = new Map, Qc = [], Rc$1 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc$1(xt, Cn) {
    switch (xt) {
    case "focusin":
    case "focusout":
        Lc = null;
        break;
    case "dragenter":
    case "dragleave":
        Mc = null;
        break;
    case "mouseover":
    case "mouseout":
        Nc = null;
        break;
    case "pointerover":
    case "pointerout":
        Oc$1.delete(Cn.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        Pc.delete(Cn.pointerId)
    }
}
function Tc(xt, Cn, as, cs, Cs, Ls) {
    return xt === null || xt.nativeEvent !== Ls ? (xt = {
        blockedOn: Cn,
        domEventName: as,
        eventSystemFlags: cs,
        nativeEvent: Ls,
        targetContainers: [Cs]
    },
    Cn !== null && (Cn = Cb(Cn),
    Cn !== null && Fc(Cn)),
    xt) : (xt.eventSystemFlags |= cs,
    Cn = xt.targetContainers,
    Cs !== null && Cn.indexOf(Cs) === -1 && Cn.push(Cs),
    xt)
}
function Uc(xt, Cn, as, cs, Cs) {
    switch (Cn) {
    case "focusin":
        return Lc = Tc(Lc, xt, Cn, as, cs, Cs),
        !0;
    case "dragenter":
        return Mc = Tc(Mc, xt, Cn, as, cs, Cs),
        !0;
    case "mouseover":
        return Nc = Tc(Nc, xt, Cn, as, cs, Cs),
        !0;
    case "pointerover":
        var Ls = Cs.pointerId;
        return Oc$1.set(Ls, Tc(Oc$1.get(Ls) || null, xt, Cn, as, cs, Cs)),
        !0;
    case "gotpointercapture":
        return Ls = Cs.pointerId,
        Pc.set(Ls, Tc(Pc.get(Ls) || null, xt, Cn, as, cs, Cs)),
        !0
    }
    return !1
}
function Vc(xt) {
    var Cn = Wc(xt.target);
    if (Cn !== null) {
        var as = Vb(Cn);
        if (as !== null) {
            if (Cn = as.tag,
            Cn === 13) {
                if (Cn = Wb(as),
                Cn !== null) {
                    xt.blockedOn = Cn,
                    Ic$1(xt.priority, function() {
                        Gc(as)
                    });
                    return
                }
            } else if (Cn === 3 && as.stateNode.current.memoizedState.isDehydrated) {
                xt.blockedOn = as.tag === 3 ? as.stateNode.containerInfo : null;
                return
            }
        }
    }
    xt.blockedOn = null
}
function Xc$1(xt) {
    if (xt.blockedOn !== null)
        return !1;
    for (var Cn = xt.targetContainers; 0 < Cn.length; ) {
        var as = Yc$1(xt.domEventName, xt.eventSystemFlags, Cn[0], xt.nativeEvent);
        if (as === null) {
            as = xt.nativeEvent;
            var cs = new as.constructor(as.type,as);
            wb = cs,
            as.target.dispatchEvent(cs),
            wb = null
        } else
            return Cn = Cb(as),
            Cn !== null && Fc(Cn),
            xt.blockedOn = as,
            !1;
        Cn.shift()
    }
    return !0
}
function Zc(xt, Cn, as) {
    Xc$1(xt) && as.delete(Cn)
}
function $c() {
    Jc = !1,
    Lc !== null && Xc$1(Lc) && (Lc = null),
    Mc !== null && Xc$1(Mc) && (Mc = null),
    Nc !== null && Xc$1(Nc) && (Nc = null),
    Oc$1.forEach(Zc),
    Pc.forEach(Zc)
}
function ad(xt, Cn) {
    xt.blockedOn === Cn && (xt.blockedOn = null,
    Jc || (Jc = !0,
    ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)))
}
function bd(xt) {
    function Cn(Cs) {
        return ad(Cs, xt)
    }
    if (0 < Kc.length) {
        ad(Kc[0], xt);
        for (var as = 1; as < Kc.length; as++) {
            var cs = Kc[as];
            cs.blockedOn === xt && (cs.blockedOn = null)
        }
    }
    for (Lc !== null && ad(Lc, xt),
    Mc !== null && ad(Mc, xt),
    Nc !== null && ad(Nc, xt),
    Oc$1.forEach(Cn),
    Pc.forEach(Cn),
    as = 0; as < Qc.length; as++)
        cs = Qc[as],
        cs.blockedOn === xt && (cs.blockedOn = null);
    for (; 0 < Qc.length && (as = Qc[0],
    as.blockedOn === null); )
        Vc(as),
        as.blockedOn === null && Qc.shift()
}
var cd = ua.ReactCurrentBatchConfig
  , dd = !0;
function ed(xt, Cn, as, cs) {
    var Cs = C$7
      , Ls = cd.transition;
    cd.transition = null;
    try {
        C$7 = 1,
        fd(xt, Cn, as, cs)
    } finally {
        C$7 = Cs,
        cd.transition = Ls
    }
}
function gd(xt, Cn, as, cs) {
    var Cs = C$7
      , Ls = cd.transition;
    cd.transition = null;
    try {
        C$7 = 4,
        fd(xt, Cn, as, cs)
    } finally {
        C$7 = Cs,
        cd.transition = Ls
    }
}
function fd(xt, Cn, as, cs) {
    if (dd) {
        var Cs = Yc$1(xt, Cn, as, cs);
        if (Cs === null)
            hd(xt, Cn, cs, id$2, as),
            Sc$1(xt, cs);
        else if (Uc(Cs, xt, Cn, as, cs))
            cs.stopPropagation();
        else if (Sc$1(xt, cs),
        Cn & 4 && -1 < Rc$1.indexOf(xt)) {
            for (; Cs !== null; ) {
                var Ls = Cb(Cs);
                if (Ls !== null && Ec$1(Ls),
                Ls = Yc$1(xt, Cn, as, cs),
                Ls === null && hd(xt, Cn, cs, id$2, as),
                Ls === Cs)
                    break;
                Cs = Ls
            }
            Cs !== null && cs.stopPropagation()
        } else
            hd(xt, Cn, cs, null, as)
    }
}
var id$2 = null;
function Yc$1(xt, Cn, as, cs) {
    if (id$2 = null,
    xt = xb(cs),
    xt = Wc(xt),
    xt !== null)
        if (Cn = Vb(xt),
        Cn === null)
            xt = null;
        else if (as = Cn.tag,
        as === 13) {
            if (xt = Wb(Cn),
            xt !== null)
                return xt;
            xt = null
        } else if (as === 3) {
            if (Cn.stateNode.current.memoizedState.isDehydrated)
                return Cn.tag === 3 ? Cn.stateNode.containerInfo : null;
            xt = null
        } else
            Cn !== xt && (xt = null);
    return id$2 = xt,
    null
}
function jd(xt) {
    switch (xt) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (ec()) {
        case fc$1:
            return 1;
        case gc$1:
            return 4;
        case hc$1:
        case ic:
            return 16;
        case jc:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var kd = null
  , ld = null
  , md = null;
function nd() {
    if (md)
        return md;
    var xt, Cn = ld, as = Cn.length, cs, Cs = "value"in kd ? kd.value : kd.textContent, Ls = Cs.length;
    for (xt = 0; xt < as && Cn[xt] === Cs[xt]; xt++)
        ;
    var Vs = as - xt;
    for (cs = 1; cs <= Vs && Cn[as - cs] === Cs[Ls - cs]; cs++)
        ;
    return md = Cs.slice(xt, 1 < cs ? 1 - cs : void 0)
}
function od(xt) {
    var Cn = xt.keyCode;
    return "charCode"in xt ? (xt = xt.charCode,
    xt === 0 && Cn === 13 && (xt = 13)) : xt = Cn,
    xt === 10 && (xt = 13),
    32 <= xt || xt === 13 ? xt : 0
}
function pd() {
    return !0
}
function qd() {
    return !1
}
function rd(xt) {
    function Cn(as, cs, Cs, Ls, Vs) {
        this._reactName = as,
        this._targetInst = Cs,
        this.type = cs,
        this.nativeEvent = Ls,
        this.target = Vs,
        this.currentTarget = null;
        for (var Ws in xt)
            xt.hasOwnProperty(Ws) && (as = xt[Ws],
            this[Ws] = as ? as(Ls) : Ls[Ws]);
        return this.isDefaultPrevented = (Ls.defaultPrevented != null ? Ls.defaultPrevented : Ls.returnValue === !1) ? pd : qd,
        this.isPropagationStopped = qd,
        this
    }
    return A$5(Cn.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var as = this.nativeEvent;
            as && (as.preventDefault ? as.preventDefault() : typeof as.returnValue != "unknown" && (as.returnValue = !1),
            this.isDefaultPrevented = pd)
        },
        stopPropagation: function() {
            var as = this.nativeEvent;
            as && (as.stopPropagation ? as.stopPropagation() : typeof as.cancelBubble != "unknown" && (as.cancelBubble = !0),
            this.isPropagationStopped = pd)
        },
        persist: function() {},
        isPersistent: pd
    }),
    Cn
}
var sd = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(xt) {
        return xt.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, td = rd(sd), ud = A$5({}, sd, {
    view: 0,
    detail: 0
}), vd = rd(ud), wd, xd, yd, Ad = A$5({}, ud, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: zd,
    button: 0,
    buttons: 0,
    relatedTarget: function(xt) {
        return xt.relatedTarget === void 0 ? xt.fromElement === xt.srcElement ? xt.toElement : xt.fromElement : xt.relatedTarget
    },
    movementX: function(xt) {
        return "movementX"in xt ? xt.movementX : (xt !== yd && (yd && xt.type === "mousemove" ? (wd = xt.screenX - yd.screenX,
        xd = xt.screenY - yd.screenY) : xd = wd = 0,
        yd = xt),
        wd)
    },
    movementY: function(xt) {
        return "movementY"in xt ? xt.movementY : xd
    }
}), Bd = rd(Ad), Cd = A$5({}, Ad, {
    dataTransfer: 0
}), Dd = rd(Cd), Ed = A$5({}, ud, {
    relatedTarget: 0
}), Fd = rd(Ed), Gd = A$5({}, sd, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), Hd = rd(Gd), Id = A$5({}, sd, {
    clipboardData: function(xt) {
        return "clipboardData"in xt ? xt.clipboardData : window.clipboardData
    }
}), Jd = rd(Id), Kd = A$5({}, sd, {
    data: 0
}), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, Od = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function Pd(xt) {
    var Cn = this.nativeEvent;
    return Cn.getModifierState ? Cn.getModifierState(xt) : (xt = Od[xt]) ? !!Cn[xt] : !1
}
function zd() {
    return Pd
}
var Qd = A$5({}, ud, {
    key: function(xt) {
        if (xt.key) {
            var Cn = Md[xt.key] || xt.key;
            if (Cn !== "Unidentified")
                return Cn
        }
        return xt.type === "keypress" ? (xt = od(xt),
        xt === 13 ? "Enter" : String.fromCharCode(xt)) : xt.type === "keydown" || xt.type === "keyup" ? Nd[xt.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: zd,
    charCode: function(xt) {
        return xt.type === "keypress" ? od(xt) : 0
    },
    keyCode: function(xt) {
        return xt.type === "keydown" || xt.type === "keyup" ? xt.keyCode : 0
    },
    which: function(xt) {
        return xt.type === "keypress" ? od(xt) : xt.type === "keydown" || xt.type === "keyup" ? xt.keyCode : 0
    }
})
  , Rd = rd(Qd)
  , Sd = A$5({}, Ad, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , Td = rd(Sd)
  , Ud = A$5({}, ud, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: zd
})
  , Vd = rd(Ud)
  , Wd = A$5({}, sd, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , Xd = rd(Wd)
  , Yd = A$5({}, Ad, {
    deltaX: function(xt) {
        return "deltaX"in xt ? xt.deltaX : "wheelDeltaX"in xt ? -xt.wheelDeltaX : 0
    },
    deltaY: function(xt) {
        return "deltaY"in xt ? xt.deltaY : "wheelDeltaY"in xt ? -xt.wheelDeltaY : "wheelDelta"in xt ? -xt.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , Zd = rd(Yd)
  , $d = [9, 13, 27, 32]
  , ae$2 = ia$1 && "CompositionEvent"in window
  , be$4 = null;
ia$1 && "documentMode"in document && (be$4 = document.documentMode);
var ce$4 = ia$1 && "TextEvent"in window && !be$4
  , de$3 = ia$1 && (!ae$2 || be$4 && 8 < be$4 && 11 >= be$4)
  , ee$2 = " "
  , fe$2 = !1;
function ge$3(xt, Cn) {
    switch (xt) {
    case "keyup":
        return $d.indexOf(Cn.keyCode) !== -1;
    case "keydown":
        return Cn.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function he$2(xt) {
    return xt = xt.detail,
    typeof xt == "object" && "data"in xt ? xt.data : null
}
var ie$1 = !1;
function je$4(xt, Cn) {
    switch (xt) {
    case "compositionend":
        return he$2(Cn);
    case "keypress":
        return Cn.which !== 32 ? null : (fe$2 = !0,
        ee$2);
    case "textInput":
        return xt = Cn.data,
        xt === ee$2 && fe$2 ? null : xt;
    default:
        return null
    }
}
function ke$2(xt, Cn) {
    if (ie$1)
        return xt === "compositionend" || !ae$2 && ge$3(xt, Cn) ? (xt = nd(),
        md = ld = kd = null,
        ie$1 = !1,
        xt) : null;
    switch (xt) {
    case "paste":
        return null;
    case "keypress":
        if (!(Cn.ctrlKey || Cn.altKey || Cn.metaKey) || Cn.ctrlKey && Cn.altKey) {
            if (Cn.char && 1 < Cn.char.length)
                return Cn.char;
            if (Cn.which)
                return String.fromCharCode(Cn.which)
        }
        return null;
    case "compositionend":
        return de$3 && Cn.locale !== "ko" ? null : Cn.data;
    default:
        return null
    }
}
var le$2 = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function me$3(xt) {
    var Cn = xt && xt.nodeName && xt.nodeName.toLowerCase();
    return Cn === "input" ? !!le$2[xt.type] : Cn === "textarea"
}
function ne$2(xt, Cn, as, cs) {
    Eb(cs),
    Cn = oe$3(Cn, "onChange"),
    0 < Cn.length && (as = new td("onChange","change",null,as,cs),
    xt.push({
        event: as,
        listeners: Cn
    }))
}
var pe$4 = null
  , qe$2 = null;
function re$2(xt) {
    se$2(xt, 0)
}
function te$2(xt) {
    var Cn = ue$2(xt);
    if (Wa$1(Cn))
        return xt
}
function ve$2(xt, Cn) {
    if (xt === "change")
        return Cn
}
var we$3 = !1;
if (ia$1) {
    var xe$3;
    if (ia$1) {
        var ye$4 = "oninput"in document;
        if (!ye$4) {
            var ze$2 = document.createElement("div");
            ze$2.setAttribute("oninput", "return;"),
            ye$4 = typeof ze$2.oninput == "function"
        }
        xe$3 = ye$4
    } else
        xe$3 = !1;
    we$3 = xe$3 && (!document.documentMode || 9 < document.documentMode)
}
function Ae$3() {
    pe$4 && (pe$4.detachEvent("onpropertychange", Be$3),
    qe$2 = pe$4 = null)
}
function Be$3(xt) {
    if (xt.propertyName === "value" && te$2(qe$2)) {
        var Cn = [];
        ne$2(Cn, qe$2, xt, xb(xt)),
        Jb(re$2, Cn)
    }
}
function Ce$3(xt, Cn, as) {
    xt === "focusin" ? (Ae$3(),
    pe$4 = Cn,
    qe$2 = as,
    pe$4.attachEvent("onpropertychange", Be$3)) : xt === "focusout" && Ae$3()
}
function De$3(xt) {
    if (xt === "selectionchange" || xt === "keyup" || xt === "keydown")
        return te$2(qe$2)
}
function Ee$4(xt, Cn) {
    if (xt === "click")
        return te$2(Cn)
}
function Fe$5(xt, Cn) {
    if (xt === "input" || xt === "change")
        return te$2(Cn)
}
function Ge$2(xt, Cn) {
    return xt === Cn && (xt !== 0 || 1 / xt === 1 / Cn) || xt !== xt && Cn !== Cn
}
var He$2 = typeof Object.is == "function" ? Object.is : Ge$2;
function Ie$3(xt, Cn) {
    if (He$2(xt, Cn))
        return !0;
    if (typeof xt != "object" || xt === null || typeof Cn != "object" || Cn === null)
        return !1;
    var as = Object.keys(xt)
      , cs = Object.keys(Cn);
    if (as.length !== cs.length)
        return !1;
    for (cs = 0; cs < as.length; cs++) {
        var Cs = as[cs];
        if (!ja$1.call(Cn, Cs) || !He$2(xt[Cs], Cn[Cs]))
            return !1
    }
    return !0
}
function Je$2(xt) {
    for (; xt && xt.firstChild; )
        xt = xt.firstChild;
    return xt
}
function Ke$3(xt, Cn) {
    var as = Je$2(xt);
    xt = 0;
    for (var cs; as; ) {
        if (as.nodeType === 3) {
            if (cs = xt + as.textContent.length,
            xt <= Cn && cs >= Cn)
                return {
                    node: as,
                    offset: Cn - xt
                };
            xt = cs
        }
        e: {
            for (; as; ) {
                if (as.nextSibling) {
                    as = as.nextSibling;
                    break e
                }
                as = as.parentNode
            }
            as = void 0
        }
        as = Je$2(as)
    }
}
function Le$2(xt, Cn) {
    return xt && Cn ? xt === Cn ? !0 : xt && xt.nodeType === 3 ? !1 : Cn && Cn.nodeType === 3 ? Le$2(xt, Cn.parentNode) : "contains"in xt ? xt.contains(Cn) : xt.compareDocumentPosition ? !!(xt.compareDocumentPosition(Cn) & 16) : !1 : !1
}
function Me$4() {
    for (var xt = window, Cn = Xa(); Cn instanceof xt.HTMLIFrameElement; ) {
        try {
            var as = typeof Cn.contentWindow.location.href == "string"
        } catch {
            as = !1
        }
        if (as)
            xt = Cn.contentWindow;
        else
            break;
        Cn = Xa(xt.document)
    }
    return Cn
}
function Ne$3(xt) {
    var Cn = xt && xt.nodeName && xt.nodeName.toLowerCase();
    return Cn && (Cn === "input" && (xt.type === "text" || xt.type === "search" || xt.type === "tel" || xt.type === "url" || xt.type === "password") || Cn === "textarea" || xt.contentEditable === "true")
}
function Oe$1(xt) {
    var Cn = Me$4()
      , as = xt.focusedElem
      , cs = xt.selectionRange;
    if (Cn !== as && as && as.ownerDocument && Le$2(as.ownerDocument.documentElement, as)) {
        if (cs !== null && Ne$3(as)) {
            if (Cn = cs.start,
            xt = cs.end,
            xt === void 0 && (xt = Cn),
            "selectionStart"in as)
                as.selectionStart = Cn,
                as.selectionEnd = Math.min(xt, as.value.length);
            else if (xt = (Cn = as.ownerDocument || document) && Cn.defaultView || window,
            xt.getSelection) {
                xt = xt.getSelection();
                var Cs = as.textContent.length
                  , Ls = Math.min(cs.start, Cs);
                cs = cs.end === void 0 ? Ls : Math.min(cs.end, Cs),
                !xt.extend && Ls > cs && (Cs = cs,
                cs = Ls,
                Ls = Cs),
                Cs = Ke$3(as, Ls);
                var Vs = Ke$3(as, cs);
                Cs && Vs && (xt.rangeCount !== 1 || xt.anchorNode !== Cs.node || xt.anchorOffset !== Cs.offset || xt.focusNode !== Vs.node || xt.focusOffset !== Vs.offset) && (Cn = Cn.createRange(),
                Cn.setStart(Cs.node, Cs.offset),
                xt.removeAllRanges(),
                Ls > cs ? (xt.addRange(Cn),
                xt.extend(Vs.node, Vs.offset)) : (Cn.setEnd(Vs.node, Vs.offset),
                xt.addRange(Cn)))
            }
        }
        for (Cn = [],
        xt = as; xt = xt.parentNode; )
            xt.nodeType === 1 && Cn.push({
                element: xt,
                left: xt.scrollLeft,
                top: xt.scrollTop
            });
        for (typeof as.focus == "function" && as.focus(),
        as = 0; as < Cn.length; as++)
            xt = Cn[as],
            xt.element.scrollLeft = xt.left,
            xt.element.scrollTop = xt.top
    }
}
var Pe$3 = ia$1 && "documentMode"in document && 11 >= document.documentMode
  , Qe$1 = null
  , Re$4 = null
  , Se$4 = null
  , Te$4 = !1;
function Ue$3(xt, Cn, as) {
    var cs = as.window === as ? as.document : as.nodeType === 9 ? as : as.ownerDocument;
    Te$4 || Qe$1 == null || Qe$1 !== Xa(cs) || (cs = Qe$1,
    "selectionStart"in cs && Ne$3(cs) ? cs = {
        start: cs.selectionStart,
        end: cs.selectionEnd
    } : (cs = (cs.ownerDocument && cs.ownerDocument.defaultView || window).getSelection(),
    cs = {
        anchorNode: cs.anchorNode,
        anchorOffset: cs.anchorOffset,
        focusNode: cs.focusNode,
        focusOffset: cs.focusOffset
    }),
    Se$4 && Ie$3(Se$4, cs) || (Se$4 = cs,
    cs = oe$3(Re$4, "onSelect"),
    0 < cs.length && (Cn = new td("onSelect","select",null,Cn,as),
    xt.push({
        event: Cn,
        listeners: cs
    }),
    Cn.target = Qe$1)))
}
function Ve$3(xt, Cn) {
    var as = {};
    return as[xt.toLowerCase()] = Cn.toLowerCase(),
    as["Webkit" + xt] = "webkit" + Cn,
    as["Moz" + xt] = "moz" + Cn,
    as
}
var We$3 = {
    animationend: Ve$3("Animation", "AnimationEnd"),
    animationiteration: Ve$3("Animation", "AnimationIteration"),
    animationstart: Ve$3("Animation", "AnimationStart"),
    transitionend: Ve$3("Transition", "TransitionEnd")
}
  , Xe$2 = {}
  , Ye$2 = {};
ia$1 && (Ye$2 = document.createElement("div").style,
"AnimationEvent"in window || (delete We$3.animationend.animation,
delete We$3.animationiteration.animation,
delete We$3.animationstart.animation),
"TransitionEvent"in window || delete We$3.transitionend.transition);
function Ze$2(xt) {
    if (Xe$2[xt])
        return Xe$2[xt];
    if (!We$3[xt])
        return xt;
    var Cn = We$3[xt], as;
    for (as in Cn)
        if (Cn.hasOwnProperty(as) && as in Ye$2)
            return Xe$2[xt] = Cn[as];
    return xt
}
var $e$2 = Ze$2("animationend")
  , af = Ze$2("animationiteration")
  , bf = Ze$2("animationstart")
  , cf = Ze$2("transitionend")
  , df = new Map
  , ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(xt, Cn) {
    df.set(xt, Cn),
    fa$1(Cn, [xt])
}
for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf]
      , jf = hf.toLowerCase()
      , kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf)
}
ff($e$2, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa$1("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa$1("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa$1("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa$1("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa$1("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa$1("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(xt, Cn, as) {
    var cs = xt.type || "unknown-event";
    xt.currentTarget = as,
    Ub(cs, Cn, void 0, xt),
    xt.currentTarget = null
}
function se$2(xt, Cn) {
    Cn = (Cn & 4) !== 0;
    for (var as = 0; as < xt.length; as++) {
        var cs = xt[as]
          , Cs = cs.event;
        cs = cs.listeners;
        e: {
            var Ls = void 0;
            if (Cn)
                for (var Vs = cs.length - 1; 0 <= Vs; Vs--) {
                    var Ws = cs[Vs]
                      , Xs = Ws.instance
                      , ga = Ws.currentTarget;
                    if (Ws = Ws.listener,
                    Xs !== Ls && Cs.isPropagationStopped())
                        break e;
                    nf(Cs, Ws, ga),
                    Ls = Xs
                }
            else
                for (Vs = 0; Vs < cs.length; Vs++) {
                    if (Ws = cs[Vs],
                    Xs = Ws.instance,
                    ga = Ws.currentTarget,
                    Ws = Ws.listener,
                    Xs !== Ls && Cs.isPropagationStopped())
                        break e;
                    nf(Cs, Ws, ga),
                    Ls = Xs
                }
        }
    }
    if (Qb)
        throw xt = Rb,
        Qb = !1,
        Rb = null,
        xt
}
function D$3(xt, Cn) {
    var as = Cn[of];
    as === void 0 && (as = Cn[of] = new Set);
    var cs = xt + "__bubble";
    as.has(cs) || (pf(Cn, xt, 2, !1),
    as.add(cs))
}
function qf(xt, Cn, as) {
    var cs = 0;
    Cn && (cs |= 4),
    pf(as, xt, cs, Cn)
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(xt) {
    if (!xt[rf]) {
        xt[rf] = !0,
        da.forEach(function(as) {
            as !== "selectionchange" && (mf.has(as) || qf(as, !1, xt),
            qf(as, !0, xt))
        });
        var Cn = xt.nodeType === 9 ? xt : xt.ownerDocument;
        Cn === null || Cn[rf] || (Cn[rf] = !0,
        qf("selectionchange", !1, Cn))
    }
}
function pf(xt, Cn, as, cs) {
    switch (jd(Cn)) {
    case 1:
        var Cs = ed;
        break;
    case 4:
        Cs = gd;
        break;
    default:
        Cs = fd
    }
    as = Cs.bind(null, Cn, as, xt),
    Cs = void 0,
    !Lb || Cn !== "touchstart" && Cn !== "touchmove" && Cn !== "wheel" || (Cs = !0),
    cs ? Cs !== void 0 ? xt.addEventListener(Cn, as, {
        capture: !0,
        passive: Cs
    }) : xt.addEventListener(Cn, as, !0) : Cs !== void 0 ? xt.addEventListener(Cn, as, {
        passive: Cs
    }) : xt.addEventListener(Cn, as, !1)
}
function hd(xt, Cn, as, cs, Cs) {
    var Ls = cs;
    if (!(Cn & 1) && !(Cn & 2) && cs !== null)
        e: for (; ; ) {
            if (cs === null)
                return;
            var Vs = cs.tag;
            if (Vs === 3 || Vs === 4) {
                var Ws = cs.stateNode.containerInfo;
                if (Ws === Cs || Ws.nodeType === 8 && Ws.parentNode === Cs)
                    break;
                if (Vs === 4)
                    for (Vs = cs.return; Vs !== null; ) {
                        var Xs = Vs.tag;
                        if ((Xs === 3 || Xs === 4) && (Xs = Vs.stateNode.containerInfo,
                        Xs === Cs || Xs.nodeType === 8 && Xs.parentNode === Cs))
                            return;
                        Vs = Vs.return
                    }
                for (; Ws !== null; ) {
                    if (Vs = Wc(Ws),
                    Vs === null)
                        return;
                    if (Xs = Vs.tag,
                    Xs === 5 || Xs === 6) {
                        cs = Ls = Vs;
                        continue e
                    }
                    Ws = Ws.parentNode
                }
            }
            cs = cs.return
        }
    Jb(function() {
        var ga = Ls
          , ba = xb(as)
          , yl = [];
        e: {
            var xl = df.get(xt);
            if (xl !== void 0) {
                var wl = td
                  , _l = xt;
                switch (xt) {
                case "keypress":
                    if (od(as) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    wl = Rd;
                    break;
                case "focusin":
                    _l = "focus",
                    wl = Fd;
                    break;
                case "focusout":
                    _l = "blur",
                    wl = Fd;
                    break;
                case "beforeblur":
                case "afterblur":
                    wl = Fd;
                    break;
                case "click":
                    if (as.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    wl = Bd;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    wl = Dd;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    wl = Vd;
                    break;
                case $e$2:
                case af:
                case bf:
                    wl = Hd;
                    break;
                case cf:
                    wl = Xd;
                    break;
                case "scroll":
                    wl = vd;
                    break;
                case "wheel":
                    wl = Zd;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    wl = Jd;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    wl = Td
                }
                var El = (Cn & 4) !== 0
                  , Cl = !El && xt === "scroll"
                  , $l = El ? xl !== null ? xl + "Capture" : null : xl;
                El = [];
                for (var Sl = ga, Tl; Sl !== null; ) {
                    Tl = Sl;
                    var Rl = Tl.stateNode;
                    if (Tl.tag === 5 && Rl !== null && (Tl = Rl,
                    $l !== null && (Rl = Kb(Sl, $l),
                    Rl != null && El.push(tf(Sl, Rl, Tl)))),
                    Cl)
                        break;
                    Sl = Sl.return
                }
                0 < El.length && (xl = new wl(xl,_l,null,as,ba),
                yl.push({
                    event: xl,
                    listeners: El
                }))
            }
        }
        if (!(Cn & 7)) {
            e: {
                if (xl = xt === "mouseover" || xt === "pointerover",
                wl = xt === "mouseout" || xt === "pointerout",
                xl && as !== wb && (_l = as.relatedTarget || as.fromElement) && (Wc(_l) || _l[uf]))
                    break e;
                if ((wl || xl) && (xl = ba.window === ba ? ba : (xl = ba.ownerDocument) ? xl.defaultView || xl.parentWindow : window,
                wl ? (_l = as.relatedTarget || as.toElement,
                wl = ga,
                _l = _l ? Wc(_l) : null,
                _l !== null && (Cl = Vb(_l),
                _l !== Cl || _l.tag !== 5 && _l.tag !== 6) && (_l = null)) : (wl = null,
                _l = ga),
                wl !== _l)) {
                    if (El = Bd,
                    Rl = "onMouseLeave",
                    $l = "onMouseEnter",
                    Sl = "mouse",
                    (xt === "pointerout" || xt === "pointerover") && (El = Td,
                    Rl = "onPointerLeave",
                    $l = "onPointerEnter",
                    Sl = "pointer"),
                    Cl = wl == null ? xl : ue$2(wl),
                    Tl = _l == null ? xl : ue$2(_l),
                    xl = new El(Rl,Sl + "leave",wl,as,ba),
                    xl.target = Cl,
                    xl.relatedTarget = Tl,
                    Rl = null,
                    Wc(ba) === ga && (El = new El($l,Sl + "enter",_l,as,ba),
                    El.target = Tl,
                    El.relatedTarget = Cl,
                    Rl = El),
                    Cl = Rl,
                    wl && _l)
                        t: {
                            for (El = wl,
                            $l = _l,
                            Sl = 0,
                            Tl = El; Tl; Tl = vf(Tl))
                                Sl++;
                            for (Tl = 0,
                            Rl = $l; Rl; Rl = vf(Rl))
                                Tl++;
                            for (; 0 < Sl - Tl; )
                                El = vf(El),
                                Sl--;
                            for (; 0 < Tl - Sl; )
                                $l = vf($l),
                                Tl--;
                            for (; Sl--; ) {
                                if (El === $l || $l !== null && El === $l.alternate)
                                    break t;
                                El = vf(El),
                                $l = vf($l)
                            }
                            El = null
                        }
                    else
                        El = null;
                    wl !== null && wf(yl, xl, wl, El, !1),
                    _l !== null && Cl !== null && wf(yl, Cl, _l, El, !0)
                }
            }
            e: {
                if (xl = ga ? ue$2(ga) : window,
                wl = xl.nodeName && xl.nodeName.toLowerCase(),
                wl === "select" || wl === "input" && xl.type === "file")
                    var Il = ve$2;
                else if (me$3(xl))
                    if (we$3)
                        Il = Fe$5;
                    else {
                        Il = De$3;
                        var Ml = Ce$3
                    }
                else
                    (wl = xl.nodeName) && wl.toLowerCase() === "input" && (xl.type === "checkbox" || xl.type === "radio") && (Il = Ee$4);
                if (Il && (Il = Il(xt, ga))) {
                    ne$2(yl, Il, as, ba);
                    break e
                }
                Ml && Ml(xt, xl, ga),
                xt === "focusout" && (Ml = xl._wrapperState) && Ml.controlled && xl.type === "number" && cb(xl, "number", xl.value)
            }
            switch (Ml = ga ? ue$2(ga) : window,
            xt) {
            case "focusin":
                (me$3(Ml) || Ml.contentEditable === "true") && (Qe$1 = Ml,
                Re$4 = ga,
                Se$4 = null);
                break;
            case "focusout":
                Se$4 = Re$4 = Qe$1 = null;
                break;
            case "mousedown":
                Te$4 = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                Te$4 = !1,
                Ue$3(yl, as, ba);
                break;
            case "selectionchange":
                if (Pe$3)
                    break;
            case "keydown":
            case "keyup":
                Ue$3(yl, as, ba)
            }
            var Nl;
            if (ae$2)
                e: {
                    switch (xt) {
                    case "compositionstart":
                        var Ll = "onCompositionStart";
                        break e;
                    case "compositionend":
                        Ll = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        Ll = "onCompositionUpdate";
                        break e
                    }
                    Ll = void 0
                }
            else
                ie$1 ? ge$3(xt, as) && (Ll = "onCompositionEnd") : xt === "keydown" && as.keyCode === 229 && (Ll = "onCompositionStart");
            Ll && (de$3 && as.locale !== "ko" && (ie$1 || Ll !== "onCompositionStart" ? Ll === "onCompositionEnd" && ie$1 && (Nl = nd()) : (kd = ba,
            ld = "value"in kd ? kd.value : kd.textContent,
            ie$1 = !0)),
            Ml = oe$3(ga, Ll),
            0 < Ml.length && (Ll = new Ld(Ll,xt,null,as,ba),
            yl.push({
                event: Ll,
                listeners: Ml
            }),
            Nl ? Ll.data = Nl : (Nl = he$2(as),
            Nl !== null && (Ll.data = Nl)))),
            (Nl = ce$4 ? je$4(xt, as) : ke$2(xt, as)) && (ga = oe$3(ga, "onBeforeInput"),
            0 < ga.length && (ba = new Ld("onBeforeInput","beforeinput",null,as,ba),
            yl.push({
                event: ba,
                listeners: ga
            }),
            ba.data = Nl))
        }
        se$2(yl, Cn)
    })
}
function tf(xt, Cn, as) {
    return {
        instance: xt,
        listener: Cn,
        currentTarget: as
    }
}
function oe$3(xt, Cn) {
    for (var as = Cn + "Capture", cs = []; xt !== null; ) {
        var Cs = xt
          , Ls = Cs.stateNode;
        Cs.tag === 5 && Ls !== null && (Cs = Ls,
        Ls = Kb(xt, as),
        Ls != null && cs.unshift(tf(xt, Ls, Cs)),
        Ls = Kb(xt, Cn),
        Ls != null && cs.push(tf(xt, Ls, Cs))),
        xt = xt.return
    }
    return cs
}
function vf(xt) {
    if (xt === null)
        return null;
    do
        xt = xt.return;
    while (xt && xt.tag !== 5);
    return xt || null
}
function wf(xt, Cn, as, cs, Cs) {
    for (var Ls = Cn._reactName, Vs = []; as !== null && as !== cs; ) {
        var Ws = as
          , Xs = Ws.alternate
          , ga = Ws.stateNode;
        if (Xs !== null && Xs === cs)
            break;
        Ws.tag === 5 && ga !== null && (Ws = ga,
        Cs ? (Xs = Kb(as, Ls),
        Xs != null && Vs.unshift(tf(as, Xs, Ws))) : Cs || (Xs = Kb(as, Ls),
        Xs != null && Vs.push(tf(as, Xs, Ws)))),
        as = as.return
    }
    Vs.length !== 0 && xt.push({
        event: Cn,
        listeners: Vs
    })
}
var xf = /\r\n?/g
  , yf = /\u0000|\uFFFD/g;
function zf(xt) {
    return (typeof xt == "string" ? xt : "" + xt).replace(xf, `
`).replace(yf, "")
}
function Af(xt, Cn, as) {
    if (Cn = zf(Cn),
    zf(xt) !== Cn && as)
        throw Error(p$7(425))
}
function Bf() {}
var Cf = null
  , Df = null;
function Ef(xt, Cn) {
    return xt === "textarea" || xt === "noscript" || typeof Cn.children == "string" || typeof Cn.children == "number" || typeof Cn.dangerouslySetInnerHTML == "object" && Cn.dangerouslySetInnerHTML !== null && Cn.dangerouslySetInnerHTML.__html != null
}
var Ff = typeof setTimeout == "function" ? setTimeout : void 0
  , Gf = typeof clearTimeout == "function" ? clearTimeout : void 0
  , Hf = typeof Promise == "function" ? Promise : void 0
  , Jf = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hf < "u" ? function(xt) {
    return Hf.resolve(null).then(xt).catch(If)
}
: Ff;
function If(xt) {
    setTimeout(function() {
        throw xt
    })
}
function Kf(xt, Cn) {
    var as = Cn
      , cs = 0;
    do {
        var Cs = as.nextSibling;
        if (xt.removeChild(as),
        Cs && Cs.nodeType === 8)
            if (as = Cs.data,
            as === "/$") {
                if (cs === 0) {
                    xt.removeChild(Cs),
                    bd(Cn);
                    return
                }
                cs--
            } else
                as !== "$" && as !== "$?" && as !== "$!" || cs++;
        as = Cs
    } while (as);
    bd(Cn)
}
function Lf(xt) {
    for (; xt != null; xt = xt.nextSibling) {
        var Cn = xt.nodeType;
        if (Cn === 1 || Cn === 3)
            break;
        if (Cn === 8) {
            if (Cn = xt.data,
            Cn === "$" || Cn === "$!" || Cn === "$?")
                break;
            if (Cn === "/$")
                return null
        }
    }
    return xt
}
function Mf(xt) {
    xt = xt.previousSibling;
    for (var Cn = 0; xt; ) {
        if (xt.nodeType === 8) {
            var as = xt.data;
            if (as === "$" || as === "$!" || as === "$?") {
                if (Cn === 0)
                    return xt;
                Cn--
            } else
                as === "/$" && Cn++
        }
        xt = xt.previousSibling
    }
    return null
}
var Nf = Math.random().toString(36).slice(2)
  , Of = "__reactFiber$" + Nf
  , Pf = "__reactProps$" + Nf
  , uf = "__reactContainer$" + Nf
  , of = "__reactEvents$" + Nf
  , Qf = "__reactListeners$" + Nf
  , Rf = "__reactHandles$" + Nf;
function Wc(xt) {
    var Cn = xt[Of];
    if (Cn)
        return Cn;
    for (var as = xt.parentNode; as; ) {
        if (Cn = as[uf] || as[Of]) {
            if (as = Cn.alternate,
            Cn.child !== null || as !== null && as.child !== null)
                for (xt = Mf(xt); xt !== null; ) {
                    if (as = xt[Of])
                        return as;
                    xt = Mf(xt)
                }
            return Cn
        }
        xt = as,
        as = xt.parentNode
    }
    return null
}
function Cb(xt) {
    return xt = xt[Of] || xt[uf],
    !xt || xt.tag !== 5 && xt.tag !== 6 && xt.tag !== 13 && xt.tag !== 3 ? null : xt
}
function ue$2(xt) {
    if (xt.tag === 5 || xt.tag === 6)
        return xt.stateNode;
    throw Error(p$7(33))
}
function Db(xt) {
    return xt[Pf] || null
}
var Sf = []
  , Tf = -1;
function Uf(xt) {
    return {
        current: xt
    }
}
function E$5(xt) {
    0 > Tf || (xt.current = Sf[Tf],
    Sf[Tf] = null,
    Tf--)
}
function G$3(xt, Cn) {
    Tf++,
    Sf[Tf] = xt.current,
    xt.current = Cn
}
var Vf = {}
  , H$8 = Uf(Vf)
  , Wf = Uf(!1)
  , Xf = Vf;
function Yf(xt, Cn) {
    var as = xt.type.contextTypes;
    if (!as)
        return Vf;
    var cs = xt.stateNode;
    if (cs && cs.__reactInternalMemoizedUnmaskedChildContext === Cn)
        return cs.__reactInternalMemoizedMaskedChildContext;
    var Cs = {}, Ls;
    for (Ls in as)
        Cs[Ls] = Cn[Ls];
    return cs && (xt = xt.stateNode,
    xt.__reactInternalMemoizedUnmaskedChildContext = Cn,
    xt.__reactInternalMemoizedMaskedChildContext = Cs),
    Cs
}
function Zf(xt) {
    return xt = xt.childContextTypes,
    xt != null
}
function $f() {
    E$5(Wf),
    E$5(H$8)
}
function ag(xt, Cn, as) {
    if (H$8.current !== Vf)
        throw Error(p$7(168));
    G$3(H$8, Cn),
    G$3(Wf, as)
}
function bg(xt, Cn, as) {
    var cs = xt.stateNode;
    if (Cn = Cn.childContextTypes,
    typeof cs.getChildContext != "function")
        return as;
    cs = cs.getChildContext();
    for (var Cs in cs)
        if (!(Cs in Cn))
            throw Error(p$7(108, Ra(xt) || "Unknown", Cs));
    return A$5({}, as, cs)
}
function cg(xt) {
    return xt = (xt = xt.stateNode) && xt.__reactInternalMemoizedMergedChildContext || Vf,
    Xf = H$8.current,
    G$3(H$8, xt),
    G$3(Wf, Wf.current),
    !0
}
function dg(xt, Cn, as) {
    var cs = xt.stateNode;
    if (!cs)
        throw Error(p$7(169));
    as ? (xt = bg(xt, Cn, Xf),
    cs.__reactInternalMemoizedMergedChildContext = xt,
    E$5(Wf),
    E$5(H$8),
    G$3(H$8, xt)) : E$5(Wf),
    G$3(Wf, as)
}
var eg = null
  , fg = !1
  , gg = !1;
function hg(xt) {
    eg === null ? eg = [xt] : eg.push(xt)
}
function ig(xt) {
    fg = !0,
    hg(xt)
}
function jg() {
    if (!gg && eg !== null) {
        gg = !0;
        var xt = 0
          , Cn = C$7;
        try {
            var as = eg;
            for (C$7 = 1; xt < as.length; xt++) {
                var cs = as[xt];
                do
                    cs = cs(!0);
                while (cs !== null)
            }
            eg = null,
            fg = !1
        } catch (Cs) {
            throw eg !== null && (eg = eg.slice(xt + 1)),
            ac(fc$1, jg),
            Cs
        } finally {
            C$7 = Cn,
            gg = !1
        }
    }
    return null
}
var kg = []
  , lg = 0
  , mg = null
  , ng = 0
  , og = []
  , pg = 0
  , qg = null
  , rg = 1
  , sg = "";
function tg(xt, Cn) {
    kg[lg++] = ng,
    kg[lg++] = mg,
    mg = xt,
    ng = Cn
}
function ug(xt, Cn, as) {
    og[pg++] = rg,
    og[pg++] = sg,
    og[pg++] = qg,
    qg = xt;
    var cs = rg;
    xt = sg;
    var Cs = 32 - oc(cs) - 1;
    cs &= ~(1 << Cs),
    as += 1;
    var Ls = 32 - oc(Cn) + Cs;
    if (30 < Ls) {
        var Vs = Cs - Cs % 5;
        Ls = (cs & (1 << Vs) - 1).toString(32),
        cs >>= Vs,
        Cs -= Vs,
        rg = 1 << 32 - oc(Cn) + Cs | as << Cs | cs,
        sg = Ls + xt
    } else
        rg = 1 << Ls | as << Cs | cs,
        sg = xt
}
function vg(xt) {
    xt.return !== null && (tg(xt, 1),
    ug(xt, 1, 0))
}
function wg(xt) {
    for (; xt === mg; )
        mg = kg[--lg],
        kg[lg] = null,
        ng = kg[--lg],
        kg[lg] = null;
    for (; xt === qg; )
        qg = og[--pg],
        og[pg] = null,
        sg = og[--pg],
        og[pg] = null,
        rg = og[--pg],
        og[pg] = null
}
var xg = null
  , yg = null
  , I$4 = !1
  , zg = null;
function Ag(xt, Cn) {
    var as = Bg(5, null, null, 0);
    as.elementType = "DELETED",
    as.stateNode = Cn,
    as.return = xt,
    Cn = xt.deletions,
    Cn === null ? (xt.deletions = [as],
    xt.flags |= 16) : Cn.push(as)
}
function Cg(xt, Cn) {
    switch (xt.tag) {
    case 5:
        var as = xt.type;
        return Cn = Cn.nodeType !== 1 || as.toLowerCase() !== Cn.nodeName.toLowerCase() ? null : Cn,
        Cn !== null ? (xt.stateNode = Cn,
        xg = xt,
        yg = Lf(Cn.firstChild),
        !0) : !1;
    case 6:
        return Cn = xt.pendingProps === "" || Cn.nodeType !== 3 ? null : Cn,
        Cn !== null ? (xt.stateNode = Cn,
        xg = xt,
        yg = null,
        !0) : !1;
    case 13:
        return Cn = Cn.nodeType !== 8 ? null : Cn,
        Cn !== null ? (as = qg !== null ? {
            id: rg,
            overflow: sg
        } : null,
        xt.memoizedState = {
            dehydrated: Cn,
            treeContext: as,
            retryLane: 1073741824
        },
        as = Bg(18, null, null, 0),
        as.stateNode = Cn,
        as.return = xt,
        xt.child = as,
        xg = xt,
        yg = null,
        !0) : !1;
    default:
        return !1
    }
}
function Dg(xt) {
    return (xt.mode & 1) !== 0 && (xt.flags & 128) === 0
}
function Eg(xt) {
    if (I$4) {
        var Cn = yg;
        if (Cn) {
            var as = Cn;
            if (!Cg(xt, Cn)) {
                if (Dg(xt))
                    throw Error(p$7(418));
                Cn = Lf(as.nextSibling);
                var cs = xg;
                Cn && Cg(xt, Cn) ? Ag(cs, as) : (xt.flags = xt.flags & -4097 | 2,
                I$4 = !1,
                xg = xt)
            }
        } else {
            if (Dg(xt))
                throw Error(p$7(418));
            xt.flags = xt.flags & -4097 | 2,
            I$4 = !1,
            xg = xt
        }
    }
}
function Fg(xt) {
    for (xt = xt.return; xt !== null && xt.tag !== 5 && xt.tag !== 3 && xt.tag !== 13; )
        xt = xt.return;
    xg = xt
}
function Gg(xt) {
    if (xt !== xg)
        return !1;
    if (!I$4)
        return Fg(xt),
        I$4 = !0,
        !1;
    var Cn;
    if ((Cn = xt.tag !== 3) && !(Cn = xt.tag !== 5) && (Cn = xt.type,
    Cn = Cn !== "head" && Cn !== "body" && !Ef(xt.type, xt.memoizedProps)),
    Cn && (Cn = yg)) {
        if (Dg(xt))
            throw Hg(),
            Error(p$7(418));
        for (; Cn; )
            Ag(xt, Cn),
            Cn = Lf(Cn.nextSibling)
    }
    if (Fg(xt),
    xt.tag === 13) {
        if (xt = xt.memoizedState,
        xt = xt !== null ? xt.dehydrated : null,
        !xt)
            throw Error(p$7(317));
        e: {
            for (xt = xt.nextSibling,
            Cn = 0; xt; ) {
                if (xt.nodeType === 8) {
                    var as = xt.data;
                    if (as === "/$") {
                        if (Cn === 0) {
                            yg = Lf(xt.nextSibling);
                            break e
                        }
                        Cn--
                    } else
                        as !== "$" && as !== "$!" && as !== "$?" || Cn++
                }
                xt = xt.nextSibling
            }
            yg = null
        }
    } else
        yg = xg ? Lf(xt.stateNode.nextSibling) : null;
    return !0
}
function Hg() {
    for (var xt = yg; xt; )
        xt = Lf(xt.nextSibling)
}
function Ig() {
    yg = xg = null,
    I$4 = !1
}
function Jg(xt) {
    zg === null ? zg = [xt] : zg.push(xt)
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(xt, Cn, as) {
    if (xt = as.ref,
    xt !== null && typeof xt != "function" && typeof xt != "object") {
        if (as._owner) {
            if (as = as._owner,
            as) {
                if (as.tag !== 1)
                    throw Error(p$7(309));
                var cs = as.stateNode
            }
            if (!cs)
                throw Error(p$7(147, xt));
            var Cs = cs
              , Ls = "" + xt;
            return Cn !== null && Cn.ref !== null && typeof Cn.ref == "function" && Cn.ref._stringRef === Ls ? Cn.ref : (Cn = function(Vs) {
                var Ws = Cs.refs;
                Vs === null ? delete Ws[Ls] : Ws[Ls] = Vs
            }
            ,
            Cn._stringRef = Ls,
            Cn)
        }
        if (typeof xt != "string")
            throw Error(p$7(284));
        if (!as._owner)
            throw Error(p$7(290, xt))
    }
    return xt
}
function Mg(xt, Cn) {
    throw xt = Object.prototype.toString.call(Cn),
    Error(p$7(31, xt === "[object Object]" ? "object with keys {" + Object.keys(Cn).join(", ") + "}" : xt))
}
function Ng(xt) {
    var Cn = xt._init;
    return Cn(xt._payload)
}
function Og(xt) {
    function Cn($l, Sl) {
        if (xt) {
            var Tl = $l.deletions;
            Tl === null ? ($l.deletions = [Sl],
            $l.flags |= 16) : Tl.push(Sl)
        }
    }
    function as($l, Sl) {
        if (!xt)
            return null;
        for (; Sl !== null; )
            Cn($l, Sl),
            Sl = Sl.sibling;
        return null
    }
    function cs($l, Sl) {
        for ($l = new Map; Sl !== null; )
            Sl.key !== null ? $l.set(Sl.key, Sl) : $l.set(Sl.index, Sl),
            Sl = Sl.sibling;
        return $l
    }
    function Cs($l, Sl) {
        return $l = Pg($l, Sl),
        $l.index = 0,
        $l.sibling = null,
        $l
    }
    function Ls($l, Sl, Tl) {
        return $l.index = Tl,
        xt ? (Tl = $l.alternate,
        Tl !== null ? (Tl = Tl.index,
        Tl < Sl ? ($l.flags |= 2,
        Sl) : Tl) : ($l.flags |= 2,
        Sl)) : ($l.flags |= 1048576,
        Sl)
    }
    function Vs($l) {
        return xt && $l.alternate === null && ($l.flags |= 2),
        $l
    }
    function Ws($l, Sl, Tl, Rl) {
        return Sl === null || Sl.tag !== 6 ? (Sl = Qg(Tl, $l.mode, Rl),
        Sl.return = $l,
        Sl) : (Sl = Cs(Sl, Tl),
        Sl.return = $l,
        Sl)
    }
    function Xs($l, Sl, Tl, Rl) {
        var Il = Tl.type;
        return Il === ya ? ba($l, Sl, Tl.props.children, Rl, Tl.key) : Sl !== null && (Sl.elementType === Il || typeof Il == "object" && Il !== null && Il.$$typeof === Ha$1 && Ng(Il) === Sl.type) ? (Rl = Cs(Sl, Tl.props),
        Rl.ref = Lg($l, Sl, Tl),
        Rl.return = $l,
        Rl) : (Rl = Rg(Tl.type, Tl.key, Tl.props, null, $l.mode, Rl),
        Rl.ref = Lg($l, Sl, Tl),
        Rl.return = $l,
        Rl)
    }
    function ga($l, Sl, Tl, Rl) {
        return Sl === null || Sl.tag !== 4 || Sl.stateNode.containerInfo !== Tl.containerInfo || Sl.stateNode.implementation !== Tl.implementation ? (Sl = Sg(Tl, $l.mode, Rl),
        Sl.return = $l,
        Sl) : (Sl = Cs(Sl, Tl.children || []),
        Sl.return = $l,
        Sl)
    }
    function ba($l, Sl, Tl, Rl, Il) {
        return Sl === null || Sl.tag !== 7 ? (Sl = Tg(Tl, $l.mode, Rl, Il),
        Sl.return = $l,
        Sl) : (Sl = Cs(Sl, Tl),
        Sl.return = $l,
        Sl)
    }
    function yl($l, Sl, Tl) {
        if (typeof Sl == "string" && Sl !== "" || typeof Sl == "number")
            return Sl = Qg("" + Sl, $l.mode, Tl),
            Sl.return = $l,
            Sl;
        if (typeof Sl == "object" && Sl !== null) {
            switch (Sl.$$typeof) {
            case va:
                return Tl = Rg(Sl.type, Sl.key, Sl.props, null, $l.mode, Tl),
                Tl.ref = Lg($l, null, Sl),
                Tl.return = $l,
                Tl;
            case wa:
                return Sl = Sg(Sl, $l.mode, Tl),
                Sl.return = $l,
                Sl;
            case Ha$1:
                var Rl = Sl._init;
                return yl($l, Rl(Sl._payload), Tl)
            }
            if (eb(Sl) || Ka$1(Sl))
                return Sl = Tg(Sl, $l.mode, Tl, null),
                Sl.return = $l,
                Sl;
            Mg($l, Sl)
        }
        return null
    }
    function xl($l, Sl, Tl, Rl) {
        var Il = Sl !== null ? Sl.key : null;
        if (typeof Tl == "string" && Tl !== "" || typeof Tl == "number")
            return Il !== null ? null : Ws($l, Sl, "" + Tl, Rl);
        if (typeof Tl == "object" && Tl !== null) {
            switch (Tl.$$typeof) {
            case va:
                return Tl.key === Il ? Xs($l, Sl, Tl, Rl) : null;
            case wa:
                return Tl.key === Il ? ga($l, Sl, Tl, Rl) : null;
            case Ha$1:
                return Il = Tl._init,
                xl($l, Sl, Il(Tl._payload), Rl)
            }
            if (eb(Tl) || Ka$1(Tl))
                return Il !== null ? null : ba($l, Sl, Tl, Rl, null);
            Mg($l, Tl)
        }
        return null
    }
    function wl($l, Sl, Tl, Rl, Il) {
        if (typeof Rl == "string" && Rl !== "" || typeof Rl == "number")
            return $l = $l.get(Tl) || null,
            Ws(Sl, $l, "" + Rl, Il);
        if (typeof Rl == "object" && Rl !== null) {
            switch (Rl.$$typeof) {
            case va:
                return $l = $l.get(Rl.key === null ? Tl : Rl.key) || null,
                Xs(Sl, $l, Rl, Il);
            case wa:
                return $l = $l.get(Rl.key === null ? Tl : Rl.key) || null,
                ga(Sl, $l, Rl, Il);
            case Ha$1:
                var Ml = Rl._init;
                return wl($l, Sl, Tl, Ml(Rl._payload), Il)
            }
            if (eb(Rl) || Ka$1(Rl))
                return $l = $l.get(Tl) || null,
                ba(Sl, $l, Rl, Il, null);
            Mg(Sl, Rl)
        }
        return null
    }
    function _l($l, Sl, Tl, Rl) {
        for (var Il = null, Ml = null, Nl = Sl, Ll = Sl = 0, Fl = null; Nl !== null && Ll < Tl.length; Ll++) {
            Nl.index > Ll ? (Fl = Nl,
            Nl = null) : Fl = Nl.sibling;
            var Ul = xl($l, Nl, Tl[Ll], Rl);
            if (Ul === null) {
                Nl === null && (Nl = Fl);
                break
            }
            xt && Nl && Ul.alternate === null && Cn($l, Nl),
            Sl = Ls(Ul, Sl, Ll),
            Ml === null ? Il = Ul : Ml.sibling = Ul,
            Ml = Ul,
            Nl = Fl
        }
        if (Ll === Tl.length)
            return as($l, Nl),
            I$4 && tg($l, Ll),
            Il;
        if (Nl === null) {
            for (; Ll < Tl.length; Ll++)
                Nl = yl($l, Tl[Ll], Rl),
                Nl !== null && (Sl = Ls(Nl, Sl, Ll),
                Ml === null ? Il = Nl : Ml.sibling = Nl,
                Ml = Nl);
            return I$4 && tg($l, Ll),
            Il
        }
        for (Nl = cs($l, Nl); Ll < Tl.length; Ll++)
            Fl = wl(Nl, $l, Ll, Tl[Ll], Rl),
            Fl !== null && (xt && Fl.alternate !== null && Nl.delete(Fl.key === null ? Ll : Fl.key),
            Sl = Ls(Fl, Sl, Ll),
            Ml === null ? Il = Fl : Ml.sibling = Fl,
            Ml = Fl);
        return xt && Nl.forEach(function(Dl) {
            return Cn($l, Dl)
        }),
        I$4 && tg($l, Ll),
        Il
    }
    function El($l, Sl, Tl, Rl) {
        var Il = Ka$1(Tl);
        if (typeof Il != "function")
            throw Error(p$7(150));
        if (Tl = Il.call(Tl),
        Tl == null)
            throw Error(p$7(151));
        for (var Ml = Il = null, Nl = Sl, Ll = Sl = 0, Fl = null, Ul = Tl.next(); Nl !== null && !Ul.done; Ll++,
        Ul = Tl.next()) {
            Nl.index > Ll ? (Fl = Nl,
            Nl = null) : Fl = Nl.sibling;
            var Dl = xl($l, Nl, Ul.value, Rl);
            if (Dl === null) {
                Nl === null && (Nl = Fl);
                break
            }
            xt && Nl && Dl.alternate === null && Cn($l, Nl),
            Sl = Ls(Dl, Sl, Ll),
            Ml === null ? Il = Dl : Ml.sibling = Dl,
            Ml = Dl,
            Nl = Fl
        }
        if (Ul.done)
            return as($l, Nl),
            I$4 && tg($l, Ll),
            Il;
        if (Nl === null) {
            for (; !Ul.done; Ll++,
            Ul = Tl.next())
                Ul = yl($l, Ul.value, Rl),
                Ul !== null && (Sl = Ls(Ul, Sl, Ll),
                Ml === null ? Il = Ul : Ml.sibling = Ul,
                Ml = Ul);
            return I$4 && tg($l, Ll),
            Il
        }
        for (Nl = cs($l, Nl); !Ul.done; Ll++,
        Ul = Tl.next())
            Ul = wl(Nl, $l, Ll, Ul.value, Rl),
            Ul !== null && (xt && Ul.alternate !== null && Nl.delete(Ul.key === null ? Ll : Ul.key),
            Sl = Ls(Ul, Sl, Ll),
            Ml === null ? Il = Ul : Ml.sibling = Ul,
            Ml = Ul);
        return xt && Nl.forEach(function(Zl) {
            return Cn($l, Zl)
        }),
        I$4 && tg($l, Ll),
        Il
    }
    function Cl($l, Sl, Tl, Rl) {
        if (typeof Tl == "object" && Tl !== null && Tl.type === ya && Tl.key === null && (Tl = Tl.props.children),
        typeof Tl == "object" && Tl !== null) {
            switch (Tl.$$typeof) {
            case va:
                e: {
                    for (var Il = Tl.key, Ml = Sl; Ml !== null; ) {
                        if (Ml.key === Il) {
                            if (Il = Tl.type,
                            Il === ya) {
                                if (Ml.tag === 7) {
                                    as($l, Ml.sibling),
                                    Sl = Cs(Ml, Tl.props.children),
                                    Sl.return = $l,
                                    $l = Sl;
                                    break e
                                }
                            } else if (Ml.elementType === Il || typeof Il == "object" && Il !== null && Il.$$typeof === Ha$1 && Ng(Il) === Ml.type) {
                                as($l, Ml.sibling),
                                Sl = Cs(Ml, Tl.props),
                                Sl.ref = Lg($l, Ml, Tl),
                                Sl.return = $l,
                                $l = Sl;
                                break e
                            }
                            as($l, Ml);
                            break
                        } else
                            Cn($l, Ml);
                        Ml = Ml.sibling
                    }
                    Tl.type === ya ? (Sl = Tg(Tl.props.children, $l.mode, Rl, Tl.key),
                    Sl.return = $l,
                    $l = Sl) : (Rl = Rg(Tl.type, Tl.key, Tl.props, null, $l.mode, Rl),
                    Rl.ref = Lg($l, Sl, Tl),
                    Rl.return = $l,
                    $l = Rl)
                }
                return Vs($l);
            case wa:
                e: {
                    for (Ml = Tl.key; Sl !== null; ) {
                        if (Sl.key === Ml)
                            if (Sl.tag === 4 && Sl.stateNode.containerInfo === Tl.containerInfo && Sl.stateNode.implementation === Tl.implementation) {
                                as($l, Sl.sibling),
                                Sl = Cs(Sl, Tl.children || []),
                                Sl.return = $l,
                                $l = Sl;
                                break e
                            } else {
                                as($l, Sl);
                                break
                            }
                        else
                            Cn($l, Sl);
                        Sl = Sl.sibling
                    }
                    Sl = Sg(Tl, $l.mode, Rl),
                    Sl.return = $l,
                    $l = Sl
                }
                return Vs($l);
            case Ha$1:
                return Ml = Tl._init,
                Cl($l, Sl, Ml(Tl._payload), Rl)
            }
            if (eb(Tl))
                return _l($l, Sl, Tl, Rl);
            if (Ka$1(Tl))
                return El($l, Sl, Tl, Rl);
            Mg($l, Tl)
        }
        return typeof Tl == "string" && Tl !== "" || typeof Tl == "number" ? (Tl = "" + Tl,
        Sl !== null && Sl.tag === 6 ? (as($l, Sl.sibling),
        Sl = Cs(Sl, Tl),
        Sl.return = $l,
        $l = Sl) : (as($l, Sl),
        Sl = Qg(Tl, $l.mode, Rl),
        Sl.return = $l,
        $l = Sl),
        Vs($l)) : as($l, Sl)
    }
    return Cl
}
var Ug = Og(!0)
  , Vg = Og(!1)
  , Wg = Uf(null)
  , Xg = null
  , Yg = null
  , Zg = null;
function $g() {
    Zg = Yg = Xg = null
}
function ah(xt) {
    var Cn = Wg.current;
    E$5(Wg),
    xt._currentValue = Cn
}
function bh(xt, Cn, as) {
    for (; xt !== null; ) {
        var cs = xt.alternate;
        if ((xt.childLanes & Cn) !== Cn ? (xt.childLanes |= Cn,
        cs !== null && (cs.childLanes |= Cn)) : cs !== null && (cs.childLanes & Cn) !== Cn && (cs.childLanes |= Cn),
        xt === as)
            break;
        xt = xt.return
    }
}
function ch(xt, Cn) {
    Xg = xt,
    Zg = Yg = null,
    xt = xt.dependencies,
    xt !== null && xt.firstContext !== null && (xt.lanes & Cn && (dh = !0),
    xt.firstContext = null)
}
function eh(xt) {
    var Cn = xt._currentValue;
    if (Zg !== xt)
        if (xt = {
            context: xt,
            memoizedValue: Cn,
            next: null
        },
        Yg === null) {
            if (Xg === null)
                throw Error(p$7(308));
            Yg = xt,
            Xg.dependencies = {
                lanes: 0,
                firstContext: xt
            }
        } else
            Yg = Yg.next = xt;
    return Cn
}
var fh = null;
function gh(xt) {
    fh === null ? fh = [xt] : fh.push(xt)
}
function hh(xt, Cn, as, cs) {
    var Cs = Cn.interleaved;
    return Cs === null ? (as.next = as,
    gh(Cn)) : (as.next = Cs.next,
    Cs.next = as),
    Cn.interleaved = as,
    ih(xt, cs)
}
function ih(xt, Cn) {
    xt.lanes |= Cn;
    var as = xt.alternate;
    for (as !== null && (as.lanes |= Cn),
    as = xt,
    xt = xt.return; xt !== null; )
        xt.childLanes |= Cn,
        as = xt.alternate,
        as !== null && (as.childLanes |= Cn),
        as = xt,
        xt = xt.return;
    return as.tag === 3 ? as.stateNode : null
}
var jh = !1;
function kh(xt) {
    xt.updateQueue = {
        baseState: xt.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function lh(xt, Cn) {
    xt = xt.updateQueue,
    Cn.updateQueue === xt && (Cn.updateQueue = {
        baseState: xt.baseState,
        firstBaseUpdate: xt.firstBaseUpdate,
        lastBaseUpdate: xt.lastBaseUpdate,
        shared: xt.shared,
        effects: xt.effects
    })
}
function mh(xt, Cn) {
    return {
        eventTime: xt,
        lane: Cn,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function nh(xt, Cn, as) {
    var cs = xt.updateQueue;
    if (cs === null)
        return null;
    if (cs = cs.shared,
    K$3 & 2) {
        var Cs = cs.pending;
        return Cs === null ? Cn.next = Cn : (Cn.next = Cs.next,
        Cs.next = Cn),
        cs.pending = Cn,
        ih(xt, as)
    }
    return Cs = cs.interleaved,
    Cs === null ? (Cn.next = Cn,
    gh(cs)) : (Cn.next = Cs.next,
    Cs.next = Cn),
    cs.interleaved = Cn,
    ih(xt, as)
}
function oh(xt, Cn, as) {
    if (Cn = Cn.updateQueue,
    Cn !== null && (Cn = Cn.shared,
    (as & 4194240) !== 0)) {
        var cs = Cn.lanes;
        cs &= xt.pendingLanes,
        as |= cs,
        Cn.lanes = as,
        Cc$1(xt, as)
    }
}
function ph(xt, Cn) {
    var as = xt.updateQueue
      , cs = xt.alternate;
    if (cs !== null && (cs = cs.updateQueue,
    as === cs)) {
        var Cs = null
          , Ls = null;
        if (as = as.firstBaseUpdate,
        as !== null) {
            do {
                var Vs = {
                    eventTime: as.eventTime,
                    lane: as.lane,
                    tag: as.tag,
                    payload: as.payload,
                    callback: as.callback,
                    next: null
                };
                Ls === null ? Cs = Ls = Vs : Ls = Ls.next = Vs,
                as = as.next
            } while (as !== null);
            Ls === null ? Cs = Ls = Cn : Ls = Ls.next = Cn
        } else
            Cs = Ls = Cn;
        as = {
            baseState: cs.baseState,
            firstBaseUpdate: Cs,
            lastBaseUpdate: Ls,
            shared: cs.shared,
            effects: cs.effects
        },
        xt.updateQueue = as;
        return
    }
    xt = as.lastBaseUpdate,
    xt === null ? as.firstBaseUpdate = Cn : xt.next = Cn,
    as.lastBaseUpdate = Cn
}
function qh(xt, Cn, as, cs) {
    var Cs = xt.updateQueue;
    jh = !1;
    var Ls = Cs.firstBaseUpdate
      , Vs = Cs.lastBaseUpdate
      , Ws = Cs.shared.pending;
    if (Ws !== null) {
        Cs.shared.pending = null;
        var Xs = Ws
          , ga = Xs.next;
        Xs.next = null,
        Vs === null ? Ls = ga : Vs.next = ga,
        Vs = Xs;
        var ba = xt.alternate;
        ba !== null && (ba = ba.updateQueue,
        Ws = ba.lastBaseUpdate,
        Ws !== Vs && (Ws === null ? ba.firstBaseUpdate = ga : Ws.next = ga,
        ba.lastBaseUpdate = Xs))
    }
    if (Ls !== null) {
        var yl = Cs.baseState;
        Vs = 0,
        ba = ga = Xs = null,
        Ws = Ls;
        do {
            var xl = Ws.lane
              , wl = Ws.eventTime;
            if ((cs & xl) === xl) {
                ba !== null && (ba = ba.next = {
                    eventTime: wl,
                    lane: 0,
                    tag: Ws.tag,
                    payload: Ws.payload,
                    callback: Ws.callback,
                    next: null
                });
                e: {
                    var _l = xt
                      , El = Ws;
                    switch (xl = Cn,
                    wl = as,
                    El.tag) {
                    case 1:
                        if (_l = El.payload,
                        typeof _l == "function") {
                            yl = _l.call(wl, yl, xl);
                            break e
                        }
                        yl = _l;
                        break e;
                    case 3:
                        _l.flags = _l.flags & -65537 | 128;
                    case 0:
                        if (_l = El.payload,
                        xl = typeof _l == "function" ? _l.call(wl, yl, xl) : _l,
                        xl == null)
                            break e;
                        yl = A$5({}, yl, xl);
                        break e;
                    case 2:
                        jh = !0
                    }
                }
                Ws.callback !== null && Ws.lane !== 0 && (xt.flags |= 64,
                xl = Cs.effects,
                xl === null ? Cs.effects = [Ws] : xl.push(Ws))
            } else
                wl = {
                    eventTime: wl,
                    lane: xl,
                    tag: Ws.tag,
                    payload: Ws.payload,
                    callback: Ws.callback,
                    next: null
                },
                ba === null ? (ga = ba = wl,
                Xs = yl) : ba = ba.next = wl,
                Vs |= xl;
            if (Ws = Ws.next,
            Ws === null) {
                if (Ws = Cs.shared.pending,
                Ws === null)
                    break;
                xl = Ws,
                Ws = xl.next,
                xl.next = null,
                Cs.lastBaseUpdate = xl,
                Cs.shared.pending = null
            }
        } while (!0);
        if (ba === null && (Xs = yl),
        Cs.baseState = Xs,
        Cs.firstBaseUpdate = ga,
        Cs.lastBaseUpdate = ba,
        Cn = Cs.shared.interleaved,
        Cn !== null) {
            Cs = Cn;
            do
                Vs |= Cs.lane,
                Cs = Cs.next;
            while (Cs !== Cn)
        } else
            Ls === null && (Cs.shared.lanes = 0);
        rh |= Vs,
        xt.lanes = Vs,
        xt.memoizedState = yl
    }
}
function sh(xt, Cn, as) {
    if (xt = Cn.effects,
    Cn.effects = null,
    xt !== null)
        for (Cn = 0; Cn < xt.length; Cn++) {
            var cs = xt[Cn]
              , Cs = cs.callback;
            if (Cs !== null) {
                if (cs.callback = null,
                cs = as,
                typeof Cs != "function")
                    throw Error(p$7(191, Cs));
                Cs.call(cs)
            }
        }
}
var th = {}
  , uh = Uf(th)
  , vh$1 = Uf(th)
  , wh = Uf(th);
function xh(xt) {
    if (xt === th)
        throw Error(p$7(174));
    return xt
}
function yh(xt, Cn) {
    switch (G$3(wh, Cn),
    G$3(vh$1, xt),
    G$3(uh, th),
    xt = Cn.nodeType,
    xt) {
    case 9:
    case 11:
        Cn = (Cn = Cn.documentElement) ? Cn.namespaceURI : lb(null, "");
        break;
    default:
        xt = xt === 8 ? Cn.parentNode : Cn,
        Cn = xt.namespaceURI || null,
        xt = xt.tagName,
        Cn = lb(Cn, xt)
    }
    E$5(uh),
    G$3(uh, Cn)
}
function zh() {
    E$5(uh),
    E$5(vh$1),
    E$5(wh)
}
function Ah(xt) {
    xh(wh.current);
    var Cn = xh(uh.current)
      , as = lb(Cn, xt.type);
    Cn !== as && (G$3(vh$1, xt),
    G$3(uh, as))
}
function Bh(xt) {
    vh$1.current === xt && (E$5(uh),
    E$5(vh$1))
}
var L$3 = Uf(0);
function Ch(xt) {
    for (var Cn = xt; Cn !== null; ) {
        if (Cn.tag === 13) {
            var as = Cn.memoizedState;
            if (as !== null && (as = as.dehydrated,
            as === null || as.data === "$?" || as.data === "$!"))
                return Cn
        } else if (Cn.tag === 19 && Cn.memoizedProps.revealOrder !== void 0) {
            if (Cn.flags & 128)
                return Cn
        } else if (Cn.child !== null) {
            Cn.child.return = Cn,
            Cn = Cn.child;
            continue
        }
        if (Cn === xt)
            break;
        for (; Cn.sibling === null; ) {
            if (Cn.return === null || Cn.return === xt)
                return null;
            Cn = Cn.return
        }
        Cn.sibling.return = Cn.return,
        Cn = Cn.sibling
    }
    return null
}
var Dh = [];
function Eh() {
    for (var xt = 0; xt < Dh.length; xt++)
        Dh[xt]._workInProgressVersionPrimary = null;
    Dh.length = 0
}
var Fh = ua.ReactCurrentDispatcher
  , Gh = ua.ReactCurrentBatchConfig
  , Hh = 0
  , M$7 = null
  , N$3 = null
  , O$3 = null
  , Ih = !1
  , Jh = !1
  , Kh = 0
  , Lh = 0;
function P$8() {
    throw Error(p$7(321))
}
function Mh(xt, Cn) {
    if (Cn === null)
        return !1;
    for (var as = 0; as < Cn.length && as < xt.length; as++)
        if (!He$2(xt[as], Cn[as]))
            return !1;
    return !0
}
function Nh(xt, Cn, as, cs, Cs, Ls) {
    if (Hh = Ls,
    M$7 = Cn,
    Cn.memoizedState = null,
    Cn.updateQueue = null,
    Cn.lanes = 0,
    Fh.current = xt === null || xt.memoizedState === null ? Oh : Ph,
    xt = as(cs, Cs),
    Jh) {
        Ls = 0;
        do {
            if (Jh = !1,
            Kh = 0,
            25 <= Ls)
                throw Error(p$7(301));
            Ls += 1,
            O$3 = N$3 = null,
            Cn.updateQueue = null,
            Fh.current = Qh,
            xt = as(cs, Cs)
        } while (Jh)
    }
    if (Fh.current = Rh,
    Cn = N$3 !== null && N$3.next !== null,
    Hh = 0,
    O$3 = N$3 = M$7 = null,
    Ih = !1,
    Cn)
        throw Error(p$7(300));
    return xt
}
function Sh() {
    var xt = Kh !== 0;
    return Kh = 0,
    xt
}
function Th() {
    var xt = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return O$3 === null ? M$7.memoizedState = O$3 = xt : O$3 = O$3.next = xt,
    O$3
}
function Uh() {
    if (N$3 === null) {
        var xt = M$7.alternate;
        xt = xt !== null ? xt.memoizedState : null
    } else
        xt = N$3.next;
    var Cn = O$3 === null ? M$7.memoizedState : O$3.next;
    if (Cn !== null)
        O$3 = Cn,
        N$3 = xt;
    else {
        if (xt === null)
            throw Error(p$7(310));
        N$3 = xt,
        xt = {
            memoizedState: N$3.memoizedState,
            baseState: N$3.baseState,
            baseQueue: N$3.baseQueue,
            queue: N$3.queue,
            next: null
        },
        O$3 === null ? M$7.memoizedState = O$3 = xt : O$3 = O$3.next = xt
    }
    return O$3
}
function Vh(xt, Cn) {
    return typeof Cn == "function" ? Cn(xt) : Cn
}
function Wh(xt) {
    var Cn = Uh()
      , as = Cn.queue;
    if (as === null)
        throw Error(p$7(311));
    as.lastRenderedReducer = xt;
    var cs = N$3
      , Cs = cs.baseQueue
      , Ls = as.pending;
    if (Ls !== null) {
        if (Cs !== null) {
            var Vs = Cs.next;
            Cs.next = Ls.next,
            Ls.next = Vs
        }
        cs.baseQueue = Cs = Ls,
        as.pending = null
    }
    if (Cs !== null) {
        Ls = Cs.next,
        cs = cs.baseState;
        var Ws = Vs = null
          , Xs = null
          , ga = Ls;
        do {
            var ba = ga.lane;
            if ((Hh & ba) === ba)
                Xs !== null && (Xs = Xs.next = {
                    lane: 0,
                    action: ga.action,
                    hasEagerState: ga.hasEagerState,
                    eagerState: ga.eagerState,
                    next: null
                }),
                cs = ga.hasEagerState ? ga.eagerState : xt(cs, ga.action);
            else {
                var yl = {
                    lane: ba,
                    action: ga.action,
                    hasEagerState: ga.hasEagerState,
                    eagerState: ga.eagerState,
                    next: null
                };
                Xs === null ? (Ws = Xs = yl,
                Vs = cs) : Xs = Xs.next = yl,
                M$7.lanes |= ba,
                rh |= ba
            }
            ga = ga.next
        } while (ga !== null && ga !== Ls);
        Xs === null ? Vs = cs : Xs.next = Ws,
        He$2(cs, Cn.memoizedState) || (dh = !0),
        Cn.memoizedState = cs,
        Cn.baseState = Vs,
        Cn.baseQueue = Xs,
        as.lastRenderedState = cs
    }
    if (xt = as.interleaved,
    xt !== null) {
        Cs = xt;
        do
            Ls = Cs.lane,
            M$7.lanes |= Ls,
            rh |= Ls,
            Cs = Cs.next;
        while (Cs !== xt)
    } else
        Cs === null && (as.lanes = 0);
    return [Cn.memoizedState, as.dispatch]
}
function Xh(xt) {
    var Cn = Uh()
      , as = Cn.queue;
    if (as === null)
        throw Error(p$7(311));
    as.lastRenderedReducer = xt;
    var cs = as.dispatch
      , Cs = as.pending
      , Ls = Cn.memoizedState;
    if (Cs !== null) {
        as.pending = null;
        var Vs = Cs = Cs.next;
        do
            Ls = xt(Ls, Vs.action),
            Vs = Vs.next;
        while (Vs !== Cs);
        He$2(Ls, Cn.memoizedState) || (dh = !0),
        Cn.memoizedState = Ls,
        Cn.baseQueue === null && (Cn.baseState = Ls),
        as.lastRenderedState = Ls
    }
    return [Ls, cs]
}
function Yh() {}
function Zh(xt, Cn) {
    var as = M$7
      , cs = Uh()
      , Cs = Cn()
      , Ls = !He$2(cs.memoizedState, Cs);
    if (Ls && (cs.memoizedState = Cs,
    dh = !0),
    cs = cs.queue,
    $h(ai$1.bind(null, as, cs, xt), [xt]),
    cs.getSnapshot !== Cn || Ls || O$3 !== null && O$3.memoizedState.tag & 1) {
        if (as.flags |= 2048,
        bi$1(9, ci.bind(null, as, cs, Cs, Cn), void 0, null),
        Q$2 === null)
            throw Error(p$7(349));
        Hh & 30 || di(as, Cn, Cs)
    }
    return Cs
}
function di(xt, Cn, as) {
    xt.flags |= 16384,
    xt = {
        getSnapshot: Cn,
        value: as
    },
    Cn = M$7.updateQueue,
    Cn === null ? (Cn = {
        lastEffect: null,
        stores: null
    },
    M$7.updateQueue = Cn,
    Cn.stores = [xt]) : (as = Cn.stores,
    as === null ? Cn.stores = [xt] : as.push(xt))
}
function ci(xt, Cn, as, cs) {
    Cn.value = as,
    Cn.getSnapshot = cs,
    ei(Cn) && fi$1(xt)
}
function ai$1(xt, Cn, as) {
    return as(function() {
        ei(Cn) && fi$1(xt)
    })
}
function ei(xt) {
    var Cn = xt.getSnapshot;
    xt = xt.value;
    try {
        var as = Cn();
        return !He$2(xt, as)
    } catch {
        return !0
    }
}
function fi$1(xt) {
    var Cn = ih(xt, 1);
    Cn !== null && gi$1(Cn, xt, 1, -1)
}
function hi$1(xt) {
    var Cn = Th();
    return typeof xt == "function" && (xt = xt()),
    Cn.memoizedState = Cn.baseState = xt,
    xt = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Vh,
        lastRenderedState: xt
    },
    Cn.queue = xt,
    xt = xt.dispatch = ii$1.bind(null, M$7, xt),
    [Cn.memoizedState, xt]
}
function bi$1(xt, Cn, as, cs) {
    return xt = {
        tag: xt,
        create: Cn,
        destroy: as,
        deps: cs,
        next: null
    },
    Cn = M$7.updateQueue,
    Cn === null ? (Cn = {
        lastEffect: null,
        stores: null
    },
    M$7.updateQueue = Cn,
    Cn.lastEffect = xt.next = xt) : (as = Cn.lastEffect,
    as === null ? Cn.lastEffect = xt.next = xt : (cs = as.next,
    as.next = xt,
    xt.next = cs,
    Cn.lastEffect = xt)),
    xt
}
function ji() {
    return Uh().memoizedState
}
function ki$1(xt, Cn, as, cs) {
    var Cs = Th();
    M$7.flags |= xt,
    Cs.memoizedState = bi$1(1 | Cn, as, void 0, cs === void 0 ? null : cs)
}
function li(xt, Cn, as, cs) {
    var Cs = Uh();
    cs = cs === void 0 ? null : cs;
    var Ls = void 0;
    if (N$3 !== null) {
        var Vs = N$3.memoizedState;
        if (Ls = Vs.destroy,
        cs !== null && Mh(cs, Vs.deps)) {
            Cs.memoizedState = bi$1(Cn, as, Ls, cs);
            return
        }
    }
    M$7.flags |= xt,
    Cs.memoizedState = bi$1(1 | Cn, as, Ls, cs)
}
function mi$1(xt, Cn) {
    return ki$1(8390656, 8, xt, Cn)
}
function $h(xt, Cn) {
    return li(2048, 8, xt, Cn)
}
function ni(xt, Cn) {
    return li(4, 2, xt, Cn)
}
function oi(xt, Cn) {
    return li(4, 4, xt, Cn)
}
function pi(xt, Cn) {
    if (typeof Cn == "function")
        return xt = xt(),
        Cn(xt),
        function() {
            Cn(null)
        }
        ;
    if (Cn != null)
        return xt = xt(),
        Cn.current = xt,
        function() {
            Cn.current = null
        }
}
function qi(xt, Cn, as) {
    return as = as != null ? as.concat([xt]) : null,
    li(4, 4, pi.bind(null, Cn, xt), as)
}
function ri() {}
function si(xt, Cn) {
    var as = Uh();
    Cn = Cn === void 0 ? null : Cn;
    var cs = as.memoizedState;
    return cs !== null && Cn !== null && Mh(Cn, cs[1]) ? cs[0] : (as.memoizedState = [xt, Cn],
    xt)
}
function ti(xt, Cn) {
    var as = Uh();
    Cn = Cn === void 0 ? null : Cn;
    var cs = as.memoizedState;
    return cs !== null && Cn !== null && Mh(Cn, cs[1]) ? cs[0] : (xt = xt(),
    as.memoizedState = [xt, Cn],
    xt)
}
function ui(xt, Cn, as) {
    return Hh & 21 ? (He$2(as, Cn) || (as = yc$1(),
    M$7.lanes |= as,
    rh |= as,
    xt.baseState = !0),
    Cn) : (xt.baseState && (xt.baseState = !1,
    dh = !0),
    xt.memoizedState = as)
}
function vi$1(xt, Cn) {
    var as = C$7;
    C$7 = as !== 0 && 4 > as ? as : 4,
    xt(!0);
    var cs = Gh.transition;
    Gh.transition = {};
    try {
        xt(!1),
        Cn()
    } finally {
        C$7 = as,
        Gh.transition = cs
    }
}
function wi$1() {
    return Uh().memoizedState
}
function xi$1(xt, Cn, as) {
    var cs = yi$1(xt);
    if (as = {
        lane: cs,
        action: as,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    zi(xt))
        Ai$1(Cn, as);
    else if (as = hh(xt, Cn, as, cs),
    as !== null) {
        var Cs = R$2();
        gi$1(as, xt, cs, Cs),
        Bi(as, Cn, cs)
    }
}
function ii$1(xt, Cn, as) {
    var cs = yi$1(xt)
      , Cs = {
        lane: cs,
        action: as,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (zi(xt))
        Ai$1(Cn, Cs);
    else {
        var Ls = xt.alternate;
        if (xt.lanes === 0 && (Ls === null || Ls.lanes === 0) && (Ls = Cn.lastRenderedReducer,
        Ls !== null))
            try {
                var Vs = Cn.lastRenderedState
                  , Ws = Ls(Vs, as);
                if (Cs.hasEagerState = !0,
                Cs.eagerState = Ws,
                He$2(Ws, Vs)) {
                    var Xs = Cn.interleaved;
                    Xs === null ? (Cs.next = Cs,
                    gh(Cn)) : (Cs.next = Xs.next,
                    Xs.next = Cs),
                    Cn.interleaved = Cs;
                    return
                }
            } catch {} finally {}
        as = hh(xt, Cn, Cs, cs),
        as !== null && (Cs = R$2(),
        gi$1(as, xt, cs, Cs),
        Bi(as, Cn, cs))
    }
}
function zi(xt) {
    var Cn = xt.alternate;
    return xt === M$7 || Cn !== null && Cn === M$7
}
function Ai$1(xt, Cn) {
    Jh = Ih = !0;
    var as = xt.pending;
    as === null ? Cn.next = Cn : (Cn.next = as.next,
    as.next = Cn),
    xt.pending = Cn
}
function Bi(xt, Cn, as) {
    if (as & 4194240) {
        var cs = Cn.lanes;
        cs &= xt.pendingLanes,
        as |= cs,
        Cn.lanes = as,
        Cc$1(xt, as)
    }
}
var Rh = {
    readContext: eh,
    useCallback: P$8,
    useContext: P$8,
    useEffect: P$8,
    useImperativeHandle: P$8,
    useInsertionEffect: P$8,
    useLayoutEffect: P$8,
    useMemo: P$8,
    useReducer: P$8,
    useRef: P$8,
    useState: P$8,
    useDebugValue: P$8,
    useDeferredValue: P$8,
    useTransition: P$8,
    useMutableSource: P$8,
    useSyncExternalStore: P$8,
    useId: P$8,
    unstable_isNewReconciler: !1
}
  , Oh = {
    readContext: eh,
    useCallback: function(xt, Cn) {
        return Th().memoizedState = [xt, Cn === void 0 ? null : Cn],
        xt
    },
    useContext: eh,
    useEffect: mi$1,
    useImperativeHandle: function(xt, Cn, as) {
        return as = as != null ? as.concat([xt]) : null,
        ki$1(4194308, 4, pi.bind(null, Cn, xt), as)
    },
    useLayoutEffect: function(xt, Cn) {
        return ki$1(4194308, 4, xt, Cn)
    },
    useInsertionEffect: function(xt, Cn) {
        return ki$1(4, 2, xt, Cn)
    },
    useMemo: function(xt, Cn) {
        var as = Th();
        return Cn = Cn === void 0 ? null : Cn,
        xt = xt(),
        as.memoizedState = [xt, Cn],
        xt
    },
    useReducer: function(xt, Cn, as) {
        var cs = Th();
        return Cn = as !== void 0 ? as(Cn) : Cn,
        cs.memoizedState = cs.baseState = Cn,
        xt = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: xt,
            lastRenderedState: Cn
        },
        cs.queue = xt,
        xt = xt.dispatch = xi$1.bind(null, M$7, xt),
        [cs.memoizedState, xt]
    },
    useRef: function(xt) {
        var Cn = Th();
        return xt = {
            current: xt
        },
        Cn.memoizedState = xt
    },
    useState: hi$1,
    useDebugValue: ri,
    useDeferredValue: function(xt) {
        return Th().memoizedState = xt
    },
    useTransition: function() {
        var xt = hi$1(!1)
          , Cn = xt[0];
        return xt = vi$1.bind(null, xt[1]),
        Th().memoizedState = xt,
        [Cn, xt]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(xt, Cn, as) {
        var cs = M$7
          , Cs = Th();
        if (I$4) {
            if (as === void 0)
                throw Error(p$7(407));
            as = as()
        } else {
            if (as = Cn(),
            Q$2 === null)
                throw Error(p$7(349));
            Hh & 30 || di(cs, Cn, as)
        }
        Cs.memoizedState = as;
        var Ls = {
            value: as,
            getSnapshot: Cn
        };
        return Cs.queue = Ls,
        mi$1(ai$1.bind(null, cs, Ls, xt), [xt]),
        cs.flags |= 2048,
        bi$1(9, ci.bind(null, cs, Ls, as, Cn), void 0, null),
        as
    },
    useId: function() {
        var xt = Th()
          , Cn = Q$2.identifierPrefix;
        if (I$4) {
            var as = sg
              , cs = rg;
            as = (cs & ~(1 << 32 - oc(cs) - 1)).toString(32) + as,
            Cn = ":" + Cn + "R" + as,
            as = Kh++,
            0 < as && (Cn += "H" + as.toString(32)),
            Cn += ":"
        } else
            as = Lh++,
            Cn = ":" + Cn + "r" + as.toString(32) + ":";
        return xt.memoizedState = Cn
    },
    unstable_isNewReconciler: !1
}
  , Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
        return Wh(Vh)
    },
    useDebugValue: ri,
    useDeferredValue: function(xt) {
        var Cn = Uh();
        return ui(Cn, N$3.memoizedState, xt)
    },
    useTransition: function() {
        var xt = Wh(Vh)[0]
          , Cn = Uh().memoizedState;
        return [xt, Cn]
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi$1,
    unstable_isNewReconciler: !1
}
  , Qh = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Xh,
    useRef: ji,
    useState: function() {
        return Xh(Vh)
    },
    useDebugValue: ri,
    useDeferredValue: function(xt) {
        var Cn = Uh();
        return N$3 === null ? Cn.memoizedState = xt : ui(Cn, N$3.memoizedState, xt)
    },
    useTransition: function() {
        var xt = Xh(Vh)[0]
          , Cn = Uh().memoizedState;
        return [xt, Cn]
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi$1,
    unstable_isNewReconciler: !1
};
function Ci$1(xt, Cn) {
    if (xt && xt.defaultProps) {
        Cn = A$5({}, Cn),
        xt = xt.defaultProps;
        for (var as in xt)
            Cn[as] === void 0 && (Cn[as] = xt[as]);
        return Cn
    }
    return Cn
}
function Di(xt, Cn, as, cs) {
    Cn = xt.memoizedState,
    as = as(cs, Cn),
    as = as == null ? Cn : A$5({}, Cn, as),
    xt.memoizedState = as,
    xt.lanes === 0 && (xt.updateQueue.baseState = as)
}
var Ei$1 = {
    isMounted: function(xt) {
        return (xt = xt._reactInternals) ? Vb(xt) === xt : !1
    },
    enqueueSetState: function(xt, Cn, as) {
        xt = xt._reactInternals;
        var cs = R$2()
          , Cs = yi$1(xt)
          , Ls = mh(cs, Cs);
        Ls.payload = Cn,
        as != null && (Ls.callback = as),
        Cn = nh(xt, Ls, Cs),
        Cn !== null && (gi$1(Cn, xt, Cs, cs),
        oh(Cn, xt, Cs))
    },
    enqueueReplaceState: function(xt, Cn, as) {
        xt = xt._reactInternals;
        var cs = R$2()
          , Cs = yi$1(xt)
          , Ls = mh(cs, Cs);
        Ls.tag = 1,
        Ls.payload = Cn,
        as != null && (Ls.callback = as),
        Cn = nh(xt, Ls, Cs),
        Cn !== null && (gi$1(Cn, xt, Cs, cs),
        oh(Cn, xt, Cs))
    },
    enqueueForceUpdate: function(xt, Cn) {
        xt = xt._reactInternals;
        var as = R$2()
          , cs = yi$1(xt)
          , Cs = mh(as, cs);
        Cs.tag = 2,
        Cn != null && (Cs.callback = Cn),
        Cn = nh(xt, Cs, cs),
        Cn !== null && (gi$1(Cn, xt, cs, as),
        oh(Cn, xt, cs))
    }
};
function Fi(xt, Cn, as, cs, Cs, Ls, Vs) {
    return xt = xt.stateNode,
    typeof xt.shouldComponentUpdate == "function" ? xt.shouldComponentUpdate(cs, Ls, Vs) : Cn.prototype && Cn.prototype.isPureReactComponent ? !Ie$3(as, cs) || !Ie$3(Cs, Ls) : !0
}
function Gi(xt, Cn, as) {
    var cs = !1
      , Cs = Vf
      , Ls = Cn.contextType;
    return typeof Ls == "object" && Ls !== null ? Ls = eh(Ls) : (Cs = Zf(Cn) ? Xf : H$8.current,
    cs = Cn.contextTypes,
    Ls = (cs = cs != null) ? Yf(xt, Cs) : Vf),
    Cn = new Cn(as,Ls),
    xt.memoizedState = Cn.state !== null && Cn.state !== void 0 ? Cn.state : null,
    Cn.updater = Ei$1,
    xt.stateNode = Cn,
    Cn._reactInternals = xt,
    cs && (xt = xt.stateNode,
    xt.__reactInternalMemoizedUnmaskedChildContext = Cs,
    xt.__reactInternalMemoizedMaskedChildContext = Ls),
    Cn
}
function Hi$1(xt, Cn, as, cs) {
    xt = Cn.state,
    typeof Cn.componentWillReceiveProps == "function" && Cn.componentWillReceiveProps(as, cs),
    typeof Cn.UNSAFE_componentWillReceiveProps == "function" && Cn.UNSAFE_componentWillReceiveProps(as, cs),
    Cn.state !== xt && Ei$1.enqueueReplaceState(Cn, Cn.state, null)
}
function Ii$1(xt, Cn, as, cs) {
    var Cs = xt.stateNode;
    Cs.props = as,
    Cs.state = xt.memoizedState,
    Cs.refs = {},
    kh(xt);
    var Ls = Cn.contextType;
    typeof Ls == "object" && Ls !== null ? Cs.context = eh(Ls) : (Ls = Zf(Cn) ? Xf : H$8.current,
    Cs.context = Yf(xt, Ls)),
    Cs.state = xt.memoizedState,
    Ls = Cn.getDerivedStateFromProps,
    typeof Ls == "function" && (Di(xt, Cn, Ls, as),
    Cs.state = xt.memoizedState),
    typeof Cn.getDerivedStateFromProps == "function" || typeof Cs.getSnapshotBeforeUpdate == "function" || typeof Cs.UNSAFE_componentWillMount != "function" && typeof Cs.componentWillMount != "function" || (Cn = Cs.state,
    typeof Cs.componentWillMount == "function" && Cs.componentWillMount(),
    typeof Cs.UNSAFE_componentWillMount == "function" && Cs.UNSAFE_componentWillMount(),
    Cn !== Cs.state && Ei$1.enqueueReplaceState(Cs, Cs.state, null),
    qh(xt, as, Cs, cs),
    Cs.state = xt.memoizedState),
    typeof Cs.componentDidMount == "function" && (xt.flags |= 4194308)
}
function Ji(xt, Cn) {
    try {
        var as = ""
          , cs = Cn;
        do
            as += Pa$1(cs),
            cs = cs.return;
        while (cs);
        var Cs = as
    } catch (Ls) {
        Cs = `
Error generating stack: ` + Ls.message + `
` + Ls.stack
    }
    return {
        value: xt,
        source: Cn,
        stack: Cs,
        digest: null
    }
}
function Ki(xt, Cn, as) {
    return {
        value: xt,
        source: null,
        stack: as ?? null,
        digest: Cn ?? null
    }
}
function Li(xt, Cn) {
    try {
        console.error(Cn.value)
    } catch (as) {
        setTimeout(function() {
            throw as
        })
    }
}
var Mi = typeof WeakMap == "function" ? WeakMap : Map;
function Ni(xt, Cn, as) {
    as = mh(-1, as),
    as.tag = 3,
    as.payload = {
        element: null
    };
    var cs = Cn.value;
    return as.callback = function() {
        Oi$1 || (Oi$1 = !0,
        Pi = cs),
        Li(xt, Cn)
    }
    ,
    as
}
function Qi(xt, Cn, as) {
    as = mh(-1, as),
    as.tag = 3;
    var cs = xt.type.getDerivedStateFromError;
    if (typeof cs == "function") {
        var Cs = Cn.value;
        as.payload = function() {
            return cs(Cs)
        }
        ,
        as.callback = function() {
            Li(xt, Cn)
        }
    }
    var Ls = xt.stateNode;
    return Ls !== null && typeof Ls.componentDidCatch == "function" && (as.callback = function() {
        Li(xt, Cn),
        typeof cs != "function" && (Ri$1 === null ? Ri$1 = new Set([this]) : Ri$1.add(this));
        var Vs = Cn.stack;
        this.componentDidCatch(Cn.value, {
            componentStack: Vs !== null ? Vs : ""
        })
    }
    ),
    as
}
function Si$1(xt, Cn, as) {
    var cs = xt.pingCache;
    if (cs === null) {
        cs = xt.pingCache = new Mi;
        var Cs = new Set;
        cs.set(Cn, Cs)
    } else
        Cs = cs.get(Cn),
        Cs === void 0 && (Cs = new Set,
        cs.set(Cn, Cs));
    Cs.has(as) || (Cs.add(as),
    xt = Ti$1.bind(null, xt, Cn, as),
    Cn.then(xt, xt))
}
function Ui(xt) {
    do {
        var Cn;
        if ((Cn = xt.tag === 13) && (Cn = xt.memoizedState,
        Cn = Cn !== null ? Cn.dehydrated !== null : !0),
        Cn)
            return xt;
        xt = xt.return
    } while (xt !== null);
    return null
}
function Vi(xt, Cn, as, cs, Cs) {
    return xt.mode & 1 ? (xt.flags |= 65536,
    xt.lanes = Cs,
    xt) : (xt === Cn ? xt.flags |= 65536 : (xt.flags |= 128,
    as.flags |= 131072,
    as.flags &= -52805,
    as.tag === 1 && (as.alternate === null ? as.tag = 17 : (Cn = mh(-1, 1),
    Cn.tag = 2,
    nh(as, Cn, 1))),
    as.lanes |= 1),
    xt)
}
var Wi = ua.ReactCurrentOwner
  , dh = !1;
function Xi(xt, Cn, as, cs) {
    Cn.child = xt === null ? Vg(Cn, null, as, cs) : Ug(Cn, xt.child, as, cs)
}
function Yi(xt, Cn, as, cs, Cs) {
    as = as.render;
    var Ls = Cn.ref;
    return ch(Cn, Cs),
    cs = Nh(xt, Cn, as, cs, Ls, Cs),
    as = Sh(),
    xt !== null && !dh ? (Cn.updateQueue = xt.updateQueue,
    Cn.flags &= -2053,
    xt.lanes &= ~Cs,
    Zi(xt, Cn, Cs)) : (I$4 && as && vg(Cn),
    Cn.flags |= 1,
    Xi(xt, Cn, cs, Cs),
    Cn.child)
}
function $i(xt, Cn, as, cs, Cs) {
    if (xt === null) {
        var Ls = as.type;
        return typeof Ls == "function" && !aj(Ls) && Ls.defaultProps === void 0 && as.compare === null && as.defaultProps === void 0 ? (Cn.tag = 15,
        Cn.type = Ls,
        bj(xt, Cn, Ls, cs, Cs)) : (xt = Rg(as.type, null, cs, Cn, Cn.mode, Cs),
        xt.ref = Cn.ref,
        xt.return = Cn,
        Cn.child = xt)
    }
    if (Ls = xt.child,
    !(xt.lanes & Cs)) {
        var Vs = Ls.memoizedProps;
        if (as = as.compare,
        as = as !== null ? as : Ie$3,
        as(Vs, cs) && xt.ref === Cn.ref)
            return Zi(xt, Cn, Cs)
    }
    return Cn.flags |= 1,
    xt = Pg(Ls, cs),
    xt.ref = Cn.ref,
    xt.return = Cn,
    Cn.child = xt
}
function bj(xt, Cn, as, cs, Cs) {
    if (xt !== null) {
        var Ls = xt.memoizedProps;
        if (Ie$3(Ls, cs) && xt.ref === Cn.ref)
            if (dh = !1,
            Cn.pendingProps = cs = Ls,
            (xt.lanes & Cs) !== 0)
                xt.flags & 131072 && (dh = !0);
            else
                return Cn.lanes = xt.lanes,
                Zi(xt, Cn, Cs)
    }
    return cj(xt, Cn, as, cs, Cs)
}
function dj(xt, Cn, as) {
    var cs = Cn.pendingProps
      , Cs = cs.children
      , Ls = xt !== null ? xt.memoizedState : null;
    if (cs.mode === "hidden")
        if (!(Cn.mode & 1))
            Cn.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            G$3(ej, fj),
            fj |= as;
        else {
            if (!(as & 1073741824))
                return xt = Ls !== null ? Ls.baseLanes | as : as,
                Cn.lanes = Cn.childLanes = 1073741824,
                Cn.memoizedState = {
                    baseLanes: xt,
                    cachePool: null,
                    transitions: null
                },
                Cn.updateQueue = null,
                G$3(ej, fj),
                fj |= xt,
                null;
            Cn.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            cs = Ls !== null ? Ls.baseLanes : as,
            G$3(ej, fj),
            fj |= cs
        }
    else
        Ls !== null ? (cs = Ls.baseLanes | as,
        Cn.memoizedState = null) : cs = as,
        G$3(ej, fj),
        fj |= cs;
    return Xi(xt, Cn, Cs, as),
    Cn.child
}
function gj(xt, Cn) {
    var as = Cn.ref;
    (xt === null && as !== null || xt !== null && xt.ref !== as) && (Cn.flags |= 512,
    Cn.flags |= 2097152)
}
function cj(xt, Cn, as, cs, Cs) {
    var Ls = Zf(as) ? Xf : H$8.current;
    return Ls = Yf(Cn, Ls),
    ch(Cn, Cs),
    as = Nh(xt, Cn, as, cs, Ls, Cs),
    cs = Sh(),
    xt !== null && !dh ? (Cn.updateQueue = xt.updateQueue,
    Cn.flags &= -2053,
    xt.lanes &= ~Cs,
    Zi(xt, Cn, Cs)) : (I$4 && cs && vg(Cn),
    Cn.flags |= 1,
    Xi(xt, Cn, as, Cs),
    Cn.child)
}
function hj(xt, Cn, as, cs, Cs) {
    if (Zf(as)) {
        var Ls = !0;
        cg(Cn)
    } else
        Ls = !1;
    if (ch(Cn, Cs),
    Cn.stateNode === null)
        ij(xt, Cn),
        Gi(Cn, as, cs),
        Ii$1(Cn, as, cs, Cs),
        cs = !0;
    else if (xt === null) {
        var Vs = Cn.stateNode
          , Ws = Cn.memoizedProps;
        Vs.props = Ws;
        var Xs = Vs.context
          , ga = as.contextType;
        typeof ga == "object" && ga !== null ? ga = eh(ga) : (ga = Zf(as) ? Xf : H$8.current,
        ga = Yf(Cn, ga));
        var ba = as.getDerivedStateFromProps
          , yl = typeof ba == "function" || typeof Vs.getSnapshotBeforeUpdate == "function";
        yl || typeof Vs.UNSAFE_componentWillReceiveProps != "function" && typeof Vs.componentWillReceiveProps != "function" || (Ws !== cs || Xs !== ga) && Hi$1(Cn, Vs, cs, ga),
        jh = !1;
        var xl = Cn.memoizedState;
        Vs.state = xl,
        qh(Cn, cs, Vs, Cs),
        Xs = Cn.memoizedState,
        Ws !== cs || xl !== Xs || Wf.current || jh ? (typeof ba == "function" && (Di(Cn, as, ba, cs),
        Xs = Cn.memoizedState),
        (Ws = jh || Fi(Cn, as, Ws, cs, xl, Xs, ga)) ? (yl || typeof Vs.UNSAFE_componentWillMount != "function" && typeof Vs.componentWillMount != "function" || (typeof Vs.componentWillMount == "function" && Vs.componentWillMount(),
        typeof Vs.UNSAFE_componentWillMount == "function" && Vs.UNSAFE_componentWillMount()),
        typeof Vs.componentDidMount == "function" && (Cn.flags |= 4194308)) : (typeof Vs.componentDidMount == "function" && (Cn.flags |= 4194308),
        Cn.memoizedProps = cs,
        Cn.memoizedState = Xs),
        Vs.props = cs,
        Vs.state = Xs,
        Vs.context = ga,
        cs = Ws) : (typeof Vs.componentDidMount == "function" && (Cn.flags |= 4194308),
        cs = !1)
    } else {
        Vs = Cn.stateNode,
        lh(xt, Cn),
        Ws = Cn.memoizedProps,
        ga = Cn.type === Cn.elementType ? Ws : Ci$1(Cn.type, Ws),
        Vs.props = ga,
        yl = Cn.pendingProps,
        xl = Vs.context,
        Xs = as.contextType,
        typeof Xs == "object" && Xs !== null ? Xs = eh(Xs) : (Xs = Zf(as) ? Xf : H$8.current,
        Xs = Yf(Cn, Xs));
        var wl = as.getDerivedStateFromProps;
        (ba = typeof wl == "function" || typeof Vs.getSnapshotBeforeUpdate == "function") || typeof Vs.UNSAFE_componentWillReceiveProps != "function" && typeof Vs.componentWillReceiveProps != "function" || (Ws !== yl || xl !== Xs) && Hi$1(Cn, Vs, cs, Xs),
        jh = !1,
        xl = Cn.memoizedState,
        Vs.state = xl,
        qh(Cn, cs, Vs, Cs);
        var _l = Cn.memoizedState;
        Ws !== yl || xl !== _l || Wf.current || jh ? (typeof wl == "function" && (Di(Cn, as, wl, cs),
        _l = Cn.memoizedState),
        (ga = jh || Fi(Cn, as, ga, cs, xl, _l, Xs) || !1) ? (ba || typeof Vs.UNSAFE_componentWillUpdate != "function" && typeof Vs.componentWillUpdate != "function" || (typeof Vs.componentWillUpdate == "function" && Vs.componentWillUpdate(cs, _l, Xs),
        typeof Vs.UNSAFE_componentWillUpdate == "function" && Vs.UNSAFE_componentWillUpdate(cs, _l, Xs)),
        typeof Vs.componentDidUpdate == "function" && (Cn.flags |= 4),
        typeof Vs.getSnapshotBeforeUpdate == "function" && (Cn.flags |= 1024)) : (typeof Vs.componentDidUpdate != "function" || Ws === xt.memoizedProps && xl === xt.memoizedState || (Cn.flags |= 4),
        typeof Vs.getSnapshotBeforeUpdate != "function" || Ws === xt.memoizedProps && xl === xt.memoizedState || (Cn.flags |= 1024),
        Cn.memoizedProps = cs,
        Cn.memoizedState = _l),
        Vs.props = cs,
        Vs.state = _l,
        Vs.context = Xs,
        cs = ga) : (typeof Vs.componentDidUpdate != "function" || Ws === xt.memoizedProps && xl === xt.memoizedState || (Cn.flags |= 4),
        typeof Vs.getSnapshotBeforeUpdate != "function" || Ws === xt.memoizedProps && xl === xt.memoizedState || (Cn.flags |= 1024),
        cs = !1)
    }
    return jj(xt, Cn, as, cs, Ls, Cs)
}
function jj(xt, Cn, as, cs, Cs, Ls) {
    gj(xt, Cn);
    var Vs = (Cn.flags & 128) !== 0;
    if (!cs && !Vs)
        return Cs && dg(Cn, as, !1),
        Zi(xt, Cn, Ls);
    cs = Cn.stateNode,
    Wi.current = Cn;
    var Ws = Vs && typeof as.getDerivedStateFromError != "function" ? null : cs.render();
    return Cn.flags |= 1,
    xt !== null && Vs ? (Cn.child = Ug(Cn, xt.child, null, Ls),
    Cn.child = Ug(Cn, null, Ws, Ls)) : Xi(xt, Cn, Ws, Ls),
    Cn.memoizedState = cs.state,
    Cs && dg(Cn, as, !0),
    Cn.child
}
function kj(xt) {
    var Cn = xt.stateNode;
    Cn.pendingContext ? ag(xt, Cn.pendingContext, Cn.pendingContext !== Cn.context) : Cn.context && ag(xt, Cn.context, !1),
    yh(xt, Cn.containerInfo)
}
function lj(xt, Cn, as, cs, Cs) {
    return Ig(),
    Jg(Cs),
    Cn.flags |= 256,
    Xi(xt, Cn, as, cs),
    Cn.child
}
var mj = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function nj(xt) {
    return {
        baseLanes: xt,
        cachePool: null,
        transitions: null
    }
}
function oj(xt, Cn, as) {
    var cs = Cn.pendingProps, Cs = L$3.current, Ls = !1, Vs = (Cn.flags & 128) !== 0, Ws;
    if ((Ws = Vs) || (Ws = xt !== null && xt.memoizedState === null ? !1 : (Cs & 2) !== 0),
    Ws ? (Ls = !0,
    Cn.flags &= -129) : (xt === null || xt.memoizedState !== null) && (Cs |= 1),
    G$3(L$3, Cs & 1),
    xt === null)
        return Eg(Cn),
        xt = Cn.memoizedState,
        xt !== null && (xt = xt.dehydrated,
        xt !== null) ? (Cn.mode & 1 ? xt.data === "$!" ? Cn.lanes = 8 : Cn.lanes = 1073741824 : Cn.lanes = 1,
        null) : (Vs = cs.children,
        xt = cs.fallback,
        Ls ? (cs = Cn.mode,
        Ls = Cn.child,
        Vs = {
            mode: "hidden",
            children: Vs
        },
        !(cs & 1) && Ls !== null ? (Ls.childLanes = 0,
        Ls.pendingProps = Vs) : Ls = pj(Vs, cs, 0, null),
        xt = Tg(xt, cs, as, null),
        Ls.return = Cn,
        xt.return = Cn,
        Ls.sibling = xt,
        Cn.child = Ls,
        Cn.child.memoizedState = nj(as),
        Cn.memoizedState = mj,
        xt) : qj(Cn, Vs));
    if (Cs = xt.memoizedState,
    Cs !== null && (Ws = Cs.dehydrated,
    Ws !== null))
        return rj(xt, Cn, Vs, cs, Ws, Cs, as);
    if (Ls) {
        Ls = cs.fallback,
        Vs = Cn.mode,
        Cs = xt.child,
        Ws = Cs.sibling;
        var Xs = {
            mode: "hidden",
            children: cs.children
        };
        return !(Vs & 1) && Cn.child !== Cs ? (cs = Cn.child,
        cs.childLanes = 0,
        cs.pendingProps = Xs,
        Cn.deletions = null) : (cs = Pg(Cs, Xs),
        cs.subtreeFlags = Cs.subtreeFlags & 14680064),
        Ws !== null ? Ls = Pg(Ws, Ls) : (Ls = Tg(Ls, Vs, as, null),
        Ls.flags |= 2),
        Ls.return = Cn,
        cs.return = Cn,
        cs.sibling = Ls,
        Cn.child = cs,
        cs = Ls,
        Ls = Cn.child,
        Vs = xt.child.memoizedState,
        Vs = Vs === null ? nj(as) : {
            baseLanes: Vs.baseLanes | as,
            cachePool: null,
            transitions: Vs.transitions
        },
        Ls.memoizedState = Vs,
        Ls.childLanes = xt.childLanes & ~as,
        Cn.memoizedState = mj,
        cs
    }
    return Ls = xt.child,
    xt = Ls.sibling,
    cs = Pg(Ls, {
        mode: "visible",
        children: cs.children
    }),
    !(Cn.mode & 1) && (cs.lanes = as),
    cs.return = Cn,
    cs.sibling = null,
    xt !== null && (as = Cn.deletions,
    as === null ? (Cn.deletions = [xt],
    Cn.flags |= 16) : as.push(xt)),
    Cn.child = cs,
    Cn.memoizedState = null,
    cs
}
function qj(xt, Cn) {
    return Cn = pj({
        mode: "visible",
        children: Cn
    }, xt.mode, 0, null),
    Cn.return = xt,
    xt.child = Cn
}
function sj(xt, Cn, as, cs) {
    return cs !== null && Jg(cs),
    Ug(Cn, xt.child, null, as),
    xt = qj(Cn, Cn.pendingProps.children),
    xt.flags |= 2,
    Cn.memoizedState = null,
    xt
}
function rj(xt, Cn, as, cs, Cs, Ls, Vs) {
    if (as)
        return Cn.flags & 256 ? (Cn.flags &= -257,
        cs = Ki(Error(p$7(422))),
        sj(xt, Cn, Vs, cs)) : Cn.memoizedState !== null ? (Cn.child = xt.child,
        Cn.flags |= 128,
        null) : (Ls = cs.fallback,
        Cs = Cn.mode,
        cs = pj({
            mode: "visible",
            children: cs.children
        }, Cs, 0, null),
        Ls = Tg(Ls, Cs, Vs, null),
        Ls.flags |= 2,
        cs.return = Cn,
        Ls.return = Cn,
        cs.sibling = Ls,
        Cn.child = cs,
        Cn.mode & 1 && Ug(Cn, xt.child, null, Vs),
        Cn.child.memoizedState = nj(Vs),
        Cn.memoizedState = mj,
        Ls);
    if (!(Cn.mode & 1))
        return sj(xt, Cn, Vs, null);
    if (Cs.data === "$!") {
        if (cs = Cs.nextSibling && Cs.nextSibling.dataset,
        cs)
            var Ws = cs.dgst;
        return cs = Ws,
        Ls = Error(p$7(419)),
        cs = Ki(Ls, cs, void 0),
        sj(xt, Cn, Vs, cs)
    }
    if (Ws = (Vs & xt.childLanes) !== 0,
    dh || Ws) {
        if (cs = Q$2,
        cs !== null) {
            switch (Vs & -Vs) {
            case 4:
                Cs = 2;
                break;
            case 16:
                Cs = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                Cs = 32;
                break;
            case 536870912:
                Cs = 268435456;
                break;
            default:
                Cs = 0
            }
            Cs = Cs & (cs.suspendedLanes | Vs) ? 0 : Cs,
            Cs !== 0 && Cs !== Ls.retryLane && (Ls.retryLane = Cs,
            ih(xt, Cs),
            gi$1(cs, xt, Cs, -1))
        }
        return tj(),
        cs = Ki(Error(p$7(421))),
        sj(xt, Cn, Vs, cs)
    }
    return Cs.data === "$?" ? (Cn.flags |= 128,
    Cn.child = xt.child,
    Cn = uj.bind(null, xt),
    Cs._reactRetry = Cn,
    null) : (xt = Ls.treeContext,
    yg = Lf(Cs.nextSibling),
    xg = Cn,
    I$4 = !0,
    zg = null,
    xt !== null && (og[pg++] = rg,
    og[pg++] = sg,
    og[pg++] = qg,
    rg = xt.id,
    sg = xt.overflow,
    qg = Cn),
    Cn = qj(Cn, cs.children),
    Cn.flags |= 4096,
    Cn)
}
function vj(xt, Cn, as) {
    xt.lanes |= Cn;
    var cs = xt.alternate;
    cs !== null && (cs.lanes |= Cn),
    bh(xt.return, Cn, as)
}
function wj(xt, Cn, as, cs, Cs) {
    var Ls = xt.memoizedState;
    Ls === null ? xt.memoizedState = {
        isBackwards: Cn,
        rendering: null,
        renderingStartTime: 0,
        last: cs,
        tail: as,
        tailMode: Cs
    } : (Ls.isBackwards = Cn,
    Ls.rendering = null,
    Ls.renderingStartTime = 0,
    Ls.last = cs,
    Ls.tail = as,
    Ls.tailMode = Cs)
}
function xj(xt, Cn, as) {
    var cs = Cn.pendingProps
      , Cs = cs.revealOrder
      , Ls = cs.tail;
    if (Xi(xt, Cn, cs.children, as),
    cs = L$3.current,
    cs & 2)
        cs = cs & 1 | 2,
        Cn.flags |= 128;
    else {
        if (xt !== null && xt.flags & 128)
            e: for (xt = Cn.child; xt !== null; ) {
                if (xt.tag === 13)
                    xt.memoizedState !== null && vj(xt, as, Cn);
                else if (xt.tag === 19)
                    vj(xt, as, Cn);
                else if (xt.child !== null) {
                    xt.child.return = xt,
                    xt = xt.child;
                    continue
                }
                if (xt === Cn)
                    break e;
                for (; xt.sibling === null; ) {
                    if (xt.return === null || xt.return === Cn)
                        break e;
                    xt = xt.return
                }
                xt.sibling.return = xt.return,
                xt = xt.sibling
            }
        cs &= 1
    }
    if (G$3(L$3, cs),
    !(Cn.mode & 1))
        Cn.memoizedState = null;
    else
        switch (Cs) {
        case "forwards":
            for (as = Cn.child,
            Cs = null; as !== null; )
                xt = as.alternate,
                xt !== null && Ch(xt) === null && (Cs = as),
                as = as.sibling;
            as = Cs,
            as === null ? (Cs = Cn.child,
            Cn.child = null) : (Cs = as.sibling,
            as.sibling = null),
            wj(Cn, !1, Cs, as, Ls);
            break;
        case "backwards":
            for (as = null,
            Cs = Cn.child,
            Cn.child = null; Cs !== null; ) {
                if (xt = Cs.alternate,
                xt !== null && Ch(xt) === null) {
                    Cn.child = Cs;
                    break
                }
                xt = Cs.sibling,
                Cs.sibling = as,
                as = Cs,
                Cs = xt
            }
            wj(Cn, !0, as, null, Ls);
            break;
        case "together":
            wj(Cn, !1, null, null, void 0);
            break;
        default:
            Cn.memoizedState = null
        }
    return Cn.child
}
function ij(xt, Cn) {
    !(Cn.mode & 1) && xt !== null && (xt.alternate = null,
    Cn.alternate = null,
    Cn.flags |= 2)
}
function Zi(xt, Cn, as) {
    if (xt !== null && (Cn.dependencies = xt.dependencies),
    rh |= Cn.lanes,
    !(as & Cn.childLanes))
        return null;
    if (xt !== null && Cn.child !== xt.child)
        throw Error(p$7(153));
    if (Cn.child !== null) {
        for (xt = Cn.child,
        as = Pg(xt, xt.pendingProps),
        Cn.child = as,
        as.return = Cn; xt.sibling !== null; )
            xt = xt.sibling,
            as = as.sibling = Pg(xt, xt.pendingProps),
            as.return = Cn;
        as.sibling = null
    }
    return Cn.child
}
function yj(xt, Cn, as) {
    switch (Cn.tag) {
    case 3:
        kj(Cn),
        Ig();
        break;
    case 5:
        Ah(Cn);
        break;
    case 1:
        Zf(Cn.type) && cg(Cn);
        break;
    case 4:
        yh(Cn, Cn.stateNode.containerInfo);
        break;
    case 10:
        var cs = Cn.type._context
          , Cs = Cn.memoizedProps.value;
        G$3(Wg, cs._currentValue),
        cs._currentValue = Cs;
        break;
    case 13:
        if (cs = Cn.memoizedState,
        cs !== null)
            return cs.dehydrated !== null ? (G$3(L$3, L$3.current & 1),
            Cn.flags |= 128,
            null) : as & Cn.child.childLanes ? oj(xt, Cn, as) : (G$3(L$3, L$3.current & 1),
            xt = Zi(xt, Cn, as),
            xt !== null ? xt.sibling : null);
        G$3(L$3, L$3.current & 1);
        break;
    case 19:
        if (cs = (as & Cn.childLanes) !== 0,
        xt.flags & 128) {
            if (cs)
                return xj(xt, Cn, as);
            Cn.flags |= 128
        }
        if (Cs = Cn.memoizedState,
        Cs !== null && (Cs.rendering = null,
        Cs.tail = null,
        Cs.lastEffect = null),
        G$3(L$3, L$3.current),
        cs)
            break;
        return null;
    case 22:
    case 23:
        return Cn.lanes = 0,
        dj(xt, Cn, as)
    }
    return Zi(xt, Cn, as)
}
var zj, Aj, Bj, Cj;
zj = function(xt, Cn) {
    for (var as = Cn.child; as !== null; ) {
        if (as.tag === 5 || as.tag === 6)
            xt.appendChild(as.stateNode);
        else if (as.tag !== 4 && as.child !== null) {
            as.child.return = as,
            as = as.child;
            continue
        }
        if (as === Cn)
            break;
        for (; as.sibling === null; ) {
            if (as.return === null || as.return === Cn)
                return;
            as = as.return
        }
        as.sibling.return = as.return,
        as = as.sibling
    }
}
;
Aj = function() {}
;
Bj = function(xt, Cn, as, cs) {
    var Cs = xt.memoizedProps;
    if (Cs !== cs) {
        xt = Cn.stateNode,
        xh(uh.current);
        var Ls = null;
        switch (as) {
        case "input":
            Cs = Ya$1(xt, Cs),
            cs = Ya$1(xt, cs),
            Ls = [];
            break;
        case "select":
            Cs = A$5({}, Cs, {
                value: void 0
            }),
            cs = A$5({}, cs, {
                value: void 0
            }),
            Ls = [];
            break;
        case "textarea":
            Cs = gb(xt, Cs),
            cs = gb(xt, cs),
            Ls = [];
            break;
        default:
            typeof Cs.onClick != "function" && typeof cs.onClick == "function" && (xt.onclick = Bf)
        }
        ub(as, cs);
        var Vs;
        as = null;
        for (ga in Cs)
            if (!cs.hasOwnProperty(ga) && Cs.hasOwnProperty(ga) && Cs[ga] != null)
                if (ga === "style") {
                    var Ws = Cs[ga];
                    for (Vs in Ws)
                        Ws.hasOwnProperty(Vs) && (as || (as = {}),
                        as[Vs] = "")
                } else
                    ga !== "dangerouslySetInnerHTML" && ga !== "children" && ga !== "suppressContentEditableWarning" && ga !== "suppressHydrationWarning" && ga !== "autoFocus" && (ea.hasOwnProperty(ga) ? Ls || (Ls = []) : (Ls = Ls || []).push(ga, null));
        for (ga in cs) {
            var Xs = cs[ga];
            if (Ws = Cs != null ? Cs[ga] : void 0,
            cs.hasOwnProperty(ga) && Xs !== Ws && (Xs != null || Ws != null))
                if (ga === "style")
                    if (Ws) {
                        for (Vs in Ws)
                            !Ws.hasOwnProperty(Vs) || Xs && Xs.hasOwnProperty(Vs) || (as || (as = {}),
                            as[Vs] = "");
                        for (Vs in Xs)
                            Xs.hasOwnProperty(Vs) && Ws[Vs] !== Xs[Vs] && (as || (as = {}),
                            as[Vs] = Xs[Vs])
                    } else
                        as || (Ls || (Ls = []),
                        Ls.push(ga, as)),
                        as = Xs;
                else
                    ga === "dangerouslySetInnerHTML" ? (Xs = Xs ? Xs.__html : void 0,
                    Ws = Ws ? Ws.__html : void 0,
                    Xs != null && Ws !== Xs && (Ls = Ls || []).push(ga, Xs)) : ga === "children" ? typeof Xs != "string" && typeof Xs != "number" || (Ls = Ls || []).push(ga, "" + Xs) : ga !== "suppressContentEditableWarning" && ga !== "suppressHydrationWarning" && (ea.hasOwnProperty(ga) ? (Xs != null && ga === "onScroll" && D$3("scroll", xt),
                    Ls || Ws === Xs || (Ls = [])) : (Ls = Ls || []).push(ga, Xs))
        }
        as && (Ls = Ls || []).push("style", as);
        var ga = Ls;
        (Cn.updateQueue = ga) && (Cn.flags |= 4)
    }
}
;
Cj = function(xt, Cn, as, cs) {
    as !== cs && (Cn.flags |= 4)
}
;
function Dj(xt, Cn) {
    if (!I$4)
        switch (xt.tailMode) {
        case "hidden":
            Cn = xt.tail;
            for (var as = null; Cn !== null; )
                Cn.alternate !== null && (as = Cn),
                Cn = Cn.sibling;
            as === null ? xt.tail = null : as.sibling = null;
            break;
        case "collapsed":
            as = xt.tail;
            for (var cs = null; as !== null; )
                as.alternate !== null && (cs = as),
                as = as.sibling;
            cs === null ? Cn || xt.tail === null ? xt.tail = null : xt.tail.sibling = null : cs.sibling = null
        }
}
function S$4(xt) {
    var Cn = xt.alternate !== null && xt.alternate.child === xt.child
      , as = 0
      , cs = 0;
    if (Cn)
        for (var Cs = xt.child; Cs !== null; )
            as |= Cs.lanes | Cs.childLanes,
            cs |= Cs.subtreeFlags & 14680064,
            cs |= Cs.flags & 14680064,
            Cs.return = xt,
            Cs = Cs.sibling;
    else
        for (Cs = xt.child; Cs !== null; )
            as |= Cs.lanes | Cs.childLanes,
            cs |= Cs.subtreeFlags,
            cs |= Cs.flags,
            Cs.return = xt,
            Cs = Cs.sibling;
    return xt.subtreeFlags |= cs,
    xt.childLanes = as,
    Cn
}
function Ej(xt, Cn, as) {
    var cs = Cn.pendingProps;
    switch (wg(Cn),
    Cn.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return S$4(Cn),
        null;
    case 1:
        return Zf(Cn.type) && $f(),
        S$4(Cn),
        null;
    case 3:
        return cs = Cn.stateNode,
        zh(),
        E$5(Wf),
        E$5(H$8),
        Eh(),
        cs.pendingContext && (cs.context = cs.pendingContext,
        cs.pendingContext = null),
        (xt === null || xt.child === null) && (Gg(Cn) ? Cn.flags |= 4 : xt === null || xt.memoizedState.isDehydrated && !(Cn.flags & 256) || (Cn.flags |= 1024,
        zg !== null && (Fj(zg),
        zg = null))),
        Aj(xt, Cn),
        S$4(Cn),
        null;
    case 5:
        Bh(Cn);
        var Cs = xh(wh.current);
        if (as = Cn.type,
        xt !== null && Cn.stateNode != null)
            Bj(xt, Cn, as, cs, Cs),
            xt.ref !== Cn.ref && (Cn.flags |= 512,
            Cn.flags |= 2097152);
        else {
            if (!cs) {
                if (Cn.stateNode === null)
                    throw Error(p$7(166));
                return S$4(Cn),
                null
            }
            if (xt = xh(uh.current),
            Gg(Cn)) {
                cs = Cn.stateNode,
                as = Cn.type;
                var Ls = Cn.memoizedProps;
                switch (cs[Of] = Cn,
                cs[Pf] = Ls,
                xt = (Cn.mode & 1) !== 0,
                as) {
                case "dialog":
                    D$3("cancel", cs),
                    D$3("close", cs);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    D$3("load", cs);
                    break;
                case "video":
                case "audio":
                    for (Cs = 0; Cs < lf.length; Cs++)
                        D$3(lf[Cs], cs);
                    break;
                case "source":
                    D$3("error", cs);
                    break;
                case "img":
                case "image":
                case "link":
                    D$3("error", cs),
                    D$3("load", cs);
                    break;
                case "details":
                    D$3("toggle", cs);
                    break;
                case "input":
                    Za$1(cs, Ls),
                    D$3("invalid", cs);
                    break;
                case "select":
                    cs._wrapperState = {
                        wasMultiple: !!Ls.multiple
                    },
                    D$3("invalid", cs);
                    break;
                case "textarea":
                    hb(cs, Ls),
                    D$3("invalid", cs)
                }
                ub(as, Ls),
                Cs = null;
                for (var Vs in Ls)
                    if (Ls.hasOwnProperty(Vs)) {
                        var Ws = Ls[Vs];
                        Vs === "children" ? typeof Ws == "string" ? cs.textContent !== Ws && (Ls.suppressHydrationWarning !== !0 && Af(cs.textContent, Ws, xt),
                        Cs = ["children", Ws]) : typeof Ws == "number" && cs.textContent !== "" + Ws && (Ls.suppressHydrationWarning !== !0 && Af(cs.textContent, Ws, xt),
                        Cs = ["children", "" + Ws]) : ea.hasOwnProperty(Vs) && Ws != null && Vs === "onScroll" && D$3("scroll", cs)
                    }
                switch (as) {
                case "input":
                    Va$1(cs),
                    db(cs, Ls, !0);
                    break;
                case "textarea":
                    Va$1(cs),
                    jb(cs);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof Ls.onClick == "function" && (cs.onclick = Bf)
                }
                cs = Cs,
                Cn.updateQueue = cs,
                cs !== null && (Cn.flags |= 4)
            } else {
                Vs = Cs.nodeType === 9 ? Cs : Cs.ownerDocument,
                xt === "http://www.w3.org/1999/xhtml" && (xt = kb(as)),
                xt === "http://www.w3.org/1999/xhtml" ? as === "script" ? (xt = Vs.createElement("div"),
                xt.innerHTML = "<script><\/script>",
                xt = xt.removeChild(xt.firstChild)) : typeof cs.is == "string" ? xt = Vs.createElement(as, {
                    is: cs.is
                }) : (xt = Vs.createElement(as),
                as === "select" && (Vs = xt,
                cs.multiple ? Vs.multiple = !0 : cs.size && (Vs.size = cs.size))) : xt = Vs.createElementNS(xt, as),
                xt[Of] = Cn,
                xt[Pf] = cs,
                zj(xt, Cn, !1, !1),
                Cn.stateNode = xt;
                e: {
                    switch (Vs = vb(as, cs),
                    as) {
                    case "dialog":
                        D$3("cancel", xt),
                        D$3("close", xt),
                        Cs = cs;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        D$3("load", xt),
                        Cs = cs;
                        break;
                    case "video":
                    case "audio":
                        for (Cs = 0; Cs < lf.length; Cs++)
                            D$3(lf[Cs], xt);
                        Cs = cs;
                        break;
                    case "source":
                        D$3("error", xt),
                        Cs = cs;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        D$3("error", xt),
                        D$3("load", xt),
                        Cs = cs;
                        break;
                    case "details":
                        D$3("toggle", xt),
                        Cs = cs;
                        break;
                    case "input":
                        Za$1(xt, cs),
                        Cs = Ya$1(xt, cs),
                        D$3("invalid", xt);
                        break;
                    case "option":
                        Cs = cs;
                        break;
                    case "select":
                        xt._wrapperState = {
                            wasMultiple: !!cs.multiple
                        },
                        Cs = A$5({}, cs, {
                            value: void 0
                        }),
                        D$3("invalid", xt);
                        break;
                    case "textarea":
                        hb(xt, cs),
                        Cs = gb(xt, cs),
                        D$3("invalid", xt);
                        break;
                    default:
                        Cs = cs
                    }
                    ub(as, Cs),
                    Ws = Cs;
                    for (Ls in Ws)
                        if (Ws.hasOwnProperty(Ls)) {
                            var Xs = Ws[Ls];
                            Ls === "style" ? sb(xt, Xs) : Ls === "dangerouslySetInnerHTML" ? (Xs = Xs ? Xs.__html : void 0,
                            Xs != null && nb(xt, Xs)) : Ls === "children" ? typeof Xs == "string" ? (as !== "textarea" || Xs !== "") && ob(xt, Xs) : typeof Xs == "number" && ob(xt, "" + Xs) : Ls !== "suppressContentEditableWarning" && Ls !== "suppressHydrationWarning" && Ls !== "autoFocus" && (ea.hasOwnProperty(Ls) ? Xs != null && Ls === "onScroll" && D$3("scroll", xt) : Xs != null && ta$1(xt, Ls, Xs, Vs))
                        }
                    switch (as) {
                    case "input":
                        Va$1(xt),
                        db(xt, cs, !1);
                        break;
                    case "textarea":
                        Va$1(xt),
                        jb(xt);
                        break;
                    case "option":
                        cs.value != null && xt.setAttribute("value", "" + Sa$1(cs.value));
                        break;
                    case "select":
                        xt.multiple = !!cs.multiple,
                        Ls = cs.value,
                        Ls != null ? fb(xt, !!cs.multiple, Ls, !1) : cs.defaultValue != null && fb(xt, !!cs.multiple, cs.defaultValue, !0);
                        break;
                    default:
                        typeof Cs.onClick == "function" && (xt.onclick = Bf)
                    }
                    switch (as) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        cs = !!cs.autoFocus;
                        break e;
                    case "img":
                        cs = !0;
                        break e;
                    default:
                        cs = !1
                    }
                }
                cs && (Cn.flags |= 4)
            }
            Cn.ref !== null && (Cn.flags |= 512,
            Cn.flags |= 2097152)
        }
        return S$4(Cn),
        null;
    case 6:
        if (xt && Cn.stateNode != null)
            Cj(xt, Cn, xt.memoizedProps, cs);
        else {
            if (typeof cs != "string" && Cn.stateNode === null)
                throw Error(p$7(166));
            if (as = xh(wh.current),
            xh(uh.current),
            Gg(Cn)) {
                if (cs = Cn.stateNode,
                as = Cn.memoizedProps,
                cs[Of] = Cn,
                (Ls = cs.nodeValue !== as) && (xt = xg,
                xt !== null))
                    switch (xt.tag) {
                    case 3:
                        Af(cs.nodeValue, as, (xt.mode & 1) !== 0);
                        break;
                    case 5:
                        xt.memoizedProps.suppressHydrationWarning !== !0 && Af(cs.nodeValue, as, (xt.mode & 1) !== 0)
                    }
                Ls && (Cn.flags |= 4)
            } else
                cs = (as.nodeType === 9 ? as : as.ownerDocument).createTextNode(cs),
                cs[Of] = Cn,
                Cn.stateNode = cs
        }
        return S$4(Cn),
        null;
    case 13:
        if (E$5(L$3),
        cs = Cn.memoizedState,
        xt === null || xt.memoizedState !== null && xt.memoizedState.dehydrated !== null) {
            if (I$4 && yg !== null && Cn.mode & 1 && !(Cn.flags & 128))
                Hg(),
                Ig(),
                Cn.flags |= 98560,
                Ls = !1;
            else if (Ls = Gg(Cn),
            cs !== null && cs.dehydrated !== null) {
                if (xt === null) {
                    if (!Ls)
                        throw Error(p$7(318));
                    if (Ls = Cn.memoizedState,
                    Ls = Ls !== null ? Ls.dehydrated : null,
                    !Ls)
                        throw Error(p$7(317));
                    Ls[Of] = Cn
                } else
                    Ig(),
                    !(Cn.flags & 128) && (Cn.memoizedState = null),
                    Cn.flags |= 4;
                S$4(Cn),
                Ls = !1
            } else
                zg !== null && (Fj(zg),
                zg = null),
                Ls = !0;
            if (!Ls)
                return Cn.flags & 65536 ? Cn : null
        }
        return Cn.flags & 128 ? (Cn.lanes = as,
        Cn) : (cs = cs !== null,
        cs !== (xt !== null && xt.memoizedState !== null) && cs && (Cn.child.flags |= 8192,
        Cn.mode & 1 && (xt === null || L$3.current & 1 ? T$5 === 0 && (T$5 = 3) : tj())),
        Cn.updateQueue !== null && (Cn.flags |= 4),
        S$4(Cn),
        null);
    case 4:
        return zh(),
        Aj(xt, Cn),
        xt === null && sf(Cn.stateNode.containerInfo),
        S$4(Cn),
        null;
    case 10:
        return ah(Cn.type._context),
        S$4(Cn),
        null;
    case 17:
        return Zf(Cn.type) && $f(),
        S$4(Cn),
        null;
    case 19:
        if (E$5(L$3),
        Ls = Cn.memoizedState,
        Ls === null)
            return S$4(Cn),
            null;
        if (cs = (Cn.flags & 128) !== 0,
        Vs = Ls.rendering,
        Vs === null)
            if (cs)
                Dj(Ls, !1);
            else {
                if (T$5 !== 0 || xt !== null && xt.flags & 128)
                    for (xt = Cn.child; xt !== null; ) {
                        if (Vs = Ch(xt),
                        Vs !== null) {
                            for (Cn.flags |= 128,
                            Dj(Ls, !1),
                            cs = Vs.updateQueue,
                            cs !== null && (Cn.updateQueue = cs,
                            Cn.flags |= 4),
                            Cn.subtreeFlags = 0,
                            cs = as,
                            as = Cn.child; as !== null; )
                                Ls = as,
                                xt = cs,
                                Ls.flags &= 14680066,
                                Vs = Ls.alternate,
                                Vs === null ? (Ls.childLanes = 0,
                                Ls.lanes = xt,
                                Ls.child = null,
                                Ls.subtreeFlags = 0,
                                Ls.memoizedProps = null,
                                Ls.memoizedState = null,
                                Ls.updateQueue = null,
                                Ls.dependencies = null,
                                Ls.stateNode = null) : (Ls.childLanes = Vs.childLanes,
                                Ls.lanes = Vs.lanes,
                                Ls.child = Vs.child,
                                Ls.subtreeFlags = 0,
                                Ls.deletions = null,
                                Ls.memoizedProps = Vs.memoizedProps,
                                Ls.memoizedState = Vs.memoizedState,
                                Ls.updateQueue = Vs.updateQueue,
                                Ls.type = Vs.type,
                                xt = Vs.dependencies,
                                Ls.dependencies = xt === null ? null : {
                                    lanes: xt.lanes,
                                    firstContext: xt.firstContext
                                }),
                                as = as.sibling;
                            return G$3(L$3, L$3.current & 1 | 2),
                            Cn.child
                        }
                        xt = xt.sibling
                    }
                Ls.tail !== null && B$2() > Gj && (Cn.flags |= 128,
                cs = !0,
                Dj(Ls, !1),
                Cn.lanes = 4194304)
            }
        else {
            if (!cs)
                if (xt = Ch(Vs),
                xt !== null) {
                    if (Cn.flags |= 128,
                    cs = !0,
                    as = xt.updateQueue,
                    as !== null && (Cn.updateQueue = as,
                    Cn.flags |= 4),
                    Dj(Ls, !0),
                    Ls.tail === null && Ls.tailMode === "hidden" && !Vs.alternate && !I$4)
                        return S$4(Cn),
                        null
                } else
                    2 * B$2() - Ls.renderingStartTime > Gj && as !== 1073741824 && (Cn.flags |= 128,
                    cs = !0,
                    Dj(Ls, !1),
                    Cn.lanes = 4194304);
            Ls.isBackwards ? (Vs.sibling = Cn.child,
            Cn.child = Vs) : (as = Ls.last,
            as !== null ? as.sibling = Vs : Cn.child = Vs,
            Ls.last = Vs)
        }
        return Ls.tail !== null ? (Cn = Ls.tail,
        Ls.rendering = Cn,
        Ls.tail = Cn.sibling,
        Ls.renderingStartTime = B$2(),
        Cn.sibling = null,
        as = L$3.current,
        G$3(L$3, cs ? as & 1 | 2 : as & 1),
        Cn) : (S$4(Cn),
        null);
    case 22:
    case 23:
        return Hj(),
        cs = Cn.memoizedState !== null,
        xt !== null && xt.memoizedState !== null !== cs && (Cn.flags |= 8192),
        cs && Cn.mode & 1 ? fj & 1073741824 && (S$4(Cn),
        Cn.subtreeFlags & 6 && (Cn.flags |= 8192)) : S$4(Cn),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(p$7(156, Cn.tag))
}
function Ij(xt, Cn) {
    switch (wg(Cn),
    Cn.tag) {
    case 1:
        return Zf(Cn.type) && $f(),
        xt = Cn.flags,
        xt & 65536 ? (Cn.flags = xt & -65537 | 128,
        Cn) : null;
    case 3:
        return zh(),
        E$5(Wf),
        E$5(H$8),
        Eh(),
        xt = Cn.flags,
        xt & 65536 && !(xt & 128) ? (Cn.flags = xt & -65537 | 128,
        Cn) : null;
    case 5:
        return Bh(Cn),
        null;
    case 13:
        if (E$5(L$3),
        xt = Cn.memoizedState,
        xt !== null && xt.dehydrated !== null) {
            if (Cn.alternate === null)
                throw Error(p$7(340));
            Ig()
        }
        return xt = Cn.flags,
        xt & 65536 ? (Cn.flags = xt & -65537 | 128,
        Cn) : null;
    case 19:
        return E$5(L$3),
        null;
    case 4:
        return zh(),
        null;
    case 10:
        return ah(Cn.type._context),
        null;
    case 22:
    case 23:
        return Hj(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var Jj = !1
  , U$5 = !1
  , Kj = typeof WeakSet == "function" ? WeakSet : Set
  , V$4 = null;
function Lj(xt, Cn) {
    var as = xt.ref;
    if (as !== null)
        if (typeof as == "function")
            try {
                as(null)
            } catch (cs) {
                W$2(xt, Cn, cs)
            }
        else
            as.current = null
}
function Mj(xt, Cn, as) {
    try {
        as()
    } catch (cs) {
        W$2(xt, Cn, cs)
    }
}
var Nj = !1;
function Oj(xt, Cn) {
    if (Cf = dd,
    xt = Me$4(),
    Ne$3(xt)) {
        if ("selectionStart"in xt)
            var as = {
                start: xt.selectionStart,
                end: xt.selectionEnd
            };
        else
            e: {
                as = (as = xt.ownerDocument) && as.defaultView || window;
                var cs = as.getSelection && as.getSelection();
                if (cs && cs.rangeCount !== 0) {
                    as = cs.anchorNode;
                    var Cs = cs.anchorOffset
                      , Ls = cs.focusNode;
                    cs = cs.focusOffset;
                    try {
                        as.nodeType,
                        Ls.nodeType
                    } catch {
                        as = null;
                        break e
                    }
                    var Vs = 0
                      , Ws = -1
                      , Xs = -1
                      , ga = 0
                      , ba = 0
                      , yl = xt
                      , xl = null;
                    t: for (; ; ) {
                        for (var wl; yl !== as || Cs !== 0 && yl.nodeType !== 3 || (Ws = Vs + Cs),
                        yl !== Ls || cs !== 0 && yl.nodeType !== 3 || (Xs = Vs + cs),
                        yl.nodeType === 3 && (Vs += yl.nodeValue.length),
                        (wl = yl.firstChild) !== null; )
                            xl = yl,
                            yl = wl;
                        for (; ; ) {
                            if (yl === xt)
                                break t;
                            if (xl === as && ++ga === Cs && (Ws = Vs),
                            xl === Ls && ++ba === cs && (Xs = Vs),
                            (wl = yl.nextSibling) !== null)
                                break;
                            yl = xl,
                            xl = yl.parentNode
                        }
                        yl = wl
                    }
                    as = Ws === -1 || Xs === -1 ? null : {
                        start: Ws,
                        end: Xs
                    }
                } else
                    as = null
            }
        as = as || {
            start: 0,
            end: 0
        }
    } else
        as = null;
    for (Df = {
        focusedElem: xt,
        selectionRange: as
    },
    dd = !1,
    V$4 = Cn; V$4 !== null; )
        if (Cn = V$4,
        xt = Cn.child,
        (Cn.subtreeFlags & 1028) !== 0 && xt !== null)
            xt.return = Cn,
            V$4 = xt;
        else
            for (; V$4 !== null; ) {
                Cn = V$4;
                try {
                    var _l = Cn.alternate;
                    if (Cn.flags & 1024)
                        switch (Cn.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (_l !== null) {
                                var El = _l.memoizedProps
                                  , Cl = _l.memoizedState
                                  , $l = Cn.stateNode
                                  , Sl = $l.getSnapshotBeforeUpdate(Cn.elementType === Cn.type ? El : Ci$1(Cn.type, El), Cl);
                                $l.__reactInternalSnapshotBeforeUpdate = Sl
                            }
                            break;
                        case 3:
                            var Tl = Cn.stateNode.containerInfo;
                            Tl.nodeType === 1 ? Tl.textContent = "" : Tl.nodeType === 9 && Tl.documentElement && Tl.removeChild(Tl.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(p$7(163))
                        }
                } catch (Rl) {
                    W$2(Cn, Cn.return, Rl)
                }
                if (xt = Cn.sibling,
                xt !== null) {
                    xt.return = Cn.return,
                    V$4 = xt;
                    break
                }
                V$4 = Cn.return
            }
    return _l = Nj,
    Nj = !1,
    _l
}
function Pj(xt, Cn, as) {
    var cs = Cn.updateQueue;
    if (cs = cs !== null ? cs.lastEffect : null,
    cs !== null) {
        var Cs = cs = cs.next;
        do {
            if ((Cs.tag & xt) === xt) {
                var Ls = Cs.destroy;
                Cs.destroy = void 0,
                Ls !== void 0 && Mj(Cn, as, Ls)
            }
            Cs = Cs.next
        } while (Cs !== cs)
    }
}
function Qj(xt, Cn) {
    if (Cn = Cn.updateQueue,
    Cn = Cn !== null ? Cn.lastEffect : null,
    Cn !== null) {
        var as = Cn = Cn.next;
        do {
            if ((as.tag & xt) === xt) {
                var cs = as.create;
                as.destroy = cs()
            }
            as = as.next
        } while (as !== Cn)
    }
}
function Rj(xt) {
    var Cn = xt.ref;
    if (Cn !== null) {
        var as = xt.stateNode;
        switch (xt.tag) {
        case 5:
            xt = as;
            break;
        default:
            xt = as
        }
        typeof Cn == "function" ? Cn(xt) : Cn.current = xt
    }
}
function Sj(xt) {
    var Cn = xt.alternate;
    Cn !== null && (xt.alternate = null,
    Sj(Cn)),
    xt.child = null,
    xt.deletions = null,
    xt.sibling = null,
    xt.tag === 5 && (Cn = xt.stateNode,
    Cn !== null && (delete Cn[Of],
    delete Cn[Pf],
    delete Cn[of],
    delete Cn[Qf],
    delete Cn[Rf])),
    xt.stateNode = null,
    xt.return = null,
    xt.dependencies = null,
    xt.memoizedProps = null,
    xt.memoizedState = null,
    xt.pendingProps = null,
    xt.stateNode = null,
    xt.updateQueue = null
}
function Tj(xt) {
    return xt.tag === 5 || xt.tag === 3 || xt.tag === 4
}
function Uj(xt) {
    e: for (; ; ) {
        for (; xt.sibling === null; ) {
            if (xt.return === null || Tj(xt.return))
                return null;
            xt = xt.return
        }
        for (xt.sibling.return = xt.return,
        xt = xt.sibling; xt.tag !== 5 && xt.tag !== 6 && xt.tag !== 18; ) {
            if (xt.flags & 2 || xt.child === null || xt.tag === 4)
                continue e;
            xt.child.return = xt,
            xt = xt.child
        }
        if (!(xt.flags & 2))
            return xt.stateNode
    }
}
function Vj(xt, Cn, as) {
    var cs = xt.tag;
    if (cs === 5 || cs === 6)
        xt = xt.stateNode,
        Cn ? as.nodeType === 8 ? as.parentNode.insertBefore(xt, Cn) : as.insertBefore(xt, Cn) : (as.nodeType === 8 ? (Cn = as.parentNode,
        Cn.insertBefore(xt, as)) : (Cn = as,
        Cn.appendChild(xt)),
        as = as._reactRootContainer,
        as != null || Cn.onclick !== null || (Cn.onclick = Bf));
    else if (cs !== 4 && (xt = xt.child,
    xt !== null))
        for (Vj(xt, Cn, as),
        xt = xt.sibling; xt !== null; )
            Vj(xt, Cn, as),
            xt = xt.sibling
}
function Wj(xt, Cn, as) {
    var cs = xt.tag;
    if (cs === 5 || cs === 6)
        xt = xt.stateNode,
        Cn ? as.insertBefore(xt, Cn) : as.appendChild(xt);
    else if (cs !== 4 && (xt = xt.child,
    xt !== null))
        for (Wj(xt, Cn, as),
        xt = xt.sibling; xt !== null; )
            Wj(xt, Cn, as),
            xt = xt.sibling
}
var X$5 = null
  , Xj = !1;
function Yj(xt, Cn, as) {
    for (as = as.child; as !== null; )
        Zj(xt, Cn, as),
        as = as.sibling
}
function Zj(xt, Cn, as) {
    if (lc$1 && typeof lc$1.onCommitFiberUnmount == "function")
        try {
            lc$1.onCommitFiberUnmount(kc$1, as)
        } catch {}
    switch (as.tag) {
    case 5:
        U$5 || Lj(as, Cn);
    case 6:
        var cs = X$5
          , Cs = Xj;
        X$5 = null,
        Yj(xt, Cn, as),
        X$5 = cs,
        Xj = Cs,
        X$5 !== null && (Xj ? (xt = X$5,
        as = as.stateNode,
        xt.nodeType === 8 ? xt.parentNode.removeChild(as) : xt.removeChild(as)) : X$5.removeChild(as.stateNode));
        break;
    case 18:
        X$5 !== null && (Xj ? (xt = X$5,
        as = as.stateNode,
        xt.nodeType === 8 ? Kf(xt.parentNode, as) : xt.nodeType === 1 && Kf(xt, as),
        bd(xt)) : Kf(X$5, as.stateNode));
        break;
    case 4:
        cs = X$5,
        Cs = Xj,
        X$5 = as.stateNode.containerInfo,
        Xj = !0,
        Yj(xt, Cn, as),
        X$5 = cs,
        Xj = Cs;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!U$5 && (cs = as.updateQueue,
        cs !== null && (cs = cs.lastEffect,
        cs !== null))) {
            Cs = cs = cs.next;
            do {
                var Ls = Cs
                  , Vs = Ls.destroy;
                Ls = Ls.tag,
                Vs !== void 0 && (Ls & 2 || Ls & 4) && Mj(as, Cn, Vs),
                Cs = Cs.next
            } while (Cs !== cs)
        }
        Yj(xt, Cn, as);
        break;
    case 1:
        if (!U$5 && (Lj(as, Cn),
        cs = as.stateNode,
        typeof cs.componentWillUnmount == "function"))
            try {
                cs.props = as.memoizedProps,
                cs.state = as.memoizedState,
                cs.componentWillUnmount()
            } catch (Ws) {
                W$2(as, Cn, Ws)
            }
        Yj(xt, Cn, as);
        break;
    case 21:
        Yj(xt, Cn, as);
        break;
    case 22:
        as.mode & 1 ? (U$5 = (cs = U$5) || as.memoizedState !== null,
        Yj(xt, Cn, as),
        U$5 = cs) : Yj(xt, Cn, as);
        break;
    default:
        Yj(xt, Cn, as)
    }
}
function ak(xt) {
    var Cn = xt.updateQueue;
    if (Cn !== null) {
        xt.updateQueue = null;
        var as = xt.stateNode;
        as === null && (as = xt.stateNode = new Kj),
        Cn.forEach(function(cs) {
            var Cs = bk.bind(null, xt, cs);
            as.has(cs) || (as.add(cs),
            cs.then(Cs, Cs))
        })
    }
}
function ck(xt, Cn) {
    var as = Cn.deletions;
    if (as !== null)
        for (var cs = 0; cs < as.length; cs++) {
            var Cs = as[cs];
            try {
                var Ls = xt
                  , Vs = Cn
                  , Ws = Vs;
                e: for (; Ws !== null; ) {
                    switch (Ws.tag) {
                    case 5:
                        X$5 = Ws.stateNode,
                        Xj = !1;
                        break e;
                    case 3:
                        X$5 = Ws.stateNode.containerInfo,
                        Xj = !0;
                        break e;
                    case 4:
                        X$5 = Ws.stateNode.containerInfo,
                        Xj = !0;
                        break e
                    }
                    Ws = Ws.return
                }
                if (X$5 === null)
                    throw Error(p$7(160));
                Zj(Ls, Vs, Cs),
                X$5 = null,
                Xj = !1;
                var Xs = Cs.alternate;
                Xs !== null && (Xs.return = null),
                Cs.return = null
            } catch (ga) {
                W$2(Cs, Cn, ga)
            }
        }
    if (Cn.subtreeFlags & 12854)
        for (Cn = Cn.child; Cn !== null; )
            dk(Cn, xt),
            Cn = Cn.sibling
}
function dk(xt, Cn) {
    var as = xt.alternate
      , cs = xt.flags;
    switch (xt.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (ck(Cn, xt),
        ek(xt),
        cs & 4) {
            try {
                Pj(3, xt, xt.return),
                Qj(3, xt)
            } catch (El) {
                W$2(xt, xt.return, El)
            }
            try {
                Pj(5, xt, xt.return)
            } catch (El) {
                W$2(xt, xt.return, El)
            }
        }
        break;
    case 1:
        ck(Cn, xt),
        ek(xt),
        cs & 512 && as !== null && Lj(as, as.return);
        break;
    case 5:
        if (ck(Cn, xt),
        ek(xt),
        cs & 512 && as !== null && Lj(as, as.return),
        xt.flags & 32) {
            var Cs = xt.stateNode;
            try {
                ob(Cs, "")
            } catch (El) {
                W$2(xt, xt.return, El)
            }
        }
        if (cs & 4 && (Cs = xt.stateNode,
        Cs != null)) {
            var Ls = xt.memoizedProps
              , Vs = as !== null ? as.memoizedProps : Ls
              , Ws = xt.type
              , Xs = xt.updateQueue;
            if (xt.updateQueue = null,
            Xs !== null)
                try {
                    Ws === "input" && Ls.type === "radio" && Ls.name != null && ab(Cs, Ls),
                    vb(Ws, Vs);
                    var ga = vb(Ws, Ls);
                    for (Vs = 0; Vs < Xs.length; Vs += 2) {
                        var ba = Xs[Vs]
                          , yl = Xs[Vs + 1];
                        ba === "style" ? sb(Cs, yl) : ba === "dangerouslySetInnerHTML" ? nb(Cs, yl) : ba === "children" ? ob(Cs, yl) : ta$1(Cs, ba, yl, ga)
                    }
                    switch (Ws) {
                    case "input":
                        bb(Cs, Ls);
                        break;
                    case "textarea":
                        ib(Cs, Ls);
                        break;
                    case "select":
                        var xl = Cs._wrapperState.wasMultiple;
                        Cs._wrapperState.wasMultiple = !!Ls.multiple;
                        var wl = Ls.value;
                        wl != null ? fb(Cs, !!Ls.multiple, wl, !1) : xl !== !!Ls.multiple && (Ls.defaultValue != null ? fb(Cs, !!Ls.multiple, Ls.defaultValue, !0) : fb(Cs, !!Ls.multiple, Ls.multiple ? [] : "", !1))
                    }
                    Cs[Pf] = Ls
                } catch (El) {
                    W$2(xt, xt.return, El)
                }
        }
        break;
    case 6:
        if (ck(Cn, xt),
        ek(xt),
        cs & 4) {
            if (xt.stateNode === null)
                throw Error(p$7(162));
            Cs = xt.stateNode,
            Ls = xt.memoizedProps;
            try {
                Cs.nodeValue = Ls
            } catch (El) {
                W$2(xt, xt.return, El)
            }
        }
        break;
    case 3:
        if (ck(Cn, xt),
        ek(xt),
        cs & 4 && as !== null && as.memoizedState.isDehydrated)
            try {
                bd(Cn.containerInfo)
            } catch (El) {
                W$2(xt, xt.return, El)
            }
        break;
    case 4:
        ck(Cn, xt),
        ek(xt);
        break;
    case 13:
        ck(Cn, xt),
        ek(xt),
        Cs = xt.child,
        Cs.flags & 8192 && (Ls = Cs.memoizedState !== null,
        Cs.stateNode.isHidden = Ls,
        !Ls || Cs.alternate !== null && Cs.alternate.memoizedState !== null || (fk = B$2())),
        cs & 4 && ak(xt);
        break;
    case 22:
        if (ba = as !== null && as.memoizedState !== null,
        xt.mode & 1 ? (U$5 = (ga = U$5) || ba,
        ck(Cn, xt),
        U$5 = ga) : ck(Cn, xt),
        ek(xt),
        cs & 8192) {
            if (ga = xt.memoizedState !== null,
            (xt.stateNode.isHidden = ga) && !ba && xt.mode & 1)
                for (V$4 = xt,
                ba = xt.child; ba !== null; ) {
                    for (yl = V$4 = ba; V$4 !== null; ) {
                        switch (xl = V$4,
                        wl = xl.child,
                        xl.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Pj(4, xl, xl.return);
                            break;
                        case 1:
                            Lj(xl, xl.return);
                            var _l = xl.stateNode;
                            if (typeof _l.componentWillUnmount == "function") {
                                cs = xl,
                                as = xl.return;
                                try {
                                    Cn = cs,
                                    _l.props = Cn.memoizedProps,
                                    _l.state = Cn.memoizedState,
                                    _l.componentWillUnmount()
                                } catch (El) {
                                    W$2(cs, as, El)
                                }
                            }
                            break;
                        case 5:
                            Lj(xl, xl.return);
                            break;
                        case 22:
                            if (xl.memoizedState !== null) {
                                gk(yl);
                                continue
                            }
                        }
                        wl !== null ? (wl.return = xl,
                        V$4 = wl) : gk(yl)
                    }
                    ba = ba.sibling
                }
            e: for (ba = null,
            yl = xt; ; ) {
                if (yl.tag === 5) {
                    if (ba === null) {
                        ba = yl;
                        try {
                            Cs = yl.stateNode,
                            ga ? (Ls = Cs.style,
                            typeof Ls.setProperty == "function" ? Ls.setProperty("display", "none", "important") : Ls.display = "none") : (Ws = yl.stateNode,
                            Xs = yl.memoizedProps.style,
                            Vs = Xs != null && Xs.hasOwnProperty("display") ? Xs.display : null,
                            Ws.style.display = rb("display", Vs))
                        } catch (El) {
                            W$2(xt, xt.return, El)
                        }
                    }
                } else if (yl.tag === 6) {
                    if (ba === null)
                        try {
                            yl.stateNode.nodeValue = ga ? "" : yl.memoizedProps
                        } catch (El) {
                            W$2(xt, xt.return, El)
                        }
                } else if ((yl.tag !== 22 && yl.tag !== 23 || yl.memoizedState === null || yl === xt) && yl.child !== null) {
                    yl.child.return = yl,
                    yl = yl.child;
                    continue
                }
                if (yl === xt)
                    break e;
                for (; yl.sibling === null; ) {
                    if (yl.return === null || yl.return === xt)
                        break e;
                    ba === yl && (ba = null),
                    yl = yl.return
                }
                ba === yl && (ba = null),
                yl.sibling.return = yl.return,
                yl = yl.sibling
            }
        }
        break;
    case 19:
        ck(Cn, xt),
        ek(xt),
        cs & 4 && ak(xt);
        break;
    case 21:
        break;
    default:
        ck(Cn, xt),
        ek(xt)
    }
}
function ek(xt) {
    var Cn = xt.flags;
    if (Cn & 2) {
        try {
            e: {
                for (var as = xt.return; as !== null; ) {
                    if (Tj(as)) {
                        var cs = as;
                        break e
                    }
                    as = as.return
                }
                throw Error(p$7(160))
            }
            switch (cs.tag) {
            case 5:
                var Cs = cs.stateNode;
                cs.flags & 32 && (ob(Cs, ""),
                cs.flags &= -33);
                var Ls = Uj(xt);
                Wj(xt, Ls, Cs);
                break;
            case 3:
            case 4:
                var Vs = cs.stateNode.containerInfo
                  , Ws = Uj(xt);
                Vj(xt, Ws, Vs);
                break;
            default:
                throw Error(p$7(161))
            }
        } catch (Xs) {
            W$2(xt, xt.return, Xs)
        }
        xt.flags &= -3
    }
    Cn & 4096 && (xt.flags &= -4097)
}
function hk(xt, Cn, as) {
    V$4 = xt,
    ik(xt)
}
function ik(xt, Cn, as) {
    for (var cs = (xt.mode & 1) !== 0; V$4 !== null; ) {
        var Cs = V$4
          , Ls = Cs.child;
        if (Cs.tag === 22 && cs) {
            var Vs = Cs.memoizedState !== null || Jj;
            if (!Vs) {
                var Ws = Cs.alternate
                  , Xs = Ws !== null && Ws.memoizedState !== null || U$5;
                Ws = Jj;
                var ga = U$5;
                if (Jj = Vs,
                (U$5 = Xs) && !ga)
                    for (V$4 = Cs; V$4 !== null; )
                        Vs = V$4,
                        Xs = Vs.child,
                        Vs.tag === 22 && Vs.memoizedState !== null ? jk(Cs) : Xs !== null ? (Xs.return = Vs,
                        V$4 = Xs) : jk(Cs);
                for (; Ls !== null; )
                    V$4 = Ls,
                    ik(Ls),
                    Ls = Ls.sibling;
                V$4 = Cs,
                Jj = Ws,
                U$5 = ga
            }
            kk(xt)
        } else
            Cs.subtreeFlags & 8772 && Ls !== null ? (Ls.return = Cs,
            V$4 = Ls) : kk(xt)
    }
}
function kk(xt) {
    for (; V$4 !== null; ) {
        var Cn = V$4;
        if (Cn.flags & 8772) {
            var as = Cn.alternate;
            try {
                if (Cn.flags & 8772)
                    switch (Cn.tag) {
                    case 0:
                    case 11:
                    case 15:
                        U$5 || Qj(5, Cn);
                        break;
                    case 1:
                        var cs = Cn.stateNode;
                        if (Cn.flags & 4 && !U$5)
                            if (as === null)
                                cs.componentDidMount();
                            else {
                                var Cs = Cn.elementType === Cn.type ? as.memoizedProps : Ci$1(Cn.type, as.memoizedProps);
                                cs.componentDidUpdate(Cs, as.memoizedState, cs.__reactInternalSnapshotBeforeUpdate)
                            }
                        var Ls = Cn.updateQueue;
                        Ls !== null && sh(Cn, Ls, cs);
                        break;
                    case 3:
                        var Vs = Cn.updateQueue;
                        if (Vs !== null) {
                            if (as = null,
                            Cn.child !== null)
                                switch (Cn.child.tag) {
                                case 5:
                                    as = Cn.child.stateNode;
                                    break;
                                case 1:
                                    as = Cn.child.stateNode
                                }
                            sh(Cn, Vs, as)
                        }
                        break;
                    case 5:
                        var Ws = Cn.stateNode;
                        if (as === null && Cn.flags & 4) {
                            as = Ws;
                            var Xs = Cn.memoizedProps;
                            switch (Cn.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                Xs.autoFocus && as.focus();
                                break;
                            case "img":
                                Xs.src && (as.src = Xs.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (Cn.memoizedState === null) {
                            var ga = Cn.alternate;
                            if (ga !== null) {
                                var ba = ga.memoizedState;
                                if (ba !== null) {
                                    var yl = ba.dehydrated;
                                    yl !== null && bd(yl)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(p$7(163))
                    }
                U$5 || Cn.flags & 512 && Rj(Cn)
            } catch (xl) {
                W$2(Cn, Cn.return, xl)
            }
        }
        if (Cn === xt) {
            V$4 = null;
            break
        }
        if (as = Cn.sibling,
        as !== null) {
            as.return = Cn.return,
            V$4 = as;
            break
        }
        V$4 = Cn.return
    }
}
function gk(xt) {
    for (; V$4 !== null; ) {
        var Cn = V$4;
        if (Cn === xt) {
            V$4 = null;
            break
        }
        var as = Cn.sibling;
        if (as !== null) {
            as.return = Cn.return,
            V$4 = as;
            break
        }
        V$4 = Cn.return
    }
}
function jk(xt) {
    for (; V$4 !== null; ) {
        var Cn = V$4;
        try {
            switch (Cn.tag) {
            case 0:
            case 11:
            case 15:
                var as = Cn.return;
                try {
                    Qj(4, Cn)
                } catch (Xs) {
                    W$2(Cn, as, Xs)
                }
                break;
            case 1:
                var cs = Cn.stateNode;
                if (typeof cs.componentDidMount == "function") {
                    var Cs = Cn.return;
                    try {
                        cs.componentDidMount()
                    } catch (Xs) {
                        W$2(Cn, Cs, Xs)
                    }
                }
                var Ls = Cn.return;
                try {
                    Rj(Cn)
                } catch (Xs) {
                    W$2(Cn, Ls, Xs)
                }
                break;
            case 5:
                var Vs = Cn.return;
                try {
                    Rj(Cn)
                } catch (Xs) {
                    W$2(Cn, Vs, Xs)
                }
            }
        } catch (Xs) {
            W$2(Cn, Cn.return, Xs)
        }
        if (Cn === xt) {
            V$4 = null;
            break
        }
        var Ws = Cn.sibling;
        if (Ws !== null) {
            Ws.return = Cn.return,
            V$4 = Ws;
            break
        }
        V$4 = Cn.return
    }
}
var lk = Math.ceil
  , mk = ua.ReactCurrentDispatcher
  , nk = ua.ReactCurrentOwner
  , ok = ua.ReactCurrentBatchConfig
  , K$3 = 0
  , Q$2 = null
  , Y$3 = null
  , Z$3 = 0
  , fj = 0
  , ej = Uf(0)
  , T$5 = 0
  , pk = null
  , rh = 0
  , qk = 0
  , rk = 0
  , sk = null
  , tk = null
  , fk = 0
  , Gj = 1 / 0
  , uk = null
  , Oi$1 = !1
  , Pi = null
  , Ri$1 = null
  , vk = !1
  , wk = null
  , xk = 0
  , yk = 0
  , zk = null
  , Ak = -1
  , Bk = 0;
function R$2() {
    return K$3 & 6 ? B$2() : Ak !== -1 ? Ak : Ak = B$2()
}
function yi$1(xt) {
    return xt.mode & 1 ? K$3 & 2 && Z$3 !== 0 ? Z$3 & -Z$3 : Kg.transition !== null ? (Bk === 0 && (Bk = yc$1()),
    Bk) : (xt = C$7,
    xt !== 0 || (xt = window.event,
    xt = xt === void 0 ? 16 : jd(xt.type)),
    xt) : 1
}
function gi$1(xt, Cn, as, cs) {
    if (50 < yk)
        throw yk = 0,
        zk = null,
        Error(p$7(185));
    Ac$1(xt, as, cs),
    (!(K$3 & 2) || xt !== Q$2) && (xt === Q$2 && (!(K$3 & 2) && (qk |= as),
    T$5 === 4 && Ck(xt, Z$3)),
    Dk(xt, cs),
    as === 1 && K$3 === 0 && !(Cn.mode & 1) && (Gj = B$2() + 500,
    fg && jg()))
}
function Dk(xt, Cn) {
    var as = xt.callbackNode;
    wc$1(xt, Cn);
    var cs = uc(xt, xt === Q$2 ? Z$3 : 0);
    if (cs === 0)
        as !== null && bc$1(as),
        xt.callbackNode = null,
        xt.callbackPriority = 0;
    else if (Cn = cs & -cs,
    xt.callbackPriority !== Cn) {
        if (as != null && bc$1(as),
        Cn === 1)
            xt.tag === 0 ? ig(Ek.bind(null, xt)) : hg(Ek.bind(null, xt)),
            Jf(function() {
                !(K$3 & 6) && jg()
            }),
            as = null;
        else {
            switch (Dc$1(cs)) {
            case 1:
                as = fc$1;
                break;
            case 4:
                as = gc$1;
                break;
            case 16:
                as = hc$1;
                break;
            case 536870912:
                as = jc;
                break;
            default:
                as = hc$1
            }
            as = Fk(as, Gk.bind(null, xt))
        }
        xt.callbackPriority = Cn,
        xt.callbackNode = as
    }
}
function Gk(xt, Cn) {
    if (Ak = -1,
    Bk = 0,
    K$3 & 6)
        throw Error(p$7(327));
    var as = xt.callbackNode;
    if (Hk() && xt.callbackNode !== as)
        return null;
    var cs = uc(xt, xt === Q$2 ? Z$3 : 0);
    if (cs === 0)
        return null;
    if (cs & 30 || cs & xt.expiredLanes || Cn)
        Cn = Ik(xt, cs);
    else {
        Cn = cs;
        var Cs = K$3;
        K$3 |= 2;
        var Ls = Jk();
        (Q$2 !== xt || Z$3 !== Cn) && (uk = null,
        Gj = B$2() + 500,
        Kk(xt, Cn));
        do
            try {
                Lk();
                break
            } catch (Ws) {
                Mk(xt, Ws)
            }
        while (!0);
        $g(),
        mk.current = Ls,
        K$3 = Cs,
        Y$3 !== null ? Cn = 0 : (Q$2 = null,
        Z$3 = 0,
        Cn = T$5)
    }
    if (Cn !== 0) {
        if (Cn === 2 && (Cs = xc(xt),
        Cs !== 0 && (cs = Cs,
        Cn = Nk(xt, Cs))),
        Cn === 1)
            throw as = pk,
            Kk(xt, 0),
            Ck(xt, cs),
            Dk(xt, B$2()),
            as;
        if (Cn === 6)
            Ck(xt, cs);
        else {
            if (Cs = xt.current.alternate,
            !(cs & 30) && !Ok(Cs) && (Cn = Ik(xt, cs),
            Cn === 2 && (Ls = xc(xt),
            Ls !== 0 && (cs = Ls,
            Cn = Nk(xt, Ls))),
            Cn === 1))
                throw as = pk,
                Kk(xt, 0),
                Ck(xt, cs),
                Dk(xt, B$2()),
                as;
            switch (xt.finishedWork = Cs,
            xt.finishedLanes = cs,
            Cn) {
            case 0:
            case 1:
                throw Error(p$7(345));
            case 2:
                Pk(xt, tk, uk);
                break;
            case 3:
                if (Ck(xt, cs),
                (cs & 130023424) === cs && (Cn = fk + 500 - B$2(),
                10 < Cn)) {
                    if (uc(xt, 0) !== 0)
                        break;
                    if (Cs = xt.suspendedLanes,
                    (Cs & cs) !== cs) {
                        R$2(),
                        xt.pingedLanes |= xt.suspendedLanes & Cs;
                        break
                    }
                    xt.timeoutHandle = Ff(Pk.bind(null, xt, tk, uk), Cn);
                    break
                }
                Pk(xt, tk, uk);
                break;
            case 4:
                if (Ck(xt, cs),
                (cs & 4194240) === cs)
                    break;
                for (Cn = xt.eventTimes,
                Cs = -1; 0 < cs; ) {
                    var Vs = 31 - oc(cs);
                    Ls = 1 << Vs,
                    Vs = Cn[Vs],
                    Vs > Cs && (Cs = Vs),
                    cs &= ~Ls
                }
                if (cs = Cs,
                cs = B$2() - cs,
                cs = (120 > cs ? 120 : 480 > cs ? 480 : 1080 > cs ? 1080 : 1920 > cs ? 1920 : 3e3 > cs ? 3e3 : 4320 > cs ? 4320 : 1960 * lk(cs / 1960)) - cs,
                10 < cs) {
                    xt.timeoutHandle = Ff(Pk.bind(null, xt, tk, uk), cs);
                    break
                }
                Pk(xt, tk, uk);
                break;
            case 5:
                Pk(xt, tk, uk);
                break;
            default:
                throw Error(p$7(329))
            }
        }
    }
    return Dk(xt, B$2()),
    xt.callbackNode === as ? Gk.bind(null, xt) : null
}
function Nk(xt, Cn) {
    var as = sk;
    return xt.current.memoizedState.isDehydrated && (Kk(xt, Cn).flags |= 256),
    xt = Ik(xt, Cn),
    xt !== 2 && (Cn = tk,
    tk = as,
    Cn !== null && Fj(Cn)),
    xt
}
function Fj(xt) {
    tk === null ? tk = xt : tk.push.apply(tk, xt)
}
function Ok(xt) {
    for (var Cn = xt; ; ) {
        if (Cn.flags & 16384) {
            var as = Cn.updateQueue;
            if (as !== null && (as = as.stores,
            as !== null))
                for (var cs = 0; cs < as.length; cs++) {
                    var Cs = as[cs]
                      , Ls = Cs.getSnapshot;
                    Cs = Cs.value;
                    try {
                        if (!He$2(Ls(), Cs))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (as = Cn.child,
        Cn.subtreeFlags & 16384 && as !== null)
            as.return = Cn,
            Cn = as;
        else {
            if (Cn === xt)
                break;
            for (; Cn.sibling === null; ) {
                if (Cn.return === null || Cn.return === xt)
                    return !0;
                Cn = Cn.return
            }
            Cn.sibling.return = Cn.return,
            Cn = Cn.sibling
        }
    }
    return !0
}
function Ck(xt, Cn) {
    for (Cn &= ~rk,
    Cn &= ~qk,
    xt.suspendedLanes |= Cn,
    xt.pingedLanes &= ~Cn,
    xt = xt.expirationTimes; 0 < Cn; ) {
        var as = 31 - oc(Cn)
          , cs = 1 << as;
        xt[as] = -1,
        Cn &= ~cs
    }
}
function Ek(xt) {
    if (K$3 & 6)
        throw Error(p$7(327));
    Hk();
    var Cn = uc(xt, 0);
    if (!(Cn & 1))
        return Dk(xt, B$2()),
        null;
    var as = Ik(xt, Cn);
    if (xt.tag !== 0 && as === 2) {
        var cs = xc(xt);
        cs !== 0 && (Cn = cs,
        as = Nk(xt, cs))
    }
    if (as === 1)
        throw as = pk,
        Kk(xt, 0),
        Ck(xt, Cn),
        Dk(xt, B$2()),
        as;
    if (as === 6)
        throw Error(p$7(345));
    return xt.finishedWork = xt.current.alternate,
    xt.finishedLanes = Cn,
    Pk(xt, tk, uk),
    Dk(xt, B$2()),
    null
}
function Qk(xt, Cn) {
    var as = K$3;
    K$3 |= 1;
    try {
        return xt(Cn)
    } finally {
        K$3 = as,
        K$3 === 0 && (Gj = B$2() + 500,
        fg && jg())
    }
}
function Rk(xt) {
    wk !== null && wk.tag === 0 && !(K$3 & 6) && Hk();
    var Cn = K$3;
    K$3 |= 1;
    var as = ok.transition
      , cs = C$7;
    try {
        if (ok.transition = null,
        C$7 = 1,
        xt)
            return xt()
    } finally {
        C$7 = cs,
        ok.transition = as,
        K$3 = Cn,
        !(K$3 & 6) && jg()
    }
}
function Hj() {
    fj = ej.current,
    E$5(ej)
}
function Kk(xt, Cn) {
    xt.finishedWork = null,
    xt.finishedLanes = 0;
    var as = xt.timeoutHandle;
    if (as !== -1 && (xt.timeoutHandle = -1,
    Gf(as)),
    Y$3 !== null)
        for (as = Y$3.return; as !== null; ) {
            var cs = as;
            switch (wg(cs),
            cs.tag) {
            case 1:
                cs = cs.type.childContextTypes,
                cs != null && $f();
                break;
            case 3:
                zh(),
                E$5(Wf),
                E$5(H$8),
                Eh();
                break;
            case 5:
                Bh(cs);
                break;
            case 4:
                zh();
                break;
            case 13:
                E$5(L$3);
                break;
            case 19:
                E$5(L$3);
                break;
            case 10:
                ah(cs.type._context);
                break;
            case 22:
            case 23:
                Hj()
            }
            as = as.return
        }
    if (Q$2 = xt,
    Y$3 = xt = Pg(xt.current, null),
    Z$3 = fj = Cn,
    T$5 = 0,
    pk = null,
    rk = qk = rh = 0,
    tk = sk = null,
    fh !== null) {
        for (Cn = 0; Cn < fh.length; Cn++)
            if (as = fh[Cn],
            cs = as.interleaved,
            cs !== null) {
                as.interleaved = null;
                var Cs = cs.next
                  , Ls = as.pending;
                if (Ls !== null) {
                    var Vs = Ls.next;
                    Ls.next = Cs,
                    cs.next = Vs
                }
                as.pending = cs
            }
        fh = null
    }
    return xt
}
function Mk(xt, Cn) {
    do {
        var as = Y$3;
        try {
            if ($g(),
            Fh.current = Rh,
            Ih) {
                for (var cs = M$7.memoizedState; cs !== null; ) {
                    var Cs = cs.queue;
                    Cs !== null && (Cs.pending = null),
                    cs = cs.next
                }
                Ih = !1
            }
            if (Hh = 0,
            O$3 = N$3 = M$7 = null,
            Jh = !1,
            Kh = 0,
            nk.current = null,
            as === null || as.return === null) {
                T$5 = 1,
                pk = Cn,
                Y$3 = null;
                break
            }
            e: {
                var Ls = xt
                  , Vs = as.return
                  , Ws = as
                  , Xs = Cn;
                if (Cn = Z$3,
                Ws.flags |= 32768,
                Xs !== null && typeof Xs == "object" && typeof Xs.then == "function") {
                    var ga = Xs
                      , ba = Ws
                      , yl = ba.tag;
                    if (!(ba.mode & 1) && (yl === 0 || yl === 11 || yl === 15)) {
                        var xl = ba.alternate;
                        xl ? (ba.updateQueue = xl.updateQueue,
                        ba.memoizedState = xl.memoizedState,
                        ba.lanes = xl.lanes) : (ba.updateQueue = null,
                        ba.memoizedState = null)
                    }
                    var wl = Ui(Vs);
                    if (wl !== null) {
                        wl.flags &= -257,
                        Vi(wl, Vs, Ws, Ls, Cn),
                        wl.mode & 1 && Si$1(Ls, ga, Cn),
                        Cn = wl,
                        Xs = ga;
                        var _l = Cn.updateQueue;
                        if (_l === null) {
                            var El = new Set;
                            El.add(Xs),
                            Cn.updateQueue = El
                        } else
                            _l.add(Xs);
                        break e
                    } else {
                        if (!(Cn & 1)) {
                            Si$1(Ls, ga, Cn),
                            tj();
                            break e
                        }
                        Xs = Error(p$7(426))
                    }
                } else if (I$4 && Ws.mode & 1) {
                    var Cl = Ui(Vs);
                    if (Cl !== null) {
                        !(Cl.flags & 65536) && (Cl.flags |= 256),
                        Vi(Cl, Vs, Ws, Ls, Cn),
                        Jg(Ji(Xs, Ws));
                        break e
                    }
                }
                Ls = Xs = Ji(Xs, Ws),
                T$5 !== 4 && (T$5 = 2),
                sk === null ? sk = [Ls] : sk.push(Ls),
                Ls = Vs;
                do {
                    switch (Ls.tag) {
                    case 3:
                        Ls.flags |= 65536,
                        Cn &= -Cn,
                        Ls.lanes |= Cn;
                        var $l = Ni(Ls, Xs, Cn);
                        ph(Ls, $l);
                        break e;
                    case 1:
                        Ws = Xs;
                        var Sl = Ls.type
                          , Tl = Ls.stateNode;
                        if (!(Ls.flags & 128) && (typeof Sl.getDerivedStateFromError == "function" || Tl !== null && typeof Tl.componentDidCatch == "function" && (Ri$1 === null || !Ri$1.has(Tl)))) {
                            Ls.flags |= 65536,
                            Cn &= -Cn,
                            Ls.lanes |= Cn;
                            var Rl = Qi(Ls, Ws, Cn);
                            ph(Ls, Rl);
                            break e
                        }
                    }
                    Ls = Ls.return
                } while (Ls !== null)
            }
            Sk(as)
        } catch (Il) {
            Cn = Il,
            Y$3 === as && as !== null && (Y$3 = as = as.return);
            continue
        }
        break
    } while (!0)
}
function Jk() {
    var xt = mk.current;
    return mk.current = Rh,
    xt === null ? Rh : xt
}
function tj() {
    (T$5 === 0 || T$5 === 3 || T$5 === 2) && (T$5 = 4),
    Q$2 === null || !(rh & 268435455) && !(qk & 268435455) || Ck(Q$2, Z$3)
}
function Ik(xt, Cn) {
    var as = K$3;
    K$3 |= 2;
    var cs = Jk();
    (Q$2 !== xt || Z$3 !== Cn) && (uk = null,
    Kk(xt, Cn));
    do
        try {
            Tk();
            break
        } catch (Cs) {
            Mk(xt, Cs)
        }
    while (!0);
    if ($g(),
    K$3 = as,
    mk.current = cs,
    Y$3 !== null)
        throw Error(p$7(261));
    return Q$2 = null,
    Z$3 = 0,
    T$5
}
function Tk() {
    for (; Y$3 !== null; )
        Uk(Y$3)
}
function Lk() {
    for (; Y$3 !== null && !cc(); )
        Uk(Y$3)
}
function Uk(xt) {
    var Cn = Vk(xt.alternate, xt, fj);
    xt.memoizedProps = xt.pendingProps,
    Cn === null ? Sk(xt) : Y$3 = Cn,
    nk.current = null
}
function Sk(xt) {
    var Cn = xt;
    do {
        var as = Cn.alternate;
        if (xt = Cn.return,
        Cn.flags & 32768) {
            if (as = Ij(as, Cn),
            as !== null) {
                as.flags &= 32767,
                Y$3 = as;
                return
            }
            if (xt !== null)
                xt.flags |= 32768,
                xt.subtreeFlags = 0,
                xt.deletions = null;
            else {
                T$5 = 6,
                Y$3 = null;
                return
            }
        } else if (as = Ej(as, Cn, fj),
        as !== null) {
            Y$3 = as;
            return
        }
        if (Cn = Cn.sibling,
        Cn !== null) {
            Y$3 = Cn;
            return
        }
        Y$3 = Cn = xt
    } while (Cn !== null);
    T$5 === 0 && (T$5 = 5)
}
function Pk(xt, Cn, as) {
    var cs = C$7
      , Cs = ok.transition;
    try {
        ok.transition = null,
        C$7 = 1,
        Wk(xt, Cn, as, cs)
    } finally {
        ok.transition = Cs,
        C$7 = cs
    }
    return null
}
function Wk(xt, Cn, as, cs) {
    do
        Hk();
    while (wk !== null);
    if (K$3 & 6)
        throw Error(p$7(327));
    as = xt.finishedWork;
    var Cs = xt.finishedLanes;
    if (as === null)
        return null;
    if (xt.finishedWork = null,
    xt.finishedLanes = 0,
    as === xt.current)
        throw Error(p$7(177));
    xt.callbackNode = null,
    xt.callbackPriority = 0;
    var Ls = as.lanes | as.childLanes;
    if (Bc(xt, Ls),
    xt === Q$2 && (Y$3 = Q$2 = null,
    Z$3 = 0),
    !(as.subtreeFlags & 2064) && !(as.flags & 2064) || vk || (vk = !0,
    Fk(hc$1, function() {
        return Hk(),
        null
    })),
    Ls = (as.flags & 15990) !== 0,
    as.subtreeFlags & 15990 || Ls) {
        Ls = ok.transition,
        ok.transition = null;
        var Vs = C$7;
        C$7 = 1;
        var Ws = K$3;
        K$3 |= 4,
        nk.current = null,
        Oj(xt, as),
        dk(as, xt),
        Oe$1(Df),
        dd = !!Cf,
        Df = Cf = null,
        xt.current = as,
        hk(as),
        dc$1(),
        K$3 = Ws,
        C$7 = Vs,
        ok.transition = Ls
    } else
        xt.current = as;
    if (vk && (vk = !1,
    wk = xt,
    xk = Cs),
    Ls = xt.pendingLanes,
    Ls === 0 && (Ri$1 = null),
    mc$1(as.stateNode),
    Dk(xt, B$2()),
    Cn !== null)
        for (cs = xt.onRecoverableError,
        as = 0; as < Cn.length; as++)
            Cs = Cn[as],
            cs(Cs.value, {
                componentStack: Cs.stack,
                digest: Cs.digest
            });
    if (Oi$1)
        throw Oi$1 = !1,
        xt = Pi,
        Pi = null,
        xt;
    return xk & 1 && xt.tag !== 0 && Hk(),
    Ls = xt.pendingLanes,
    Ls & 1 ? xt === zk ? yk++ : (yk = 0,
    zk = xt) : yk = 0,
    jg(),
    null
}
function Hk() {
    if (wk !== null) {
        var xt = Dc$1(xk)
          , Cn = ok.transition
          , as = C$7;
        try {
            if (ok.transition = null,
            C$7 = 16 > xt ? 16 : xt,
            wk === null)
                var cs = !1;
            else {
                if (xt = wk,
                wk = null,
                xk = 0,
                K$3 & 6)
                    throw Error(p$7(331));
                var Cs = K$3;
                for (K$3 |= 4,
                V$4 = xt.current; V$4 !== null; ) {
                    var Ls = V$4
                      , Vs = Ls.child;
                    if (V$4.flags & 16) {
                        var Ws = Ls.deletions;
                        if (Ws !== null) {
                            for (var Xs = 0; Xs < Ws.length; Xs++) {
                                var ga = Ws[Xs];
                                for (V$4 = ga; V$4 !== null; ) {
                                    var ba = V$4;
                                    switch (ba.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Pj(8, ba, Ls)
                                    }
                                    var yl = ba.child;
                                    if (yl !== null)
                                        yl.return = ba,
                                        V$4 = yl;
                                    else
                                        for (; V$4 !== null; ) {
                                            ba = V$4;
                                            var xl = ba.sibling
                                              , wl = ba.return;
                                            if (Sj(ba),
                                            ba === ga) {
                                                V$4 = null;
                                                break
                                            }
                                            if (xl !== null) {
                                                xl.return = wl,
                                                V$4 = xl;
                                                break
                                            }
                                            V$4 = wl
                                        }
                                }
                            }
                            var _l = Ls.alternate;
                            if (_l !== null) {
                                var El = _l.child;
                                if (El !== null) {
                                    _l.child = null;
                                    do {
                                        var Cl = El.sibling;
                                        El.sibling = null,
                                        El = Cl
                                    } while (El !== null)
                                }
                            }
                            V$4 = Ls
                        }
                    }
                    if (Ls.subtreeFlags & 2064 && Vs !== null)
                        Vs.return = Ls,
                        V$4 = Vs;
                    else
                        e: for (; V$4 !== null; ) {
                            if (Ls = V$4,
                            Ls.flags & 2048)
                                switch (Ls.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Pj(9, Ls, Ls.return)
                                }
                            var $l = Ls.sibling;
                            if ($l !== null) {
                                $l.return = Ls.return,
                                V$4 = $l;
                                break e
                            }
                            V$4 = Ls.return
                        }
                }
                var Sl = xt.current;
                for (V$4 = Sl; V$4 !== null; ) {
                    Vs = V$4;
                    var Tl = Vs.child;
                    if (Vs.subtreeFlags & 2064 && Tl !== null)
                        Tl.return = Vs,
                        V$4 = Tl;
                    else
                        e: for (Vs = Sl; V$4 !== null; ) {
                            if (Ws = V$4,
                            Ws.flags & 2048)
                                try {
                                    switch (Ws.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Qj(9, Ws)
                                    }
                                } catch (Il) {
                                    W$2(Ws, Ws.return, Il)
                                }
                            if (Ws === Vs) {
                                V$4 = null;
                                break e
                            }
                            var Rl = Ws.sibling;
                            if (Rl !== null) {
                                Rl.return = Ws.return,
                                V$4 = Rl;
                                break e
                            }
                            V$4 = Ws.return
                        }
                }
                if (K$3 = Cs,
                jg(),
                lc$1 && typeof lc$1.onPostCommitFiberRoot == "function")
                    try {
                        lc$1.onPostCommitFiberRoot(kc$1, xt)
                    } catch {}
                cs = !0
            }
            return cs
        } finally {
            C$7 = as,
            ok.transition = Cn
        }
    }
    return !1
}
function Xk(xt, Cn, as) {
    Cn = Ji(as, Cn),
    Cn = Ni(xt, Cn, 1),
    xt = nh(xt, Cn, 1),
    Cn = R$2(),
    xt !== null && (Ac$1(xt, 1, Cn),
    Dk(xt, Cn))
}
function W$2(xt, Cn, as) {
    if (xt.tag === 3)
        Xk(xt, xt, as);
    else
        for (; Cn !== null; ) {
            if (Cn.tag === 3) {
                Xk(Cn, xt, as);
                break
            } else if (Cn.tag === 1) {
                var cs = Cn.stateNode;
                if (typeof Cn.type.getDerivedStateFromError == "function" || typeof cs.componentDidCatch == "function" && (Ri$1 === null || !Ri$1.has(cs))) {
                    xt = Ji(as, xt),
                    xt = Qi(Cn, xt, 1),
                    Cn = nh(Cn, xt, 1),
                    xt = R$2(),
                    Cn !== null && (Ac$1(Cn, 1, xt),
                    Dk(Cn, xt));
                    break
                }
            }
            Cn = Cn.return
        }
}
function Ti$1(xt, Cn, as) {
    var cs = xt.pingCache;
    cs !== null && cs.delete(Cn),
    Cn = R$2(),
    xt.pingedLanes |= xt.suspendedLanes & as,
    Q$2 === xt && (Z$3 & as) === as && (T$5 === 4 || T$5 === 3 && (Z$3 & 130023424) === Z$3 && 500 > B$2() - fk ? Kk(xt, 0) : rk |= as),
    Dk(xt, Cn)
}
function Yk(xt, Cn) {
    Cn === 0 && (xt.mode & 1 ? (Cn = sc$1,
    sc$1 <<= 1,
    !(sc$1 & 130023424) && (sc$1 = 4194304)) : Cn = 1);
    var as = R$2();
    xt = ih(xt, Cn),
    xt !== null && (Ac$1(xt, Cn, as),
    Dk(xt, as))
}
function uj(xt) {
    var Cn = xt.memoizedState
      , as = 0;
    Cn !== null && (as = Cn.retryLane),
    Yk(xt, as)
}
function bk(xt, Cn) {
    var as = 0;
    switch (xt.tag) {
    case 13:
        var cs = xt.stateNode
          , Cs = xt.memoizedState;
        Cs !== null && (as = Cs.retryLane);
        break;
    case 19:
        cs = xt.stateNode;
        break;
    default:
        throw Error(p$7(314))
    }
    cs !== null && cs.delete(Cn),
    Yk(xt, as)
}
var Vk;
Vk = function(xt, Cn, as) {
    if (xt !== null)
        if (xt.memoizedProps !== Cn.pendingProps || Wf.current)
            dh = !0;
        else {
            if (!(xt.lanes & as) && !(Cn.flags & 128))
                return dh = !1,
                yj(xt, Cn, as);
            dh = !!(xt.flags & 131072)
        }
    else
        dh = !1,
        I$4 && Cn.flags & 1048576 && ug(Cn, ng, Cn.index);
    switch (Cn.lanes = 0,
    Cn.tag) {
    case 2:
        var cs = Cn.type;
        ij(xt, Cn),
        xt = Cn.pendingProps;
        var Cs = Yf(Cn, H$8.current);
        ch(Cn, as),
        Cs = Nh(null, Cn, cs, xt, Cs, as);
        var Ls = Sh();
        return Cn.flags |= 1,
        typeof Cs == "object" && Cs !== null && typeof Cs.render == "function" && Cs.$$typeof === void 0 ? (Cn.tag = 1,
        Cn.memoizedState = null,
        Cn.updateQueue = null,
        Zf(cs) ? (Ls = !0,
        cg(Cn)) : Ls = !1,
        Cn.memoizedState = Cs.state !== null && Cs.state !== void 0 ? Cs.state : null,
        kh(Cn),
        Cs.updater = Ei$1,
        Cn.stateNode = Cs,
        Cs._reactInternals = Cn,
        Ii$1(Cn, cs, xt, as),
        Cn = jj(null, Cn, cs, !0, Ls, as)) : (Cn.tag = 0,
        I$4 && Ls && vg(Cn),
        Xi(null, Cn, Cs, as),
        Cn = Cn.child),
        Cn;
    case 16:
        cs = Cn.elementType;
        e: {
            switch (ij(xt, Cn),
            xt = Cn.pendingProps,
            Cs = cs._init,
            cs = Cs(cs._payload),
            Cn.type = cs,
            Cs = Cn.tag = Zk(cs),
            xt = Ci$1(cs, xt),
            Cs) {
            case 0:
                Cn = cj(null, Cn, cs, xt, as);
                break e;
            case 1:
                Cn = hj(null, Cn, cs, xt, as);
                break e;
            case 11:
                Cn = Yi(null, Cn, cs, xt, as);
                break e;
            case 14:
                Cn = $i(null, Cn, cs, Ci$1(cs.type, xt), as);
                break e
            }
            throw Error(p$7(306, cs, ""))
        }
        return Cn;
    case 0:
        return cs = Cn.type,
        Cs = Cn.pendingProps,
        Cs = Cn.elementType === cs ? Cs : Ci$1(cs, Cs),
        cj(xt, Cn, cs, Cs, as);
    case 1:
        return cs = Cn.type,
        Cs = Cn.pendingProps,
        Cs = Cn.elementType === cs ? Cs : Ci$1(cs, Cs),
        hj(xt, Cn, cs, Cs, as);
    case 3:
        e: {
            if (kj(Cn),
            xt === null)
                throw Error(p$7(387));
            cs = Cn.pendingProps,
            Ls = Cn.memoizedState,
            Cs = Ls.element,
            lh(xt, Cn),
            qh(Cn, cs, null, as);
            var Vs = Cn.memoizedState;
            if (cs = Vs.element,
            Ls.isDehydrated)
                if (Ls = {
                    element: cs,
                    isDehydrated: !1,
                    cache: Vs.cache,
                    pendingSuspenseBoundaries: Vs.pendingSuspenseBoundaries,
                    transitions: Vs.transitions
                },
                Cn.updateQueue.baseState = Ls,
                Cn.memoizedState = Ls,
                Cn.flags & 256) {
                    Cs = Ji(Error(p$7(423)), Cn),
                    Cn = lj(xt, Cn, cs, as, Cs);
                    break e
                } else if (cs !== Cs) {
                    Cs = Ji(Error(p$7(424)), Cn),
                    Cn = lj(xt, Cn, cs, as, Cs);
                    break e
                } else
                    for (yg = Lf(Cn.stateNode.containerInfo.firstChild),
                    xg = Cn,
                    I$4 = !0,
                    zg = null,
                    as = Vg(Cn, null, cs, as),
                    Cn.child = as; as; )
                        as.flags = as.flags & -3 | 4096,
                        as = as.sibling;
            else {
                if (Ig(),
                cs === Cs) {
                    Cn = Zi(xt, Cn, as);
                    break e
                }
                Xi(xt, Cn, cs, as)
            }
            Cn = Cn.child
        }
        return Cn;
    case 5:
        return Ah(Cn),
        xt === null && Eg(Cn),
        cs = Cn.type,
        Cs = Cn.pendingProps,
        Ls = xt !== null ? xt.memoizedProps : null,
        Vs = Cs.children,
        Ef(cs, Cs) ? Vs = null : Ls !== null && Ef(cs, Ls) && (Cn.flags |= 32),
        gj(xt, Cn),
        Xi(xt, Cn, Vs, as),
        Cn.child;
    case 6:
        return xt === null && Eg(Cn),
        null;
    case 13:
        return oj(xt, Cn, as);
    case 4:
        return yh(Cn, Cn.stateNode.containerInfo),
        cs = Cn.pendingProps,
        xt === null ? Cn.child = Ug(Cn, null, cs, as) : Xi(xt, Cn, cs, as),
        Cn.child;
    case 11:
        return cs = Cn.type,
        Cs = Cn.pendingProps,
        Cs = Cn.elementType === cs ? Cs : Ci$1(cs, Cs),
        Yi(xt, Cn, cs, Cs, as);
    case 7:
        return Xi(xt, Cn, Cn.pendingProps, as),
        Cn.child;
    case 8:
        return Xi(xt, Cn, Cn.pendingProps.children, as),
        Cn.child;
    case 12:
        return Xi(xt, Cn, Cn.pendingProps.children, as),
        Cn.child;
    case 10:
        e: {
            if (cs = Cn.type._context,
            Cs = Cn.pendingProps,
            Ls = Cn.memoizedProps,
            Vs = Cs.value,
            G$3(Wg, cs._currentValue),
            cs._currentValue = Vs,
            Ls !== null)
                if (He$2(Ls.value, Vs)) {
                    if (Ls.children === Cs.children && !Wf.current) {
                        Cn = Zi(xt, Cn, as);
                        break e
                    }
                } else
                    for (Ls = Cn.child,
                    Ls !== null && (Ls.return = Cn); Ls !== null; ) {
                        var Ws = Ls.dependencies;
                        if (Ws !== null) {
                            Vs = Ls.child;
                            for (var Xs = Ws.firstContext; Xs !== null; ) {
                                if (Xs.context === cs) {
                                    if (Ls.tag === 1) {
                                        Xs = mh(-1, as & -as),
                                        Xs.tag = 2;
                                        var ga = Ls.updateQueue;
                                        if (ga !== null) {
                                            ga = ga.shared;
                                            var ba = ga.pending;
                                            ba === null ? Xs.next = Xs : (Xs.next = ba.next,
                                            ba.next = Xs),
                                            ga.pending = Xs
                                        }
                                    }
                                    Ls.lanes |= as,
                                    Xs = Ls.alternate,
                                    Xs !== null && (Xs.lanes |= as),
                                    bh(Ls.return, as, Cn),
                                    Ws.lanes |= as;
                                    break
                                }
                                Xs = Xs.next
                            }
                        } else if (Ls.tag === 10)
                            Vs = Ls.type === Cn.type ? null : Ls.child;
                        else if (Ls.tag === 18) {
                            if (Vs = Ls.return,
                            Vs === null)
                                throw Error(p$7(341));
                            Vs.lanes |= as,
                            Ws = Vs.alternate,
                            Ws !== null && (Ws.lanes |= as),
                            bh(Vs, as, Cn),
                            Vs = Ls.sibling
                        } else
                            Vs = Ls.child;
                        if (Vs !== null)
                            Vs.return = Ls;
                        else
                            for (Vs = Ls; Vs !== null; ) {
                                if (Vs === Cn) {
                                    Vs = null;
                                    break
                                }
                                if (Ls = Vs.sibling,
                                Ls !== null) {
                                    Ls.return = Vs.return,
                                    Vs = Ls;
                                    break
                                }
                                Vs = Vs.return
                            }
                        Ls = Vs
                    }
            Xi(xt, Cn, Cs.children, as),
            Cn = Cn.child
        }
        return Cn;
    case 9:
        return Cs = Cn.type,
        cs = Cn.pendingProps.children,
        ch(Cn, as),
        Cs = eh(Cs),
        cs = cs(Cs),
        Cn.flags |= 1,
        Xi(xt, Cn, cs, as),
        Cn.child;
    case 14:
        return cs = Cn.type,
        Cs = Ci$1(cs, Cn.pendingProps),
        Cs = Ci$1(cs.type, Cs),
        $i(xt, Cn, cs, Cs, as);
    case 15:
        return bj(xt, Cn, Cn.type, Cn.pendingProps, as);
    case 17:
        return cs = Cn.type,
        Cs = Cn.pendingProps,
        Cs = Cn.elementType === cs ? Cs : Ci$1(cs, Cs),
        ij(xt, Cn),
        Cn.tag = 1,
        Zf(cs) ? (xt = !0,
        cg(Cn)) : xt = !1,
        ch(Cn, as),
        Gi(Cn, cs, Cs),
        Ii$1(Cn, cs, Cs, as),
        jj(null, Cn, cs, !0, xt, as);
    case 19:
        return xj(xt, Cn, as);
    case 22:
        return dj(xt, Cn, as)
    }
    throw Error(p$7(156, Cn.tag))
}
;
function Fk(xt, Cn) {
    return ac(xt, Cn)
}
function $k(xt, Cn, as, cs) {
    this.tag = xt,
    this.key = as,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = Cn,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = cs,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function Bg(xt, Cn, as, cs) {
    return new $k(xt,Cn,as,cs)
}
function aj(xt) {
    return xt = xt.prototype,
    !(!xt || !xt.isReactComponent)
}
function Zk(xt) {
    if (typeof xt == "function")
        return aj(xt) ? 1 : 0;
    if (xt != null) {
        if (xt = xt.$$typeof,
        xt === Da$1)
            return 11;
        if (xt === Ga$1)
            return 14
    }
    return 2
}
function Pg(xt, Cn) {
    var as = xt.alternate;
    return as === null ? (as = Bg(xt.tag, Cn, xt.key, xt.mode),
    as.elementType = xt.elementType,
    as.type = xt.type,
    as.stateNode = xt.stateNode,
    as.alternate = xt,
    xt.alternate = as) : (as.pendingProps = Cn,
    as.type = xt.type,
    as.flags = 0,
    as.subtreeFlags = 0,
    as.deletions = null),
    as.flags = xt.flags & 14680064,
    as.childLanes = xt.childLanes,
    as.lanes = xt.lanes,
    as.child = xt.child,
    as.memoizedProps = xt.memoizedProps,
    as.memoizedState = xt.memoizedState,
    as.updateQueue = xt.updateQueue,
    Cn = xt.dependencies,
    as.dependencies = Cn === null ? null : {
        lanes: Cn.lanes,
        firstContext: Cn.firstContext
    },
    as.sibling = xt.sibling,
    as.index = xt.index,
    as.ref = xt.ref,
    as
}
function Rg(xt, Cn, as, cs, Cs, Ls) {
    var Vs = 2;
    if (cs = xt,
    typeof xt == "function")
        aj(xt) && (Vs = 1);
    else if (typeof xt == "string")
        Vs = 5;
    else
        e: switch (xt) {
        case ya:
            return Tg(as.children, Cs, Ls, Cn);
        case za$1:
            Vs = 8,
            Cs |= 8;
            break;
        case Aa:
            return xt = Bg(12, as, Cn, Cs | 2),
            xt.elementType = Aa,
            xt.lanes = Ls,
            xt;
        case Ea:
            return xt = Bg(13, as, Cn, Cs),
            xt.elementType = Ea,
            xt.lanes = Ls,
            xt;
        case Fa$1:
            return xt = Bg(19, as, Cn, Cs),
            xt.elementType = Fa$1,
            xt.lanes = Ls,
            xt;
        case Ia$1:
            return pj(as, Cs, Ls, Cn);
        default:
            if (typeof xt == "object" && xt !== null)
                switch (xt.$$typeof) {
                case Ba:
                    Vs = 10;
                    break e;
                case Ca:
                    Vs = 9;
                    break e;
                case Da$1:
                    Vs = 11;
                    break e;
                case Ga$1:
                    Vs = 14;
                    break e;
                case Ha$1:
                    Vs = 16,
                    cs = null;
                    break e
                }
            throw Error(p$7(130, xt == null ? xt : typeof xt, ""))
        }
    return Cn = Bg(Vs, as, Cn, Cs),
    Cn.elementType = xt,
    Cn.type = cs,
    Cn.lanes = Ls,
    Cn
}
function Tg(xt, Cn, as, cs) {
    return xt = Bg(7, xt, cs, Cn),
    xt.lanes = as,
    xt
}
function pj(xt, Cn, as, cs) {
    return xt = Bg(22, xt, cs, Cn),
    xt.elementType = Ia$1,
    xt.lanes = as,
    xt.stateNode = {
        isHidden: !1
    },
    xt
}
function Qg(xt, Cn, as) {
    return xt = Bg(6, xt, null, Cn),
    xt.lanes = as,
    xt
}
function Sg(xt, Cn, as) {
    return Cn = Bg(4, xt.children !== null ? xt.children : [], xt.key, Cn),
    Cn.lanes = as,
    Cn.stateNode = {
        containerInfo: xt.containerInfo,
        pendingChildren: null,
        implementation: xt.implementation
    },
    Cn
}
function al(xt, Cn, as, cs, Cs) {
    this.tag = Cn,
    this.containerInfo = xt,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = zc(0),
    this.expirationTimes = zc(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = zc(0),
    this.identifierPrefix = cs,
    this.onRecoverableError = Cs,
    this.mutableSourceEagerHydrationData = null
}
function bl(xt, Cn, as, cs, Cs, Ls, Vs, Ws, Xs) {
    return xt = new al(xt,Cn,as,Ws,Xs),
    Cn === 1 ? (Cn = 1,
    Ls === !0 && (Cn |= 8)) : Cn = 0,
    Ls = Bg(3, null, null, Cn),
    xt.current = Ls,
    Ls.stateNode = xt,
    Ls.memoizedState = {
        element: cs,
        isDehydrated: as,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    kh(Ls),
    xt
}
function cl(xt, Cn, as) {
    var cs = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: wa,
        key: cs == null ? null : "" + cs,
        children: xt,
        containerInfo: Cn,
        implementation: as
    }
}
function dl(xt) {
    if (!xt)
        return Vf;
    xt = xt._reactInternals;
    e: {
        if (Vb(xt) !== xt || xt.tag !== 1)
            throw Error(p$7(170));
        var Cn = xt;
        do {
            switch (Cn.tag) {
            case 3:
                Cn = Cn.stateNode.context;
                break e;
            case 1:
                if (Zf(Cn.type)) {
                    Cn = Cn.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            Cn = Cn.return
        } while (Cn !== null);
        throw Error(p$7(171))
    }
    if (xt.tag === 1) {
        var as = xt.type;
        if (Zf(as))
            return bg(xt, as, Cn)
    }
    return Cn
}
function el(xt, Cn, as, cs, Cs, Ls, Vs, Ws, Xs) {
    return xt = bl(as, cs, !0, xt, Cs, Ls, Vs, Ws, Xs),
    xt.context = dl(null),
    as = xt.current,
    cs = R$2(),
    Cs = yi$1(as),
    Ls = mh(cs, Cs),
    Ls.callback = Cn ?? null,
    nh(as, Ls, Cs),
    xt.current.lanes = Cs,
    Ac$1(xt, Cs, cs),
    Dk(xt, cs),
    xt
}
function fl(xt, Cn, as, cs) {
    var Cs = Cn.current
      , Ls = R$2()
      , Vs = yi$1(Cs);
    return as = dl(as),
    Cn.context === null ? Cn.context = as : Cn.pendingContext = as,
    Cn = mh(Ls, Vs),
    Cn.payload = {
        element: xt
    },
    cs = cs === void 0 ? null : cs,
    cs !== null && (Cn.callback = cs),
    xt = nh(Cs, Cn, Vs),
    xt !== null && (gi$1(xt, Cs, Vs, Ls),
    oh(xt, Cs, Vs)),
    Vs
}
function gl(xt) {
    if (xt = xt.current,
    !xt.child)
        return null;
    switch (xt.child.tag) {
    case 5:
        return xt.child.stateNode;
    default:
        return xt.child.stateNode
    }
}
function hl(xt, Cn) {
    if (xt = xt.memoizedState,
    xt !== null && xt.dehydrated !== null) {
        var as = xt.retryLane;
        xt.retryLane = as !== 0 && as < Cn ? as : Cn
    }
}
function il(xt, Cn) {
    hl(xt, Cn),
    (xt = xt.alternate) && hl(xt, Cn)
}
function jl() {
    return null
}
var kl = typeof reportError == "function" ? reportError : function(xt) {
    console.error(xt)
}
;
function ll(xt) {
    this._internalRoot = xt
}
ml.prototype.render = ll.prototype.render = function(xt) {
    var Cn = this._internalRoot;
    if (Cn === null)
        throw Error(p$7(409));
    fl(xt, Cn, null, null)
}
;
ml.prototype.unmount = ll.prototype.unmount = function() {
    var xt = this._internalRoot;
    if (xt !== null) {
        this._internalRoot = null;
        var Cn = xt.containerInfo;
        Rk(function() {
            fl(null, xt, null, null)
        }),
        Cn[uf] = null
    }
}
;
function ml(xt) {
    this._internalRoot = xt
}
ml.prototype.unstable_scheduleHydration = function(xt) {
    if (xt) {
        var Cn = Hc$1();
        xt = {
            blockedOn: null,
            target: xt,
            priority: Cn
        };
        for (var as = 0; as < Qc.length && Cn !== 0 && Cn < Qc[as].priority; as++)
            ;
        Qc.splice(as, 0, xt),
        as === 0 && Vc(xt)
    }
}
;
function nl(xt) {
    return !(!xt || xt.nodeType !== 1 && xt.nodeType !== 9 && xt.nodeType !== 11)
}
function ol(xt) {
    return !(!xt || xt.nodeType !== 1 && xt.nodeType !== 9 && xt.nodeType !== 11 && (xt.nodeType !== 8 || xt.nodeValue !== " react-mount-point-unstable "))
}
function pl() {}
function ql(xt, Cn, as, cs, Cs) {
    if (Cs) {
        if (typeof cs == "function") {
            var Ls = cs;
            cs = function() {
                var ga = gl(Vs);
                Ls.call(ga)
            }
        }
        var Vs = el(Cn, cs, xt, 0, null, !1, !1, "", pl);
        return xt._reactRootContainer = Vs,
        xt[uf] = Vs.current,
        sf(xt.nodeType === 8 ? xt.parentNode : xt),
        Rk(),
        Vs
    }
    for (; Cs = xt.lastChild; )
        xt.removeChild(Cs);
    if (typeof cs == "function") {
        var Ws = cs;
        cs = function() {
            var ga = gl(Xs);
            Ws.call(ga)
        }
    }
    var Xs = bl(xt, 0, !1, null, null, !1, !1, "", pl);
    return xt._reactRootContainer = Xs,
    xt[uf] = Xs.current,
    sf(xt.nodeType === 8 ? xt.parentNode : xt),
    Rk(function() {
        fl(Cn, Xs, as, cs)
    }),
    Xs
}
function rl(xt, Cn, as, cs, Cs) {
    var Ls = as._reactRootContainer;
    if (Ls) {
        var Vs = Ls;
        if (typeof Cs == "function") {
            var Ws = Cs;
            Cs = function() {
                var Xs = gl(Vs);
                Ws.call(Xs)
            }
        }
        fl(Cn, Vs, xt, Cs)
    } else
        Vs = ql(as, Cn, xt, Cs, cs);
    return gl(Vs)
}
Ec$1 = function(xt) {
    switch (xt.tag) {
    case 3:
        var Cn = xt.stateNode;
        if (Cn.current.memoizedState.isDehydrated) {
            var as = tc(Cn.pendingLanes);
            as !== 0 && (Cc$1(Cn, as | 1),
            Dk(Cn, B$2()),
            !(K$3 & 6) && (Gj = B$2() + 500,
            jg()))
        }
        break;
    case 13:
        Rk(function() {
            var cs = ih(xt, 1);
            if (cs !== null) {
                var Cs = R$2();
                gi$1(cs, xt, 1, Cs)
            }
        }),
        il(xt, 1)
    }
}
;
Fc = function(xt) {
    if (xt.tag === 13) {
        var Cn = ih(xt, 134217728);
        if (Cn !== null) {
            var as = R$2();
            gi$1(Cn, xt, 134217728, as)
        }
        il(xt, 134217728)
    }
}
;
Gc = function(xt) {
    if (xt.tag === 13) {
        var Cn = yi$1(xt)
          , as = ih(xt, Cn);
        if (as !== null) {
            var cs = R$2();
            gi$1(as, xt, Cn, cs)
        }
        il(xt, Cn)
    }
}
;
Hc$1 = function() {
    return C$7
}
;
Ic$1 = function(xt, Cn) {
    var as = C$7;
    try {
        return C$7 = xt,
        Cn()
    } finally {
        C$7 = as
    }
}
;
yb = function(xt, Cn, as) {
    switch (Cn) {
    case "input":
        if (bb(xt, as),
        Cn = as.name,
        as.type === "radio" && Cn != null) {
            for (as = xt; as.parentNode; )
                as = as.parentNode;
            for (as = as.querySelectorAll("input[name=" + JSON.stringify("" + Cn) + '][type="radio"]'),
            Cn = 0; Cn < as.length; Cn++) {
                var cs = as[Cn];
                if (cs !== xt && cs.form === xt.form) {
                    var Cs = Db(cs);
                    if (!Cs)
                        throw Error(p$7(90));
                    Wa$1(cs),
                    bb(cs, Cs)
                }
            }
        }
        break;
    case "textarea":
        ib(xt, as);
        break;
    case "select":
        Cn = as.value,
        Cn != null && fb(xt, !!as.multiple, Cn, !1)
    }
}
;
Gb = Qk;
Hb = Rk;
var sl = {
    usingClientEntryPoint: !1,
    Events: [Cb, ue$2, Db, Eb, Fb, Qk]
}
  , tl = {
    findFiberByHostInstance: Wc,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom"
}
  , ul = {
    bundleType: tl.bundleType,
    version: tl.version,
    rendererPackageName: tl.rendererPackageName,
    rendererConfig: tl.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ua.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(xt) {
        return xt = Zb(xt),
        xt === null ? null : xt.stateNode
    },
    findFiberByHostInstance: tl.findFiberByHostInstance || jl,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber)
        try {
            kc$1 = vl.inject(ul),
            lc$1 = vl
        } catch {}
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(xt, Cn) {
    var as = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!nl(Cn))
        throw Error(p$7(200));
    return cl(xt, Cn, null, as)
}
;
reactDom_production_min.createRoot = function(xt, Cn) {
    if (!nl(xt))
        throw Error(p$7(299));
    var as = !1
      , cs = ""
      , Cs = kl;
    return Cn != null && (Cn.unstable_strictMode === !0 && (as = !0),
    Cn.identifierPrefix !== void 0 && (cs = Cn.identifierPrefix),
    Cn.onRecoverableError !== void 0 && (Cs = Cn.onRecoverableError)),
    Cn = bl(xt, 1, !1, null, null, as, !1, cs, Cs),
    xt[uf] = Cn.current,
    sf(xt.nodeType === 8 ? xt.parentNode : xt),
    new ll(Cn)
}
;
reactDom_production_min.findDOMNode = function(xt) {
    if (xt == null)
        return null;
    if (xt.nodeType === 1)
        return xt;
    var Cn = xt._reactInternals;
    if (Cn === void 0)
        throw typeof xt.render == "function" ? Error(p$7(188)) : (xt = Object.keys(xt).join(","),
        Error(p$7(268, xt)));
    return xt = Zb(Cn),
    xt = xt === null ? null : xt.stateNode,
    xt
}
;
reactDom_production_min.flushSync = function(xt) {
    return Rk(xt)
}
;
reactDom_production_min.hydrate = function(xt, Cn, as) {
    if (!ol(Cn))
        throw Error(p$7(200));
    return rl(null, xt, Cn, !0, as)
}
;
reactDom_production_min.hydrateRoot = function(xt, Cn, as) {
    if (!nl(xt))
        throw Error(p$7(405));
    var cs = as != null && as.hydratedSources || null
      , Cs = !1
      , Ls = ""
      , Vs = kl;
    if (as != null && (as.unstable_strictMode === !0 && (Cs = !0),
    as.identifierPrefix !== void 0 && (Ls = as.identifierPrefix),
    as.onRecoverableError !== void 0 && (Vs = as.onRecoverableError)),
    Cn = el(Cn, null, xt, 1, as ?? null, Cs, !1, Ls, Vs),
    xt[uf] = Cn.current,
    sf(xt),
    cs)
        for (xt = 0; xt < cs.length; xt++)
            as = cs[xt],
            Cs = as._getVersion,
            Cs = Cs(as._source),
            Cn.mutableSourceEagerHydrationData == null ? Cn.mutableSourceEagerHydrationData = [as, Cs] : Cn.mutableSourceEagerHydrationData.push(as, Cs);
    return new ml(Cn)
}
;
reactDom_production_min.render = function(xt, Cn, as) {
    if (!ol(Cn))
        throw Error(p$7(200));
    return rl(null, xt, Cn, !1, as)
}
;
reactDom_production_min.unmountComponentAtNode = function(xt) {
    if (!ol(xt))
        throw Error(p$7(40));
    return xt._reactRootContainer ? (Rk(function() {
        rl(null, null, xt, !1, function() {
            xt._reactRootContainer = null,
            xt[uf] = null
        })
    }),
    !0) : !1
}
;
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(xt, Cn, as, cs) {
    if (!ol(as))
        throw Error(p$7(200));
    if (xt == null || xt._reactInternals === void 0)
        throw Error(p$7(38));
    return rl(xt, Cn, as, !1, cs)
}
;
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)
        } catch (xt) {
            console.error(xt)
        }
}
checkDCE(),
reactDom.exports = reactDom_production_min;
var reactDomExports = reactDom.exports;
const ReactDOM = getDefaultExportFromCjs(reactDomExports);
var m$5 = reactDomExports;
client.createRoot = m$5.createRoot,
client.hydrateRoot = m$5.hydrateRoot;
let z$3 = class Q1 extends Error {
    constructor(Cn, as, cs) {
        super(typeof as == "object" ? as.message : as || Cn, {
            cause: typeof as == "object" ? as.cause : cs
        }),
        this.type = Cn,
        this.name = "TypedError",
        Object.setPrototypeOf(this, Q1.prototype)
    }
}
;
function Do$1(xt) {
    return xt.replace(/_[a-z]/g, Cn => Cn[1].toUpperCase())
}
const xo$1 = "ERR_INVALID_VALUE"
  , Mo$2 = "ERR_UNEXPECTED_VALUE"
  , jo$1 = "ERR_UNEXPECTED_TYPE"
  , Jn$1 = "ERR_PARSE";
function Yn$1(xt, Cn) {
    const as = {};
    for (const cs in xt) {
        const Cs = xt[cs];
        if (!Cs)
            continue;
        let Ls, Vs;
        typeof Cs == "function" ? (Ls = cs,
        Vs = Cs) : [Ls,Vs] = Cs;
        try {
            const Ws = Vs(Cn(Ls));
            Ws !== void 0 && (as[cs] = Ws)
        } catch (Ws) {
            throw new z$3(Jn$1,`Parser for "${cs}" property failed${Ls === cs ? "" : `. Source field: "${Ls}"`}`,Ws)
        }
    }
    return as
}
function Qn$1(xt) {
    let Cn = xt;
    if (typeof Cn == "string")
        try {
            Cn = JSON.parse(Cn)
        } catch (as) {
            throw new z$3(xo$1,{
                cause: as
            })
        }
    if (typeof Cn != "object" || !Cn || Array.isArray(Cn))
        throw new z$3(Mo$2);
    return Cn
}
function q$2(xt, Cn) {
    return as => {
        const cs = Cs => {
            if (!(as && Cs === void 0))
                try {
                    return Cn(Cs)
                } catch (Ls) {
                    throw new z$3(Jn$1,{
                        message: `"${xt}" transformer failed to parse the value`,
                        cause: Ls
                    })
                }
        }
        ;
        return Object.assign(cs, {
            isValid(Cs) {
                try {
                    return cs(Cs),
                    !0
                } catch {
                    return !1
                }
            }
        })
    }
}
function Ue$2(xt, Cn) {
    return q$2("object", as => {
        const cs = Qn$1(as);
        return Yn$1(xt, Cs => cs[Cs])
    }
    )
}
function Re$3(xt) {
    throw new z$3(jo$1,`Unexpected value received: ${JSON.stringify(xt)}`)
}
const N$2 = q$2("string", xt => {
    if (typeof xt == "string" || typeof xt == "number")
        return xt.toString();
    Re$3(xt)
}
);
function _e$2(xt) {
    return /^#[\da-f]{6}$/i.test(xt)
}
function No$1(xt) {
    return /^#[\da-f]{3}$/i.test(xt)
}
function Zn$1(xt) {
    const Cn = xt.replace(/\s/g, "").toLowerCase();
    if (_e$2(Cn))
        return Cn;
    if (No$1(Cn)) {
        let cs = "#";
        for (let Cs = 0; Cs < 3; Cs += 1)
            cs += Cn[1 + Cs].repeat(2);
        return cs
    }
    const as = Cn.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || Cn.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
    if (!as)
        throw new Error(`Value "${xt}" does not satisfy any of known RGB formats.`);
    return as.slice(1).reduce( (cs, Cs) => {
        const Ls = parseInt(Cs, 10).toString(16);
        return cs + (Ls.length === 1 ? "0" : "") + Ls
    }
    , "#")
}
const qo$1 = q$2("rgb", xt => Zn$1(N$2()(xt)))
  , Uo$1 = q$2("themeParams", xt => {
    const Cn = qo$1(!0);
    return Object.entries(Qn$1(xt)).reduce( (as, [cs,Cs]) => (as[Do$1(cs)] = Cn(Cs),
    as), {})
}
);
function $o$1(xt, Cn) {
    return q$2("array", as => {
        let cs;
        if (Array.isArray(as))
            cs = as;
        else if (typeof as == "string")
            try {
                const Cs = JSON.parse(as);
                Array.isArray(Cs) && (cs = Cs)
            } catch {}
        return cs || Re$3(as),
        cs.map(xt)
    }
    )
}
let G$2 = class X1 extends Error {
    constructor(Cn, as, cs) {
        super(typeof as == "object" ? as.message : as || Cn, {
            cause: typeof as == "object" ? as.cause : cs
        }),
        this.type = Cn,
        this.name = "TypedError",
        Object.setPrototypeOf(this, X1.prototype)
    }
}
;
function er$1(xt) {
    return xt.replace(/[A-Z]/g, Cn => `_${Cn.toLowerCase()}`)
}
function Fo$1(xt) {
    return xt.replace(/_[a-z]/g, Cn => Cn[1].toUpperCase())
}
const Ho$1 = "ERR_INVALID_VALUE"
  , Wo$1 = "ERR_UNEXPECTED_VALUE"
  , zo$1 = "ERR_UNEXPECTED_TYPE"
  , tr$1 = "ERR_PARSE";
function nr$1(xt, Cn) {
    const as = {};
    for (const cs in xt) {
        const Cs = xt[cs];
        if (!Cs)
            continue;
        let Ls, Vs;
        typeof Cs == "function" ? (Ls = cs,
        Vs = Cs) : [Ls,Vs] = Cs;
        try {
            const Ws = Vs(Cn(Ls));
            Ws !== void 0 && (as[cs] = Ws)
        } catch (Ws) {
            throw new G$2(tr$1,`Parser for "${cs}" property failed${Ls === cs ? "" : `. Source field: "${Ls}"`}`,Ws)
        }
    }
    return as
}
function rr$1(xt) {
    let Cn = xt;
    if (typeof Cn == "string")
        try {
            Cn = JSON.parse(Cn)
        } catch (as) {
            throw new G$2(Ho$1,{
                cause: as
            })
        }
    if (typeof Cn != "object" || !Cn || Array.isArray(Cn))
        throw new G$2(Wo$1);
    return Cn
}
function D$2(xt, Cn) {
    return as => {
        const cs = Cs => {
            if (!(as && Cs === void 0))
                try {
                    return Cn(Cs)
                } catch (Ls) {
                    throw new G$2(tr$1,{
                        message: `"${xt}" transformer failed to parse the value`,
                        cause: Ls
                    })
                }
        }
        ;
        return Object.assign(cs, {
            isValid(Cs) {
                try {
                    return cs(Cs),
                    !0
                } catch {
                    return !1
                }
            }
        })
    }
}
function O$2(xt, Cn) {
    return D$2(Cn || "object", as => {
        const cs = rr$1(as);
        return nr$1(xt, Cs => cs[Cs])
    }
    )
}
function Te$3(xt) {
    throw new G$2(zo$1,`Unexpected value received: ${JSON.stringify(xt)}`)
}
const Fe$4 = D$2("boolean", xt => {
    if (typeof xt == "boolean")
        return xt;
    const Cn = String(xt);
    if (Cn === "1" || Cn === "true")
        return !0;
    if (Cn === "0" || Cn === "false")
        return !1;
    Te$3(xt)
}
)
  , B$1 = D$2("string", xt => {
    if (typeof xt == "string" || typeof xt == "number")
        return xt.toString();
    Te$3(xt)
}
)
  , fe$1 = D$2("number", xt => {
    if (typeof xt == "number")
        return xt;
    if (typeof xt == "string") {
        const Cn = Number(xt);
        if (!Number.isNaN(Cn))
            return Cn
    }
    Te$3(xt)
}
)
  , Go$1 = D$2("date", xt => xt instanceof Date ? xt : new Date(fe$1()(xt) * 1e3));
function or$1(xt, Cn) {
    return D$2(Cn || "searchParams", as => {
        typeof as != "string" && !(as instanceof URLSearchParams) && Te$3(as);
        const cs = typeof as == "string" ? new URLSearchParams(as) : as;
        return nr$1(xt, Cs => {
            const Ls = cs.get(Cs);
            return Ls === null ? void 0 : Ls
        }
        )
    }
    )
}
function ht$2(xt) {
    for (const Cn in xt)
        xt[Cn] = [er$1(Cn), xt[Cn]];
    return xt
}
const Jo$1 = xt => {
    const Cn = fe$1()
      , as = fe$1(!0)
      , cs = B$1()
      , Cs = B$1(!0)
      , Ls = Fe$4(!0)
      , Vs = O$2(ht$2({
        addedToAttachmentMenu: Ls,
        allowsWriteToPm: Ls,
        firstName: cs,
        id: Cn,
        isBot: Ls,
        isPremium: Ls,
        languageCode: Cs,
        lastName: Cs,
        photoUrl: Cs,
        username: Cs
    }), "User")(!0);
    return or$1(ht$2({
        authDate: Go$1(),
        canSendAfter: as,
        chat: O$2(ht$2({
            id: Cn,
            type: cs,
            title: cs,
            photoUrl: Cs,
            username: Cs
        }), "Chat")(!0),
        chatInstance: Cs,
        chatType: Cs,
        hash: cs,
        queryId: Cs,
        receiver: Vs,
        startParam: Cs,
        signature: cs,
        user: Vs
    }), "initData")(xt)
}
;
function Yo$1(xt) {
    return /^#[\da-f]{6}$/i.test(xt)
}
function Qo$1(xt) {
    return /^#[\da-f]{3}$/i.test(xt)
}
function Ko$1(xt) {
    const Cn = xt.replace(/\s/g, "").toLowerCase();
    if (Yo$1(Cn))
        return Cn;
    if (Qo$1(Cn)) {
        let cs = "#";
        for (let Cs = 0; Cs < 3; Cs += 1)
            cs += Cn[1 + Cs].repeat(2);
        return cs
    }
    const as = Cn.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || Cn.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
    if (!as)
        throw new Error(`Value "${xt}" does not satisfy any of known RGB formats.`);
    return as.slice(1).reduce( (cs, Cs) => {
        const Ls = parseInt(Cs, 10).toString(16);
        return cs + (Ls.length === 1 ? "0" : "") + Ls
    }
    , "#")
}
const Zo$1 = D$2("rgb", xt => Ko$1(B$1()(xt)))
  , Rn$1 = D$2("themeParams", xt => {
    const Cn = Zo$1(!0);
    return Object.entries(rr$1(xt)).reduce( (as, [cs,Cs]) => (as[Fo$1(cs)] = Cn(Cs),
    as), {})
}
);
function vt(xt) {
    return JSON.stringify(Object.fromEntries(Object.entries(xt).map( ([Cn,as]) => [er$1(Cn), as])))
}
const Xo$1 = xt => {
    const Cn = B$1()
      , as = B$1(!0)
      , cs = Fe$4(!0);
    return or$1({
        botInline: ["tgWebAppBotInline", cs],
        defaultColors: ["tgWebAppDefaultColors", Rn$1(!0)],
        fullscreen: ["tgWebAppFullscreen", cs],
        initData: ["tgWebAppData", Jo$1(!0)],
        initDataRaw: ["tgWebAppData", as],
        platform: ["tgWebAppPlatform", Cn],
        showSettings: ["tgWebAppShowSettings", cs],
        startParam: ["tgWebAppStartParam", as],
        themeParams: ["tgWebAppThemeParams", Rn$1()],
        version: ["tgWebAppVersion", Cn]
    }, "launchParams")(xt)
}
;
function es(xt) {
    const {initDataRaw: Cn, startParam: as, showSettings: cs, botInline: Cs, fullscreen: Ls, defaultColors: Vs} = xt
      , Ws = new URLSearchParams;
    return Ws.set("tgWebAppPlatform", xt.platform),
    Ws.set("tgWebAppThemeParams", vt(xt.themeParams)),
    Ws.set("tgWebAppVersion", xt.version),
    Cn && Ws.set("tgWebAppData", Cn),
    as && Ws.set("tgWebAppStartParam", as),
    typeof cs == "boolean" && Ws.set("tgWebAppShowSettings", cs ? "1" : "0"),
    typeof Cs == "boolean" && Ws.set("tgWebAppBotInline", Cs ? "1" : "0"),
    typeof Ls == "boolean" && Ws.set("tgWebAppFullscreen", Ls ? "1" : "0"),
    Vs && Ws.set("tgWebAppDefaultColors", vt(Vs)),
    Ws.toString()
}
const sr$1 = O$2({
    eventType: B$1(),
    eventData: xt => xt
}, "miniAppsMessage")
  , ar$1 = D$2("fn", xt => {
    if (typeof xt == "function")
        return xt;
    Te$3(xt)
}
);
function ts(xt) {
    return !!xt && typeof xt == "object" && !Array.isArray(xt)
}
const ns = O$2({
    TelegramWebviewProxy: O$2({
        postEvent: ar$1()
    })()
});
function ir$1(xt) {
    return ns().isValid(xt)
}
function rs() {
    try {
        return window.self !== window.top
    } catch {
        return !0
    }
}
var os = Object.defineProperty
  , ss = (xt, Cn, as) => Cn in xt ? os(xt, Cn, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: as
}) : xt[Cn] = as
  , cr$1 = (xt, Cn, as) => ss(xt, typeof Cn != "symbol" ? Cn + "" : Cn, as);
let p$6 = class J1 extends Error {
    constructor(Cn, as, cs) {
        super(typeof as == "object" ? as.message : as || Cn, {
            cause: typeof as == "object" ? as.cause : cs
        }),
        this.type = Cn,
        this.name = "TypedError",
        Object.setPrototypeOf(this, J1.prototype)
    }
}
;
function pr$1(xt, Cn, as) {
    return xt.addEventListener(Cn, as),
    () => xt.removeEventListener(Cn, as)
}
function ne$1(...xt) {
    const Cn = xt.flat(1);
    return [Cn.push.bind(Cn), () => {
        Cn.forEach(as => {
            as()
        }
        )
    }
    ]
}
const lr$1 = "ERR_ABORTED"
  , dr$1 = "ERR_CANCELED"
  , _r$1 = "ERR_TIMED_OUT";
function Tn$1(xt) {
    return new p$6(lr$1,{
        cause: xt
    })
}
function Bn$1(xt, Cn) {
    return xt.reject = Cn.reject,
    xt
}
let b$3 = class h1 extends Promise {
    constructor(Cn, as) {
        let cs, Cs;
        typeof Cn == "function" ? (cs = Cn,
        Cs = as) : Cs = Cn;
        let Ls, Vs;
        super( (Ws, Xs) => {
            Cs || (Cs = {});
            const {abortSignal: ga} = Cs;
            if (ga && ga.aborted)
                return Xs(Tn$1(ga.reason));
            const [ba,yl] = ne$1()
              , xl = Cl => (...$l) => (yl(),
            Cl(...$l))
              , wl = new AbortController
              , {signal: _l} = wl;
            Vs = xl(Cl => {
                wl.abort(Cl),
                Xs(Cl)
            }
            ),
            Ls = xl(Ws),
            ga && ba(pr$1(ga, "abort", () => {
                Vs(Tn$1(ga.reason))
            }
            ));
            const {timeout: El} = Cs;
            if (El) {
                const Cl = setTimeout( () => {
                    Vs(new p$6(_r$1,`Timeout reached: ${El}ms`))
                }
                , El);
                ba( () => {
                    clearTimeout(Cl)
                }
                )
            }
            cs && cs(Ls, Vs, _l)
        }
        ),
        cr$1(this, "reject"),
        this.reject = Vs
    }
    static withFn(Cn, as) {
        return new h1( (cs, Cs, Ls) => {
            try {
                const Vs = Cn(Ls);
                return Vs instanceof Promise ? Vs.then(cs, Cs) : cs(Vs)
            } catch (Vs) {
                Cs(Vs)
            }
        }
        ,as)
    }
    static resolve(Cn) {
        return new h1(as => {
            as(Cn)
        }
        )
    }
    static reject(Cn) {
        return new h1( (as, cs) => {
            cs(Cn)
        }
        )
    }
    cancel() {
        this.reject(new p$6(dr$1))
    }
    catch(Cn) {
        return this.then(void 0, Cn)
    }
    finally(Cn) {
        return Bn$1(super.finally(Cn), this)
    }
    then(Cn, as) {
        return Bn$1(super.then(Cn, as), this)
    }
}
;
function Pn$1(xt, Cn) {
    return xt.resolve = Cn.resolve,
    xt
}
let is = class p1 extends b$3 {
    constructor(Cn, as) {
        let cs, Cs;
        typeof Cn == "function" ? (cs = Cn,
        Cs = as) : Cs = Cn;
        let Ls;
        super( (Vs, Ws, Xs) => {
            Ls = Vs,
            cs && cs(Vs, Ws, Xs)
        }
        , Cs),
        cr$1(this, "resolve"),
        this.resolve = Ls
    }
    static withFn(Cn, as) {
        return new p1( (cs, Cs, Ls) => b$3.withFn(Cn, {
            abortSignal: Ls
        }).then(cs, Cs),as)
    }
    static resolve(Cn) {
        return new p1(as => {
            as(Cn)
        }
        )
    }
    static reject(Cn) {
        return new p1( (as, cs) => {
            cs(Cn)
        }
        )
    }
    catch(Cn) {
        return this.then(void 0, Cn)
    }
    finally(Cn) {
        return Pn$1(super.finally(Cn), this)
    }
    then(Cn, as) {
        return Pn$1(super.then(Cn, as), this)
    }
}
;
function fr$1(xt) {
    return `tapps/${xt}`
}
function P$7(xt, Cn) {
    sessionStorage.setItem(fr$1(xt), JSON.stringify(Cn))
}
function k$2(xt) {
    const Cn = sessionStorage.getItem(fr$1(xt));
    try {
        return Cn ? JSON.parse(Cn) : void 0
    } catch {}
}
function Lt$2(xt) {
    return xt.replace(/[A-Z]/g, Cn => `-${Cn.toLowerCase()}`)
}
function us(xt, Cn) {
    Cn || (Cn = {});
    const {textColor: as, bgColor: cs, shouldLog: Cs=!0} = Cn;
    function Ls(Vs, ...Ws) {
        if (!Cs || typeof Cs == "function" && !Cs())
            return;
        const Xs = "font-weight:bold;padding:0 5px;border-radius:5px";
        console[Vs](`%c${Intl.DateTimeFormat("en-GB", {
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            fractionalSecondDigits: 3,
            timeZone: "UTC"
        }).format(new Date)}%c / %c${xt}`, `${Xs};background-color: lightblue;color:black`, "", `${Xs};${as ? `color:${as};` : ""}${cs ? `background-color:${cs}` : ""}`, ...Ws)
    }
    return [function(...Vs) {
        Ls("log", ...Vs)
    }
    , function(...Vs) {
        Ls("error", ...Vs)
    }
    ]
}
function Vt$2(xt, Cn) {
    document.documentElement.style.setProperty(xt, Cn)
}
function Nt$1(xt) {
    document.documentElement.style.removeProperty(xt)
}
function ps(xt, Cn) {
    Cn()
}
function re$1(xt, Cn) {
    Cn || (Cn = {});
    const as = Cn.equals || Object.is;
    let cs = []
      , Cs = xt;
    const Ls = ga => {
        if (!as(Cs, ga)) {
            const ba = Cs;
            Cs = ga,
            ps(Xs, () => {
                [...cs].forEach( ([yl,xl]) => {
                    yl(ga, ba),
                    xl && Ws(yl, !0)
                }
                )
            }
            )
        }
    }
    ;
    function Vs(ga) {
        const ba = typeof ga != "object" ? {
            once: ga
        } : ga;
        return {
            once: ba.once || !1,
            signal: ba.signal || !1
        }
    }
    const Ws = (ga, ba) => {
        const yl = Vs(ba)
          , xl = cs.findIndex( ([wl,_l]) => wl === ga && _l.once === yl.once && _l.signal === yl.signal);
        xl >= 0 && cs.splice(xl, 1)
    }
      , Xs = Object.assign(function() {
        return ls(Xs),
        Cs
    }, {
        destroy() {
            cs = []
        },
        set: Ls,
        reset() {
            Ls(xt)
        },
        sub(ga, ba) {
            return cs.push([ga, Vs(ba)]),
            () => Ws(ga, ba)
        },
        unsub: Ws,
        unsubAll() {
            cs = cs.filter(ga => ga[1].signal)
        }
    });
    return Xs
}
const bt$1 = [];
function ls(xt) {
    bt$1.length && bt$1[bt$1.length - 1].add(xt)
}
const ds = re$1(!1)
  , [qt$1,_s] = us("Bridge", {
    bgColor: "#9147ff",
    textColor: "white",
    shouldLog: ds
})
  , fs = {
    clipboard_text_received: O$2({
        req_id: B$1(),
        data: xt => xt === null ? xt : B$1(!0)(xt)
    }, "clipboard_text_received"),
    custom_method_invoked: O$2({
        req_id: B$1(),
        result: xt => xt,
        error: B$1(!0)
    }, "custom_method_invoked"),
    popup_closed: D$2("popup_closed", xt => xt ? O$2({
        button_id: Cn => Cn == null ? void 0 : B$1()(Cn)
    })()(xt) : {}),
    viewport_changed: O$2({
        height: fe$1(),
        width: xt => xt == null ? window.innerWidth : fe$1()(xt),
        is_state_stable: Fe$4(),
        is_expanded: Fe$4()
    }, "viewport_changed")
};
function ms(xt) {
    const Cn = window
      , [,as] = ne$1(pr$1(Cn, "message", cs => {
        if (cs.source !== Cn.parent)
            return;
        let Cs;
        try {
            Cs = sr$1()(cs.data)
        } catch {
            return
        }
        const {eventType: Ls, eventData: Vs} = Cs
          , Ws = fs[Ls];
        try {
            const Xs = Ws ? Ws()(Vs) : Vs;
            qt$1("Event received:", Xs ? {
                eventType: Ls,
                eventData: Xs
            } : {
                eventType: Ls
            }),
            xt([Ls, Xs])
        } catch (Xs) {
            _s([`An error occurred processing the "${Ls}" event from the Telegram application.`, "Please, file an issue here:", "https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose"].join(`
`), Cs, Xs)
        }
    }
    ));
    return as
}
const At$1 = re$1()
  , kn$1 = re$1();
function mr$1() {
    return kn$1() || kn$1.set(ms(At$1.set)),
    At$1
}
const gt$2 = re$1({});
function hr$1(xt) {
    let Cn = gt$2()[xt];
    return Cn || (Cn = re$1(void 0, {
        equals() {
            return !1
        }
    }),
    mr$1().sub(as => {
        as && as[0] === xt && Cn.set(as[1])
    }
    ),
    gt$2.set({
        ...gt$2(),
        [xt]: Cn
    })),
    Cn
}
function w$4(xt, Cn, as) {
    return hr$1(xt).sub(Cn, as)
}
const hs = "ERR_METHOD_UNSUPPORTED"
  , bs = "ERR_RETRIEVE_LP_FAILED"
  , gs = "ERR_METHOD_PARAMETER_UNSUPPORTED"
  , br = "ERR_UNKNOWN_ENV"
  , ws = "ERR_INVOKE_CUSTOM_METHOD_RESPONSE"
  , ys = re$1("https://web.telegram.org");
function Ut$2(xt, Cn) {
    qt$1("Posting event:", Cn ? {
        eventType: xt,
        eventData: Cn
    } : {
        eventType: xt
    });
    const as = window;
    if (ir$1(as)) {
        as.TelegramWebviewProxy.postEvent(xt, JSON.stringify(Cn));
        return
    }
    const cs = JSON.stringify({
        eventType: xt,
        eventData: Cn
    });
    if (rs())
        return as.parent.postMessage(cs, ys());
    const {external: Cs} = as;
    if (O$2({
        notify: ar$1()
    })().isValid(Cs)) {
        Cs.notify(cs);
        return
    }
    throw new p$6(br)
}
function $t(xt, Cn, as) {
    as || (as = {});
    const {capture: cs} = as
      , [Cs,Ls] = ne$1();
    return new b$3(Vs => {
        (Array.isArray(Cn) ? Cn : [Cn]).forEach(Ws => {
            Cs(w$4(Ws, Xs => {
                (!cs || (Array.isArray(Cn) ? cs({
                    event: Ws,
                    payload: Xs
                }) : cs(Xs))) && Vs(Xs)
            }
            ))
        }
        ),
        (as.postEvent || Ut$2)(xt, as.params)
    }
    ,as).finally(Ls)
}
function Ft$1(xt) {
    return Xo$1()(xt)
}
function gr(xt) {
    return Ft$1(xt.replace(/^[^?#]*[?#]/, "").replace(/[?#]/g, "&"))
}
function Ss() {
    return gr(window.location.href)
}
function Es() {
    const xt = performance.getEntriesByType("navigation")[0];
    if (!xt)
        throw new Error("Unable to get first navigation entry.");
    return gr(xt.name)
}
const vs = "launchParams";
function As() {
    return Ft$1(k$2(vs) || "")
}
function wr(xt) {
    P$7("launchParams", es(xt))
}
function yr(xt) {
    return xt instanceof Error ? xt.message + (xt.cause ? `
  ${yr(xt.cause)}` : "") : JSON.stringify(xt)
}
function Y$2() {
    const xt = [];
    for (const Cn of [Ss, Es, As])
        try {
            const as = Cn();
            return wr(as),
            as
        } catch (as) {
            xt.push(as)
        }
    throw new p$6(bs,["Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?", " Refer to docs for more information:", "https://docs.telegram-mini-apps.com/packages/telegram-apps-bridge/environment", "Collected errors:", ...xt.map(Cn => ` ${yr(Cn)}`)].join(`
`))
}
function In$1(xt) {
    try {
        return Y$2(),
        !0
    } catch {
        return !1
    }
    return b$3.withFn(async () => {
        if (ir$1(window))
            return !0;
        try {
            return await $t("web_app_request_theme", "theme_changed", {
                timeout: 100
            }),
            !0
        } catch {
            return !1
        }
    }
    , xt)
}
function Ct$2(xt, Cn) {
    window.dispatchEvent(new MessageEvent("message",{
        data: JSON.stringify({
            eventType: xt,
            eventData: Cn
        }),
        source: window.parent
    }))
}
function Rs() {
    [["TelegramGameProxy_receiveEvent"], ["TelegramGameProxy", "receiveEvent"], ["Telegram", "WebView", "receiveEvent"]].forEach(xt => {
        let Cn = window;
        xt.forEach( (as, cs, Cs) => {
            if (cs === Cs.length - 1) {
                Cn[as] = Ct$2;
                return
            }
            as in Cn || (Cn[as] = {}),
            Cn = Cn[as]
        }
        )
    }
    )
}
function Ts() {
    ["TelegramGameProxy_receiveEvent", "TelegramGameProxy", "Telegram"].forEach(xt => {
        delete window[xt]
    }
    )
}
function C$6(xt, Cn, as) {
    hr$1(xt).unsub(Cn, as)
}
function Sr(xt) {
    return ({req_id: Cn}) => Cn === xt
}
function On$1(xt) {
    return xt.split(".").map(Number)
}
function Bs(xt, Cn) {
    const as = On$1(xt)
      , cs = On$1(Cn)
      , Cs = Math.max(as.length, cs.length);
    for (let Ls = 0; Ls < Cs; Ls += 1) {
        const Vs = as[Ls] || 0
          , Ws = cs[Ls] || 0;
        if (Vs !== Ws)
            return Vs > Ws ? 1 : -1
    }
    return 0
}
function S$3(xt, Cn) {
    return Bs(xt, Cn) <= 0
}
function J$4(xt, Cn, as) {
    if (typeof as == "string") {
        if (xt === "web_app_open_link") {
            if (Cn === "try_instant_view")
                return S$3("6.4", as);
            if (Cn === "try_browser")
                return S$3("7.6", as)
        }
        if (xt === "web_app_set_header_color" && Cn === "color")
            return S$3("6.9", as);
        if (xt === "web_app_close" && Cn === "return_back")
            return S$3("7.6", as);
        if (xt === "web_app_setup_main_button" && Cn === "has_shine_effect")
            return S$3("7.10", as)
    }
    switch (xt) {
    case "web_app_open_tg_link":
    case "web_app_open_invoice":
    case "web_app_setup_back_button":
    case "web_app_set_background_color":
    case "web_app_set_header_color":
    case "web_app_trigger_haptic_feedback":
        return S$3("6.1", Cn);
    case "web_app_open_popup":
        return S$3("6.2", Cn);
    case "web_app_close_scan_qr_popup":
    case "web_app_open_scan_qr_popup":
    case "web_app_read_text_from_clipboard":
        return S$3("6.4", Cn);
    case "web_app_switch_inline_query":
        return S$3("6.7", Cn);
    case "web_app_invoke_custom_method":
    case "web_app_request_write_access":
    case "web_app_request_phone":
        return S$3("6.9", Cn);
    case "web_app_setup_settings_button":
        return S$3("6.10", Cn);
    case "web_app_biometry_get_info":
    case "web_app_biometry_open_settings":
    case "web_app_biometry_request_access":
    case "web_app_biometry_request_auth":
    case "web_app_biometry_update_token":
        return S$3("7.2", Cn);
    case "web_app_setup_swipe_behavior":
        return S$3("7.7", Cn);
    case "web_app_share_to_story":
        return S$3("7.8", Cn);
    case "web_app_setup_secondary_button":
    case "web_app_set_bottom_bar_color":
        return S$3("7.10", Cn);
    case "web_app_request_safe_area":
    case "web_app_request_content_safe_area":
    case "web_app_request_fullscreen":
    case "web_app_exit_fullscreen":
    case "web_app_set_emoji_status":
    case "web_app_add_to_home_screen":
    case "web_app_check_home_screen":
    case "web_app_request_emoji_status_access":
        return S$3("8.0", Cn);
    default:
        return ["iframe_ready", "iframe_will_reload", "web_app_close", "web_app_data_send", "web_app_expand", "web_app_open_link", "web_app_ready", "web_app_request_theme", "web_app_request_viewport", "web_app_setup_main_button", "web_app_setup_closing_behavior"].includes(xt)
    }
}
function Ps(xt, Cn) {
    Cn || (Cn = "strict");
    const as = typeof Cn == "function" ? Cn : cs => {
        const {method: Cs, version: Ls} = cs;
        let Vs, Ws;
        if ("param"in cs ? (Vs = `Parameter "${cs.param}" of "${Cs}" method is unsupported in Mini Apps version ${Ls}`,
        Ws = gs) : (Vs = `Method "${Cs}" is unsupported in Mini Apps version ${Ls}`,
        Ws = hs),
        Cn === "strict")
            throw new p$6(Ws,Vs);
        return console.warn(Vs)
    }
    ;
    return (cs, Cs) => J$4(cs, xt) ? ts(Cs) && cs === "web_app_set_header_color" && "color"in Cs && !J$4(cs, "color", xt) ? as({
        version: xt,
        method: cs,
        param: "color"
    }) : Ut$2(cs, Cs) : as({
        version: xt,
        method: cs
    })
}
function ks(xt, Cn, as, cs) {
    return $t("web_app_invoke_custom_method", "custom_method_invoked", {
        ...cs || {},
        params: {
            method: xt,
            params: Cn,
            req_id: as
        },
        capture: Sr(as)
    }).then( ({result: Cs, error: Ls}) => {
        if (Ls)
            throw new p$6(ws,Ls);
        return Cs
    }
    )
}
function Is() {
    return performance.getEntriesByType("navigation")[0]
}
function x$4() {
    const xt = Is();
    return !!xt && xt.type === "reload"
}
let X$4;
function Os(xt, Cn) {
    X$4 && X$4.set(xt, Cn) || Cn()
}
function Rt$2(xt) {
    if (X$4)
        return xt();
    X$4 = new Map;
    try {
        xt()
    } finally {
        X$4.forEach(Cn => Cn()),
        X$4 = void 0
    }
}
function c$9(xt, Cn) {
    Cn || (Cn = {});
    const as = Cn.equals || Object.is;
    let cs = []
      , Cs = xt;
    const Ls = ga => {
        if (!as(Cs, ga)) {
            const ba = Cs;
            Cs = ga,
            Os(Xs, () => {
                [...cs].forEach( ([yl,xl]) => {
                    yl(ga, ba),
                    xl && Ws(yl, !0)
                }
                )
            }
            )
        }
    }
    ;
    function Vs(ga) {
        const ba = typeof ga != "object" ? {
            once: ga
        } : ga;
        return {
            once: ba.once || !1,
            signal: ba.signal || !1
        }
    }
    const Ws = (ga, ba) => {
        const yl = Vs(ba)
          , xl = cs.findIndex( ([wl,_l]) => wl === ga && _l.once === yl.once && _l.signal === yl.signal);
        xl >= 0 && cs.splice(xl, 1)
    }
      , Xs = Object.assign(function() {
        return Ds(Xs),
        Cs
    }, {
        destroy() {
            cs = []
        },
        set: Ls,
        reset() {
            Ls(xt)
        },
        sub(ga, ba) {
            return cs.push([ga, Vs(ba)]),
            () => Ws(ga, ba)
        },
        unsub: Ws,
        unsubAll() {
            cs = cs.filter(ga => ga[1].signal)
        }
    });
    return Xs
}
const ue$1 = [];
function Ds(xt) {
    ue$1.length && ue$1[ue$1.length - 1].add(xt)
}
function d$5(xt, Cn) {
    let as = new Set, cs;
    function Cs() {
        return cs || (cs = c$9(Vs(), Cn))
    }
    function Ls() {
        Cs().set(Vs())
    }
    function Vs() {
        as.forEach(ga => {
            ga.unsub(Ls, {
                signal: !0
            })
        }
        );
        const Ws = new Set;
        let Xs;
        ue$1.push(Ws);
        try {
            Xs = xt()
        } finally {
            ue$1.pop()
        }
        return Ws.forEach(ga => {
            ga.sub(Ls, {
                signal: !0
            })
        }
        ),
        as = Ws,
        Xs
    }
    return Object.assign(function() {
        return Cs()()
    }, {
        destroy() {
            Cs().destroy()
        },
        sub(...Ws) {
            return Cs().sub(...Ws)
        },
        unsub(...Ws) {
            Cs().unsub(...Ws)
        },
        unsubAll(...Ws) {
            Cs().unsubAll(...Ws)
        }
    })
}
const xs = c$9(( () => {
    let xt = 0;
    return () => (xt += 1).toString()
}
)())
  , Er$1 = c$9(Ut$2)
  , V$3 = c$9("0.0");
function Ms(xt) {
    xt || (xt = {});
    const {postEvent: Cn} = xt
      , as = xt.version || Y$2().version;
    V$3.set(as),
    Er$1.set(typeof Cn == "function" ? Cn : Ps(as))
}
function vr() {
    return xs()()
}
function oe$2(xt, Cn, as) {
    return ks(xt, Cn, vr(), {
        ...as || {},
        postEvent: _$6
    })
}
const E$4 = (xt, Cn, as) => (as || (as = {}),
as.postEvent || (as.postEvent = _$6),
$t(xt, Cn, as))
  , _$6 = (xt, Cn) => Er$1()(xt, Cn);
function M$6(xt) {
    return d$5( () => J$4(xt, V$3()))
}
const ce$3 = "ERR_POPUP_INVALID_PARAMS"
  , Ht$2 = "ERR_INVALID_URL"
  , js = "ERR_INVALID_SLUG"
  , F$4 = "ERR_ALREADY_REQUESTING"
  , Wt = "ERR_ALREADY_OPENED"
  , Ns = "ERR_ALREADY_MOUNTING"
  , qs = "ERR_VARS_ALREADY_BOUND"
  , Us = "ERR_NOT_AVAILABLE"
  , $s = "ERR_NOT_INITIALIZED"
  , Dn$1 = "ERR_NOT_SUPPORTED"
  , Fs = "ERR_NOT_MOUNTED"
  , Hs = "ERR_FULLSCREEN_FAILED";
function xn$1() {
    return typeof window > "u"
}
function h$4(xt, Cn, {isSupported: as, isMounted: cs, component: Cs, supports: Ls}={}) {
    const Vs = `${Cs ? `${Cs}.` : ""}${xt}()`;
    as = as ? Array.isArray(as) || typeof as == "object" && "any"in as ? as : [as] : void 0;
    function Ws(El) {
        if (Ls) {
            const Cl = Ls[El];
            return J$4(Cl[0], Cl[1], V$3())
        }
        return !0
    }
    const Xs = () => {
        if (!as)
            return;
        const El = `it is unsupported in Mini Apps version ${V$3()}`;
        function Cl(Sl) {
            return typeof Sl == "string" ? J$4(Sl, V$3()) ? void 0 : El : Sl.fn() ? void 0 : Sl.error
        }
        if (Array.isArray(as)) {
            for (const Sl of as) {
                const Tl = Cl(Sl);
                if (Tl)
                    return Tl
            }
            return
        }
        let $l;
        for (const Sl of as.any)
            if ($l = Cl(Sl),
            !$l)
                return;
        return El
    }
      , ga = (...El) => {
        if (Ls) {
            for (const Cl in Ls)
                if (Ls[Cl][2](...El) && !Ws(Cl))
                    return `option ${Cl} is not supported in Mini Apps version ${V$3()}`
        }
    }
      , ba = d$5( () => !Xs())
      , yl = d$5( () => V$3() !== "0.0")
      , xl = d$5( () => !cs || cs())
      , wl = d$5( () => In$1("simple") && !xn$1() && yl() && ba() && xl());
    let _l;
    if (Ls) {
        _l = {};
        for (const El in Ls)
            _l[El] = d$5( () => Ws(El))
    }
    return Object.assign( (...El) => {
        const Cl = `Unable to call the ${Vs} ${Cs ? "method" : "function"}:`;
        if (xn$1() || !In$1("simple"))
            throw new p$6(br,`${Cl} it can't be called outside Mini Apps`);
        if (!yl())
            throw new p$6($s,`${Cl} the SDK was not initialized. Use the SDK init() function`);
        const $l = Xs();
        if ($l)
            throw new p$6(Dn$1,`${Cl} ${$l}`);
        const Sl = ga(...El);
        if (Sl)
            throw new p$6(Dn$1,`${Cl} ${Sl}`);
        if (!xl())
            throw new p$6(Fs,`${Cl} the component is not mounted. Use the ${Cs}.mount() method`);
        return Cn(...El)
    }
    , Cn, {
        isAvailable: wl,
        ifAvailable(...El) {
            return wl() ? Cn(...El) : void 0
        }
    }, as ? {
        isSupported: ba
    } : {}, _l ? {
        supports: _l
    } : {})
}
function We$2(xt, Cn) {
    return Cn || (Cn = {}),
    (as, cs, Cs, Ls) => h$4(as, cs, {
        ...Cn,
        isSupported: Cs || Cn.isSupported,
        supports: Ls,
        component: xt
    })
}
function Q$1(xt, Cn, as) {
    return We$2(xt, {
        isSupported: as,
        isMounted: Cn
    })
}
function I$3(xt, Cn) {
    return We$2(xt, {
        isSupported: Cn
    })
}
const ze$1 = "web_app_setup_back_button"
  , Ar$1 = "back_button_pressed"
  , Ge$1 = "backButton"
  , Tt = c$9(!1)
  , me$2 = c$9(!1)
  , zs = M$6(ze$1)
  , Cr = Q$1(Ge$1, me$2, ze$1)
  , zt$1 = I$3(Ge$1, ze$1)
  , Gs = Cr("hide", () => {
    Gt$2(!1)
}
)
  , Js = zt$1("mount", () => {
    me$2() || (Gt$2(x$4() && k$2(Ge$1) || !1),
    me$2.set(!0))
}
);
function Gt$2(xt) {
    xt !== Tt() && (_$6(ze$1, {
        is_visible: xt
    }),
    P$7(Ge$1, xt),
    Tt.set(xt))
}
const Ys = zt$1("onClick", xt => w$4(Ar$1, xt))
  , Qs = zt$1("offClick", xt => {
    C$6(Ar$1, xt)
}
)
  , Ks = Cr("show", () => {
    Gt$2(!0)
}
);
function Zs() {
    me$2.set(!1)
}
const Hc = Object.freeze(Object.defineProperty({
    __proto__: null,
    hide: Gs,
    isMounted: me$2,
    isSupported: zs,
    isVisible: Tt,
    mount: Js,
    offClick: Qs,
    onClick: Ys,
    show: Ks,
    unmount: Zs
}, Symbol.toStringTag, {
    value: "Module"
}));
function Be$2(xt, Cn, as, cs, Cs) {
    const Ls = Cs === void 0 || Cs ? b$3 : Promise;
    return Object.assign( (...Vs) => Ls.resolve().then(async () => {
        if (as()) {
            const Xs = Cn();
            throw cs.set(Xs),
            Xs
        }
        Rt$2( () => {
            as.set(Ls.resolve(xt(...Vs))),
            cs.set(void 0)
        }
        );
        let Ws;
        try {
            Ws = [!0, await as()]
        } catch (Xs) {
            Ws = [!1, Xs]
        }
        if (Rt$2( () => {
            as.set(void 0),
            cs.set(Ws[0] ? void 0 : Ws[1])
        }
        ),
        !Ws[0])
            throw Ws[1];
        return Ws[1]
    }
    ), xt)
}
function Rr(xt, Cn, as, cs, Cs, Ls) {
    const Vs = Be$2(Cn, () => new p$6(Ns,`The ${xt} component is already mounting`), Cs, Ls);
    return Ws => b$3.resolve().then(async () => {
        if (!cs()) {
            const Xs = await Vs(Ws);
            Rt$2( () => {
                cs.set(!0),
                as(Xs)
            }
            )
        }
    }
    )
}
const U$4 = We$2
  , Je$1 = c$9({
    available: !1
})
  , De$2 = c$9(!1)
  , xe$2 = c$9(!1)
  , Ye$1 = c$9(!1)
  , Tr = c$9()
  , Jt = c$9();
function Yt$1(xt) {
    return xt.available ? {
        available: !0,
        tokenSaved: xt.token_saved,
        deviceId: xt.device_id,
        accessRequested: xt.access_requested,
        type: xt.type,
        accessGranted: xt.access_granted
    } : {
        available: !1
    }
}
const Mn$1 = "web_app_biometry_get_info"
  , ta = h$4("requestBiometry", xt => E$4(Mn$1, "biometry_info_received", xt).then(Yt$1), {
    isSupported: Mn$1
})
  , Qe = "web_app_biometry_request_auth"
  , na = "web_app_biometry_request_access"
  , ra = "web_app_biometry_open_settings"
  , oa = "web_app_biometry_update_token"
  , Qt = "biometry_info_received"
  , te$1 = "biometry"
  , aa = U$4(te$1)
  , ia = I$3(te$1, Qe)
  , Kt$1 = Q$1(te$1, Ye$1, Qe);
function Br$1() {
    throw new p$6(Us,"Biometry is not available")
}
Kt$1("authenticate", xt => b$3.withFn(async Cn => {
    if (De$2())
        throw new p$6(F$4,"Authentication is already in progress");
    const as = Je$1();
    (!as || !as.available) && Br$1(),
    De$2.set(!0);
    try {
        const cs = await E$4(Qe, "biometry_auth_requested", {
            abortSignal: Cn,
            params: {
                reason: ((xt || {}).reason || "").trim()
            }
        })
          , {token: Cs} = cs;
        return typeof Cs == "string" && Ke$2({
            ...as,
            token: Cs
        }),
        cs
    } finally {
        De$2.set(!1)
    }
}
, xt));
ia("openSettings", () => {
    _$6(ra)
}
);
Kt$1("requestAccess", xt => b$3.withFn(async Cn => {
    if (xe$2())
        throw new p$6(F$4,"Access request is already in progress");
    xe$2.set(!0);
    try {
        const as = await E$4(na, Qt, {
            abortSignal: Cn,
            params: {
                reason: (xt || {}).reason || ""
            }
        }).then(Yt$1);
        return as.available || Br$1(),
        Ke$2(as),
        as.accessGranted
    } finally {
        xe$2.set(!1)
    }
}
, xt));
aa("mount", Rr(te$1, xt => x$4() && k$2(te$1) || ta(xt), xt => {
    w$4(Qt, Pr$1),
    Ke$2(xt)
}
, Ye$1, Jt, Tr));
const Pr$1 = xt => {
    Ke$2(Yt$1(xt))
}
;
function Ke$2(xt) {
    Je$1.set(xt),
    P$7(te$1, xt)
}
Kt$1("updateToken", xt => (xt || (xt = {}),
E$4(oa, "biometry_token_updated", {
    ...xt,
    params: {
        token: xt.token || "",
        reason: xt.reason
    }
}).then(Cn => Cn.status)));
function Ze$1(xt, Cn) {
    return We$2(xt, {
        isMounted: Cn
    })
}
const Xe$1 = "closingBehavior"
  , Bt$1 = c$9(!1)
  , he$1 = c$9(!1)
  , kr$1 = Ze$1(Xe$1, he$1)
  , fa = U$4(Xe$1);
kr$1("disableConfirmation", () => {
    Zt$1(!1)
}
);
kr$1("enableConfirmation", () => {
    Zt$1(!0)
}
);
fa("mount", () => {
    he$1() || (Zt$1(x$4() && k$2(Xe$1) || !1),
    he$1.set(!0))
}
);
function Zt$1(xt) {
    xt !== Bt$1() && (_$6("web_app_setup_closing_behavior", {
        need_confirmation: xt
    }),
    P$7(Xe$1, xt),
    Bt$1.set(xt))
}
const Ir = "web_app_invoke_custom_method"
  , et$1 = I$3("cloudStorage", Ir);
et$1("deleteItem", (xt, Cn) => {
    const as = Array.isArray(xt) ? xt : [xt];
    return as.length ? oe$2("deleteStorageValues", {
        keys: as
    }, Cn).then() : b$3.resolve()
}
);
function Sa(xt, Cn) {
    const as = Array.isArray(xt) ? xt : [xt];
    return as.length ? oe$2("getStorageValues", {
        keys: as
    }, Cn).then(cs => {
        const Cs = Ue$2(Object.fromEntries(as.map(Ls => [Ls, N$2()])))()(cs);
        return Array.isArray(xt) ? Cs : Cs[xt]
    }
    ) : b$3.resolve(typeof xt == "string" ? "" : {})
}
et$1("getItem", Sa);
et$1("getKeys", xt => oe$2("getStorageKeys", {}, xt).then($o$1(N$2())()));
et$1("setItem", (xt, Cn, as) => oe$2("saveStorageValue", {
    key: xt,
    value: Cn
}, as).then());
const Pe$2 = "web_app_trigger_haptic_feedback"
  , Xt = I$3("hapticFeedback", Pe$2);
Xt("impactOccurred", xt => {
    _$6(Pe$2, {
        type: "impact",
        impact_style: xt
    })
}
);
Xt("notificationOccurred", xt => {
    _$6(Pe$2, {
        type: "notification",
        notification_type: xt
    })
}
);
Xt("selectionChanged", () => {
    _$6(Pe$2, {
        type: "selection_change"
    })
}
);
const en$1 = c$9(void 0);
function j$5(xt) {
    return d$5( () => {
        const Cn = en$1();
        return Cn ? Cn[xt] : void 0
    }
    )
}
const Or$1 = j$5("authDate")
  , Dr = j$5("canSendAfter")
  , Pa = d$5( () => {
    const xt = Or$1()
      , Cn = Dr();
    return Cn && xt ? new Date(xt.getTime() + Cn * 1e3) : void 0
}
)
  , ka = j$5("chat")
  , Ia = j$5("chatType")
  , Oa = j$5("chatInstance")
  , Da = j$5("hash")
  , xa = j$5("queryId")
  , xr = c$9()
  , Ma = j$5("receiver");
function ja() {
    const xt = Y$2();
    en$1.set(xt.initData),
    xr.set(xt.initDataRaw)
}
const La = j$5("startParam")
  , Va = j$5("user")
  , Yc = Object.freeze(Object.defineProperty({
    __proto__: null,
    authDate: Or$1,
    canSendAfter: Dr,
    canSendAfterDate: Pa,
    chat: ka,
    chatInstance: Oa,
    chatType: Ia,
    hash: Da,
    queryId: xa,
    raw: xr,
    receiver: Ma,
    restore: ja,
    startParam: La,
    state: en$1,
    user: Va
}, Symbol.toStringTag, {
    value: "Module"
}))
  , tn = "web_app_open_invoice"
  , Na = I$3("invoice", tn)
  , Me$3 = c$9(!1);
async function Mr$1(xt, Cn, as) {
    if (Me$3())
        throw new p$6(Wt,"An invoice is already opened");
    let cs;
    if (Cn === "url") {
        const {hostname: Cs, pathname: Ls} = new URL(xt,window.location.href);
        if (Cs !== "t.me")
            throw new p$6(Ht$2,`Link has unexpected hostname: ${Cs}`);
        const Vs = Ls.match(/^\/(\$|invoice\/)([A-Za-z0-9\-_=]+)$/);
        if (!Vs)
            throw new p$6(js,'Expected to receive a link with a pathname in format "/invoice/{slug}" or "/${slug}"');
        [,,cs] = Vs
    } else
        cs = xt,
        as = Cn;
    return Me$3.set(!0),
    E$4(tn, "invoice_closed", {
        ...as,
        params: {
            slug: cs
        },
        capture: Cs => cs === Cs.slug
    }).then(Cs => Cs.status).finally( () => {
        Me$3.set(!1)
    }
    )
}
Na("open", Mr$1);
function jr(xt) {
    return Object.fromEntries(Object.entries(xt).filter(Cn => Cn[1] !== void 0))
}
function Lr$1(xt) {
    const Cn = Zn$1(xt);
    return Math.sqrt([.299, .587, .114].reduce( (as, cs, Cs) => {
        const Ls = parseInt(Cn.slice(1 + Cs * 2, 1 + (Cs + 1) * 2), 16);
        return as + Ls * Ls * cs
    }
    , 0)) < 120
}
const be$3 = c$9(!1)
  , je$3 = c$9(!1)
  , $$3 = c$9({});
function A$4(xt) {
    return d$5( () => $$3()[xt])
}
const $a = A$4("accentTextColor")
  , nn = A$4("bgColor")
  , rn = A$4("buttonColor")
  , Vr$1 = A$4("buttonTextColor")
  , Nr = A$4("bottomBarBgColor")
  , Fa = A$4("destructiveTextColor")
  , Ha = A$4("headerBgColor")
  , Wa = A$4("hintColor")
  , za = d$5( () => {
    const {bgColor: xt} = $$3();
    return !xt || Lr$1(xt)
}
)
  , Ga = A$4("linkColor")
  , He$1 = A$4("secondaryBgColor")
  , Ja = A$4("sectionBgColor")
  , Ya = A$4("sectionHeaderTextColor")
  , Qa = A$4("sectionSeparatorColor")
  , Ka = A$4("subtitleTextColor")
  , Za = A$4("textColor")
  , pe$3 = c$9({
    hasShineEffect: !1,
    isEnabled: !0,
    isLoaderVisible: !1,
    isVisible: !1,
    text: "Continue"
})
  , on$1 = d$5( () => {
    const xt = pe$3();
    return {
        ...xt,
        backgroundColor: xt.backgroundColor || rn() || "#2481cc",
        textColor: xt.textColor || Vr$1() || "#ffffff"
    }
}
)
  , ge$2 = c$9(!1)
  , ai = "web_app_setup_main_button"
  , qr = "main_button_pressed"
  , tt = "mainButton"
  , sn = U$4(tt)
  , ii = Ze$1(tt, ge$2);
sn("mount", () => {
    if (!ge$2()) {
        const xt = x$4() && k$2(tt);
        xt && pe$3.set(xt),
        ge$2.set(!0)
    }
}
);
sn("onClick", xt => w$4(qr, xt));
sn("offClick", xt => {
    C$6(qr, xt)
}
);
ii("setParams", xt => {
    pe$3.set({
        ...pe$3(),
        ...jr(xt)
    }),
    P$7(tt, pe$3());
    const Cn = on$1();
    Cn.text && _$6(ai, {
        color: Cn.backgroundColor,
        has_shine_effect: Cn.hasShineEffect,
        is_active: Cn.isEnabled,
        is_progress_visible: Cn.isLoaderVisible,
        is_visible: Cn.isVisible,
        text: Cn.text,
        text_color: Cn.textColor
    })
}
);
function an$1() {
    throw new p$6(qs,"CSS variables are already bound")
}
function _i(xt) {
    return Uo$1()(xt)
}
const nt = "themeParams"
  , Ur = "theme_changed"
  , fi = U$4(nt)
  , mi = Ze$1(nt, be$3)
  , hi = mi("bindCssVars", xt => {
    je$3() && an$1(),
    xt || (xt = cs => `--tg-theme-${Lt$2(cs)}`);
    function Cn(cs) {
        Object.entries($$3()).forEach( ([Cs,Ls]) => {
            Ls && cs(Cs, Ls)
        }
        )
    }
    function as() {
        Cn( (cs, Cs) => {
            Vt$2(xt(cs), Cs)
        }
        )
    }
    return as(),
    $$3.sub(as),
    je$3.set(!0),
    () => {
        Cn(Nt$1),
        $$3.unsub(as),
        je$3.set(!1)
    }
}
)
  , $r = fi("mount", () => {
    be$3() || (w$4(Ur, Fr$1),
    $$3.set(x$4() && k$2(nt) || Y$2().themeParams),
    be$3.set(!0))
}
)
  , Fr$1 = xt => {
    const Cn = _i(xt.theme_params);
    $$3.set(Cn),
    P$7(nt, Cn)
}
;
function bi() {
    C$6(Ur, Fr$1),
    be$3.set(!1)
}
function Hr$1(xt) {
    return d$5( () => {
        const Cn = xt();
        return _e$2(Cn) ? Cn : Cn === "bg_color" ? nn() : He$1()
    }
    )
}
const we$2 = c$9("bg_color")
  , cn$1 = Hr$1(we$2)
  , ye$3 = c$9("bottom_bar_bg_color")
  , un$1 = d$5( () => {
    const xt = ye$3();
    return _e$2(xt) ? xt : xt === "bottom_bar_bg_color" ? Nr() || He$1() : xt === "secondary_bg_color" ? He$1() : nn()
}
)
  , Se$3 = c$9("bg_color")
  , Wr$1 = Hr$1(Se$3)
  , Ee$3 = c$9(!1)
  , Le$1 = c$9(!1)
  , gi = d$5( () => {
    const xt = cn$1();
    return xt ? Lr$1(xt) : !1
}
)
  , rt$1 = c$9(!0)
  , zr$1 = d$5( () => ({
    backgroundColor: we$2(),
    bottomBarColor: ye$3(),
    headerColor: Se$3(),
    isActive: rt$1()
}))
  , Pt$2 = "web_app_set_background_color"
  , kt$1 = "web_app_set_bottom_bar_color"
  , Ve$2 = "web_app_set_header_color"
  , Gr$1 = "visibility_changed"
  , ke$1 = "miniApp"
  , pn$1 = {
    any: [Pt$2, kt$1, Ve$2]
}
  , wi = d$5( () => pn$1.any.some(xt => J$4(xt, V$3())))
  , Jr = U$4(ke$1)
  , yi = I$3(ke$1, pn$1)
  , ot$1 = Q$1(ke$1, Ee$3, pn$1)
  , Si = ot$1("bindCssVars", xt => {
    Le$1() && an$1();
    const [Cn,as] = ne$1();
    function cs(Cs, Ls) {
        function Vs() {
            Vt$2(Cs, Ls() || null)
        }
        Vs(),
        Cn(Ls.sub(Vs), Nt$1.bind(null, Cs))
    }
    return xt || (xt = Cs => `--tg-${Lt$2(Cs)}`),
    cs(xt("bgColor"), cn$1),
    cs(xt("bottomBarColor"), un$1),
    cs(xt("headerColor"), Wr$1),
    Cn( () => {
        Le$1.set(!1)
    }
    ),
    Le$1.set(!0),
    as
}
)
  , Ei = Jr("close", xt => {
    _$6("web_app_close", {
        return_back: xt
    })
}
)
  , Yr$1 = xt => {
    rt$1.set(xt.is_visible),
    st()
}
  , vi = yi("mount", () => {
    if (!Ee$3()) {
        const xt = x$4() && k$2(ke$1);
        $r(),
        Qr.ifAvailable(xt ? xt.backgroundColor : "bg_color"),
        Kr$1.ifAvailable(xt ? xt.bottomBarColor : "bottom_bar_bg_color"),
        Zr.ifAvailable(xt ? xt.headerColor : "bg_color"),
        rt$1.set(xt ? xt.isActive : !0),
        w$4(Gr$1, Yr$1),
        Ee$3.set(!0)
    }
}
)
  , Ai = Jr("ready", () => {
    _$6("web_app_ready")
}
);
function st() {
    P$7(ke$1, zr$1())
}
const Qr = ot$1("setBackgroundColor", xt => {
    xt !== we$2() && (_$6(Pt$2, {
        color: xt
    }),
    we$2.set(xt),
    st())
}
, Pt$2)
  , Kr$1 = ot$1("setBottomBarColor", xt => {
    xt !== ye$3() && (_$6(kt$1, {
        color: xt
    }),
    ye$3.set(xt),
    st())
}
, kt$1)
  , Zr = ot$1("setHeaderColor", xt => {
    xt !== Se$3() && (_$6(Ve$2, _e$2(xt) ? {
        color: xt
    } : {
        color_key: xt
    }),
    Se$3.set(xt),
    st())
}
, Ve$2, {
    rgb: [Ve$2, "color", _e$2]
});
function Ci() {
    C$6(Gr$1, Yr$1),
    Ee$3.set(!1)
}
const Xc = Object.freeze(Object.defineProperty({
    __proto__: null,
    backgroundColor: we$2,
    backgroundColorRGB: cn$1,
    bindCssVars: Si,
    bottomBarColor: ye$3,
    bottomBarColorRGB: un$1,
    close: Ei,
    headerColor: Se$3,
    headerColorRGB: Wr$1,
    isActive: rt$1,
    isCssVarsBound: Le$1,
    isDark: gi,
    isMounted: Ee$3,
    isSupported: wi,
    mount: vi,
    ready: Ai,
    setBackgroundColor: Qr,
    setBottomBarColor: Kr$1,
    setHeaderColor: Zr,
    state: zr$1,
    unmount: Ci
}, Symbol.toStringTag, {
    value: "Module"
}));
function Ri(xt) {
    const Cn = xt.message.trim()
      , as = (xt.title || "").trim()
      , cs = xt.buttons || [];
    if (as.length > 64)
        throw new p$6(ce$3,`Invalid title: ${as}`);
    if (!Cn || Cn.length > 256)
        throw new p$6(ce$3,`Invalid message: ${Cn}`);
    if (cs.length > 3)
        throw new p$6(ce$3,`Invalid buttons count: ${cs.length}`);
    return {
        title: as,
        message: Cn,
        buttons: cs.length ? cs.map( (Cs, Ls) => {
            const Vs = Cs.id || "";
            if (Vs.length > 64)
                throw new p$6(ce$3,`Button with index ${Ls} has invalid id: ${Vs}`);
            if (!Cs.type || Cs.type === "default" || Cs.type === "destructive") {
                const Ws = Cs.text.trim();
                if (!Ws || Ws.length > 64)
                    throw new p$6(ce$3,`Button with index ${Ls} has invalid text: ${Ws}`);
                return {
                    type: Cs.type,
                    text: Ws,
                    id: Vs
                }
            }
            return {
                type: Cs.type,
                id: Vs
            }
        }
        ) : [{
            type: "close",
            id: ""
        }]
    }
}
const ln$1 = "web_app_open_popup"
  , Ti = I$3("popup", ln$1)
  , Ne$2 = c$9(!1);
Ti("open", async xt => {
    if (Ne$2())
        throw new p$6(Wt,"A popup is already opened");
    Ne$2.set(!0);
    try {
        const {button_id: Cn=null} = await E$4(ln$1, "popup_closed", {
            ...xt,
            params: Ri(xt)
        });
        return Cn
    } finally {
        Ne$2.set(!1)
    }
}
);
const ki = "web_app_close_scan_qr_popup"
  , dn$1 = "web_app_open_scan_qr_popup"
  , Ii = "scan_qr_popup_closed"
  , Oi = "qr_text_received"
  , Xr = I$3("qrScanner", dn$1)
  , It$2 = Xr("close", () => {
    ee$1.set(!1),
    _$6(ki)
}
)
  , ee$1 = c$9(!1);
function xi(xt) {
    return b$3.withFn(Cn => {
        if (ee$1())
            throw new p$6(Wt,"The QR Scanner is already opened");
        ee$1.set(!0),
        xt || (xt = {});
        const {onCaptured: as, text: cs, capture: Cs} = xt
          , [,Ls] = ne$1(ee$1.sub( () => {
            Vs.resolve()
        }
        ), w$4(Ii, () => {
            ee$1.set(!1)
        }
        ), w$4(Oi, Ws => {
            as ? as(Ws.data) : (!Cs || Cs(Ws.data)) && (Vs.resolve(Ws.data),
            It$2())
        }
        ))
          , Vs = new is({
            abortSignal: Cn
        }).catch(It$2).finally(Ls);
        return (xt.postEvent || _$6)(dn$1, {
            text: cs
        }),
        Vs
    }
    , xt)
}
Xr("open", xi);
const le$1 = c$9({
    hasShineEffect: !1,
    isEnabled: !0,
    isLoaderVisible: !1,
    isVisible: !1,
    position: "left",
    text: "Cancel"
})
  , _n$1 = d$5( () => {
    const xt = le$1();
    return {
        ...xt,
        backgroundColor: xt.backgroundColor || un$1() || "#000000",
        textColor: xt.textColor || rn() || "#2481cc"
    }
}
)
  , ve$1 = c$9(!1)
  , at$1 = "web_app_setup_secondary_button"
  , eo$1 = "secondary_button_pressed"
  , it = "secondaryButton"
  , fn$1 = I$3(it, at$1)
  , Hi = Q$1(it, ve$1, at$1);
fn$1("mount", () => {
    if (!ve$1()) {
        const xt = x$4() && k$2(it);
        xt && le$1.set(xt),
        ve$1.set(!0)
    }
}
);
fn$1("onClick", xt => w$4(eo$1, xt));
fn$1("offClick", xt => {
    C$6(eo$1, xt)
}
);
Hi("setParams", xt => {
    le$1.set({
        ...le$1(),
        ...Object.fromEntries(Object.entries(xt).filter( ([,as]) => as !== void 0))
    }),
    P$7(it, le$1());
    const Cn = _n$1();
    Cn.text && _$6(at$1, {
        color: Cn.backgroundColor,
        has_shine_effect: Cn.hasShineEffect,
        is_active: Cn.isEnabled,
        is_progress_visible: Cn.isLoaderVisible,
        is_visible: Cn.isVisible,
        position: Cn.position,
        text: Cn.text,
        text_color: Cn.textColor
    })
}
);
const ct$1 = "web_app_setup_settings_button"
  , to$1 = "settings_button_pressed"
  , ut = "settingsButton"
  , Ot = c$9(!1)
  , Ae$2 = c$9(!1)
  , mn$1 = I$3(ut, ct$1)
  , no$1 = Q$1(ut, Ae$2, ct$1);
no$1("hide", () => {
    hn$1(!1)
}
);
mn$1("mount", () => {
    Ae$2() || (hn$1(x$4() && k$2(ut) || !1),
    Ae$2.set(!0))
}
);
function hn$1(xt) {
    xt !== Ot() && (_$6(ct$1, {
        is_visible: xt
    }),
    P$7(ut, xt),
    Ot.set(xt))
}
mn$1("onClick", xt => w$4(to$1, xt));
mn$1("offClick", xt => {
    C$6(to$1, xt)
}
);
no$1("show", () => {
    hn$1(!0)
}
);
const pt$1 = "web_app_setup_swipe_behavior"
  , lt$1 = "swipeBehavior"
  , Ce$2 = c$9(!1)
  , Dt$1 = c$9(!0)
  , sc = I$3(lt$1, pt$1)
  , ro = Q$1(lt$1, Ce$2, pt$1);
ro("disableVertical", () => {
    bn$1(!1)
}
);
ro("enableVertical", () => {
    bn$1(!0)
}
);
sc("mount", () => {
    Ce$2() || (bn$1(x$4() && k$2(lt$1) || !1, !0),
    Ce$2.set(!0))
}
);
function bn$1(xt, Cn) {
    (xt !== Dt$1() || Cn) && (_$6(pt$1, {
        allow_vertical_swipe: xt
    }),
    P$7(lt$1, xt),
    Dt$1.set(xt))
}
const su = Object.freeze(Object.defineProperty({
    __proto__: null,
    accentTextColor: $a,
    backgroundColor: nn,
    bindCssVars: hi,
    bottomBarBgColor: Nr,
    buttonColor: rn,
    buttonTextColor: Vr$1,
    destructiveTextColor: Fa,
    headerBackgroundColor: Ha,
    hintColor: Wa,
    isCssVarsBound: je$3,
    isDark: za,
    isMounted: be$3,
    linkColor: Ga,
    mount: $r,
    secondaryBackgroundColor: He$1,
    sectionBackgroundColor: Ja,
    sectionHeaderTextColor: Ya,
    sectionSeparatorColor: Qa,
    state: $$3,
    subtitleTextColor: Ka,
    textColor: Za,
    unmount: bi
}, Symbol.toStringTag, {
    value: "Module"
}))
  , se$1 = "viewport"
  , oo = "web_app_request_fullscreen"
  , pc = "fullscreen_failed"
  , gn$1 = "fullscreen_changed"
  , so = "safe_area_changed"
  , ao$1 = "content_safe_area_changed"
  , io = "viewport_changed"
  , jn$1 = "web_app_request_safe_area"
  , Ln$1 = "web_app_request_content_safe_area"
  , Vn$1 = {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
};
function wt$2(xt) {
    return Math.max(xt, 0)
}
const de$2 = c$9({
    contentSafeAreaInsets: Vn$1,
    height: 0,
    isExpanded: !1,
    isFullscreen: !1,
    safeAreaInsets: Vn$1,
    stableHeight: 0,
    width: 0
});
function Z$2(xt) {
    return d$5( () => de$2()[xt])
}
function ae$1(xt) {
    const {height: Cn, stableHeight: as, width: cs} = xt;
    de$2.set({
        ...de$2(),
        ...jr({
            ...xt,
            height: Cn ? wt$2(Cn) : void 0,
            width: cs ? wt$2(cs) : void 0,
            stableHeight: as ? wt$2(as) : void 0
        })
    }),
    P$7(se$1, de$2())
}
function lc() {
    return k$2(se$1)
}
const co$1 = Z$2("isFullscreen")
  , wn$1 = c$9()
  , dc = d$5( () => !!wn$1())
  , uo$1 = c$9()
  , Ie$2 = c$9(!1)
  , _c$1 = d$5( () => !!dt())
  , po$1 = c$9(void 0)
  , dt = c$9()
  , fc = Q$1(se$1, Ie$2, oo);
function lo$1(xt, Cn) {
    return fc(xt, Be$2(as => E$4(Cn, [gn$1, pc], as).then(cs => {
        if ("error"in cs) {
            if (cs.error === "ALREADY_FULLSCREEN")
                return !0;
            throw new p$6(Hs,"Fullscreen request failed",cs.error)
        }
        return cs.is_fullscreen
    }
    ).then(cs => {
        cs !== co$1() && ae$1({
            isFullscreen: cs
        })
    }
    ), () => new p$6(F$4,"Fullscreen mode change is already being requested"), wn$1, uo$1))
}
const mc = lo$1("requestFullscreen", oo)
  , hc = lo$1("exitFullscreen", "web_app_exit_fullscreen")
  , _o$1 = U$4(se$1)
  , bc = Ze$1(se$1, Ie$2);
function _t$2(xt) {
    return d$5( () => yn$1()[xt])
}
const yn$1 = Z$2("safeAreaInsets")
  , fo$1 = _t$2("bottom")
  , mo$1 = _t$2("left")
  , ho$1 = _t$2("right")
  , bo$1 = _t$2("top");
function ft(xt) {
    return d$5( () => Sn$1()[xt])
}
const Sn$1 = Z$2("contentSafeAreaInsets")
  , go$1 = ft("bottom")
  , wo$1 = ft("left")
  , yo$1 = ft("right")
  , So$1 = ft("top")
  , gc = h$4("requestContentSafeAreaInsets", xt => E$4(Ln$1, "content_safe_area_changed", xt), {
    isSupported: Ln$1
})
  , wc = h$4("requestSafeAreaInsets", xt => E$4(jn$1, "safe_area_changed", xt), {
    isSupported: jn$1
});
function yc(xt) {
    return E$4("web_app_request_viewport", "viewport_changed", xt).then(Cn => ({
        height: Cn.height,
        width: Cn.width,
        isExpanded: Cn.is_expanded,
        isStable: Cn.is_state_stable
    }))
}
const Eo$1 = xt => {
    const {height: Cn} = xt;
    ae$1({
        isExpanded: xt.is_expanded,
        height: Cn,
        width: xt.width,
        stableHeight: xt.is_state_stable ? Cn : void 0
    })
}
  , vo$1 = xt => {
    ae$1({
        isFullscreen: xt.is_fullscreen
    })
}
  , Ao$1 = xt => {
    ae$1({
        safeAreaInsets: xt
    })
}
  , Co$1 = xt => {
    ae$1({
        contentSafeAreaInsets: xt
    })
}
  , Sc = _o$1("mount", Rr(se$1, xt => b$3.resolve().then(async () => {
    const Cn = x$4() && lc();
    if (Cn)
        return Cn;
    const [as,cs] = await b$3.all([wc.ifAvailable(xt) || yn$1(), gc.ifAvailable(xt) || Sn$1()])
      , Cs = Y$2()
      , Ls = {
        contentSafeAreaInsets: cs,
        isFullscreen: !!Cs.fullscreen,
        safeAreaInsets: as
    };
    if (["macos", "tdesktop", "unigram", "webk", "weba", "web"].includes(Cs.platform)) {
        const Vs = window;
        return {
            ...Ls,
            height: Vs.innerHeight,
            isExpanded: !0,
            stableHeight: Vs.innerHeight,
            width: Vs.innerWidth
        }
    }
    return yc(xt).then(Vs => ({
        ...Ls,
        height: Vs.height,
        isExpanded: Vs.isExpanded,
        stableHeight: Vs.isStable ? Vs.height : 0,
        width: Vs.width
    }))
}
), xt => {
    w$4(io, Eo$1),
    w$4(gn$1, vo$1),
    w$4(so, Ao$1),
    w$4(ao$1, Co$1),
    ae$1(xt)
}
, Ie$2, dt, po$1));
function Ec() {
    const xt = dt();
    xt && xt.cancel(),
    C$6(io, Eo$1),
    C$6(gn$1, vo$1),
    C$6(so, Ao$1),
    C$6(ao$1, Co$1),
    Ie$2.set(!1)
}
const qe$1 = c$9(!1)
  , En$1 = Z$2("height")
  , vn$1 = Z$2("stableHeight")
  , Ro$1 = Z$2("width")
  , vc = bc("bindCssVars", xt => {
    qe$1() && an$1(),
    xt || (xt = as => `--tg-viewport-${Lt$2(as)}`);
    const Cn = [["height", En$1], ["stableHeight", vn$1], ["width", Ro$1], ["safeAreaInsetTop", bo$1], ["safeAreaInsetBottom", fo$1], ["safeAreaInsetLeft", mo$1], ["safeAreaInsetRight", ho$1], ["contentSafeAreaInsetTop", So$1], ["contentSafeAreaInsetBottom", go$1], ["contentSafeAreaInsetLeft", wo$1], ["contentSafeAreaInsetRight", yo$1]].reduce( (as, [cs,Cs]) => {
        const Ls = xt(cs);
        if (Ls) {
            const Vs = () => {
                Vt$2(Ls, `${Cs()}px`)
            }
            ;
            as.push([Vs, Cs.sub(Vs), Ls])
        }
        return as
    }
    , []);
    return Cn.forEach(as => {
        as[0]()
    }
    ),
    qe$1.set(!0),
    () => {
        Cn.forEach(as => {
            as[1](),
            Nt$1(as[2])
        }
        ),
        qe$1.set(!1)
    }
}
)
  , Ac = _o$1("expand", () => {
    _$6("web_app_expand")
}
)
  , Cc = Z$2("isExpanded")
  , Rc = d$5( () => En$1() === vn$1())
  , au = Object.freeze(Object.defineProperty({
    __proto__: null,
    bindCssVars: vc,
    changeFullscreenError: uo$1,
    changeFullscreenPromise: wn$1,
    contentSafeAreaInsetBottom: go$1,
    contentSafeAreaInsetLeft: wo$1,
    contentSafeAreaInsetRight: yo$1,
    contentSafeAreaInsetTop: So$1,
    contentSafeAreaInsets: Sn$1,
    exitFullscreen: hc,
    expand: Ac,
    height: En$1,
    isChangingFullscreen: dc,
    isCssVarsBound: qe$1,
    isExpanded: Cc,
    isFullscreen: co$1,
    isMounted: Ie$2,
    isMounting: _c$1,
    isStable: Rc,
    mount: Sc,
    mountError: po$1,
    mountPromise: dt,
    requestFullscreen: mc,
    safeAreaInsetBottom: fo$1,
    safeAreaInsetLeft: mo$1,
    safeAreaInsetRight: ho$1,
    safeAreaInsetTop: bo$1,
    safeAreaInsets: yn$1,
    stableHeight: vn$1,
    state: de$2,
    unmount: Ec,
    width: Ro$1
}, Symbol.toStringTag, {
    value: "Module"
}))
  , kc = U$4();
kc("openLink", (xt, Cn) => {
    if (typeof xt == "string")
        try {
            xt = new URL(xt)
        } catch (as) {
            throw new p$6(Ht$2,`"${xt.toString()}" is invalid URL`,as)
        }
    Cn || (Cn = {}),
    _$6("web_app_open_link", {
        url: xt.toString(),
        try_browser: Cn.tryBrowser,
        try_instant_view: Cn.tryInstantView
    })
}
);
const Un$1 = "web_app_open_tg_link"
  , Ic = U$4()
  , Oc = Ic("openTelegramLink", xt => {
    const Cn = xt.toString();
    if (!Cn.match(/^https:\/\/t.me\/.+/))
        throw new p$6(Ht$2,`"${Cn}" is invalid URL`);
    if (!J$4(Un$1, V$3())) {
        window.location.href = Cn;
        return
    }
    xt = new URL(xt),
    _$6(Un$1, {
        path_full: xt.pathname + xt.search
    })
}
)
  , Dc = U$4();
Dc("shareURL", (xt, Cn) => {
    Oc("https://t.me/share/url?" + new URLSearchParams({
        url: xt,
        text: Cn || ""
    }).toString().replace(/\+/g, "%20"))
}
);
function Bu(xt) {
    Ms(xt),
    Rs();
    const [Cn,as] = ne$1(w$4("reload_iframe", () => {
        _$6("iframe_will_reload"),
        window.location.reload()
    }
    ), Ts)
      , {acceptCustomStyles: cs=!0} = {};
    if (cs) {
        const Cs = document.createElement("style");
        Cs.id = "telegram-custom-styles",
        document.head.appendChild(Cs),
        Cn(w$4("set_custom_style", Ls => {
            Cs.innerHTML = Ls
        }
        ), () => {
            document.head.removeChild(Cs)
        }
        )
    }
    return _$6("iframe_ready", {
        reload_supported: !0
    }),
    as
}
function Pu() {
    return reactExports.useMemo(Y$2, [])
}
function ku(xt) {
    return reactExports.useSyncExternalStore(Cn => xt.sub(Cn), xt)
}
const isString$3 = xt => typeof xt == "string"
  , defer = () => {
    let xt, Cn;
    const as = new Promise( (cs, Cs) => {
        xt = cs,
        Cn = Cs
    }
    );
    return as.resolve = xt,
    as.reject = Cn,
    as
}
  , makeString = xt => xt == null ? "" : "" + xt
  , copy = (xt, Cn, as) => {
    xt.forEach(cs => {
        Cn[cs] && (as[cs] = Cn[cs])
    }
    )
}
  , lastOfPathSeparatorRegExp = /###/g
  , cleanKey = xt => xt && xt.indexOf("###") > -1 ? xt.replace(lastOfPathSeparatorRegExp, ".") : xt
  , canNotTraverseDeeper = xt => !xt || isString$3(xt)
  , getLastOfPath = (xt, Cn, as) => {
    const cs = isString$3(Cn) ? Cn.split(".") : Cn;
    let Cs = 0;
    for (; Cs < cs.length - 1; ) {
        if (canNotTraverseDeeper(xt))
            return {};
        const Ls = cleanKey(cs[Cs]);
        !xt[Ls] && as && (xt[Ls] = new as),
        Object.prototype.hasOwnProperty.call(xt, Ls) ? xt = xt[Ls] : xt = {},
        ++Cs
    }
    return canNotTraverseDeeper(xt) ? {} : {
        obj: xt,
        k: cleanKey(cs[Cs])
    }
}
  , setPath = (xt, Cn, as) => {
    const {obj: cs, k: Cs} = getLastOfPath(xt, Cn, Object);
    if (cs !== void 0 || Cn.length === 1) {
        cs[Cs] = as;
        return
    }
    let Ls = Cn[Cn.length - 1]
      , Vs = Cn.slice(0, Cn.length - 1)
      , Ws = getLastOfPath(xt, Vs, Object);
    for (; Ws.obj === void 0 && Vs.length; )
        Ls = `${Vs[Vs.length - 1]}.${Ls}`,
        Vs = Vs.slice(0, Vs.length - 1),
        Ws = getLastOfPath(xt, Vs, Object),
        Ws && Ws.obj && typeof Ws.obj[`${Ws.k}.${Ls}`] < "u" && (Ws.obj = void 0);
    Ws.obj[`${Ws.k}.${Ls}`] = as
}
  , pushPath = (xt, Cn, as, cs) => {
    const {obj: Cs, k: Ls} = getLastOfPath(xt, Cn, Object);
    Cs[Ls] = Cs[Ls] || [],
    Cs[Ls].push(as)
}
  , getPath = (xt, Cn) => {
    const {obj: as, k: cs} = getLastOfPath(xt, Cn);
    if (as)
        return as[cs]
}
  , getPathWithDefaults = (xt, Cn, as) => {
    const cs = getPath(xt, as);
    return cs !== void 0 ? cs : getPath(Cn, as)
}
  , deepExtend = (xt, Cn, as) => {
    for (const cs in Cn)
        cs !== "__proto__" && cs !== "constructor" && (cs in xt ? isString$3(xt[cs]) || xt[cs]instanceof String || isString$3(Cn[cs]) || Cn[cs]instanceof String ? as && (xt[cs] = Cn[cs]) : deepExtend(xt[cs], Cn[cs], as) : xt[cs] = Cn[cs]);
    return xt
}
  , regexEscape = xt => xt.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var _entityMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "/": "&#x2F;"
};
const escape$1 = xt => isString$3(xt) ? xt.replace(/[&<>"'\/]/g, Cn => _entityMap[Cn]) : xt;
class RegExpCache {
    constructor(Cn) {
        this.capacity = Cn,
        this.regExpMap = new Map,
        this.regExpQueue = []
    }
    getRegExp(Cn) {
        const as = this.regExpMap.get(Cn);
        if (as !== void 0)
            return as;
        const cs = new RegExp(Cn);
        return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()),
        this.regExpMap.set(Cn, cs),
        this.regExpQueue.push(Cn),
        cs
    }
}
const chars = [" ", ",", "?", "!", ";"]
  , looksLikeObjectPathRegExpCache = new RegExpCache(20)
  , looksLikeObjectPath = (xt, Cn, as) => {
    Cn = Cn || "",
    as = as || "";
    const cs = chars.filter(Vs => Cn.indexOf(Vs) < 0 && as.indexOf(Vs) < 0);
    if (cs.length === 0)
        return !0;
    const Cs = looksLikeObjectPathRegExpCache.getRegExp(`(${cs.map(Vs => Vs === "?" ? "\\?" : Vs).join("|")})`);
    let Ls = !Cs.test(xt);
    if (!Ls) {
        const Vs = xt.indexOf(as);
        Vs > 0 && !Cs.test(xt.substring(0, Vs)) && (Ls = !0)
    }
    return Ls
}
  , deepFind = function(xt, Cn) {
    let as = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
    if (!xt)
        return;
    if (xt[Cn])
        return xt[Cn];
    const cs = Cn.split(as);
    let Cs = xt;
    for (let Ls = 0; Ls < cs.length; ) {
        if (!Cs || typeof Cs != "object")
            return;
        let Vs, Ws = "";
        for (let Xs = Ls; Xs < cs.length; ++Xs)
            if (Xs !== Ls && (Ws += as),
            Ws += cs[Xs],
            Vs = Cs[Ws],
            Vs !== void 0) {
                if (["string", "number", "boolean"].indexOf(typeof Vs) > -1 && Xs < cs.length - 1)
                    continue;
                Ls += Xs - Ls + 1;
                break
            }
        Cs = Vs
    }
    return Cs
}
  , getCleanedCode = xt => xt && xt.replace("_", "-")
  , consoleLogger = {
    type: "logger",
    log(xt) {
        this.output("log", xt)
    },
    warn(xt) {
        this.output("warn", xt)
    },
    error(xt) {
        this.output("error", xt)
    },
    output(xt, Cn) {
        console && console[xt] && console[xt].apply(console, Cn)
    }
};
class Logger {
    constructor(Cn) {
        let as = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.init(Cn, as)
    }
    init(Cn) {
        let as = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.prefix = as.prefix || "i18next:",
        this.logger = Cn || consoleLogger,
        this.options = as,
        this.debug = as.debug
    }
    log() {
        for (var Cn = arguments.length, as = new Array(Cn), cs = 0; cs < Cn; cs++)
            as[cs] = arguments[cs];
        return this.forward(as, "log", "", !0)
    }
    warn() {
        for (var Cn = arguments.length, as = new Array(Cn), cs = 0; cs < Cn; cs++)
            as[cs] = arguments[cs];
        return this.forward(as, "warn", "", !0)
    }
    error() {
        for (var Cn = arguments.length, as = new Array(Cn), cs = 0; cs < Cn; cs++)
            as[cs] = arguments[cs];
        return this.forward(as, "error", "")
    }
    deprecate() {
        for (var Cn = arguments.length, as = new Array(Cn), cs = 0; cs < Cn; cs++)
            as[cs] = arguments[cs];
        return this.forward(as, "warn", "WARNING DEPRECATED: ", !0)
    }
    forward(Cn, as, cs, Cs) {
        return Cs && !this.debug ? null : (isString$3(Cn[0]) && (Cn[0] = `${cs}${this.prefix} ${Cn[0]}`),
        this.logger[as](Cn))
    }
    create(Cn) {
        return new Logger(this.logger,{
            prefix: `${this.prefix}:${Cn}:`,
            ...this.options
        })
    }
    clone(Cn) {
        return Cn = Cn || this.options,
        Cn.prefix = Cn.prefix || this.prefix,
        new Logger(this.logger,Cn)
    }
}
var baseLogger = new Logger;
class EventEmitter {
    constructor() {
        this.observers = {}
    }
    on(Cn, as) {
        return Cn.split(" ").forEach(cs => {
            this.observers[cs] || (this.observers[cs] = new Map);
            const Cs = this.observers[cs].get(as) || 0;
            this.observers[cs].set(as, Cs + 1)
        }
        ),
        this
    }
    off(Cn, as) {
        if (this.observers[Cn]) {
            if (!as) {
                delete this.observers[Cn];
                return
            }
            this.observers[Cn].delete(as)
        }
    }
    emit(Cn) {
        for (var as = arguments.length, cs = new Array(as > 1 ? as - 1 : 0), Cs = 1; Cs < as; Cs++)
            cs[Cs - 1] = arguments[Cs];
        this.observers[Cn] && Array.from(this.observers[Cn].entries()).forEach(Vs => {
            let[Ws,Xs] = Vs;
            for (let ga = 0; ga < Xs; ga++)
                Ws(...cs)
        }
        ),
        this.observers["*"] && Array.from(this.observers["*"].entries()).forEach(Vs => {
            let[Ws,Xs] = Vs;
            for (let ga = 0; ga < Xs; ga++)
                Ws.apply(Ws, [Cn, ...cs])
        }
        )
    }
}
class ResourceStore extends EventEmitter {
    constructor(Cn) {
        let as = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            ns: ["translation"],
            defaultNS: "translation"
        };
        super(),
        this.data = Cn || {},
        this.options = as,
        this.options.keySeparator === void 0 && (this.options.keySeparator = "."),
        this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0)
    }
    addNamespaces(Cn) {
        this.options.ns.indexOf(Cn) < 0 && this.options.ns.push(Cn)
    }
    removeNamespaces(Cn) {
        const as = this.options.ns.indexOf(Cn);
        as > -1 && this.options.ns.splice(as, 1)
    }
    getResource(Cn, as, cs) {
        let Cs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        const Ls = Cs.keySeparator !== void 0 ? Cs.keySeparator : this.options.keySeparator
          , Vs = Cs.ignoreJSONStructure !== void 0 ? Cs.ignoreJSONStructure : this.options.ignoreJSONStructure;
        let Ws;
        Cn.indexOf(".") > -1 ? Ws = Cn.split(".") : (Ws = [Cn, as],
        cs && (Array.isArray(cs) ? Ws.push(...cs) : isString$3(cs) && Ls ? Ws.push(...cs.split(Ls)) : Ws.push(cs)));
        const Xs = getPath(this.data, Ws);
        return !Xs && !as && !cs && Cn.indexOf(".") > -1 && (Cn = Ws[0],
        as = Ws[1],
        cs = Ws.slice(2).join(".")),
        Xs || !Vs || !isString$3(cs) ? Xs : deepFind(this.data && this.data[Cn] && this.data[Cn][as], cs, Ls)
    }
    addResource(Cn, as, cs, Cs) {
        let Ls = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
            silent: !1
        };
        const Vs = Ls.keySeparator !== void 0 ? Ls.keySeparator : this.options.keySeparator;
        let Ws = [Cn, as];
        cs && (Ws = Ws.concat(Vs ? cs.split(Vs) : cs)),
        Cn.indexOf(".") > -1 && (Ws = Cn.split("."),
        Cs = as,
        as = Ws[1]),
        this.addNamespaces(as),
        setPath(this.data, Ws, Cs),
        Ls.silent || this.emit("added", Cn, as, cs, Cs)
    }
    addResources(Cn, as, cs) {
        let Cs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
            silent: !1
        };
        for (const Ls in cs)
            (isString$3(cs[Ls]) || Array.isArray(cs[Ls])) && this.addResource(Cn, as, Ls, cs[Ls], {
                silent: !0
            });
        Cs.silent || this.emit("added", Cn, as, cs)
    }
    addResourceBundle(Cn, as, cs, Cs, Ls) {
        let Vs = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
            silent: !1,
            skipCopy: !1
        }
          , Ws = [Cn, as];
        Cn.indexOf(".") > -1 && (Ws = Cn.split("."),
        Cs = cs,
        cs = as,
        as = Ws[1]),
        this.addNamespaces(as);
        let Xs = getPath(this.data, Ws) || {};
        Vs.skipCopy || (cs = JSON.parse(JSON.stringify(cs))),
        Cs ? deepExtend(Xs, cs, Ls) : Xs = {
            ...Xs,
            ...cs
        },
        setPath(this.data, Ws, Xs),
        Vs.silent || this.emit("added", Cn, as, cs)
    }
    removeResourceBundle(Cn, as) {
        this.hasResourceBundle(Cn, as) && delete this.data[Cn][as],
        this.removeNamespaces(as),
        this.emit("removed", Cn, as)
    }
    hasResourceBundle(Cn, as) {
        return this.getResource(Cn, as) !== void 0
    }
    getResourceBundle(Cn, as) {
        return as || (as = this.options.defaultNS),
        this.options.compatibilityAPI === "v1" ? {
            ...this.getResource(Cn, as)
        } : this.getResource(Cn, as)
    }
    getDataByLanguage(Cn) {
        return this.data[Cn]
    }
    hasLanguageSomeTranslations(Cn) {
        const as = this.getDataByLanguage(Cn);
        return !!(as && Object.keys(as) || []).find(Cs => as[Cs] && Object.keys(as[Cs]).length > 0)
    }
    toJSON() {
        return this.data
    }
}
var postProcessor = {
    processors: {},
    addPostProcessor(xt) {
        this.processors[xt.name] = xt
    },
    handle(xt, Cn, as, cs, Cs) {
        return xt.forEach(Ls => {
            this.processors[Ls] && (Cn = this.processors[Ls].process(Cn, as, cs, Cs))
        }
        ),
        Cn
    }
};
const checkedLoadedFor = {};
class Translator extends EventEmitter {
    constructor(Cn) {
        let as = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        super(),
        copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], Cn, this),
        this.options = as,
        this.options.keySeparator === void 0 && (this.options.keySeparator = "."),
        this.logger = baseLogger.create("translator")
    }
    changeLanguage(Cn) {
        Cn && (this.language = Cn)
    }
    exists(Cn) {
        let as = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            interpolation: {}
        };
        if (Cn == null)
            return !1;
        const cs = this.resolve(Cn, as);
        return cs && cs.res !== void 0
    }
    extractFromKey(Cn, as) {
        let cs = as.nsSeparator !== void 0 ? as.nsSeparator : this.options.nsSeparator;
        cs === void 0 && (cs = ":");
        const Cs = as.keySeparator !== void 0 ? as.keySeparator : this.options.keySeparator;
        let Ls = as.ns || this.options.defaultNS || [];
        const Vs = cs && Cn.indexOf(cs) > -1
          , Ws = !this.options.userDefinedKeySeparator && !as.keySeparator && !this.options.userDefinedNsSeparator && !as.nsSeparator && !looksLikeObjectPath(Cn, cs, Cs);
        if (Vs && !Ws) {
            const Xs = Cn.match(this.interpolator.nestingRegexp);
            if (Xs && Xs.length > 0)
                return {
                    key: Cn,
                    namespaces: isString$3(Ls) ? [Ls] : Ls
                };
            const ga = Cn.split(cs);
            (cs !== Cs || cs === Cs && this.options.ns.indexOf(ga[0]) > -1) && (Ls = ga.shift()),
            Cn = ga.join(Cs)
        }
        return {
            key: Cn,
            namespaces: isString$3(Ls) ? [Ls] : Ls
        }
    }
    translate(Cn, as, cs) {
        if (typeof as != "object" && this.options.overloadTranslationOptionHandler && (as = this.options.overloadTranslationOptionHandler(arguments)),
        typeof as == "object" && (as = {
            ...as
        }),
        as || (as = {}),
        Cn == null)
            return "";
        Array.isArray(Cn) || (Cn = [String(Cn)]);
        const Cs = as.returnDetails !== void 0 ? as.returnDetails : this.options.returnDetails
          , Ls = as.keySeparator !== void 0 ? as.keySeparator : this.options.keySeparator
          , {key: Vs, namespaces: Ws} = this.extractFromKey(Cn[Cn.length - 1], as)
          , Xs = Ws[Ws.length - 1]
          , ga = as.lng || this.language
          , ba = as.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
        if (ga && ga.toLowerCase() === "cimode") {
            if (ba) {
                const Rl = as.nsSeparator || this.options.nsSeparator;
                return Cs ? {
                    res: `${Xs}${Rl}${Vs}`,
                    usedKey: Vs,
                    exactUsedKey: Vs,
                    usedLng: ga,
                    usedNS: Xs,
                    usedParams: this.getUsedParamsDetails(as)
                } : `${Xs}${Rl}${Vs}`
            }
            return Cs ? {
                res: Vs,
                usedKey: Vs,
                exactUsedKey: Vs,
                usedLng: ga,
                usedNS: Xs,
                usedParams: this.getUsedParamsDetails(as)
            } : Vs
        }
        const yl = this.resolve(Cn, as);
        let xl = yl && yl.res;
        const wl = yl && yl.usedKey || Vs
          , _l = yl && yl.exactUsedKey || Vs
          , El = Object.prototype.toString.apply(xl)
          , Cl = ["[object Number]", "[object Function]", "[object RegExp]"]
          , $l = as.joinArrays !== void 0 ? as.joinArrays : this.options.joinArrays
          , Sl = !this.i18nFormat || this.i18nFormat.handleAsObject
          , Tl = !isString$3(xl) && typeof xl != "boolean" && typeof xl != "number";
        if (Sl && xl && Tl && Cl.indexOf(El) < 0 && !(isString$3($l) && Array.isArray(xl))) {
            if (!as.returnObjects && !this.options.returnObjects) {
                this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
                const Rl = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(wl, xl, {
                    ...as,
                    ns: Ws
                }) : `key '${Vs} (${this.language})' returned an object instead of string.`;
                return Cs ? (yl.res = Rl,
                yl.usedParams = this.getUsedParamsDetails(as),
                yl) : Rl
            }
            if (Ls) {
                const Rl = Array.isArray(xl)
                  , Il = Rl ? [] : {}
                  , Ml = Rl ? _l : wl;
                for (const Nl in xl)
                    if (Object.prototype.hasOwnProperty.call(xl, Nl)) {
                        const Ll = `${Ml}${Ls}${Nl}`;
                        Il[Nl] = this.translate(Ll, {
                            ...as,
                            joinArrays: !1,
                            ns: Ws
                        }),
                        Il[Nl] === Ll && (Il[Nl] = xl[Nl])
                    }
                xl = Il
            }
        } else if (Sl && isString$3($l) && Array.isArray(xl))
            xl = xl.join($l),
            xl && (xl = this.extendTranslation(xl, Cn, as, cs));
        else {
            let Rl = !1
              , Il = !1;
            const Ml = as.count !== void 0 && !isString$3(as.count)
              , Nl = Translator.hasDefaultValue(as)
              , Ll = Ml ? this.pluralResolver.getSuffix(ga, as.count, as) : ""
              , Fl = as.ordinal && Ml ? this.pluralResolver.getSuffix(ga, as.count, {
                ordinal: !1
            }) : ""
              , Ul = Ml && !as.ordinal && as.count === 0 && this.pluralResolver.shouldUseIntlApi()
              , Dl = Ul && as[`defaultValue${this.options.pluralSeparator}zero`] || as[`defaultValue${Ll}`] || as[`defaultValue${Fl}`] || as.defaultValue;
            !this.isValidLookup(xl) && Nl && (Rl = !0,
            xl = Dl),
            this.isValidLookup(xl) || (Il = !0,
            xl = Vs);
            const Gl = (as.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && Il ? void 0 : xl
              , Wl = Nl && Dl !== xl && this.options.updateMissing;
            if (Il || Rl || Wl) {
                if (this.logger.log(Wl ? "updateKey" : "missingKey", ga, Xs, Vs, Wl ? Dl : xl),
                Ls) {
                    const zl = this.resolve(Vs, {
                        ...as,
                        keySeparator: !1
                    });
                    zl && zl.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")
                }
                let Ql = [];
                const cu = this.languageUtils.getFallbackCodes(this.options.fallbackLng, as.lng || this.language);
                if (this.options.saveMissingTo === "fallback" && cu && cu[0])
                    for (let zl = 0; zl < cu.length; zl++)
                        Ql.push(cu[zl]);
                else
                    this.options.saveMissingTo === "all" ? Ql = this.languageUtils.toResolveHierarchy(as.lng || this.language) : Ql.push(as.lng || this.language);
                const pu = (zl, Yl, lu) => {
                    const mu = Nl && lu !== xl ? lu : Gl;
                    this.options.missingKeyHandler ? this.options.missingKeyHandler(zl, Xs, Yl, mu, Wl, as) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(zl, Xs, Yl, mu, Wl, as),
                    this.emit("missingKey", zl, Xs, Yl, xl)
                }
                ;
                this.options.saveMissing && (this.options.saveMissingPlurals && Ml ? Ql.forEach(zl => {
                    const Yl = this.pluralResolver.getSuffixes(zl, as);
                    Ul && as[`defaultValue${this.options.pluralSeparator}zero`] && Yl.indexOf(`${this.options.pluralSeparator}zero`) < 0 && Yl.push(`${this.options.pluralSeparator}zero`),
                    Yl.forEach(lu => {
                        pu([zl], Vs + lu, as[`defaultValue${lu}`] || Dl)
                    }
                    )
                }
                ) : pu(Ql, Vs, Dl))
            }
            xl = this.extendTranslation(xl, Cn, as, yl, cs),
            Il && xl === Vs && this.options.appendNamespaceToMissingKey && (xl = `${Xs}:${Vs}`),
            (Il || Rl) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? xl = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${Xs}:${Vs}` : Vs, Rl ? xl : void 0) : xl = this.options.parseMissingKeyHandler(xl))
        }
        return Cs ? (yl.res = xl,
        yl.usedParams = this.getUsedParamsDetails(as),
        yl) : xl
    }
    extendTranslation(Cn, as, cs, Cs, Ls) {
        var Vs = this;
        if (this.i18nFormat && this.i18nFormat.parse)
            Cn = this.i18nFormat.parse(Cn, {
                ...this.options.interpolation.defaultVariables,
                ...cs
            }, cs.lng || this.language || Cs.usedLng, Cs.usedNS, Cs.usedKey, {
                resolved: Cs
            });
        else if (!cs.skipInterpolation) {
            cs.interpolation && this.interpolator.init({
                ...cs,
                interpolation: {
                    ...this.options.interpolation,
                    ...cs.interpolation
                }
            });
            const ga = isString$3(Cn) && (cs && cs.interpolation && cs.interpolation.skipOnVariables !== void 0 ? cs.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
            let ba;
            if (ga) {
                const xl = Cn.match(this.interpolator.nestingRegexp);
                ba = xl && xl.length
            }
            let yl = cs.replace && !isString$3(cs.replace) ? cs.replace : cs;
            if (this.options.interpolation.defaultVariables && (yl = {
                ...this.options.interpolation.defaultVariables,
                ...yl
            }),
            Cn = this.interpolator.interpolate(Cn, yl, cs.lng || this.language || Cs.usedLng, cs),
            ga) {
                const xl = Cn.match(this.interpolator.nestingRegexp)
                  , wl = xl && xl.length;
                ba < wl && (cs.nest = !1)
            }
            !cs.lng && this.options.compatibilityAPI !== "v1" && Cs && Cs.res && (cs.lng = this.language || Cs.usedLng),
            cs.nest !== !1 && (Cn = this.interpolator.nest(Cn, function() {
                for (var xl = arguments.length, wl = new Array(xl), _l = 0; _l < xl; _l++)
                    wl[_l] = arguments[_l];
                return Ls && Ls[0] === wl[0] && !cs.context ? (Vs.logger.warn(`It seems you are nesting recursively key: ${wl[0]} in key: ${as[0]}`),
                null) : Vs.translate(...wl, as)
            }, cs)),
            cs.interpolation && this.interpolator.reset()
        }
        const Ws = cs.postProcess || this.options.postProcess
          , Xs = isString$3(Ws) ? [Ws] : Ws;
        return Cn != null && Xs && Xs.length && cs.applyPostProcessor !== !1 && (Cn = postProcessor.handle(Xs, Cn, as, this.options && this.options.postProcessPassResolved ? {
            i18nResolved: {
                ...Cs,
                usedParams: this.getUsedParamsDetails(cs)
            },
            ...cs
        } : cs, this)),
        Cn
    }
    resolve(Cn) {
        let as = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, cs, Cs, Ls, Vs, Ws;
        return isString$3(Cn) && (Cn = [Cn]),
        Cn.forEach(Xs => {
            if (this.isValidLookup(cs))
                return;
            const ga = this.extractFromKey(Xs, as)
              , ba = ga.key;
            Cs = ba;
            let yl = ga.namespaces;
            this.options.fallbackNS && (yl = yl.concat(this.options.fallbackNS));
            const xl = as.count !== void 0 && !isString$3(as.count)
              , wl = xl && !as.ordinal && as.count === 0 && this.pluralResolver.shouldUseIntlApi()
              , _l = as.context !== void 0 && (isString$3(as.context) || typeof as.context == "number") && as.context !== ""
              , El = as.lngs ? as.lngs : this.languageUtils.toResolveHierarchy(as.lng || this.language, as.fallbackLng);
            yl.forEach(Cl => {
                this.isValidLookup(cs) || (Ws = Cl,
                !checkedLoadedFor[`${El[0]}-${Cl}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(Ws) && (checkedLoadedFor[`${El[0]}-${Cl}`] = !0,
                this.logger.warn(`key "${Cs}" for languages "${El.join(", ")}" won't get resolved as namespace "${Ws}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")),
                El.forEach($l => {
                    if (this.isValidLookup(cs))
                        return;
                    Vs = $l;
                    const Sl = [ba];
                    if (this.i18nFormat && this.i18nFormat.addLookupKeys)
                        this.i18nFormat.addLookupKeys(Sl, ba, $l, Cl, as);
                    else {
                        let Rl;
                        xl && (Rl = this.pluralResolver.getSuffix($l, as.count, as));
                        const Il = `${this.options.pluralSeparator}zero`
                          , Ml = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
                        if (xl && (Sl.push(ba + Rl),
                        as.ordinal && Rl.indexOf(Ml) === 0 && Sl.push(ba + Rl.replace(Ml, this.options.pluralSeparator)),
                        wl && Sl.push(ba + Il)),
                        _l) {
                            const Nl = `${ba}${this.options.contextSeparator}${as.context}`;
                            Sl.push(Nl),
                            xl && (Sl.push(Nl + Rl),
                            as.ordinal && Rl.indexOf(Ml) === 0 && Sl.push(Nl + Rl.replace(Ml, this.options.pluralSeparator)),
                            wl && Sl.push(Nl + Il))
                        }
                    }
                    let Tl;
                    for (; Tl = Sl.pop(); )
                        this.isValidLookup(cs) || (Ls = Tl,
                        cs = this.getResource($l, Cl, Tl, as))
                }
                ))
            }
            )
        }
        ),
        {
            res: cs,
            usedKey: Cs,
            exactUsedKey: Ls,
            usedLng: Vs,
            usedNS: Ws
        }
    }
    isValidLookup(Cn) {
        return Cn !== void 0 && !(!this.options.returnNull && Cn === null) && !(!this.options.returnEmptyString && Cn === "")
    }
    getResource(Cn, as, cs) {
        let Cs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(Cn, as, cs, Cs) : this.resourceStore.getResource(Cn, as, cs, Cs)
    }
    getUsedParamsDetails() {
        let Cn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const as = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"]
          , cs = Cn.replace && !isString$3(Cn.replace);
        let Cs = cs ? Cn.replace : Cn;
        if (cs && typeof Cn.count < "u" && (Cs.count = Cn.count),
        this.options.interpolation.defaultVariables && (Cs = {
            ...this.options.interpolation.defaultVariables,
            ...Cs
        }),
        !cs) {
            Cs = {
                ...Cs
            };
            for (const Ls of as)
                delete Cs[Ls]
        }
        return Cs
    }
    static hasDefaultValue(Cn) {
        const as = "defaultValue";
        for (const cs in Cn)
            if (Object.prototype.hasOwnProperty.call(Cn, cs) && as === cs.substring(0, as.length) && Cn[cs] !== void 0)
                return !0;
        return !1
    }
}
const capitalize$1 = xt => xt.charAt(0).toUpperCase() + xt.slice(1);
class LanguageUtil {
    constructor(Cn) {
        this.options = Cn,
        this.supportedLngs = this.options.supportedLngs || !1,
        this.logger = baseLogger.create("languageUtils")
    }
    getScriptPartFromCode(Cn) {
        if (Cn = getCleanedCode(Cn),
        !Cn || Cn.indexOf("-") < 0)
            return null;
        const as = Cn.split("-");
        return as.length === 2 || (as.pop(),
        as[as.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(as.join("-"))
    }
    getLanguagePartFromCode(Cn) {
        if (Cn = getCleanedCode(Cn),
        !Cn || Cn.indexOf("-") < 0)
            return Cn;
        const as = Cn.split("-");
        return this.formatLanguageCode(as[0])
    }
    formatLanguageCode(Cn) {
        if (isString$3(Cn) && Cn.indexOf("-") > -1) {
            if (typeof Intl < "u" && typeof Intl.getCanonicalLocales < "u")
                try {
                    let Cs = Intl.getCanonicalLocales(Cn)[0];
                    if (Cs && this.options.lowerCaseLng && (Cs = Cs.toLowerCase()),
                    Cs)
                        return Cs
                } catch {}
            const as = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
            let cs = Cn.split("-");
            return this.options.lowerCaseLng ? cs = cs.map(Cs => Cs.toLowerCase()) : cs.length === 2 ? (cs[0] = cs[0].toLowerCase(),
            cs[1] = cs[1].toUpperCase(),
            as.indexOf(cs[1].toLowerCase()) > -1 && (cs[1] = capitalize$1(cs[1].toLowerCase()))) : cs.length === 3 && (cs[0] = cs[0].toLowerCase(),
            cs[1].length === 2 && (cs[1] = cs[1].toUpperCase()),
            cs[0] !== "sgn" && cs[2].length === 2 && (cs[2] = cs[2].toUpperCase()),
            as.indexOf(cs[1].toLowerCase()) > -1 && (cs[1] = capitalize$1(cs[1].toLowerCase())),
            as.indexOf(cs[2].toLowerCase()) > -1 && (cs[2] = capitalize$1(cs[2].toLowerCase()))),
            cs.join("-")
        }
        return this.options.cleanCode || this.options.lowerCaseLng ? Cn.toLowerCase() : Cn
    }
    isSupportedCode(Cn) {
        return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (Cn = this.getLanguagePartFromCode(Cn)),
        !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(Cn) > -1
    }
    getBestMatchFromCodes(Cn) {
        if (!Cn)
            return null;
        let as;
        return Cn.forEach(cs => {
            if (as)
                return;
            const Cs = this.formatLanguageCode(cs);
            (!this.options.supportedLngs || this.isSupportedCode(Cs)) && (as = Cs)
        }
        ),
        !as && this.options.supportedLngs && Cn.forEach(cs => {
            if (as)
                return;
            const Cs = this.getLanguagePartFromCode(cs);
            if (this.isSupportedCode(Cs))
                return as = Cs;
            as = this.options.supportedLngs.find(Ls => {
                if (Ls === Cs)
                    return Ls;
                if (!(Ls.indexOf("-") < 0 && Cs.indexOf("-") < 0) && (Ls.indexOf("-") > 0 && Cs.indexOf("-") < 0 && Ls.substring(0, Ls.indexOf("-")) === Cs || Ls.indexOf(Cs) === 0 && Cs.length > 1))
                    return Ls
            }
            )
        }
        ),
        as || (as = this.getFallbackCodes(this.options.fallbackLng)[0]),
        as
    }
    getFallbackCodes(Cn, as) {
        if (!Cn)
            return [];
        if (typeof Cn == "function" && (Cn = Cn(as)),
        isString$3(Cn) && (Cn = [Cn]),
        Array.isArray(Cn))
            return Cn;
        if (!as)
            return Cn.default || [];
        let cs = Cn[as];
        return cs || (cs = Cn[this.getScriptPartFromCode(as)]),
        cs || (cs = Cn[this.formatLanguageCode(as)]),
        cs || (cs = Cn[this.getLanguagePartFromCode(as)]),
        cs || (cs = Cn.default),
        cs || []
    }
    toResolveHierarchy(Cn, as) {
        const cs = this.getFallbackCodes(as || this.options.fallbackLng || [], Cn)
          , Cs = []
          , Ls = Vs => {
            Vs && (this.isSupportedCode(Vs) ? Cs.push(Vs) : this.logger.warn(`rejecting language code not found in supportedLngs: ${Vs}`))
        }
        ;
        return isString$3(Cn) && (Cn.indexOf("-") > -1 || Cn.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && Ls(this.formatLanguageCode(Cn)),
        this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && Ls(this.getScriptPartFromCode(Cn)),
        this.options.load !== "currentOnly" && Ls(this.getLanguagePartFromCode(Cn))) : isString$3(Cn) && Ls(this.formatLanguageCode(Cn)),
        cs.forEach(Vs => {
            Cs.indexOf(Vs) < 0 && Ls(this.formatLanguageCode(Vs))
        }
        ),
        Cs
    }
}
let sets = [{
    lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
    nr: [1, 2],
    fc: 1
}, {
    lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
    nr: [1, 2],
    fc: 2
}, {
    lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
    nr: [1],
    fc: 3
}, {
    lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
    nr: [1, 2, 5],
    fc: 4
}, {
    lngs: ["ar"],
    nr: [0, 1, 2, 3, 11, 100],
    fc: 5
}, {
    lngs: ["cs", "sk"],
    nr: [1, 2, 5],
    fc: 6
}, {
    lngs: ["csb", "pl"],
    nr: [1, 2, 5],
    fc: 7
}, {
    lngs: ["cy"],
    nr: [1, 2, 3, 8],
    fc: 8
}, {
    lngs: ["fr"],
    nr: [1, 2],
    fc: 9
}, {
    lngs: ["ga"],
    nr: [1, 2, 3, 7, 11],
    fc: 10
}, {
    lngs: ["gd"],
    nr: [1, 2, 3, 20],
    fc: 11
}, {
    lngs: ["is"],
    nr: [1, 2],
    fc: 12
}, {
    lngs: ["jv"],
    nr: [0, 1],
    fc: 13
}, {
    lngs: ["kw"],
    nr: [1, 2, 3, 4],
    fc: 14
}, {
    lngs: ["lt"],
    nr: [1, 2, 10],
    fc: 15
}, {
    lngs: ["lv"],
    nr: [1, 2, 0],
    fc: 16
}, {
    lngs: ["mk"],
    nr: [1, 2],
    fc: 17
}, {
    lngs: ["mnk"],
    nr: [0, 1, 2],
    fc: 18
}, {
    lngs: ["mt"],
    nr: [1, 2, 11, 20],
    fc: 19
}, {
    lngs: ["or"],
    nr: [2, 1],
    fc: 2
}, {
    lngs: ["ro"],
    nr: [1, 2, 20],
    fc: 20
}, {
    lngs: ["sl"],
    nr: [5, 1, 2, 3],
    fc: 21
}, {
    lngs: ["he", "iw"],
    nr: [1, 2, 20, 21],
    fc: 22
}]
  , _rulesPluralsTypes = {
    1: xt => +(xt > 1),
    2: xt => +(xt != 1),
    3: xt => 0,
    4: xt => xt % 10 == 1 && xt % 100 != 11 ? 0 : xt % 10 >= 2 && xt % 10 <= 4 && (xt % 100 < 10 || xt % 100 >= 20) ? 1 : 2,
    5: xt => xt == 0 ? 0 : xt == 1 ? 1 : xt == 2 ? 2 : xt % 100 >= 3 && xt % 100 <= 10 ? 3 : xt % 100 >= 11 ? 4 : 5,
    6: xt => xt == 1 ? 0 : xt >= 2 && xt <= 4 ? 1 : 2,
    7: xt => xt == 1 ? 0 : xt % 10 >= 2 && xt % 10 <= 4 && (xt % 100 < 10 || xt % 100 >= 20) ? 1 : 2,
    8: xt => xt == 1 ? 0 : xt == 2 ? 1 : xt != 8 && xt != 11 ? 2 : 3,
    9: xt => +(xt >= 2),
    10: xt => xt == 1 ? 0 : xt == 2 ? 1 : xt < 7 ? 2 : xt < 11 ? 3 : 4,
    11: xt => xt == 1 || xt == 11 ? 0 : xt == 2 || xt == 12 ? 1 : xt > 2 && xt < 20 ? 2 : 3,
    12: xt => +(xt % 10 != 1 || xt % 100 == 11),
    13: xt => +(xt !== 0),
    14: xt => xt == 1 ? 0 : xt == 2 ? 1 : xt == 3 ? 2 : 3,
    15: xt => xt % 10 == 1 && xt % 100 != 11 ? 0 : xt % 10 >= 2 && (xt % 100 < 10 || xt % 100 >= 20) ? 1 : 2,
    16: xt => xt % 10 == 1 && xt % 100 != 11 ? 0 : xt !== 0 ? 1 : 2,
    17: xt => xt == 1 || xt % 10 == 1 && xt % 100 != 11 ? 0 : 1,
    18: xt => xt == 0 ? 0 : xt == 1 ? 1 : 2,
    19: xt => xt == 1 ? 0 : xt == 0 || xt % 100 > 1 && xt % 100 < 11 ? 1 : xt % 100 > 10 && xt % 100 < 20 ? 2 : 3,
    20: xt => xt == 1 ? 0 : xt == 0 || xt % 100 > 0 && xt % 100 < 20 ? 1 : 2,
    21: xt => xt % 100 == 1 ? 1 : xt % 100 == 2 ? 2 : xt % 100 == 3 || xt % 100 == 4 ? 3 : 0,
    22: xt => xt == 1 ? 0 : xt == 2 ? 1 : (xt < 0 || xt > 10) && xt % 10 == 0 ? 2 : 3
};
const nonIntlVersions = ["v1", "v2", "v3"]
  , intlVersions = ["v4"]
  , suffixesOrder = {
    zero: 0,
    one: 1,
    two: 2,
    few: 3,
    many: 4,
    other: 5
}
  , createRules = () => {
    const xt = {};
    return sets.forEach(Cn => {
        Cn.lngs.forEach(as => {
            xt[as] = {
                numbers: Cn.nr,
                plurals: _rulesPluralsTypes[Cn.fc]
            }
        }
        )
    }
    ),
    xt
}
;
class PluralResolver {
    constructor(Cn) {
        let as = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.languageUtils = Cn,
        this.options = as,
        this.logger = baseLogger.create("pluralResolver"),
        (!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3",
        this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")),
        this.rules = createRules(),
        this.pluralRulesCache = {}
    }
    addRule(Cn, as) {
        this.rules[Cn] = as
    }
    clearCache() {
        this.pluralRulesCache = {}
    }
    getRule(Cn) {
        let as = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (this.shouldUseIntlApi()) {
            const cs = getCleanedCode(Cn === "dev" ? "en" : Cn)
              , Cs = as.ordinal ? "ordinal" : "cardinal"
              , Ls = JSON.stringify({
                cleanedCode: cs,
                type: Cs
            });
            if (Ls in this.pluralRulesCache)
                return this.pluralRulesCache[Ls];
            let Vs;
            try {
                Vs = new Intl.PluralRules(cs,{
                    type: Cs
                })
            } catch {
                if (!Cn.match(/-|_/))
                    return;
                const Xs = this.languageUtils.getLanguagePartFromCode(Cn);
                Vs = this.getRule(Xs, as)
            }
            return this.pluralRulesCache[Ls] = Vs,
            Vs
        }
        return this.rules[Cn] || this.rules[this.languageUtils.getLanguagePartFromCode(Cn)]
    }
    needsPlural(Cn) {
        let as = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const cs = this.getRule(Cn, as);
        return this.shouldUseIntlApi() ? cs && cs.resolvedOptions().pluralCategories.length > 1 : cs && cs.numbers.length > 1
    }
    getPluralFormsOfKey(Cn, as) {
        let cs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return this.getSuffixes(Cn, cs).map(Cs => `${as}${Cs}`)
    }
    getSuffixes(Cn) {
        let as = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const cs = this.getRule(Cn, as);
        return cs ? this.shouldUseIntlApi() ? cs.resolvedOptions().pluralCategories.sort( (Cs, Ls) => suffixesOrder[Cs] - suffixesOrder[Ls]).map(Cs => `${this.options.prepend}${as.ordinal ? `ordinal${this.options.prepend}` : ""}${Cs}`) : cs.numbers.map(Cs => this.getSuffix(Cn, Cs, as)) : []
    }
    getSuffix(Cn, as) {
        let cs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        const Cs = this.getRule(Cn, cs);
        return Cs ? this.shouldUseIntlApi() ? `${this.options.prepend}${cs.ordinal ? `ordinal${this.options.prepend}` : ""}${Cs.select(as)}` : this.getSuffixRetroCompatible(Cs, as) : (this.logger.warn(`no plural rule found for: ${Cn}`),
        "")
    }
    getSuffixRetroCompatible(Cn, as) {
        const cs = Cn.noAbs ? Cn.plurals(as) : Cn.plurals(Math.abs(as));
        let Cs = Cn.numbers[cs];
        this.options.simplifyPluralSuffix && Cn.numbers.length === 2 && Cn.numbers[0] === 1 && (Cs === 2 ? Cs = "plural" : Cs === 1 && (Cs = ""));
        const Ls = () => this.options.prepend && Cs.toString() ? this.options.prepend + Cs.toString() : Cs.toString();
        return this.options.compatibilityJSON === "v1" ? Cs === 1 ? "" : typeof Cs == "number" ? `_plural_${Cs.toString()}` : Ls() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && Cn.numbers.length === 2 && Cn.numbers[0] === 1 ? Ls() : this.options.prepend && cs.toString() ? this.options.prepend + cs.toString() : cs.toString()
    }
    shouldUseIntlApi() {
        return !nonIntlVersions.includes(this.options.compatibilityJSON)
    }
}
const deepFindWithDefaults = function(xt, Cn, as) {
    let cs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "."
      , Cs = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0
      , Ls = getPathWithDefaults(xt, Cn, as);
    return !Ls && Cs && isString$3(as) && (Ls = deepFind(xt, as, cs),
    Ls === void 0 && (Ls = deepFind(Cn, as, cs))),
    Ls
}
  , regexSafe = xt => xt.replace(/\$/g, "$$$$");
class Interpolator {
    constructor() {
        let Cn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.logger = baseLogger.create("interpolator"),
        this.options = Cn,
        this.format = Cn.interpolation && Cn.interpolation.format || (as => as),
        this.init(Cn)
    }
    init() {
        let Cn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        Cn.interpolation || (Cn.interpolation = {
            escapeValue: !0
        });
        const {escape: as, escapeValue: cs, useRawValueToEscape: Cs, prefix: Ls, prefixEscaped: Vs, suffix: Ws, suffixEscaped: Xs, formatSeparator: ga, unescapeSuffix: ba, unescapePrefix: yl, nestingPrefix: xl, nestingPrefixEscaped: wl, nestingSuffix: _l, nestingSuffixEscaped: El, nestingOptionsSeparator: Cl, maxReplaces: $l, alwaysFormat: Sl} = Cn.interpolation;
        this.escape = as !== void 0 ? as : escape$1,
        this.escapeValue = cs !== void 0 ? cs : !0,
        this.useRawValueToEscape = Cs !== void 0 ? Cs : !1,
        this.prefix = Ls ? regexEscape(Ls) : Vs || "{{",
        this.suffix = Ws ? regexEscape(Ws) : Xs || "}}",
        this.formatSeparator = ga || ",",
        this.unescapePrefix = ba ? "" : yl || "-",
        this.unescapeSuffix = this.unescapePrefix ? "" : ba || "",
        this.nestingPrefix = xl ? regexEscape(xl) : wl || regexEscape("$t("),
        this.nestingSuffix = _l ? regexEscape(_l) : El || regexEscape(")"),
        this.nestingOptionsSeparator = Cl || ",",
        this.maxReplaces = $l || 1e3,
        this.alwaysFormat = Sl !== void 0 ? Sl : !1,
        this.resetRegExp()
    }
    reset() {
        this.options && this.init(this.options)
    }
    resetRegExp() {
        const Cn = (as, cs) => as && as.source === cs ? (as.lastIndex = 0,
        as) : new RegExp(cs,"g");
        this.regexp = Cn(this.regexp, `${this.prefix}(.+?)${this.suffix}`),
        this.regexpUnescape = Cn(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`),
        this.nestingRegexp = Cn(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`)
    }
    interpolate(Cn, as, cs, Cs) {
        let Ls, Vs, Ws;
        const Xs = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}
          , ga = wl => {
            if (wl.indexOf(this.formatSeparator) < 0) {
                const $l = deepFindWithDefaults(as, Xs, wl, this.options.keySeparator, this.options.ignoreJSONStructure);
                return this.alwaysFormat ? this.format($l, void 0, cs, {
                    ...Cs,
                    ...as,
                    interpolationkey: wl
                }) : $l
            }
            const _l = wl.split(this.formatSeparator)
              , El = _l.shift().trim()
              , Cl = _l.join(this.formatSeparator).trim();
            return this.format(deepFindWithDefaults(as, Xs, El, this.options.keySeparator, this.options.ignoreJSONStructure), Cl, cs, {
                ...Cs,
                ...as,
                interpolationkey: El
            })
        }
        ;
        this.resetRegExp();
        const ba = Cs && Cs.missingInterpolationHandler || this.options.missingInterpolationHandler
          , yl = Cs && Cs.interpolation && Cs.interpolation.skipOnVariables !== void 0 ? Cs.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
        return [{
            regex: this.regexpUnescape,
            safeValue: wl => regexSafe(wl)
        }, {
            regex: this.regexp,
            safeValue: wl => this.escapeValue ? regexSafe(this.escape(wl)) : regexSafe(wl)
        }].forEach(wl => {
            for (Ws = 0; Ls = wl.regex.exec(Cn); ) {
                const _l = Ls[1].trim();
                if (Vs = ga(_l),
                Vs === void 0)
                    if (typeof ba == "function") {
                        const Cl = ba(Cn, Ls, Cs);
                        Vs = isString$3(Cl) ? Cl : ""
                    } else if (Cs && Object.prototype.hasOwnProperty.call(Cs, _l))
                        Vs = "";
                    else if (yl) {
                        Vs = Ls[0];
                        continue
                    } else
                        this.logger.warn(`missed to pass in variable ${_l} for interpolating ${Cn}`),
                        Vs = "";
                else
                    !isString$3(Vs) && !this.useRawValueToEscape && (Vs = makeString(Vs));
                const El = wl.safeValue(Vs);
                if (Cn = Cn.replace(Ls[0], El),
                yl ? (wl.regex.lastIndex += Vs.length,
                wl.regex.lastIndex -= Ls[0].length) : wl.regex.lastIndex = 0,
                Ws++,
                Ws >= this.maxReplaces)
                    break
            }
        }
        ),
        Cn
    }
    nest(Cn, as) {
        let cs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, Cs, Ls, Vs;
        const Ws = (Xs, ga) => {
            const ba = this.nestingOptionsSeparator;
            if (Xs.indexOf(ba) < 0)
                return Xs;
            const yl = Xs.split(new RegExp(`${ba}[ ]*{`));
            let xl = `{${yl[1]}`;
            Xs = yl[0],
            xl = this.interpolate(xl, Vs);
            const wl = xl.match(/'/g)
              , _l = xl.match(/"/g);
            (wl && wl.length % 2 === 0 && !_l || _l.length % 2 !== 0) && (xl = xl.replace(/'/g, '"'));
            try {
                Vs = JSON.parse(xl),
                ga && (Vs = {
                    ...ga,
                    ...Vs
                })
            } catch (El) {
                return this.logger.warn(`failed parsing options string in nesting for key ${Xs}`, El),
                `${Xs}${ba}${xl}`
            }
            return Vs.defaultValue && Vs.defaultValue.indexOf(this.prefix) > -1 && delete Vs.defaultValue,
            Xs
        }
        ;
        for (; Cs = this.nestingRegexp.exec(Cn); ) {
            let Xs = [];
            Vs = {
                ...cs
            },
            Vs = Vs.replace && !isString$3(Vs.replace) ? Vs.replace : Vs,
            Vs.applyPostProcessor = !1,
            delete Vs.defaultValue;
            let ga = !1;
            if (Cs[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(Cs[1])) {
                const ba = Cs[1].split(this.formatSeparator).map(yl => yl.trim());
                Cs[1] = ba.shift(),
                Xs = ba,
                ga = !0
            }
            if (Ls = as(Ws.call(this, Cs[1].trim(), Vs), Vs),
            Ls && Cs[0] === Cn && !isString$3(Ls))
                return Ls;
            isString$3(Ls) || (Ls = makeString(Ls)),
            Ls || (this.logger.warn(`missed to resolve ${Cs[1]} for nesting ${Cn}`),
            Ls = ""),
            ga && (Ls = Xs.reduce( (ba, yl) => this.format(ba, yl, cs.lng, {
                ...cs,
                interpolationkey: Cs[1].trim()
            }), Ls.trim())),
            Cn = Cn.replace(Cs[0], Ls),
            this.regexp.lastIndex = 0
        }
        return Cn
    }
}
const parseFormatStr = xt => {
    let Cn = xt.toLowerCase().trim();
    const as = {};
    if (xt.indexOf("(") > -1) {
        const cs = xt.split("(");
        Cn = cs[0].toLowerCase().trim();
        const Cs = cs[1].substring(0, cs[1].length - 1);
        Cn === "currency" && Cs.indexOf(":") < 0 ? as.currency || (as.currency = Cs.trim()) : Cn === "relativetime" && Cs.indexOf(":") < 0 ? as.range || (as.range = Cs.trim()) : Cs.split(";").forEach(Vs => {
            if (Vs) {
                const [Ws,...Xs] = Vs.split(":")
                  , ga = Xs.join(":").trim().replace(/^'+|'+$/g, "")
                  , ba = Ws.trim();
                as[ba] || (as[ba] = ga),
                ga === "false" && (as[ba] = !1),
                ga === "true" && (as[ba] = !0),
                isNaN(ga) || (as[ba] = parseInt(ga, 10))
            }
        }
        )
    }
    return {
        formatName: Cn,
        formatOptions: as
    }
}
  , createCachedFormatter = xt => {
    const Cn = {};
    return (as, cs, Cs) => {
        let Ls = Cs;
        Cs && Cs.interpolationkey && Cs.formatParams && Cs.formatParams[Cs.interpolationkey] && Cs[Cs.interpolationkey] && (Ls = {
            ...Ls,
            [Cs.interpolationkey]: void 0
        });
        const Vs = cs + JSON.stringify(Ls);
        let Ws = Cn[Vs];
        return Ws || (Ws = xt(getCleanedCode(cs), Cs),
        Cn[Vs] = Ws),
        Ws(as)
    }
}
;
class Formatter {
    constructor() {
        let Cn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.logger = baseLogger.create("formatter"),
        this.options = Cn,
        this.formats = {
            number: createCachedFormatter( (as, cs) => {
                const Cs = new Intl.NumberFormat(as,{
                    ...cs
                });
                return Ls => Cs.format(Ls)
            }
            ),
            currency: createCachedFormatter( (as, cs) => {
                const Cs = new Intl.NumberFormat(as,{
                    ...cs,
                    style: "currency"
                });
                return Ls => Cs.format(Ls)
            }
            ),
            datetime: createCachedFormatter( (as, cs) => {
                const Cs = new Intl.DateTimeFormat(as,{
                    ...cs
                });
                return Ls => Cs.format(Ls)
            }
            ),
            relativetime: createCachedFormatter( (as, cs) => {
                const Cs = new Intl.RelativeTimeFormat(as,{
                    ...cs
                });
                return Ls => Cs.format(Ls, cs.range || "day")
            }
            ),
            list: createCachedFormatter( (as, cs) => {
                const Cs = new Intl.ListFormat(as,{
                    ...cs
                });
                return Ls => Cs.format(Ls)
            }
            )
        },
        this.init(Cn)
    }
    init(Cn) {
        let as = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            interpolation: {}
        };
        this.formatSeparator = as.interpolation.formatSeparator || ","
    }
    add(Cn, as) {
        this.formats[Cn.toLowerCase().trim()] = as
    }
    addCached(Cn, as) {
        this.formats[Cn.toLowerCase().trim()] = createCachedFormatter(as)
    }
    format(Cn, as, cs) {
        let Cs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        const Ls = as.split(this.formatSeparator);
        if (Ls.length > 1 && Ls[0].indexOf("(") > 1 && Ls[0].indexOf(")") < 0 && Ls.find(Ws => Ws.indexOf(")") > -1)) {
            const Ws = Ls.findIndex(Xs => Xs.indexOf(")") > -1);
            Ls[0] = [Ls[0], ...Ls.splice(1, Ws)].join(this.formatSeparator)
        }
        return Ls.reduce( (Ws, Xs) => {
            const {formatName: ga, formatOptions: ba} = parseFormatStr(Xs);
            if (this.formats[ga]) {
                let yl = Ws;
                try {
                    const xl = Cs && Cs.formatParams && Cs.formatParams[Cs.interpolationkey] || {}
                      , wl = xl.locale || xl.lng || Cs.locale || Cs.lng || cs;
                    yl = this.formats[ga](Ws, wl, {
                        ...ba,
                        ...Cs,
                        ...xl
                    })
                } catch (xl) {
                    this.logger.warn(xl)
                }
                return yl
            } else
                this.logger.warn(`there was no format function for ${ga}`);
            return Ws
        }
        , Cn)
    }
}
const removePending = (xt, Cn) => {
    xt.pending[Cn] !== void 0 && (delete xt.pending[Cn],
    xt.pendingCount--)
}
;
class Connector extends EventEmitter {
    constructor(Cn, as, cs) {
        let Cs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        super(),
        this.backend = Cn,
        this.store = as,
        this.services = cs,
        this.languageUtils = cs.languageUtils,
        this.options = Cs,
        this.logger = baseLogger.create("backendConnector"),
        this.waitingReads = [],
        this.maxParallelReads = Cs.maxParallelReads || 10,
        this.readingCalls = 0,
        this.maxRetries = Cs.maxRetries >= 0 ? Cs.maxRetries : 5,
        this.retryTimeout = Cs.retryTimeout >= 1 ? Cs.retryTimeout : 350,
        this.state = {},
        this.queue = [],
        this.backend && this.backend.init && this.backend.init(cs, Cs.backend, Cs)
    }
    queueLoad(Cn, as, cs, Cs) {
        const Ls = {}
          , Vs = {}
          , Ws = {}
          , Xs = {};
        return Cn.forEach(ga => {
            let ba = !0;
            as.forEach(yl => {
                const xl = `${ga}|${yl}`;
                !cs.reload && this.store.hasResourceBundle(ga, yl) ? this.state[xl] = 2 : this.state[xl] < 0 || (this.state[xl] === 1 ? Vs[xl] === void 0 && (Vs[xl] = !0) : (this.state[xl] = 1,
                ba = !1,
                Vs[xl] === void 0 && (Vs[xl] = !0),
                Ls[xl] === void 0 && (Ls[xl] = !0),
                Xs[yl] === void 0 && (Xs[yl] = !0)))
            }
            ),
            ba || (Ws[ga] = !0)
        }
        ),
        (Object.keys(Ls).length || Object.keys(Vs).length) && this.queue.push({
            pending: Vs,
            pendingCount: Object.keys(Vs).length,
            loaded: {},
            errors: [],
            callback: Cs
        }),
        {
            toLoad: Object.keys(Ls),
            pending: Object.keys(Vs),
            toLoadLanguages: Object.keys(Ws),
            toLoadNamespaces: Object.keys(Xs)
        }
    }
    loaded(Cn, as, cs) {
        const Cs = Cn.split("|")
          , Ls = Cs[0]
          , Vs = Cs[1];
        as && this.emit("failedLoading", Ls, Vs, as),
        !as && cs && this.store.addResourceBundle(Ls, Vs, cs, void 0, void 0, {
            skipCopy: !0
        }),
        this.state[Cn] = as ? -1 : 2,
        as && cs && (this.state[Cn] = 0);
        const Ws = {};
        this.queue.forEach(Xs => {
            pushPath(Xs.loaded, [Ls], Vs),
            removePending(Xs, Cn),
            as && Xs.errors.push(as),
            Xs.pendingCount === 0 && !Xs.done && (Object.keys(Xs.loaded).forEach(ga => {
                Ws[ga] || (Ws[ga] = {});
                const ba = Xs.loaded[ga];
                ba.length && ba.forEach(yl => {
                    Ws[ga][yl] === void 0 && (Ws[ga][yl] = !0)
                }
                )
            }
            ),
            Xs.done = !0,
            Xs.errors.length ? Xs.callback(Xs.errors) : Xs.callback())
        }
        ),
        this.emit("loaded", Ws),
        this.queue = this.queue.filter(Xs => !Xs.done)
    }
    read(Cn, as, cs) {
        let Cs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0
          , Ls = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout
          , Vs = arguments.length > 5 ? arguments[5] : void 0;
        if (!Cn.length)
            return Vs(null, {});
        if (this.readingCalls >= this.maxParallelReads) {
            this.waitingReads.push({
                lng: Cn,
                ns: as,
                fcName: cs,
                tried: Cs,
                wait: Ls,
                callback: Vs
            });
            return
        }
        this.readingCalls++;
        const Ws = (ga, ba) => {
            if (this.readingCalls--,
            this.waitingReads.length > 0) {
                const yl = this.waitingReads.shift();
                this.read(yl.lng, yl.ns, yl.fcName, yl.tried, yl.wait, yl.callback)
            }
            if (ga && ba && Cs < this.maxRetries) {
                setTimeout( () => {
                    this.read.call(this, Cn, as, cs, Cs + 1, Ls * 2, Vs)
                }
                , Ls);
                return
            }
            Vs(ga, ba)
        }
          , Xs = this.backend[cs].bind(this.backend);
        if (Xs.length === 2) {
            try {
                const ga = Xs(Cn, as);
                ga && typeof ga.then == "function" ? ga.then(ba => Ws(null, ba)).catch(Ws) : Ws(null, ga)
            } catch (ga) {
                Ws(ga)
            }
            return
        }
        return Xs(Cn, as, Ws)
    }
    prepareLoading(Cn, as) {
        let cs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
          , Cs = arguments.length > 3 ? arguments[3] : void 0;
        if (!this.backend)
            return this.logger.warn("No backend was added via i18next.use. Will not load resources."),
            Cs && Cs();
        isString$3(Cn) && (Cn = this.languageUtils.toResolveHierarchy(Cn)),
        isString$3(as) && (as = [as]);
        const Ls = this.queueLoad(Cn, as, cs, Cs);
        if (!Ls.toLoad.length)
            return Ls.pending.length || Cs(),
            null;
        Ls.toLoad.forEach(Vs => {
            this.loadOne(Vs)
        }
        )
    }
    load(Cn, as, cs) {
        this.prepareLoading(Cn, as, {}, cs)
    }
    reload(Cn, as, cs) {
        this.prepareLoading(Cn, as, {
            reload: !0
        }, cs)
    }
    loadOne(Cn) {
        let as = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        const cs = Cn.split("|")
          , Cs = cs[0]
          , Ls = cs[1];
        this.read(Cs, Ls, "read", void 0, void 0, (Vs, Ws) => {
            Vs && this.logger.warn(`${as}loading namespace ${Ls} for language ${Cs} failed`, Vs),
            !Vs && Ws && this.logger.log(`${as}loaded namespace ${Ls} for language ${Cs}`, Ws),
            this.loaded(Cn, Vs, Ws)
        }
        )
    }
    saveMissing(Cn, as, cs, Cs, Ls) {
        let Vs = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}
          , Ws = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {}
        ;
        if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(as)) {
            this.logger.warn(`did not save key "${cs}" as the namespace "${as}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
            return
        }
        if (!(cs == null || cs === "")) {
            if (this.backend && this.backend.create) {
                const Xs = {
                    ...Vs,
                    isUpdate: Ls
                }
                  , ga = this.backend.create.bind(this.backend);
                if (ga.length < 6)
                    try {
                        let ba;
                        ga.length === 5 ? ba = ga(Cn, as, cs, Cs, Xs) : ba = ga(Cn, as, cs, Cs),
                        ba && typeof ba.then == "function" ? ba.then(yl => Ws(null, yl)).catch(Ws) : Ws(null, ba)
                    } catch (ba) {
                        Ws(ba)
                    }
                else
                    ga(Cn, as, cs, Cs, Ws, Xs)
            }
            !Cn || !Cn[0] || this.store.addResource(Cn[0], as, cs, Cs)
        }
    }
}
const get$1 = () => ({
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !1,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: xt => {
        let Cn = {};
        if (typeof xt[1] == "object" && (Cn = xt[1]),
        isString$3(xt[1]) && (Cn.defaultValue = xt[1]),
        isString$3(xt[2]) && (Cn.tDescription = xt[2]),
        typeof xt[2] == "object" || typeof xt[3] == "object") {
            const as = xt[3] || xt[2];
            Object.keys(as).forEach(cs => {
                Cn[cs] = as[cs]
            }
            )
        }
        return Cn
    }
    ,
    interpolation: {
        escapeValue: !0,
        format: xt => xt,
        prefix: "{{",
        suffix: "}}",
        formatSeparator: ",",
        unescapePrefix: "-",
        nestingPrefix: "$t(",
        nestingSuffix: ")",
        nestingOptionsSeparator: ",",
        maxReplaces: 1e3,
        skipOnVariables: !0
    }
})
  , transformOptions = xt => (isString$3(xt.ns) && (xt.ns = [xt.ns]),
isString$3(xt.fallbackLng) && (xt.fallbackLng = [xt.fallbackLng]),
isString$3(xt.fallbackNS) && (xt.fallbackNS = [xt.fallbackNS]),
xt.supportedLngs && xt.supportedLngs.indexOf("cimode") < 0 && (xt.supportedLngs = xt.supportedLngs.concat(["cimode"])),
xt)
  , noop$4 = () => {}
  , bindMemberFunctions = xt => {
    Object.getOwnPropertyNames(Object.getPrototypeOf(xt)).forEach(as => {
        typeof xt[as] == "function" && (xt[as] = xt[as].bind(xt))
    }
    )
}
;
class I18n extends EventEmitter {
    constructor() {
        let Cn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , as = arguments.length > 1 ? arguments[1] : void 0;
        if (super(),
        this.options = transformOptions(Cn),
        this.services = {},
        this.logger = baseLogger,
        this.modules = {
            external: []
        },
        bindMemberFunctions(this),
        as && !this.isInitialized && !Cn.isClone) {
            if (!this.options.initImmediate)
                return this.init(Cn, as),
                this;
            setTimeout( () => {
                this.init(Cn, as)
            }
            , 0)
        }
    }
    init() {
        var Cn = this;
        let as = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , cs = arguments.length > 1 ? arguments[1] : void 0;
        this.isInitializing = !0,
        typeof as == "function" && (cs = as,
        as = {}),
        !as.defaultNS && as.defaultNS !== !1 && as.ns && (isString$3(as.ns) ? as.defaultNS = as.ns : as.ns.indexOf("translation") < 0 && (as.defaultNS = as.ns[0]));
        const Cs = get$1();
        this.options = {
            ...Cs,
            ...this.options,
            ...transformOptions(as)
        },
        this.options.compatibilityAPI !== "v1" && (this.options.interpolation = {
            ...Cs.interpolation,
            ...this.options.interpolation
        }),
        as.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = as.keySeparator),
        as.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = as.nsSeparator);
        const Ls = ba => ba ? typeof ba == "function" ? new ba : ba : null;
        if (!this.options.isClone) {
            this.modules.logger ? baseLogger.init(Ls(this.modules.logger), this.options) : baseLogger.init(null, this.options);
            let ba;
            this.modules.formatter ? ba = this.modules.formatter : typeof Intl < "u" && (ba = Formatter);
            const yl = new LanguageUtil(this.options);
            this.store = new ResourceStore(this.options.resources,this.options);
            const xl = this.services;
            xl.logger = baseLogger,
            xl.resourceStore = this.store,
            xl.languageUtils = yl,
            xl.pluralResolver = new PluralResolver(yl,{
                prepend: this.options.pluralSeparator,
                compatibilityJSON: this.options.compatibilityJSON,
                simplifyPluralSuffix: this.options.simplifyPluralSuffix
            }),
            ba && (!this.options.interpolation.format || this.options.interpolation.format === Cs.interpolation.format) && (xl.formatter = Ls(ba),
            xl.formatter.init(xl, this.options),
            this.options.interpolation.format = xl.formatter.format.bind(xl.formatter)),
            xl.interpolator = new Interpolator(this.options),
            xl.utils = {
                hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
            },
            xl.backendConnector = new Connector(Ls(this.modules.backend),xl.resourceStore,xl,this.options),
            xl.backendConnector.on("*", function(wl) {
                for (var _l = arguments.length, El = new Array(_l > 1 ? _l - 1 : 0), Cl = 1; Cl < _l; Cl++)
                    El[Cl - 1] = arguments[Cl];
                Cn.emit(wl, ...El)
            }),
            this.modules.languageDetector && (xl.languageDetector = Ls(this.modules.languageDetector),
            xl.languageDetector.init && xl.languageDetector.init(xl, this.options.detection, this.options)),
            this.modules.i18nFormat && (xl.i18nFormat = Ls(this.modules.i18nFormat),
            xl.i18nFormat.init && xl.i18nFormat.init(this)),
            this.translator = new Translator(this.services,this.options),
            this.translator.on("*", function(wl) {
                for (var _l = arguments.length, El = new Array(_l > 1 ? _l - 1 : 0), Cl = 1; Cl < _l; Cl++)
                    El[Cl - 1] = arguments[Cl];
                Cn.emit(wl, ...El)
            }),
            this.modules.external.forEach(wl => {
                wl.init && wl.init(this)
            }
            )
        }
        if (this.format = this.options.interpolation.format,
        cs || (cs = noop$4),
        this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
            const ba = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
            ba.length > 0 && ba[0] !== "dev" && (this.options.lng = ba[0])
        }
        !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"),
        ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach(ba => {
            this[ba] = function() {
                return Cn.store[ba](...arguments)
            }
        }
        ),
        ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach(ba => {
            this[ba] = function() {
                return Cn.store[ba](...arguments),
                Cn
            }
        }
        );
        const Xs = defer()
          , ga = () => {
            const ba = (yl, xl) => {
                this.isInitializing = !1,
                this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"),
                this.isInitialized = !0,
                this.options.isClone || this.logger.log("initialized", this.options),
                this.emit("initialized", this.options),
                Xs.resolve(xl),
                cs(yl, xl)
            }
            ;
            if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized)
                return ba(null, this.t.bind(this));
            this.changeLanguage(this.options.lng, ba)
        }
        ;
        return this.options.resources || !this.options.initImmediate ? ga() : setTimeout(ga, 0),
        Xs
    }
    loadResources(Cn) {
        let cs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$4;
        const Cs = isString$3(Cn) ? Cn : this.language;
        if (typeof Cn == "function" && (cs = Cn),
        !this.options.resources || this.options.partialBundledLanguages) {
            if (Cs && Cs.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0))
                return cs();
            const Ls = []
              , Vs = Ws => {
                if (!Ws || Ws === "cimode")
                    return;
                this.services.languageUtils.toResolveHierarchy(Ws).forEach(ga => {
                    ga !== "cimode" && Ls.indexOf(ga) < 0 && Ls.push(ga)
                }
                )
            }
            ;
            Cs ? Vs(Cs) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(Xs => Vs(Xs)),
            this.options.preload && this.options.preload.forEach(Ws => Vs(Ws)),
            this.services.backendConnector.load(Ls, this.options.ns, Ws => {
                !Ws && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language),
                cs(Ws)
            }
            )
        } else
            cs(null)
    }
    reloadResources(Cn, as, cs) {
        const Cs = defer();
        return typeof Cn == "function" && (cs = Cn,
        Cn = void 0),
        typeof as == "function" && (cs = as,
        as = void 0),
        Cn || (Cn = this.languages),
        as || (as = this.options.ns),
        cs || (cs = noop$4),
        this.services.backendConnector.reload(Cn, as, Ls => {
            Cs.resolve(),
            cs(Ls)
        }
        ),
        Cs
    }
    use(Cn) {
        if (!Cn)
            throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
        if (!Cn.type)
            throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
        return Cn.type === "backend" && (this.modules.backend = Cn),
        (Cn.type === "logger" || Cn.log && Cn.warn && Cn.error) && (this.modules.logger = Cn),
        Cn.type === "languageDetector" && (this.modules.languageDetector = Cn),
        Cn.type === "i18nFormat" && (this.modules.i18nFormat = Cn),
        Cn.type === "postProcessor" && postProcessor.addPostProcessor(Cn),
        Cn.type === "formatter" && (this.modules.formatter = Cn),
        Cn.type === "3rdParty" && this.modules.external.push(Cn),
        this
    }
    setResolvedLanguage(Cn) {
        if (!(!Cn || !this.languages) && !(["cimode", "dev"].indexOf(Cn) > -1))
            for (let as = 0; as < this.languages.length; as++) {
                const cs = this.languages[as];
                if (!(["cimode", "dev"].indexOf(cs) > -1) && this.store.hasLanguageSomeTranslations(cs)) {
                    this.resolvedLanguage = cs;
                    break
                }
            }
    }
    changeLanguage(Cn, as) {
        var cs = this;
        this.isLanguageChangingTo = Cn;
        const Cs = defer();
        this.emit("languageChanging", Cn);
        const Ls = Xs => {
            this.language = Xs,
            this.languages = this.services.languageUtils.toResolveHierarchy(Xs),
            this.resolvedLanguage = void 0,
            this.setResolvedLanguage(Xs)
        }
          , Vs = (Xs, ga) => {
            ga ? (Ls(ga),
            this.translator.changeLanguage(ga),
            this.isLanguageChangingTo = void 0,
            this.emit("languageChanged", ga),
            this.logger.log("languageChanged", ga)) : this.isLanguageChangingTo = void 0,
            Cs.resolve(function() {
                return cs.t(...arguments)
            }),
            as && as(Xs, function() {
                return cs.t(...arguments)
            })
        }
          , Ws = Xs => {
            !Cn && !Xs && this.services.languageDetector && (Xs = []);
            const ga = isString$3(Xs) ? Xs : this.services.languageUtils.getBestMatchFromCodes(Xs);
            ga && (this.language || Ls(ga),
            this.translator.language || this.translator.changeLanguage(ga),
            this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(ga)),
            this.loadResources(ga, ba => {
                Vs(ba, ga)
            }
            )
        }
        ;
        return !Cn && this.services.languageDetector && !this.services.languageDetector.async ? Ws(this.services.languageDetector.detect()) : !Cn && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(Ws) : this.services.languageDetector.detect(Ws) : Ws(Cn),
        Cs
    }
    getFixedT(Cn, as, cs) {
        var Cs = this;
        const Ls = function(Vs, Ws) {
            let Xs;
            if (typeof Ws != "object") {
                for (var ga = arguments.length, ba = new Array(ga > 2 ? ga - 2 : 0), yl = 2; yl < ga; yl++)
                    ba[yl - 2] = arguments[yl];
                Xs = Cs.options.overloadTranslationOptionHandler([Vs, Ws].concat(ba))
            } else
                Xs = {
                    ...Ws
                };
            Xs.lng = Xs.lng || Ls.lng,
            Xs.lngs = Xs.lngs || Ls.lngs,
            Xs.ns = Xs.ns || Ls.ns,
            Xs.keyPrefix !== "" && (Xs.keyPrefix = Xs.keyPrefix || cs || Ls.keyPrefix);
            const xl = Cs.options.keySeparator || ".";
            let wl;
            return Xs.keyPrefix && Array.isArray(Vs) ? wl = Vs.map(_l => `${Xs.keyPrefix}${xl}${_l}`) : wl = Xs.keyPrefix ? `${Xs.keyPrefix}${xl}${Vs}` : Vs,
            Cs.t(wl, Xs)
        };
        return isString$3(Cn) ? Ls.lng = Cn : Ls.lngs = Cn,
        Ls.ns = as,
        Ls.keyPrefix = cs,
        Ls
    }
    t() {
        return this.translator && this.translator.translate(...arguments)
    }
    exists() {
        return this.translator && this.translator.exists(...arguments)
    }
    setDefaultNamespace(Cn) {
        this.options.defaultNS = Cn
    }
    hasLoadedNamespace(Cn) {
        let as = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (!this.isInitialized)
            return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages),
            !1;
        if (!this.languages || !this.languages.length)
            return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages),
            !1;
        const cs = as.lng || this.resolvedLanguage || this.languages[0]
          , Cs = this.options ? this.options.fallbackLng : !1
          , Ls = this.languages[this.languages.length - 1];
        if (cs.toLowerCase() === "cimode")
            return !0;
        const Vs = (Ws, Xs) => {
            const ga = this.services.backendConnector.state[`${Ws}|${Xs}`];
            return ga === -1 || ga === 0 || ga === 2
        }
        ;
        if (as.precheck) {
            const Ws = as.precheck(this, Vs);
            if (Ws !== void 0)
                return Ws
        }
        return !!(this.hasResourceBundle(cs, Cn) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || Vs(cs, Cn) && (!Cs || Vs(Ls, Cn)))
    }
    loadNamespaces(Cn, as) {
        const cs = defer();
        return this.options.ns ? (isString$3(Cn) && (Cn = [Cn]),
        Cn.forEach(Cs => {
            this.options.ns.indexOf(Cs) < 0 && this.options.ns.push(Cs)
        }
        ),
        this.loadResources(Cs => {
            cs.resolve(),
            as && as(Cs)
        }
        ),
        cs) : (as && as(),
        Promise.resolve())
    }
    loadLanguages(Cn, as) {
        const cs = defer();
        isString$3(Cn) && (Cn = [Cn]);
        const Cs = this.options.preload || []
          , Ls = Cn.filter(Vs => Cs.indexOf(Vs) < 0 && this.services.languageUtils.isSupportedCode(Vs));
        return Ls.length ? (this.options.preload = Cs.concat(Ls),
        this.loadResources(Vs => {
            cs.resolve(),
            as && as(Vs)
        }
        ),
        cs) : (as && as(),
        Promise.resolve())
    }
    dir(Cn) {
        if (Cn || (Cn = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)),
        !Cn)
            return "rtl";
        const as = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"]
          , cs = this.services && this.services.languageUtils || new LanguageUtil(get$1());
        return as.indexOf(cs.getLanguagePartFromCode(Cn)) > -1 || Cn.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr"
    }
    static createInstance() {
        let Cn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , as = arguments.length > 1 ? arguments[1] : void 0;
        return new I18n(Cn,as)
    }
    cloneInstance() {
        let Cn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , as = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$4;
        const cs = Cn.forkResourceStore;
        cs && delete Cn.forkResourceStore;
        const Cs = {
            ...this.options,
            ...Cn,
            isClone: !0
        }
          , Ls = new I18n(Cs);
        return (Cn.debug !== void 0 || Cn.prefix !== void 0) && (Ls.logger = Ls.logger.clone(Cn)),
        ["store", "services", "language"].forEach(Ws => {
            Ls[Ws] = this[Ws]
        }
        ),
        Ls.services = {
            ...this.services
        },
        Ls.services.utils = {
            hasLoadedNamespace: Ls.hasLoadedNamespace.bind(Ls)
        },
        cs && (Ls.store = new ResourceStore(this.store.data,Cs),
        Ls.services.resourceStore = Ls.store),
        Ls.translator = new Translator(Ls.services,Cs),
        Ls.translator.on("*", function(Ws) {
            for (var Xs = arguments.length, ga = new Array(Xs > 1 ? Xs - 1 : 0), ba = 1; ba < Xs; ba++)
                ga[ba - 1] = arguments[ba];
            Ls.emit(Ws, ...ga)
        }),
        Ls.init(Cs, as),
        Ls.translator.options = Cs,
        Ls.translator.backendConnector.services.utils = {
            hasLoadedNamespace: Ls.hasLoadedNamespace.bind(Ls)
        },
        Ls
    }
    toJSON() {
        return {
            options: this.options,
            store: this.store,
            language: this.language,
            languages: this.languages,
            resolvedLanguage: this.resolvedLanguage
        }
    }
}
const instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
const warn = (xt, Cn, as, cs) => {
    var Ls, Vs, Ws, Xs;
    const Cs = [as, {
        code: Cn,
        ...cs || {}
    }];
    if ((Vs = (Ls = xt == null ? void 0 : xt.services) == null ? void 0 : Ls.logger) != null && Vs.forward)
        return xt.services.logger.forward(Cs, "warn", "react-i18next::", !0);
    isString$2(Cs[0]) && (Cs[0] = `react-i18next:: ${Cs[0]}`),
    (Xs = (Ws = xt == null ? void 0 : xt.services) == null ? void 0 : Ws.logger) != null && Xs.warn ? xt.services.logger.warn(...Cs) : console != null && console.warn && console.warn(...Cs)
}
  , alreadyWarned$1 = {}
  , warnOnce = (xt, Cn, as, cs) => {
    isString$2(as) && alreadyWarned$1[as] || (isString$2(as) && (alreadyWarned$1[as] = new Date),
    warn(xt, Cn, as, cs))
}
  , loadedClb = (xt, Cn) => () => {
    if (xt.isInitialized)
        Cn();
    else {
        const as = () => {
            setTimeout( () => {
                xt.off("initialized", as)
            }
            , 0),
            Cn()
        }
        ;
        xt.on("initialized", as)
    }
}
  , loadNamespaces = (xt, Cn, as) => {
    xt.loadNamespaces(Cn, loadedClb(xt, as))
}
  , loadLanguages = (xt, Cn, as, cs) => {
    if (isString$2(as) && (as = [as]),
    xt.options.preload && xt.options.preload.indexOf(Cn) > -1)
        return loadNamespaces(xt, as, cs);
    as.forEach(Cs => {
        xt.options.ns.indexOf(Cs) < 0 && xt.options.ns.push(Cs)
    }
    ),
    xt.loadLanguages(Cn, loadedClb(xt, cs))
}
  , hasLoadedNamespace = (xt, Cn, as={}) => !Cn.languages || !Cn.languages.length ? (warnOnce(Cn, "NO_LANGUAGES", "i18n.languages were undefined or empty", {
    languages: Cn.languages
}),
!0) : Cn.hasLoadedNamespace(xt, {
    lng: as.lng,
    precheck: (cs, Cs) => {
        var Ls;
        if (((Ls = as.bindI18n) == null ? void 0 : Ls.indexOf("languageChanging")) > -1 && cs.services.backendConnector.backend && cs.isLanguageChangingTo && !Cs(cs.isLanguageChangingTo, xt))
            return !1
    }
})
  , isString$2 = xt => typeof xt == "string"
  , isObject$2 = xt => typeof xt == "object" && xt !== null
  , matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g
  , htmlEntities = {
    "&amp;": "&",
    "&#38;": "&",
    "&lt;": "<",
    "&#60;": "<",
    "&gt;": ">",
    "&#62;": ">",
    "&apos;": "'",
    "&#39;": "'",
    "&quot;": '"',
    "&#34;": '"',
    "&nbsp;": " ",
    "&#160;": " ",
    "&copy;": "",
    "&#169;": "",
    "&reg;": "",
    "&#174;": "",
    "&hellip;": "",
    "&#8230;": "",
    "&#x2F;": "/",
    "&#47;": "/"
}
  , unescapeHtmlEntity = xt => htmlEntities[xt]
  , unescape$1 = xt => xt.replace(matchHtmlEntity, unescapeHtmlEntity);
let defaultOptions$2 = {
    bindI18n: "languageChanged",
    bindI18nStore: "",
    transEmptyNodeValue: "",
    transSupportBasicHtmlNodes: !0,
    transWrapTextNodes: "",
    transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
    useSuspense: !0,
    unescape: unescape$1
};
const setDefaults = (xt={}) => {
    defaultOptions$2 = {
        ...defaultOptions$2,
        ...xt
    }
}
  , getDefaults = () => defaultOptions$2;
let i18nInstance;
const setI18n = xt => {
    i18nInstance = xt
}
  , getI18n = () => i18nInstance
  , initReactI18next = {
    type: "3rdParty",
    init(xt) {
        setDefaults(xt.options.react),
        setI18n(xt)
    }
}
  , I18nContext$1 = reactExports.createContext();
class ReportNamespaces {
    constructor() {
        this.usedNamespaces = {}
    }
    addUsedNamespaces(Cn) {
        Cn.forEach(as => {
            this.usedNamespaces[as] || (this.usedNamespaces[as] = !0)
        }
        )
    }
    getUsedNamespaces() {
        return Object.keys(this.usedNamespaces)
    }
}
const usePrevious = (xt, Cn) => {
    const as = reactExports.useRef();
    return reactExports.useEffect( () => {
        as.current = xt
    }
    , [xt, Cn]),
    as.current
}
  , alwaysNewT = (xt, Cn, as, cs) => xt.getFixedT(Cn, as, cs)
  , useMemoizedT = (xt, Cn, as, cs) => reactExports.useCallback(alwaysNewT(xt, Cn, as, cs), [xt, Cn, as, cs])
  , useTranslation = (xt, Cn={}) => {
    var Rl, Il, Ml, Nl;
    const {i18n: as} = Cn
      , {i18n: cs, defaultNS: Cs} = reactExports.useContext(I18nContext$1) || {}
      , Ls = as || cs || getI18n();
    if (Ls && !Ls.reportNamespaces && (Ls.reportNamespaces = new ReportNamespaces),
    !Ls) {
        warnOnce(Ls, "NO_I18NEXT_INSTANCE", "useTranslation: You will need to pass in an i18next instance by using initReactI18next");
        const Ll = (Ul, Dl) => isString$2(Dl) ? Dl : isObject$2(Dl) && isString$2(Dl.defaultValue) ? Dl.defaultValue : Array.isArray(Ul) ? Ul[Ul.length - 1] : Ul
          , Fl = [Ll, {}, !1];
        return Fl.t = Ll,
        Fl.i18n = {},
        Fl.ready = !1,
        Fl
    }
    (Rl = Ls.options.react) != null && Rl.wait && warnOnce(Ls, "DEPRECATED_OPTION", "useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
    const Vs = {
        ...getDefaults(),
        ...Ls.options.react,
        ...Cn
    }
      , {useSuspense: Ws, keyPrefix: Xs} = Vs;
    let ga = Cs || ((Il = Ls.options) == null ? void 0 : Il.defaultNS);
    ga = isString$2(ga) ? [ga] : ga || ["translation"],
    (Nl = (Ml = Ls.reportNamespaces).addUsedNamespaces) == null || Nl.call(Ml, ga);
    const ba = (Ls.isInitialized || Ls.initializedStoreOnce) && ga.every(Ll => hasLoadedNamespace(Ll, Ls, Vs))
      , yl = useMemoizedT(Ls, Cn.lng || null, Vs.nsMode === "fallback" ? ga : ga[0], Xs)
      , xl = () => yl
      , wl = () => alwaysNewT(Ls, Cn.lng || null, Vs.nsMode === "fallback" ? ga : ga[0], Xs)
      , [_l,El] = reactExports.useState(xl);
    let Cl = ga.join();
    Cn.lng && (Cl = `${Cn.lng}${Cl}`);
    const $l = usePrevious(Cl)
      , Sl = reactExports.useRef(!0);
    reactExports.useEffect( () => {
        const {bindI18n: Ll, bindI18nStore: Fl} = Vs;
        Sl.current = !0,
        !ba && !Ws && (Cn.lng ? loadLanguages(Ls, Cn.lng, ga, () => {
            Sl.current && El(wl)
        }
        ) : loadNamespaces(Ls, ga, () => {
            Sl.current && El(wl)
        }
        )),
        ba && $l && $l !== Cl && Sl.current && El(wl);
        const Ul = () => {
            Sl.current && El(wl)
        }
        ;
        return Ll && (Ls == null || Ls.on(Ll, Ul)),
        Fl && (Ls == null || Ls.store.on(Fl, Ul)),
        () => {
            Sl.current = !1,
            Ls && (Ll == null || Ll.split(" ").forEach(Dl => Ls.off(Dl, Ul))),
            Fl && Ls && Fl.split(" ").forEach(Dl => Ls.store.off(Dl, Ul))
        }
    }
    , [Ls, Cl]),
    reactExports.useEffect( () => {
        Sl.current && ba && El(xl)
    }
    , [Ls, Xs, ba]);
    const Tl = [_l, Ls, ba];
    if (Tl.t = _l,
    Tl.i18n = Ls,
    Tl.ready = ba,
    ba || !ba && !Ws)
        return Tl;
    throw new Promise(Ll => {
        Cn.lng ? loadLanguages(Ls, Cn.lng, ga, () => Ll()) : loadNamespaces(Ls, ga, () => Ll())
    }
    )
}
;
var naclUtil = {
    exports: {}
};
(function(xt) {
    (function(Cn, as) {
        xt.exports ? xt.exports = as() : (Cn.nacl || (Cn.nacl = {}),
        Cn.nacl.util = as())
    }
    )(commonjsGlobal, function() {
        var Cn = {};
        function as(cs) {
            if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(cs))
                throw new TypeError("invalid encoding")
        }
        return Cn.decodeUTF8 = function(cs) {
            if (typeof cs != "string")
                throw new TypeError("expected string");
            var Cs, Ls = unescape(encodeURIComponent(cs)), Vs = new Uint8Array(Ls.length);
            for (Cs = 0; Cs < Ls.length; Cs++)
                Vs[Cs] = Ls.charCodeAt(Cs);
            return Vs
        }
        ,
        Cn.encodeUTF8 = function(cs) {
            var Cs, Ls = [];
            for (Cs = 0; Cs < cs.length; Cs++)
                Ls.push(String.fromCharCode(cs[Cs]));
            return decodeURIComponent(escape(Ls.join("")))
        }
        ,
        typeof atob > "u" ? typeof Buffer.from < "u" ? (Cn.encodeBase64 = function(cs) {
            return Buffer.from(cs).toString("base64")
        }
        ,
        Cn.decodeBase64 = function(cs) {
            return as(cs),
            new Uint8Array(Array.prototype.slice.call(Buffer.from(cs, "base64"), 0))
        }
        ) : (Cn.encodeBase64 = function(cs) {
            return new Buffer(cs).toString("base64")
        }
        ,
        Cn.decodeBase64 = function(cs) {
            return as(cs),
            new Uint8Array(Array.prototype.slice.call(new Buffer(cs,"base64"), 0))
        }
        ) : (Cn.encodeBase64 = function(cs) {
            var Cs, Ls = [], Vs = cs.length;
            for (Cs = 0; Cs < Vs; Cs++)
                Ls.push(String.fromCharCode(cs[Cs]));
            return btoa(Ls.join(""))
        }
        ,
        Cn.decodeBase64 = function(cs) {
            as(cs);
            var Cs, Ls = atob(cs), Vs = new Uint8Array(Ls.length);
            for (Cs = 0; Cs < Ls.length; Cs++)
                Vs[Cs] = Ls.charCodeAt(Cs);
            return Vs
        }
        ),
        Cn
    })
}
)(naclUtil);
var naclUtilExports = naclUtil.exports;
const nacl$2 = getDefaultExportFromCjs(naclUtilExports);
function commonjsRequire(xt) {
    throw new Error('Could not dynamically require "' + xt + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
}
var naclFast = {
    exports: {}
};
const __viteBrowserExternal = {}
  , __viteBrowserExternal$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$0 = getAugmentedNamespace(__viteBrowserExternal$1);
(function(xt) {
    (function(Cn) {
        var as = function(Hl) {
            var Jl, Xl = new Float64Array(16);
            if (Hl)
                for (Jl = 0; Jl < Hl.length; Jl++)
                    Xl[Jl] = Hl[Jl];
            return Xl
        }
          , cs = function() {
            throw new Error("no PRNG")
        }
          , Cs = new Uint8Array(16)
          , Ls = new Uint8Array(32);
        Ls[0] = 9;
        var Vs = as()
          , Ws = as([1])
          , Xs = as([56129, 1])
          , ga = as([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995])
          , ba = as([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222])
          , yl = as([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553])
          , xl = as([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214])
          , wl = as([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
        function _l(Hl, Jl, Xl, Ol) {
            Hl[Jl] = Xl >> 24 & 255,
            Hl[Jl + 1] = Xl >> 16 & 255,
            Hl[Jl + 2] = Xl >> 8 & 255,
            Hl[Jl + 3] = Xl & 255,
            Hl[Jl + 4] = Ol >> 24 & 255,
            Hl[Jl + 5] = Ol >> 16 & 255,
            Hl[Jl + 6] = Ol >> 8 & 255,
            Hl[Jl + 7] = Ol & 255
        }
        function El(Hl, Jl, Xl, Ol, tu) {
            var bu, wu = 0;
            for (bu = 0; bu < tu; bu++)
                wu |= Hl[Jl + bu] ^ Xl[Ol + bu];
            return (1 & wu - 1 >>> 8) - 1
        }
        function Cl(Hl, Jl, Xl, Ol) {
            return El(Hl, Jl, Xl, Ol, 16)
        }
        function $l(Hl, Jl, Xl, Ol) {
            return El(Hl, Jl, Xl, Ol, 32)
        }
        function Sl(Hl, Jl, Xl, Ol) {
            for (var tu = Ol[0] & 255 | (Ol[1] & 255) << 8 | (Ol[2] & 255) << 16 | (Ol[3] & 255) << 24, bu = Xl[0] & 255 | (Xl[1] & 255) << 8 | (Xl[2] & 255) << 16 | (Xl[3] & 255) << 24, wu = Xl[4] & 255 | (Xl[5] & 255) << 8 | (Xl[6] & 255) << 16 | (Xl[7] & 255) << 24, Ou = Xl[8] & 255 | (Xl[9] & 255) << 8 | (Xl[10] & 255) << 16 | (Xl[11] & 255) << 24, zu = Xl[12] & 255 | (Xl[13] & 255) << 8 | (Xl[14] & 255) << 16 | (Xl[15] & 255) << 24, op = Ol[4] & 255 | (Ol[5] & 255) << 8 | (Ol[6] & 255) << 16 | (Ol[7] & 255) << 24, Ju = Jl[0] & 255 | (Jl[1] & 255) << 8 | (Jl[2] & 255) << 16 | (Jl[3] & 255) << 24, Ip = Jl[4] & 255 | (Jl[5] & 255) << 8 | (Jl[6] & 255) << 16 | (Jl[7] & 255) << 24, tp = Jl[8] & 255 | (Jl[9] & 255) << 8 | (Jl[10] & 255) << 16 | (Jl[11] & 255) << 24, pp = Jl[12] & 255 | (Jl[13] & 255) << 8 | (Jl[14] & 255) << 16 | (Jl[15] & 255) << 24, mp = Ol[8] & 255 | (Ol[9] & 255) << 8 | (Ol[10] & 255) << 16 | (Ol[11] & 255) << 24, bp = Xl[16] & 255 | (Xl[17] & 255) << 8 | (Xl[18] & 255) << 16 | (Xl[19] & 255) << 24, xp = Xl[20] & 255 | (Xl[21] & 255) << 8 | (Xl[22] & 255) << 16 | (Xl[23] & 255) << 24, gp = Xl[24] & 255 | (Xl[25] & 255) << 8 | (Xl[26] & 255) << 16 | (Xl[27] & 255) << 24, vp = Xl[28] & 255 | (Xl[29] & 255) << 8 | (Xl[30] & 255) << 16 | (Xl[31] & 255) << 24, yp = Ol[12] & 255 | (Ol[13] & 255) << 8 | (Ol[14] & 255) << 16 | (Ol[15] & 255) << 24, np = tu, ap = bu, ep = wu, rp = Ou, sp = zu, Xu = op, $u = Ju, Su = Ip, Vu = tp, Nu = pp, Fu = mp, Wu = bp, cp = xp, wp = gp, _p = vp, Ep = yp, hu, $p = 0; $p < 20; $p += 2)
                hu = np + cp | 0,
                sp ^= hu << 7 | hu >>> 25,
                hu = sp + np | 0,
                Vu ^= hu << 9 | hu >>> 23,
                hu = Vu + sp | 0,
                cp ^= hu << 13 | hu >>> 19,
                hu = cp + Vu | 0,
                np ^= hu << 18 | hu >>> 14,
                hu = Xu + ap | 0,
                Nu ^= hu << 7 | hu >>> 25,
                hu = Nu + Xu | 0,
                wp ^= hu << 9 | hu >>> 23,
                hu = wp + Nu | 0,
                ap ^= hu << 13 | hu >>> 19,
                hu = ap + wp | 0,
                Xu ^= hu << 18 | hu >>> 14,
                hu = Fu + $u | 0,
                _p ^= hu << 7 | hu >>> 25,
                hu = _p + Fu | 0,
                ep ^= hu << 9 | hu >>> 23,
                hu = ep + _p | 0,
                $u ^= hu << 13 | hu >>> 19,
                hu = $u + ep | 0,
                Fu ^= hu << 18 | hu >>> 14,
                hu = Ep + Wu | 0,
                rp ^= hu << 7 | hu >>> 25,
                hu = rp + Ep | 0,
                Su ^= hu << 9 | hu >>> 23,
                hu = Su + rp | 0,
                Wu ^= hu << 13 | hu >>> 19,
                hu = Wu + Su | 0,
                Ep ^= hu << 18 | hu >>> 14,
                hu = np + rp | 0,
                ap ^= hu << 7 | hu >>> 25,
                hu = ap + np | 0,
                ep ^= hu << 9 | hu >>> 23,
                hu = ep + ap | 0,
                rp ^= hu << 13 | hu >>> 19,
                hu = rp + ep | 0,
                np ^= hu << 18 | hu >>> 14,
                hu = Xu + sp | 0,
                $u ^= hu << 7 | hu >>> 25,
                hu = $u + Xu | 0,
                Su ^= hu << 9 | hu >>> 23,
                hu = Su + $u | 0,
                sp ^= hu << 13 | hu >>> 19,
                hu = sp + Su | 0,
                Xu ^= hu << 18 | hu >>> 14,
                hu = Fu + Nu | 0,
                Wu ^= hu << 7 | hu >>> 25,
                hu = Wu + Fu | 0,
                Vu ^= hu << 9 | hu >>> 23,
                hu = Vu + Wu | 0,
                Nu ^= hu << 13 | hu >>> 19,
                hu = Nu + Vu | 0,
                Fu ^= hu << 18 | hu >>> 14,
                hu = Ep + _p | 0,
                cp ^= hu << 7 | hu >>> 25,
                hu = cp + Ep | 0,
                wp ^= hu << 9 | hu >>> 23,
                hu = wp + cp | 0,
                _p ^= hu << 13 | hu >>> 19,
                hu = _p + wp | 0,
                Ep ^= hu << 18 | hu >>> 14;
            np = np + tu | 0,
            ap = ap + bu | 0,
            ep = ep + wu | 0,
            rp = rp + Ou | 0,
            sp = sp + zu | 0,
            Xu = Xu + op | 0,
            $u = $u + Ju | 0,
            Su = Su + Ip | 0,
            Vu = Vu + tp | 0,
            Nu = Nu + pp | 0,
            Fu = Fu + mp | 0,
            Wu = Wu + bp | 0,
            cp = cp + xp | 0,
            wp = wp + gp | 0,
            _p = _p + vp | 0,
            Ep = Ep + yp | 0,
            Hl[0] = np >>> 0 & 255,
            Hl[1] = np >>> 8 & 255,
            Hl[2] = np >>> 16 & 255,
            Hl[3] = np >>> 24 & 255,
            Hl[4] = ap >>> 0 & 255,
            Hl[5] = ap >>> 8 & 255,
            Hl[6] = ap >>> 16 & 255,
            Hl[7] = ap >>> 24 & 255,
            Hl[8] = ep >>> 0 & 255,
            Hl[9] = ep >>> 8 & 255,
            Hl[10] = ep >>> 16 & 255,
            Hl[11] = ep >>> 24 & 255,
            Hl[12] = rp >>> 0 & 255,
            Hl[13] = rp >>> 8 & 255,
            Hl[14] = rp >>> 16 & 255,
            Hl[15] = rp >>> 24 & 255,
            Hl[16] = sp >>> 0 & 255,
            Hl[17] = sp >>> 8 & 255,
            Hl[18] = sp >>> 16 & 255,
            Hl[19] = sp >>> 24 & 255,
            Hl[20] = Xu >>> 0 & 255,
            Hl[21] = Xu >>> 8 & 255,
            Hl[22] = Xu >>> 16 & 255,
            Hl[23] = Xu >>> 24 & 255,
            Hl[24] = $u >>> 0 & 255,
            Hl[25] = $u >>> 8 & 255,
            Hl[26] = $u >>> 16 & 255,
            Hl[27] = $u >>> 24 & 255,
            Hl[28] = Su >>> 0 & 255,
            Hl[29] = Su >>> 8 & 255,
            Hl[30] = Su >>> 16 & 255,
            Hl[31] = Su >>> 24 & 255,
            Hl[32] = Vu >>> 0 & 255,
            Hl[33] = Vu >>> 8 & 255,
            Hl[34] = Vu >>> 16 & 255,
            Hl[35] = Vu >>> 24 & 255,
            Hl[36] = Nu >>> 0 & 255,
            Hl[37] = Nu >>> 8 & 255,
            Hl[38] = Nu >>> 16 & 255,
            Hl[39] = Nu >>> 24 & 255,
            Hl[40] = Fu >>> 0 & 255,
            Hl[41] = Fu >>> 8 & 255,
            Hl[42] = Fu >>> 16 & 255,
            Hl[43] = Fu >>> 24 & 255,
            Hl[44] = Wu >>> 0 & 255,
            Hl[45] = Wu >>> 8 & 255,
            Hl[46] = Wu >>> 16 & 255,
            Hl[47] = Wu >>> 24 & 255,
            Hl[48] = cp >>> 0 & 255,
            Hl[49] = cp >>> 8 & 255,
            Hl[50] = cp >>> 16 & 255,
            Hl[51] = cp >>> 24 & 255,
            Hl[52] = wp >>> 0 & 255,
            Hl[53] = wp >>> 8 & 255,
            Hl[54] = wp >>> 16 & 255,
            Hl[55] = wp >>> 24 & 255,
            Hl[56] = _p >>> 0 & 255,
            Hl[57] = _p >>> 8 & 255,
            Hl[58] = _p >>> 16 & 255,
            Hl[59] = _p >>> 24 & 255,
            Hl[60] = Ep >>> 0 & 255,
            Hl[61] = Ep >>> 8 & 255,
            Hl[62] = Ep >>> 16 & 255,
            Hl[63] = Ep >>> 24 & 255
        }
        function Tl(Hl, Jl, Xl, Ol) {
            for (var tu = Ol[0] & 255 | (Ol[1] & 255) << 8 | (Ol[2] & 255) << 16 | (Ol[3] & 255) << 24, bu = Xl[0] & 255 | (Xl[1] & 255) << 8 | (Xl[2] & 255) << 16 | (Xl[3] & 255) << 24, wu = Xl[4] & 255 | (Xl[5] & 255) << 8 | (Xl[6] & 255) << 16 | (Xl[7] & 255) << 24, Ou = Xl[8] & 255 | (Xl[9] & 255) << 8 | (Xl[10] & 255) << 16 | (Xl[11] & 255) << 24, zu = Xl[12] & 255 | (Xl[13] & 255) << 8 | (Xl[14] & 255) << 16 | (Xl[15] & 255) << 24, op = Ol[4] & 255 | (Ol[5] & 255) << 8 | (Ol[6] & 255) << 16 | (Ol[7] & 255) << 24, Ju = Jl[0] & 255 | (Jl[1] & 255) << 8 | (Jl[2] & 255) << 16 | (Jl[3] & 255) << 24, Ip = Jl[4] & 255 | (Jl[5] & 255) << 8 | (Jl[6] & 255) << 16 | (Jl[7] & 255) << 24, tp = Jl[8] & 255 | (Jl[9] & 255) << 8 | (Jl[10] & 255) << 16 | (Jl[11] & 255) << 24, pp = Jl[12] & 255 | (Jl[13] & 255) << 8 | (Jl[14] & 255) << 16 | (Jl[15] & 255) << 24, mp = Ol[8] & 255 | (Ol[9] & 255) << 8 | (Ol[10] & 255) << 16 | (Ol[11] & 255) << 24, bp = Xl[16] & 255 | (Xl[17] & 255) << 8 | (Xl[18] & 255) << 16 | (Xl[19] & 255) << 24, xp = Xl[20] & 255 | (Xl[21] & 255) << 8 | (Xl[22] & 255) << 16 | (Xl[23] & 255) << 24, gp = Xl[24] & 255 | (Xl[25] & 255) << 8 | (Xl[26] & 255) << 16 | (Xl[27] & 255) << 24, vp = Xl[28] & 255 | (Xl[29] & 255) << 8 | (Xl[30] & 255) << 16 | (Xl[31] & 255) << 24, yp = Ol[12] & 255 | (Ol[13] & 255) << 8 | (Ol[14] & 255) << 16 | (Ol[15] & 255) << 24, np = tu, ap = bu, ep = wu, rp = Ou, sp = zu, Xu = op, $u = Ju, Su = Ip, Vu = tp, Nu = pp, Fu = mp, Wu = bp, cp = xp, wp = gp, _p = vp, Ep = yp, hu, $p = 0; $p < 20; $p += 2)
                hu = np + cp | 0,
                sp ^= hu << 7 | hu >>> 25,
                hu = sp + np | 0,
                Vu ^= hu << 9 | hu >>> 23,
                hu = Vu + sp | 0,
                cp ^= hu << 13 | hu >>> 19,
                hu = cp + Vu | 0,
                np ^= hu << 18 | hu >>> 14,
                hu = Xu + ap | 0,
                Nu ^= hu << 7 | hu >>> 25,
                hu = Nu + Xu | 0,
                wp ^= hu << 9 | hu >>> 23,
                hu = wp + Nu | 0,
                ap ^= hu << 13 | hu >>> 19,
                hu = ap + wp | 0,
                Xu ^= hu << 18 | hu >>> 14,
                hu = Fu + $u | 0,
                _p ^= hu << 7 | hu >>> 25,
                hu = _p + Fu | 0,
                ep ^= hu << 9 | hu >>> 23,
                hu = ep + _p | 0,
                $u ^= hu << 13 | hu >>> 19,
                hu = $u + ep | 0,
                Fu ^= hu << 18 | hu >>> 14,
                hu = Ep + Wu | 0,
                rp ^= hu << 7 | hu >>> 25,
                hu = rp + Ep | 0,
                Su ^= hu << 9 | hu >>> 23,
                hu = Su + rp | 0,
                Wu ^= hu << 13 | hu >>> 19,
                hu = Wu + Su | 0,
                Ep ^= hu << 18 | hu >>> 14,
                hu = np + rp | 0,
                ap ^= hu << 7 | hu >>> 25,
                hu = ap + np | 0,
                ep ^= hu << 9 | hu >>> 23,
                hu = ep + ap | 0,
                rp ^= hu << 13 | hu >>> 19,
                hu = rp + ep | 0,
                np ^= hu << 18 | hu >>> 14,
                hu = Xu + sp | 0,
                $u ^= hu << 7 | hu >>> 25,
                hu = $u + Xu | 0,
                Su ^= hu << 9 | hu >>> 23,
                hu = Su + $u | 0,
                sp ^= hu << 13 | hu >>> 19,
                hu = sp + Su | 0,
                Xu ^= hu << 18 | hu >>> 14,
                hu = Fu + Nu | 0,
                Wu ^= hu << 7 | hu >>> 25,
                hu = Wu + Fu | 0,
                Vu ^= hu << 9 | hu >>> 23,
                hu = Vu + Wu | 0,
                Nu ^= hu << 13 | hu >>> 19,
                hu = Nu + Vu | 0,
                Fu ^= hu << 18 | hu >>> 14,
                hu = Ep + _p | 0,
                cp ^= hu << 7 | hu >>> 25,
                hu = cp + Ep | 0,
                wp ^= hu << 9 | hu >>> 23,
                hu = wp + cp | 0,
                _p ^= hu << 13 | hu >>> 19,
                hu = _p + wp | 0,
                Ep ^= hu << 18 | hu >>> 14;
            Hl[0] = np >>> 0 & 255,
            Hl[1] = np >>> 8 & 255,
            Hl[2] = np >>> 16 & 255,
            Hl[3] = np >>> 24 & 255,
            Hl[4] = Xu >>> 0 & 255,
            Hl[5] = Xu >>> 8 & 255,
            Hl[6] = Xu >>> 16 & 255,
            Hl[7] = Xu >>> 24 & 255,
            Hl[8] = Fu >>> 0 & 255,
            Hl[9] = Fu >>> 8 & 255,
            Hl[10] = Fu >>> 16 & 255,
            Hl[11] = Fu >>> 24 & 255,
            Hl[12] = Ep >>> 0 & 255,
            Hl[13] = Ep >>> 8 & 255,
            Hl[14] = Ep >>> 16 & 255,
            Hl[15] = Ep >>> 24 & 255,
            Hl[16] = $u >>> 0 & 255,
            Hl[17] = $u >>> 8 & 255,
            Hl[18] = $u >>> 16 & 255,
            Hl[19] = $u >>> 24 & 255,
            Hl[20] = Su >>> 0 & 255,
            Hl[21] = Su >>> 8 & 255,
            Hl[22] = Su >>> 16 & 255,
            Hl[23] = Su >>> 24 & 255,
            Hl[24] = Vu >>> 0 & 255,
            Hl[25] = Vu >>> 8 & 255,
            Hl[26] = Vu >>> 16 & 255,
            Hl[27] = Vu >>> 24 & 255,
            Hl[28] = Nu >>> 0 & 255,
            Hl[29] = Nu >>> 8 & 255,
            Hl[30] = Nu >>> 16 & 255,
            Hl[31] = Nu >>> 24 & 255
        }
        function Rl(Hl, Jl, Xl, Ol) {
            Sl(Hl, Jl, Xl, Ol)
        }
        function Il(Hl, Jl, Xl, Ol) {
            Tl(Hl, Jl, Xl, Ol)
        }
        var Ml = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
        function Nl(Hl, Jl, Xl, Ol, tu, bu, wu) {
            var Ou = new Uint8Array(16), zu = new Uint8Array(64), op, Ju;
            for (Ju = 0; Ju < 16; Ju++)
                Ou[Ju] = 0;
            for (Ju = 0; Ju < 8; Ju++)
                Ou[Ju] = bu[Ju];
            for (; tu >= 64; ) {
                for (Rl(zu, Ou, wu, Ml),
                Ju = 0; Ju < 64; Ju++)
                    Hl[Jl + Ju] = Xl[Ol + Ju] ^ zu[Ju];
                for (op = 1,
                Ju = 8; Ju < 16; Ju++)
                    op = op + (Ou[Ju] & 255) | 0,
                    Ou[Ju] = op & 255,
                    op >>>= 8;
                tu -= 64,
                Jl += 64,
                Ol += 64
            }
            if (tu > 0)
                for (Rl(zu, Ou, wu, Ml),
                Ju = 0; Ju < tu; Ju++)
                    Hl[Jl + Ju] = Xl[Ol + Ju] ^ zu[Ju];
            return 0
        }
        function Ll(Hl, Jl, Xl, Ol, tu) {
            var bu = new Uint8Array(16), wu = new Uint8Array(64), Ou, zu;
            for (zu = 0; zu < 16; zu++)
                bu[zu] = 0;
            for (zu = 0; zu < 8; zu++)
                bu[zu] = Ol[zu];
            for (; Xl >= 64; ) {
                for (Rl(wu, bu, tu, Ml),
                zu = 0; zu < 64; zu++)
                    Hl[Jl + zu] = wu[zu];
                for (Ou = 1,
                zu = 8; zu < 16; zu++)
                    Ou = Ou + (bu[zu] & 255) | 0,
                    bu[zu] = Ou & 255,
                    Ou >>>= 8;
                Xl -= 64,
                Jl += 64
            }
            if (Xl > 0)
                for (Rl(wu, bu, tu, Ml),
                zu = 0; zu < Xl; zu++)
                    Hl[Jl + zu] = wu[zu];
            return 0
        }
        function Fl(Hl, Jl, Xl, Ol, tu) {
            var bu = new Uint8Array(32);
            Il(bu, Ol, tu, Ml);
            for (var wu = new Uint8Array(8), Ou = 0; Ou < 8; Ou++)
                wu[Ou] = Ol[Ou + 16];
            return Ll(Hl, Jl, Xl, wu, bu)
        }
        function Ul(Hl, Jl, Xl, Ol, tu, bu, wu) {
            var Ou = new Uint8Array(32);
            Il(Ou, bu, wu, Ml);
            for (var zu = new Uint8Array(8), op = 0; op < 8; op++)
                zu[op] = bu[op + 16];
            return Nl(Hl, Jl, Xl, Ol, tu, zu, Ou)
        }
        var Dl = function(Hl) {
            this.buffer = new Uint8Array(16),
            this.r = new Uint16Array(10),
            this.h = new Uint16Array(10),
            this.pad = new Uint16Array(8),
            this.leftover = 0,
            this.fin = 0;
            var Jl, Xl, Ol, tu, bu, wu, Ou, zu;
            Jl = Hl[0] & 255 | (Hl[1] & 255) << 8,
            this.r[0] = Jl & 8191,
            Xl = Hl[2] & 255 | (Hl[3] & 255) << 8,
            this.r[1] = (Jl >>> 13 | Xl << 3) & 8191,
            Ol = Hl[4] & 255 | (Hl[5] & 255) << 8,
            this.r[2] = (Xl >>> 10 | Ol << 6) & 7939,
            tu = Hl[6] & 255 | (Hl[7] & 255) << 8,
            this.r[3] = (Ol >>> 7 | tu << 9) & 8191,
            bu = Hl[8] & 255 | (Hl[9] & 255) << 8,
            this.r[4] = (tu >>> 4 | bu << 12) & 255,
            this.r[5] = bu >>> 1 & 8190,
            wu = Hl[10] & 255 | (Hl[11] & 255) << 8,
            this.r[6] = (bu >>> 14 | wu << 2) & 8191,
            Ou = Hl[12] & 255 | (Hl[13] & 255) << 8,
            this.r[7] = (wu >>> 11 | Ou << 5) & 8065,
            zu = Hl[14] & 255 | (Hl[15] & 255) << 8,
            this.r[8] = (Ou >>> 8 | zu << 8) & 8191,
            this.r[9] = zu >>> 5 & 127,
            this.pad[0] = Hl[16] & 255 | (Hl[17] & 255) << 8,
            this.pad[1] = Hl[18] & 255 | (Hl[19] & 255) << 8,
            this.pad[2] = Hl[20] & 255 | (Hl[21] & 255) << 8,
            this.pad[3] = Hl[22] & 255 | (Hl[23] & 255) << 8,
            this.pad[4] = Hl[24] & 255 | (Hl[25] & 255) << 8,
            this.pad[5] = Hl[26] & 255 | (Hl[27] & 255) << 8,
            this.pad[6] = Hl[28] & 255 | (Hl[29] & 255) << 8,
            this.pad[7] = Hl[30] & 255 | (Hl[31] & 255) << 8
        };
        Dl.prototype.blocks = function(Hl, Jl, Xl) {
            for (var Ol = this.fin ? 0 : 2048, tu, bu, wu, Ou, zu, op, Ju, Ip, tp, pp, mp, bp, xp, gp, vp, yp, np, ap, ep, rp = this.h[0], sp = this.h[1], Xu = this.h[2], $u = this.h[3], Su = this.h[4], Vu = this.h[5], Nu = this.h[6], Fu = this.h[7], Wu = this.h[8], cp = this.h[9], wp = this.r[0], _p = this.r[1], Ep = this.r[2], hu = this.r[3], $p = this.r[4], Ap = this.r[5], Mp = this.r[6], Cp = this.r[7], Rp = this.r[8], Pp = this.r[9]; Xl >= 16; )
                tu = Hl[Jl + 0] & 255 | (Hl[Jl + 1] & 255) << 8,
                rp += tu & 8191,
                bu = Hl[Jl + 2] & 255 | (Hl[Jl + 3] & 255) << 8,
                sp += (tu >>> 13 | bu << 3) & 8191,
                wu = Hl[Jl + 4] & 255 | (Hl[Jl + 5] & 255) << 8,
                Xu += (bu >>> 10 | wu << 6) & 8191,
                Ou = Hl[Jl + 6] & 255 | (Hl[Jl + 7] & 255) << 8,
                $u += (wu >>> 7 | Ou << 9) & 8191,
                zu = Hl[Jl + 8] & 255 | (Hl[Jl + 9] & 255) << 8,
                Su += (Ou >>> 4 | zu << 12) & 8191,
                Vu += zu >>> 1 & 8191,
                op = Hl[Jl + 10] & 255 | (Hl[Jl + 11] & 255) << 8,
                Nu += (zu >>> 14 | op << 2) & 8191,
                Ju = Hl[Jl + 12] & 255 | (Hl[Jl + 13] & 255) << 8,
                Fu += (op >>> 11 | Ju << 5) & 8191,
                Ip = Hl[Jl + 14] & 255 | (Hl[Jl + 15] & 255) << 8,
                Wu += (Ju >>> 8 | Ip << 8) & 8191,
                cp += Ip >>> 5 | Ol,
                tp = 0,
                pp = tp,
                pp += rp * wp,
                pp += sp * (5 * Pp),
                pp += Xu * (5 * Rp),
                pp += $u * (5 * Cp),
                pp += Su * (5 * Mp),
                tp = pp >>> 13,
                pp &= 8191,
                pp += Vu * (5 * Ap),
                pp += Nu * (5 * $p),
                pp += Fu * (5 * hu),
                pp += Wu * (5 * Ep),
                pp += cp * (5 * _p),
                tp += pp >>> 13,
                pp &= 8191,
                mp = tp,
                mp += rp * _p,
                mp += sp * wp,
                mp += Xu * (5 * Pp),
                mp += $u * (5 * Rp),
                mp += Su * (5 * Cp),
                tp = mp >>> 13,
                mp &= 8191,
                mp += Vu * (5 * Mp),
                mp += Nu * (5 * Ap),
                mp += Fu * (5 * $p),
                mp += Wu * (5 * hu),
                mp += cp * (5 * Ep),
                tp += mp >>> 13,
                mp &= 8191,
                bp = tp,
                bp += rp * Ep,
                bp += sp * _p,
                bp += Xu * wp,
                bp += $u * (5 * Pp),
                bp += Su * (5 * Rp),
                tp = bp >>> 13,
                bp &= 8191,
                bp += Vu * (5 * Cp),
                bp += Nu * (5 * Mp),
                bp += Fu * (5 * Ap),
                bp += Wu * (5 * $p),
                bp += cp * (5 * hu),
                tp += bp >>> 13,
                bp &= 8191,
                xp = tp,
                xp += rp * hu,
                xp += sp * Ep,
                xp += Xu * _p,
                xp += $u * wp,
                xp += Su * (5 * Pp),
                tp = xp >>> 13,
                xp &= 8191,
                xp += Vu * (5 * Rp),
                xp += Nu * (5 * Cp),
                xp += Fu * (5 * Mp),
                xp += Wu * (5 * Ap),
                xp += cp * (5 * $p),
                tp += xp >>> 13,
                xp &= 8191,
                gp = tp,
                gp += rp * $p,
                gp += sp * hu,
                gp += Xu * Ep,
                gp += $u * _p,
                gp += Su * wp,
                tp = gp >>> 13,
                gp &= 8191,
                gp += Vu * (5 * Pp),
                gp += Nu * (5 * Rp),
                gp += Fu * (5 * Cp),
                gp += Wu * (5 * Mp),
                gp += cp * (5 * Ap),
                tp += gp >>> 13,
                gp &= 8191,
                vp = tp,
                vp += rp * Ap,
                vp += sp * $p,
                vp += Xu * hu,
                vp += $u * Ep,
                vp += Su * _p,
                tp = vp >>> 13,
                vp &= 8191,
                vp += Vu * wp,
                vp += Nu * (5 * Pp),
                vp += Fu * (5 * Rp),
                vp += Wu * (5 * Cp),
                vp += cp * (5 * Mp),
                tp += vp >>> 13,
                vp &= 8191,
                yp = tp,
                yp += rp * Mp,
                yp += sp * Ap,
                yp += Xu * $p,
                yp += $u * hu,
                yp += Su * Ep,
                tp = yp >>> 13,
                yp &= 8191,
                yp += Vu * _p,
                yp += Nu * wp,
                yp += Fu * (5 * Pp),
                yp += Wu * (5 * Rp),
                yp += cp * (5 * Cp),
                tp += yp >>> 13,
                yp &= 8191,
                np = tp,
                np += rp * Cp,
                np += sp * Mp,
                np += Xu * Ap,
                np += $u * $p,
                np += Su * hu,
                tp = np >>> 13,
                np &= 8191,
                np += Vu * Ep,
                np += Nu * _p,
                np += Fu * wp,
                np += Wu * (5 * Pp),
                np += cp * (5 * Rp),
                tp += np >>> 13,
                np &= 8191,
                ap = tp,
                ap += rp * Rp,
                ap += sp * Cp,
                ap += Xu * Mp,
                ap += $u * Ap,
                ap += Su * $p,
                tp = ap >>> 13,
                ap &= 8191,
                ap += Vu * hu,
                ap += Nu * Ep,
                ap += Fu * _p,
                ap += Wu * wp,
                ap += cp * (5 * Pp),
                tp += ap >>> 13,
                ap &= 8191,
                ep = tp,
                ep += rp * Pp,
                ep += sp * Rp,
                ep += Xu * Cp,
                ep += $u * Mp,
                ep += Su * Ap,
                tp = ep >>> 13,
                ep &= 8191,
                ep += Vu * $p,
                ep += Nu * hu,
                ep += Fu * Ep,
                ep += Wu * _p,
                ep += cp * wp,
                tp += ep >>> 13,
                ep &= 8191,
                tp = (tp << 2) + tp | 0,
                tp = tp + pp | 0,
                pp = tp & 8191,
                tp = tp >>> 13,
                mp += tp,
                rp = pp,
                sp = mp,
                Xu = bp,
                $u = xp,
                Su = gp,
                Vu = vp,
                Nu = yp,
                Fu = np,
                Wu = ap,
                cp = ep,
                Jl += 16,
                Xl -= 16;
            this.h[0] = rp,
            this.h[1] = sp,
            this.h[2] = Xu,
            this.h[3] = $u,
            this.h[4] = Su,
            this.h[5] = Vu,
            this.h[6] = Nu,
            this.h[7] = Fu,
            this.h[8] = Wu,
            this.h[9] = cp
        }
        ,
        Dl.prototype.finish = function(Hl, Jl) {
            var Xl = new Uint16Array(10), Ol, tu, bu, wu;
            if (this.leftover) {
                for (wu = this.leftover,
                this.buffer[wu++] = 1; wu < 16; wu++)
                    this.buffer[wu] = 0;
                this.fin = 1,
                this.blocks(this.buffer, 0, 16)
            }
            for (Ol = this.h[1] >>> 13,
            this.h[1] &= 8191,
            wu = 2; wu < 10; wu++)
                this.h[wu] += Ol,
                Ol = this.h[wu] >>> 13,
                this.h[wu] &= 8191;
            for (this.h[0] += Ol * 5,
            Ol = this.h[0] >>> 13,
            this.h[0] &= 8191,
            this.h[1] += Ol,
            Ol = this.h[1] >>> 13,
            this.h[1] &= 8191,
            this.h[2] += Ol,
            Xl[0] = this.h[0] + 5,
            Ol = Xl[0] >>> 13,
            Xl[0] &= 8191,
            wu = 1; wu < 10; wu++)
                Xl[wu] = this.h[wu] + Ol,
                Ol = Xl[wu] >>> 13,
                Xl[wu] &= 8191;
            for (Xl[9] -= 8192,
            tu = (Ol ^ 1) - 1,
            wu = 0; wu < 10; wu++)
                Xl[wu] &= tu;
            for (tu = ~tu,
            wu = 0; wu < 10; wu++)
                this.h[wu] = this.h[wu] & tu | Xl[wu];
            for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535,
            this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535,
            this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535,
            this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535,
            this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535,
            this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535,
            this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535,
            this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535,
            bu = this.h[0] + this.pad[0],
            this.h[0] = bu & 65535,
            wu = 1; wu < 8; wu++)
                bu = (this.h[wu] + this.pad[wu] | 0) + (bu >>> 16) | 0,
                this.h[wu] = bu & 65535;
            Hl[Jl + 0] = this.h[0] >>> 0 & 255,
            Hl[Jl + 1] = this.h[0] >>> 8 & 255,
            Hl[Jl + 2] = this.h[1] >>> 0 & 255,
            Hl[Jl + 3] = this.h[1] >>> 8 & 255,
            Hl[Jl + 4] = this.h[2] >>> 0 & 255,
            Hl[Jl + 5] = this.h[2] >>> 8 & 255,
            Hl[Jl + 6] = this.h[3] >>> 0 & 255,
            Hl[Jl + 7] = this.h[3] >>> 8 & 255,
            Hl[Jl + 8] = this.h[4] >>> 0 & 255,
            Hl[Jl + 9] = this.h[4] >>> 8 & 255,
            Hl[Jl + 10] = this.h[5] >>> 0 & 255,
            Hl[Jl + 11] = this.h[5] >>> 8 & 255,
            Hl[Jl + 12] = this.h[6] >>> 0 & 255,
            Hl[Jl + 13] = this.h[6] >>> 8 & 255,
            Hl[Jl + 14] = this.h[7] >>> 0 & 255,
            Hl[Jl + 15] = this.h[7] >>> 8 & 255
        }
        ,
        Dl.prototype.update = function(Hl, Jl, Xl) {
            var Ol, tu;
            if (this.leftover) {
                for (tu = 16 - this.leftover,
                tu > Xl && (tu = Xl),
                Ol = 0; Ol < tu; Ol++)
                    this.buffer[this.leftover + Ol] = Hl[Jl + Ol];
                if (Xl -= tu,
                Jl += tu,
                this.leftover += tu,
                this.leftover < 16)
                    return;
                this.blocks(this.buffer, 0, 16),
                this.leftover = 0
            }
            if (Xl >= 16 && (tu = Xl - Xl % 16,
            this.blocks(Hl, Jl, tu),
            Jl += tu,
            Xl -= tu),
            Xl) {
                for (Ol = 0; Ol < Xl; Ol++)
                    this.buffer[this.leftover + Ol] = Hl[Jl + Ol];
                this.leftover += Xl
            }
        }
        ;
        function Zl(Hl, Jl, Xl, Ol, tu, bu) {
            var wu = new Dl(bu);
            return wu.update(Xl, Ol, tu),
            wu.finish(Hl, Jl),
            0
        }
        function Gl(Hl, Jl, Xl, Ol, tu, bu) {
            var wu = new Uint8Array(16);
            return Zl(wu, 0, Xl, Ol, tu, bu),
            Cl(Hl, Jl, wu, 0)
        }
        function Wl(Hl, Jl, Xl, Ol, tu) {
            var bu;
            if (Xl < 32)
                return -1;
            for (Ul(Hl, 0, Jl, 0, Xl, Ol, tu),
            Zl(Hl, 16, Hl, 32, Xl - 32, Hl),
            bu = 0; bu < 16; bu++)
                Hl[bu] = 0;
            return 0
        }
        function Ql(Hl, Jl, Xl, Ol, tu) {
            var bu, wu = new Uint8Array(32);
            if (Xl < 32 || (Fl(wu, 0, 32, Ol, tu),
            Gl(Jl, 16, Jl, 32, Xl - 32, wu) !== 0))
                return -1;
            for (Ul(Hl, 0, Jl, 0, Xl, Ol, tu),
            bu = 0; bu < 32; bu++)
                Hl[bu] = 0;
            return 0
        }
        function cu(Hl, Jl) {
            var Xl;
            for (Xl = 0; Xl < 16; Xl++)
                Hl[Xl] = Jl[Xl] | 0
        }
        function pu(Hl) {
            var Jl, Xl, Ol = 1;
            for (Jl = 0; Jl < 16; Jl++)
                Xl = Hl[Jl] + Ol + 65535,
                Ol = Math.floor(Xl / 65536),
                Hl[Jl] = Xl - Ol * 65536;
            Hl[0] += Ol - 1 + 37 * (Ol - 1)
        }
        function zl(Hl, Jl, Xl) {
            for (var Ol, tu = ~(Xl - 1), bu = 0; bu < 16; bu++)
                Ol = tu & (Hl[bu] ^ Jl[bu]),
                Hl[bu] ^= Ol,
                Jl[bu] ^= Ol
        }
        function Yl(Hl, Jl) {
            var Xl, Ol, tu, bu = as(), wu = as();
            for (Xl = 0; Xl < 16; Xl++)
                wu[Xl] = Jl[Xl];
            for (pu(wu),
            pu(wu),
            pu(wu),
            Ol = 0; Ol < 2; Ol++) {
                for (bu[0] = wu[0] - 65517,
                Xl = 1; Xl < 15; Xl++)
                    bu[Xl] = wu[Xl] - 65535 - (bu[Xl - 1] >> 16 & 1),
                    bu[Xl - 1] &= 65535;
                bu[15] = wu[15] - 32767 - (bu[14] >> 16 & 1),
                tu = bu[15] >> 16 & 1,
                bu[14] &= 65535,
                zl(wu, bu, 1 - tu)
            }
            for (Xl = 0; Xl < 16; Xl++)
                Hl[2 * Xl] = wu[Xl] & 255,
                Hl[2 * Xl + 1] = wu[Xl] >> 8
        }
        function lu(Hl, Jl) {
            var Xl = new Uint8Array(32)
              , Ol = new Uint8Array(32);
            return Yl(Xl, Hl),
            Yl(Ol, Jl),
            $l(Xl, 0, Ol, 0)
        }
        function mu(Hl) {
            var Jl = new Uint8Array(32);
            return Yl(Jl, Hl),
            Jl[0] & 1
        }
        function Cu(Hl, Jl) {
            var Xl;
            for (Xl = 0; Xl < 16; Xl++)
                Hl[Xl] = Jl[2 * Xl] + (Jl[2 * Xl + 1] << 8);
            Hl[15] &= 32767
        }
        function ju(Hl, Jl, Xl) {
            for (var Ol = 0; Ol < 16; Ol++)
                Hl[Ol] = Jl[Ol] + Xl[Ol]
        }
        function Lu(Hl, Jl, Xl) {
            for (var Ol = 0; Ol < 16; Ol++)
                Hl[Ol] = Jl[Ol] - Xl[Ol]
        }
        function Au(Hl, Jl, Xl) {
            var Ol, tu, bu = 0, wu = 0, Ou = 0, zu = 0, op = 0, Ju = 0, Ip = 0, tp = 0, pp = 0, mp = 0, bp = 0, xp = 0, gp = 0, vp = 0, yp = 0, np = 0, ap = 0, ep = 0, rp = 0, sp = 0, Xu = 0, $u = 0, Su = 0, Vu = 0, Nu = 0, Fu = 0, Wu = 0, cp = 0, wp = 0, _p = 0, Ep = 0, hu = Xl[0], $p = Xl[1], Ap = Xl[2], Mp = Xl[3], Cp = Xl[4], Rp = Xl[5], Pp = Xl[6], Hp = Xl[7], Bp = Xl[8], Fp = Xl[9], Dp = Xl[10], Vp = Xl[11], zp = Xl[12], qp = Xl[13], Yp = Xl[14], Qp = Xl[15];
            Ol = Jl[0],
            bu += Ol * hu,
            wu += Ol * $p,
            Ou += Ol * Ap,
            zu += Ol * Mp,
            op += Ol * Cp,
            Ju += Ol * Rp,
            Ip += Ol * Pp,
            tp += Ol * Hp,
            pp += Ol * Bp,
            mp += Ol * Fp,
            bp += Ol * Dp,
            xp += Ol * Vp,
            gp += Ol * zp,
            vp += Ol * qp,
            yp += Ol * Yp,
            np += Ol * Qp,
            Ol = Jl[1],
            wu += Ol * hu,
            Ou += Ol * $p,
            zu += Ol * Ap,
            op += Ol * Mp,
            Ju += Ol * Cp,
            Ip += Ol * Rp,
            tp += Ol * Pp,
            pp += Ol * Hp,
            mp += Ol * Bp,
            bp += Ol * Fp,
            xp += Ol * Dp,
            gp += Ol * Vp,
            vp += Ol * zp,
            yp += Ol * qp,
            np += Ol * Yp,
            ap += Ol * Qp,
            Ol = Jl[2],
            Ou += Ol * hu,
            zu += Ol * $p,
            op += Ol * Ap,
            Ju += Ol * Mp,
            Ip += Ol * Cp,
            tp += Ol * Rp,
            pp += Ol * Pp,
            mp += Ol * Hp,
            bp += Ol * Bp,
            xp += Ol * Fp,
            gp += Ol * Dp,
            vp += Ol * Vp,
            yp += Ol * zp,
            np += Ol * qp,
            ap += Ol * Yp,
            ep += Ol * Qp,
            Ol = Jl[3],
            zu += Ol * hu,
            op += Ol * $p,
            Ju += Ol * Ap,
            Ip += Ol * Mp,
            tp += Ol * Cp,
            pp += Ol * Rp,
            mp += Ol * Pp,
            bp += Ol * Hp,
            xp += Ol * Bp,
            gp += Ol * Fp,
            vp += Ol * Dp,
            yp += Ol * Vp,
            np += Ol * zp,
            ap += Ol * qp,
            ep += Ol * Yp,
            rp += Ol * Qp,
            Ol = Jl[4],
            op += Ol * hu,
            Ju += Ol * $p,
            Ip += Ol * Ap,
            tp += Ol * Mp,
            pp += Ol * Cp,
            mp += Ol * Rp,
            bp += Ol * Pp,
            xp += Ol * Hp,
            gp += Ol * Bp,
            vp += Ol * Fp,
            yp += Ol * Dp,
            np += Ol * Vp,
            ap += Ol * zp,
            ep += Ol * qp,
            rp += Ol * Yp,
            sp += Ol * Qp,
            Ol = Jl[5],
            Ju += Ol * hu,
            Ip += Ol * $p,
            tp += Ol * Ap,
            pp += Ol * Mp,
            mp += Ol * Cp,
            bp += Ol * Rp,
            xp += Ol * Pp,
            gp += Ol * Hp,
            vp += Ol * Bp,
            yp += Ol * Fp,
            np += Ol * Dp,
            ap += Ol * Vp,
            ep += Ol * zp,
            rp += Ol * qp,
            sp += Ol * Yp,
            Xu += Ol * Qp,
            Ol = Jl[6],
            Ip += Ol * hu,
            tp += Ol * $p,
            pp += Ol * Ap,
            mp += Ol * Mp,
            bp += Ol * Cp,
            xp += Ol * Rp,
            gp += Ol * Pp,
            vp += Ol * Hp,
            yp += Ol * Bp,
            np += Ol * Fp,
            ap += Ol * Dp,
            ep += Ol * Vp,
            rp += Ol * zp,
            sp += Ol * qp,
            Xu += Ol * Yp,
            $u += Ol * Qp,
            Ol = Jl[7],
            tp += Ol * hu,
            pp += Ol * $p,
            mp += Ol * Ap,
            bp += Ol * Mp,
            xp += Ol * Cp,
            gp += Ol * Rp,
            vp += Ol * Pp,
            yp += Ol * Hp,
            np += Ol * Bp,
            ap += Ol * Fp,
            ep += Ol * Dp,
            rp += Ol * Vp,
            sp += Ol * zp,
            Xu += Ol * qp,
            $u += Ol * Yp,
            Su += Ol * Qp,
            Ol = Jl[8],
            pp += Ol * hu,
            mp += Ol * $p,
            bp += Ol * Ap,
            xp += Ol * Mp,
            gp += Ol * Cp,
            vp += Ol * Rp,
            yp += Ol * Pp,
            np += Ol * Hp,
            ap += Ol * Bp,
            ep += Ol * Fp,
            rp += Ol * Dp,
            sp += Ol * Vp,
            Xu += Ol * zp,
            $u += Ol * qp,
            Su += Ol * Yp,
            Vu += Ol * Qp,
            Ol = Jl[9],
            mp += Ol * hu,
            bp += Ol * $p,
            xp += Ol * Ap,
            gp += Ol * Mp,
            vp += Ol * Cp,
            yp += Ol * Rp,
            np += Ol * Pp,
            ap += Ol * Hp,
            ep += Ol * Bp,
            rp += Ol * Fp,
            sp += Ol * Dp,
            Xu += Ol * Vp,
            $u += Ol * zp,
            Su += Ol * qp,
            Vu += Ol * Yp,
            Nu += Ol * Qp,
            Ol = Jl[10],
            bp += Ol * hu,
            xp += Ol * $p,
            gp += Ol * Ap,
            vp += Ol * Mp,
            yp += Ol * Cp,
            np += Ol * Rp,
            ap += Ol * Pp,
            ep += Ol * Hp,
            rp += Ol * Bp,
            sp += Ol * Fp,
            Xu += Ol * Dp,
            $u += Ol * Vp,
            Su += Ol * zp,
            Vu += Ol * qp,
            Nu += Ol * Yp,
            Fu += Ol * Qp,
            Ol = Jl[11],
            xp += Ol * hu,
            gp += Ol * $p,
            vp += Ol * Ap,
            yp += Ol * Mp,
            np += Ol * Cp,
            ap += Ol * Rp,
            ep += Ol * Pp,
            rp += Ol * Hp,
            sp += Ol * Bp,
            Xu += Ol * Fp,
            $u += Ol * Dp,
            Su += Ol * Vp,
            Vu += Ol * zp,
            Nu += Ol * qp,
            Fu += Ol * Yp,
            Wu += Ol * Qp,
            Ol = Jl[12],
            gp += Ol * hu,
            vp += Ol * $p,
            yp += Ol * Ap,
            np += Ol * Mp,
            ap += Ol * Cp,
            ep += Ol * Rp,
            rp += Ol * Pp,
            sp += Ol * Hp,
            Xu += Ol * Bp,
            $u += Ol * Fp,
            Su += Ol * Dp,
            Vu += Ol * Vp,
            Nu += Ol * zp,
            Fu += Ol * qp,
            Wu += Ol * Yp,
            cp += Ol * Qp,
            Ol = Jl[13],
            vp += Ol * hu,
            yp += Ol * $p,
            np += Ol * Ap,
            ap += Ol * Mp,
            ep += Ol * Cp,
            rp += Ol * Rp,
            sp += Ol * Pp,
            Xu += Ol * Hp,
            $u += Ol * Bp,
            Su += Ol * Fp,
            Vu += Ol * Dp,
            Nu += Ol * Vp,
            Fu += Ol * zp,
            Wu += Ol * qp,
            cp += Ol * Yp,
            wp += Ol * Qp,
            Ol = Jl[14],
            yp += Ol * hu,
            np += Ol * $p,
            ap += Ol * Ap,
            ep += Ol * Mp,
            rp += Ol * Cp,
            sp += Ol * Rp,
            Xu += Ol * Pp,
            $u += Ol * Hp,
            Su += Ol * Bp,
            Vu += Ol * Fp,
            Nu += Ol * Dp,
            Fu += Ol * Vp,
            Wu += Ol * zp,
            cp += Ol * qp,
            wp += Ol * Yp,
            _p += Ol * Qp,
            Ol = Jl[15],
            np += Ol * hu,
            ap += Ol * $p,
            ep += Ol * Ap,
            rp += Ol * Mp,
            sp += Ol * Cp,
            Xu += Ol * Rp,
            $u += Ol * Pp,
            Su += Ol * Hp,
            Vu += Ol * Bp,
            Nu += Ol * Fp,
            Fu += Ol * Dp,
            Wu += Ol * Vp,
            cp += Ol * zp,
            wp += Ol * qp,
            _p += Ol * Yp,
            Ep += Ol * Qp,
            bu += 38 * ap,
            wu += 38 * ep,
            Ou += 38 * rp,
            zu += 38 * sp,
            op += 38 * Xu,
            Ju += 38 * $u,
            Ip += 38 * Su,
            tp += 38 * Vu,
            pp += 38 * Nu,
            mp += 38 * Fu,
            bp += 38 * Wu,
            xp += 38 * cp,
            gp += 38 * wp,
            vp += 38 * _p,
            yp += 38 * Ep,
            tu = 1,
            Ol = bu + tu + 65535,
            tu = Math.floor(Ol / 65536),
            bu = Ol - tu * 65536,
            Ol = wu + tu + 65535,
            tu = Math.floor(Ol / 65536),
            wu = Ol - tu * 65536,
            Ol = Ou + tu + 65535,
            tu = Math.floor(Ol / 65536),
            Ou = Ol - tu * 65536,
            Ol = zu + tu + 65535,
            tu = Math.floor(Ol / 65536),
            zu = Ol - tu * 65536,
            Ol = op + tu + 65535,
            tu = Math.floor(Ol / 65536),
            op = Ol - tu * 65536,
            Ol = Ju + tu + 65535,
            tu = Math.floor(Ol / 65536),
            Ju = Ol - tu * 65536,
            Ol = Ip + tu + 65535,
            tu = Math.floor(Ol / 65536),
            Ip = Ol - tu * 65536,
            Ol = tp + tu + 65535,
            tu = Math.floor(Ol / 65536),
            tp = Ol - tu * 65536,
            Ol = pp + tu + 65535,
            tu = Math.floor(Ol / 65536),
            pp = Ol - tu * 65536,
            Ol = mp + tu + 65535,
            tu = Math.floor(Ol / 65536),
            mp = Ol - tu * 65536,
            Ol = bp + tu + 65535,
            tu = Math.floor(Ol / 65536),
            bp = Ol - tu * 65536,
            Ol = xp + tu + 65535,
            tu = Math.floor(Ol / 65536),
            xp = Ol - tu * 65536,
            Ol = gp + tu + 65535,
            tu = Math.floor(Ol / 65536),
            gp = Ol - tu * 65536,
            Ol = vp + tu + 65535,
            tu = Math.floor(Ol / 65536),
            vp = Ol - tu * 65536,
            Ol = yp + tu + 65535,
            tu = Math.floor(Ol / 65536),
            yp = Ol - tu * 65536,
            Ol = np + tu + 65535,
            tu = Math.floor(Ol / 65536),
            np = Ol - tu * 65536,
            bu += tu - 1 + 37 * (tu - 1),
            tu = 1,
            Ol = bu + tu + 65535,
            tu = Math.floor(Ol / 65536),
            bu = Ol - tu * 65536,
            Ol = wu + tu + 65535,
            tu = Math.floor(Ol / 65536),
            wu = Ol - tu * 65536,
            Ol = Ou + tu + 65535,
            tu = Math.floor(Ol / 65536),
            Ou = Ol - tu * 65536,
            Ol = zu + tu + 65535,
            tu = Math.floor(Ol / 65536),
            zu = Ol - tu * 65536,
            Ol = op + tu + 65535,
            tu = Math.floor(Ol / 65536),
            op = Ol - tu * 65536,
            Ol = Ju + tu + 65535,
            tu = Math.floor(Ol / 65536),
            Ju = Ol - tu * 65536,
            Ol = Ip + tu + 65535,
            tu = Math.floor(Ol / 65536),
            Ip = Ol - tu * 65536,
            Ol = tp + tu + 65535,
            tu = Math.floor(Ol / 65536),
            tp = Ol - tu * 65536,
            Ol = pp + tu + 65535,
            tu = Math.floor(Ol / 65536),
            pp = Ol - tu * 65536,
            Ol = mp + tu + 65535,
            tu = Math.floor(Ol / 65536),
            mp = Ol - tu * 65536,
            Ol = bp + tu + 65535,
            tu = Math.floor(Ol / 65536),
            bp = Ol - tu * 65536,
            Ol = xp + tu + 65535,
            tu = Math.floor(Ol / 65536),
            xp = Ol - tu * 65536,
            Ol = gp + tu + 65535,
            tu = Math.floor(Ol / 65536),
            gp = Ol - tu * 65536,
            Ol = vp + tu + 65535,
            tu = Math.floor(Ol / 65536),
            vp = Ol - tu * 65536,
            Ol = yp + tu + 65535,
            tu = Math.floor(Ol / 65536),
            yp = Ol - tu * 65536,
            Ol = np + tu + 65535,
            tu = Math.floor(Ol / 65536),
            np = Ol - tu * 65536,
            bu += tu - 1 + 37 * (tu - 1),
            Hl[0] = bu,
            Hl[1] = wu,
            Hl[2] = Ou,
            Hl[3] = zu,
            Hl[4] = op,
            Hl[5] = Ju,
            Hl[6] = Ip,
            Hl[7] = tp,
            Hl[8] = pp,
            Hl[9] = mp,
            Hl[10] = bp,
            Hl[11] = xp,
            Hl[12] = gp,
            Hl[13] = vp,
            Hl[14] = yp,
            Hl[15] = np
        }
        function Du(Hl, Jl) {
            Au(Hl, Jl, Jl)
        }
        function Qu(Hl, Jl) {
            var Xl = as(), Ol;
            for (Ol = 0; Ol < 16; Ol++)
                Xl[Ol] = Jl[Ol];
            for (Ol = 253; Ol >= 0; Ol--)
                Du(Xl, Xl),
                Ol !== 2 && Ol !== 4 && Au(Xl, Xl, Jl);
            for (Ol = 0; Ol < 16; Ol++)
                Hl[Ol] = Xl[Ol]
        }
        function fu(Hl, Jl) {
            var Xl = as(), Ol;
            for (Ol = 0; Ol < 16; Ol++)
                Xl[Ol] = Jl[Ol];
            for (Ol = 250; Ol >= 0; Ol--)
                Du(Xl, Xl),
                Ol !== 1 && Au(Xl, Xl, Jl);
            for (Ol = 0; Ol < 16; Ol++)
                Hl[Ol] = Xl[Ol]
        }
        function yu(Hl, Jl, Xl) {
            var Ol = new Uint8Array(32), tu = new Float64Array(80), bu, wu, Ou = as(), zu = as(), op = as(), Ju = as(), Ip = as(), tp = as();
            for (wu = 0; wu < 31; wu++)
                Ol[wu] = Jl[wu];
            for (Ol[31] = Jl[31] & 127 | 64,
            Ol[0] &= 248,
            Cu(tu, Xl),
            wu = 0; wu < 16; wu++)
                zu[wu] = tu[wu],
                Ju[wu] = Ou[wu] = op[wu] = 0;
            for (Ou[0] = Ju[0] = 1,
            wu = 254; wu >= 0; --wu)
                bu = Ol[wu >>> 3] >>> (wu & 7) & 1,
                zl(Ou, zu, bu),
                zl(op, Ju, bu),
                ju(Ip, Ou, op),
                Lu(Ou, Ou, op),
                ju(op, zu, Ju),
                Lu(zu, zu, Ju),
                Du(Ju, Ip),
                Du(tp, Ou),
                Au(Ou, op, Ou),
                Au(op, zu, Ip),
                ju(Ip, Ou, op),
                Lu(Ou, Ou, op),
                Du(zu, Ou),
                Lu(op, Ju, tp),
                Au(Ou, op, Xs),
                ju(Ou, Ou, Ju),
                Au(op, op, Ou),
                Au(Ou, Ju, tp),
                Au(Ju, zu, tu),
                Du(zu, Ip),
                zl(Ou, zu, bu),
                zl(op, Ju, bu);
            for (wu = 0; wu < 16; wu++)
                tu[wu + 16] = Ou[wu],
                tu[wu + 32] = op[wu],
                tu[wu + 48] = zu[wu],
                tu[wu + 64] = Ju[wu];
            var pp = tu.subarray(32)
              , mp = tu.subarray(16);
            return Qu(pp, pp),
            Au(mp, mp, pp),
            Yl(Hl, mp),
            0
        }
        function vu(Hl, Jl) {
            return yu(Hl, Jl, Ls)
        }
        function _u(Hl, Jl) {
            return cs(Jl, 32),
            vu(Hl, Jl)
        }
        function xu(Hl, Jl, Xl) {
            var Ol = new Uint8Array(32);
            return yu(Ol, Xl, Jl),
            Il(Hl, Cs, Ol, Ml)
        }
        var Ru = Wl
          , Iu = Ql;
        function Ku(Hl, Jl, Xl, Ol, tu, bu) {
            var wu = new Uint8Array(32);
            return xu(wu, tu, bu),
            Ru(Hl, Jl, Xl, Ol, wu)
        }
        function dp(Hl, Jl, Xl, Ol, tu, bu) {
            var wu = new Uint8Array(32);
            return xu(wu, tu, bu),
            Iu(Hl, Jl, Xl, Ol, wu)
        }
        var lp = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
        function qu(Hl, Jl, Xl, Ol) {
            for (var tu = new Int32Array(16), bu = new Int32Array(16), wu, Ou, zu, op, Ju, Ip, tp, pp, mp, bp, xp, gp, vp, yp, np, ap, ep, rp, sp, Xu, $u, Su, Vu, Nu, Fu, Wu, cp = Hl[0], wp = Hl[1], _p = Hl[2], Ep = Hl[3], hu = Hl[4], $p = Hl[5], Ap = Hl[6], Mp = Hl[7], Cp = Jl[0], Rp = Jl[1], Pp = Jl[2], Hp = Jl[3], Bp = Jl[4], Fp = Jl[5], Dp = Jl[6], Vp = Jl[7], zp = 0; Ol >= 128; ) {
                for (sp = 0; sp < 16; sp++)
                    Xu = 8 * sp + zp,
                    tu[sp] = Xl[Xu + 0] << 24 | Xl[Xu + 1] << 16 | Xl[Xu + 2] << 8 | Xl[Xu + 3],
                    bu[sp] = Xl[Xu + 4] << 24 | Xl[Xu + 5] << 16 | Xl[Xu + 6] << 8 | Xl[Xu + 7];
                for (sp = 0; sp < 80; sp++)
                    if (wu = cp,
                    Ou = wp,
                    zu = _p,
                    op = Ep,
                    Ju = hu,
                    Ip = $p,
                    tp = Ap,
                    pp = Mp,
                    mp = Cp,
                    bp = Rp,
                    xp = Pp,
                    gp = Hp,
                    vp = Bp,
                    yp = Fp,
                    np = Dp,
                    ap = Vp,
                    $u = Mp,
                    Su = Vp,
                    Vu = Su & 65535,
                    Nu = Su >>> 16,
                    Fu = $u & 65535,
                    Wu = $u >>> 16,
                    $u = (hu >>> 14 | Bp << 18) ^ (hu >>> 18 | Bp << 14) ^ (Bp >>> 9 | hu << 23),
                    Su = (Bp >>> 14 | hu << 18) ^ (Bp >>> 18 | hu << 14) ^ (hu >>> 9 | Bp << 23),
                    Vu += Su & 65535,
                    Nu += Su >>> 16,
                    Fu += $u & 65535,
                    Wu += $u >>> 16,
                    $u = hu & $p ^ ~hu & Ap,
                    Su = Bp & Fp ^ ~Bp & Dp,
                    Vu += Su & 65535,
                    Nu += Su >>> 16,
                    Fu += $u & 65535,
                    Wu += $u >>> 16,
                    $u = lp[sp * 2],
                    Su = lp[sp * 2 + 1],
                    Vu += Su & 65535,
                    Nu += Su >>> 16,
                    Fu += $u & 65535,
                    Wu += $u >>> 16,
                    $u = tu[sp % 16],
                    Su = bu[sp % 16],
                    Vu += Su & 65535,
                    Nu += Su >>> 16,
                    Fu += $u & 65535,
                    Wu += $u >>> 16,
                    Nu += Vu >>> 16,
                    Fu += Nu >>> 16,
                    Wu += Fu >>> 16,
                    ep = Fu & 65535 | Wu << 16,
                    rp = Vu & 65535 | Nu << 16,
                    $u = ep,
                    Su = rp,
                    Vu = Su & 65535,
                    Nu = Su >>> 16,
                    Fu = $u & 65535,
                    Wu = $u >>> 16,
                    $u = (cp >>> 28 | Cp << 4) ^ (Cp >>> 2 | cp << 30) ^ (Cp >>> 7 | cp << 25),
                    Su = (Cp >>> 28 | cp << 4) ^ (cp >>> 2 | Cp << 30) ^ (cp >>> 7 | Cp << 25),
                    Vu += Su & 65535,
                    Nu += Su >>> 16,
                    Fu += $u & 65535,
                    Wu += $u >>> 16,
                    $u = cp & wp ^ cp & _p ^ wp & _p,
                    Su = Cp & Rp ^ Cp & Pp ^ Rp & Pp,
                    Vu += Su & 65535,
                    Nu += Su >>> 16,
                    Fu += $u & 65535,
                    Wu += $u >>> 16,
                    Nu += Vu >>> 16,
                    Fu += Nu >>> 16,
                    Wu += Fu >>> 16,
                    pp = Fu & 65535 | Wu << 16,
                    ap = Vu & 65535 | Nu << 16,
                    $u = op,
                    Su = gp,
                    Vu = Su & 65535,
                    Nu = Su >>> 16,
                    Fu = $u & 65535,
                    Wu = $u >>> 16,
                    $u = ep,
                    Su = rp,
                    Vu += Su & 65535,
                    Nu += Su >>> 16,
                    Fu += $u & 65535,
                    Wu += $u >>> 16,
                    Nu += Vu >>> 16,
                    Fu += Nu >>> 16,
                    Wu += Fu >>> 16,
                    op = Fu & 65535 | Wu << 16,
                    gp = Vu & 65535 | Nu << 16,
                    wp = wu,
                    _p = Ou,
                    Ep = zu,
                    hu = op,
                    $p = Ju,
                    Ap = Ip,
                    Mp = tp,
                    cp = pp,
                    Rp = mp,
                    Pp = bp,
                    Hp = xp,
                    Bp = gp,
                    Fp = vp,
                    Dp = yp,
                    Vp = np,
                    Cp = ap,
                    sp % 16 === 15)
                        for (Xu = 0; Xu < 16; Xu++)
                            $u = tu[Xu],
                            Su = bu[Xu],
                            Vu = Su & 65535,
                            Nu = Su >>> 16,
                            Fu = $u & 65535,
                            Wu = $u >>> 16,
                            $u = tu[(Xu + 9) % 16],
                            Su = bu[(Xu + 9) % 16],
                            Vu += Su & 65535,
                            Nu += Su >>> 16,
                            Fu += $u & 65535,
                            Wu += $u >>> 16,
                            ep = tu[(Xu + 1) % 16],
                            rp = bu[(Xu + 1) % 16],
                            $u = (ep >>> 1 | rp << 31) ^ (ep >>> 8 | rp << 24) ^ ep >>> 7,
                            Su = (rp >>> 1 | ep << 31) ^ (rp >>> 8 | ep << 24) ^ (rp >>> 7 | ep << 25),
                            Vu += Su & 65535,
                            Nu += Su >>> 16,
                            Fu += $u & 65535,
                            Wu += $u >>> 16,
                            ep = tu[(Xu + 14) % 16],
                            rp = bu[(Xu + 14) % 16],
                            $u = (ep >>> 19 | rp << 13) ^ (rp >>> 29 | ep << 3) ^ ep >>> 6,
                            Su = (rp >>> 19 | ep << 13) ^ (ep >>> 29 | rp << 3) ^ (rp >>> 6 | ep << 26),
                            Vu += Su & 65535,
                            Nu += Su >>> 16,
                            Fu += $u & 65535,
                            Wu += $u >>> 16,
                            Nu += Vu >>> 16,
                            Fu += Nu >>> 16,
                            Wu += Fu >>> 16,
                            tu[Xu] = Fu & 65535 | Wu << 16,
                            bu[Xu] = Vu & 65535 | Nu << 16;
                $u = cp,
                Su = Cp,
                Vu = Su & 65535,
                Nu = Su >>> 16,
                Fu = $u & 65535,
                Wu = $u >>> 16,
                $u = Hl[0],
                Su = Jl[0],
                Vu += Su & 65535,
                Nu += Su >>> 16,
                Fu += $u & 65535,
                Wu += $u >>> 16,
                Nu += Vu >>> 16,
                Fu += Nu >>> 16,
                Wu += Fu >>> 16,
                Hl[0] = cp = Fu & 65535 | Wu << 16,
                Jl[0] = Cp = Vu & 65535 | Nu << 16,
                $u = wp,
                Su = Rp,
                Vu = Su & 65535,
                Nu = Su >>> 16,
                Fu = $u & 65535,
                Wu = $u >>> 16,
                $u = Hl[1],
                Su = Jl[1],
                Vu += Su & 65535,
                Nu += Su >>> 16,
                Fu += $u & 65535,
                Wu += $u >>> 16,
                Nu += Vu >>> 16,
                Fu += Nu >>> 16,
                Wu += Fu >>> 16,
                Hl[1] = wp = Fu & 65535 | Wu << 16,
                Jl[1] = Rp = Vu & 65535 | Nu << 16,
                $u = _p,
                Su = Pp,
                Vu = Su & 65535,
                Nu = Su >>> 16,
                Fu = $u & 65535,
                Wu = $u >>> 16,
                $u = Hl[2],
                Su = Jl[2],
                Vu += Su & 65535,
                Nu += Su >>> 16,
                Fu += $u & 65535,
                Wu += $u >>> 16,
                Nu += Vu >>> 16,
                Fu += Nu >>> 16,
                Wu += Fu >>> 16,
                Hl[2] = _p = Fu & 65535 | Wu << 16,
                Jl[2] = Pp = Vu & 65535 | Nu << 16,
                $u = Ep,
                Su = Hp,
                Vu = Su & 65535,
                Nu = Su >>> 16,
                Fu = $u & 65535,
                Wu = $u >>> 16,
                $u = Hl[3],
                Su = Jl[3],
                Vu += Su & 65535,
                Nu += Su >>> 16,
                Fu += $u & 65535,
                Wu += $u >>> 16,
                Nu += Vu >>> 16,
                Fu += Nu >>> 16,
                Wu += Fu >>> 16,
                Hl[3] = Ep = Fu & 65535 | Wu << 16,
                Jl[3] = Hp = Vu & 65535 | Nu << 16,
                $u = hu,
                Su = Bp,
                Vu = Su & 65535,
                Nu = Su >>> 16,
                Fu = $u & 65535,
                Wu = $u >>> 16,
                $u = Hl[4],
                Su = Jl[4],
                Vu += Su & 65535,
                Nu += Su >>> 16,
                Fu += $u & 65535,
                Wu += $u >>> 16,
                Nu += Vu >>> 16,
                Fu += Nu >>> 16,
                Wu += Fu >>> 16,
                Hl[4] = hu = Fu & 65535 | Wu << 16,
                Jl[4] = Bp = Vu & 65535 | Nu << 16,
                $u = $p,
                Su = Fp,
                Vu = Su & 65535,
                Nu = Su >>> 16,
                Fu = $u & 65535,
                Wu = $u >>> 16,
                $u = Hl[5],
                Su = Jl[5],
                Vu += Su & 65535,
                Nu += Su >>> 16,
                Fu += $u & 65535,
                Wu += $u >>> 16,
                Nu += Vu >>> 16,
                Fu += Nu >>> 16,
                Wu += Fu >>> 16,
                Hl[5] = $p = Fu & 65535 | Wu << 16,
                Jl[5] = Fp = Vu & 65535 | Nu << 16,
                $u = Ap,
                Su = Dp,
                Vu = Su & 65535,
                Nu = Su >>> 16,
                Fu = $u & 65535,
                Wu = $u >>> 16,
                $u = Hl[6],
                Su = Jl[6],
                Vu += Su & 65535,
                Nu += Su >>> 16,
                Fu += $u & 65535,
                Wu += $u >>> 16,
                Nu += Vu >>> 16,
                Fu += Nu >>> 16,
                Wu += Fu >>> 16,
                Hl[6] = Ap = Fu & 65535 | Wu << 16,
                Jl[6] = Dp = Vu & 65535 | Nu << 16,
                $u = Mp,
                Su = Vp,
                Vu = Su & 65535,
                Nu = Su >>> 16,
                Fu = $u & 65535,
                Wu = $u >>> 16,
                $u = Hl[7],
                Su = Jl[7],
                Vu += Su & 65535,
                Nu += Su >>> 16,
                Fu += $u & 65535,
                Wu += $u >>> 16,
                Nu += Vu >>> 16,
                Fu += Nu >>> 16,
                Wu += Fu >>> 16,
                Hl[7] = Mp = Fu & 65535 | Wu << 16,
                Jl[7] = Vp = Vu & 65535 | Nu << 16,
                zp += 128,
                Ol -= 128
            }
            return Ol
        }
        function hp(Hl, Jl, Xl) {
            var Ol = new Int32Array(8), tu = new Int32Array(8), bu = new Uint8Array(256), wu, Ou = Xl;
            for (Ol[0] = 1779033703,
            Ol[1] = 3144134277,
            Ol[2] = 1013904242,
            Ol[3] = 2773480762,
            Ol[4] = 1359893119,
            Ol[5] = 2600822924,
            Ol[6] = 528734635,
            Ol[7] = 1541459225,
            tu[0] = 4089235720,
            tu[1] = 2227873595,
            tu[2] = 4271175723,
            tu[3] = 1595750129,
            tu[4] = 2917565137,
            tu[5] = 725511199,
            tu[6] = 4215389547,
            tu[7] = 327033209,
            qu(Ol, tu, Jl, Xl),
            Xl %= 128,
            wu = 0; wu < Xl; wu++)
                bu[wu] = Jl[Ou - Xl + wu];
            for (bu[Xl] = 128,
            Xl = 256 - 128 * (Xl < 112 ? 1 : 0),
            bu[Xl - 9] = 0,
            _l(bu, Xl - 8, Ou / 536870912 | 0, Ou << 3),
            qu(Ol, tu, bu, Xl),
            wu = 0; wu < 8; wu++)
                _l(Hl, 8 * wu, Ol[wu], tu[wu]);
            return 0
        }
        function fp(Hl, Jl) {
            var Xl = as()
              , Ol = as()
              , tu = as()
              , bu = as()
              , wu = as()
              , Ou = as()
              , zu = as()
              , op = as()
              , Ju = as();
            Lu(Xl, Hl[1], Hl[0]),
            Lu(Ju, Jl[1], Jl[0]),
            Au(Xl, Xl, Ju),
            ju(Ol, Hl[0], Hl[1]),
            ju(Ju, Jl[0], Jl[1]),
            Au(Ol, Ol, Ju),
            Au(tu, Hl[3], Jl[3]),
            Au(tu, tu, ba),
            Au(bu, Hl[2], Jl[2]),
            ju(bu, bu, bu),
            Lu(wu, Ol, Xl),
            Lu(Ou, bu, tu),
            ju(zu, bu, tu),
            ju(op, Ol, Xl),
            Au(Hl[0], wu, Ou),
            Au(Hl[1], op, zu),
            Au(Hl[2], zu, Ou),
            Au(Hl[3], wu, op)
        }
        function Lp(Hl, Jl, Xl) {
            var Ol;
            for (Ol = 0; Ol < 4; Ol++)
                zl(Hl[Ol], Jl[Ol], Xl)
        }
        function uu(Hl, Jl) {
            var Xl = as()
              , Ol = as()
              , tu = as();
            Qu(tu, Jl[2]),
            Au(Xl, Jl[0], tu),
            Au(Ol, Jl[1], tu),
            Yl(Hl, Ol),
            Hl[31] ^= mu(Xl) << 7
        }
        function gu(Hl, Jl, Xl) {
            var Ol, tu;
            for (cu(Hl[0], Vs),
            cu(Hl[1], Ws),
            cu(Hl[2], Ws),
            cu(Hl[3], Vs),
            tu = 255; tu >= 0; --tu)
                Ol = Xl[tu / 8 | 0] >> (tu & 7) & 1,
                Lp(Hl, Jl, Ol),
                fp(Jl, Hl),
                fp(Hl, Hl),
                Lp(Hl, Jl, Ol)
        }
        function Eu(Hl, Jl) {
            var Xl = [as(), as(), as(), as()];
            cu(Xl[0], yl),
            cu(Xl[1], xl),
            cu(Xl[2], Ws),
            Au(Xl[3], yl, xl),
            gu(Hl, Xl, Jl)
        }
        function nu(Hl, Jl, Xl) {
            var Ol = new Uint8Array(64), tu = [as(), as(), as(), as()], bu;
            for (Xl || cs(Jl, 32),
            hp(Ol, Jl, 32),
            Ol[0] &= 248,
            Ol[31] &= 127,
            Ol[31] |= 64,
            Eu(tu, Ol),
            uu(Hl, tu),
            bu = 0; bu < 32; bu++)
                Jl[bu + 32] = Hl[bu];
            return 0
        }
        var Kl = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
        function Bl(Hl, Jl) {
            var Xl, Ol, tu, bu;
            for (Ol = 63; Ol >= 32; --Ol) {
                for (Xl = 0,
                tu = Ol - 32,
                bu = Ol - 12; tu < bu; ++tu)
                    Jl[tu] += Xl - 16 * Jl[Ol] * Kl[tu - (Ol - 32)],
                    Xl = Math.floor((Jl[tu] + 128) / 256),
                    Jl[tu] -= Xl * 256;
                Jl[tu] += Xl,
                Jl[Ol] = 0
            }
            for (Xl = 0,
            tu = 0; tu < 32; tu++)
                Jl[tu] += Xl - (Jl[31] >> 4) * Kl[tu],
                Xl = Jl[tu] >> 8,
                Jl[tu] &= 255;
            for (tu = 0; tu < 32; tu++)
                Jl[tu] -= Xl * Kl[tu];
            for (Ol = 0; Ol < 32; Ol++)
                Jl[Ol + 1] += Jl[Ol] >> 8,
                Hl[Ol] = Jl[Ol] & 255
        }
        function Pl(Hl) {
            var Jl = new Float64Array(64), Xl;
            for (Xl = 0; Xl < 64; Xl++)
                Jl[Xl] = Hl[Xl];
            for (Xl = 0; Xl < 64; Xl++)
                Hl[Xl] = 0;
            Bl(Hl, Jl)
        }
        function Al(Hl, Jl, Xl, Ol) {
            var tu = new Uint8Array(64), bu = new Uint8Array(64), wu = new Uint8Array(64), Ou, zu, op = new Float64Array(64), Ju = [as(), as(), as(), as()];
            hp(tu, Ol, 32),
            tu[0] &= 248,
            tu[31] &= 127,
            tu[31] |= 64;
            var Ip = Xl + 64;
            for (Ou = 0; Ou < Xl; Ou++)
                Hl[64 + Ou] = Jl[Ou];
            for (Ou = 0; Ou < 32; Ou++)
                Hl[32 + Ou] = tu[32 + Ou];
            for (hp(wu, Hl.subarray(32), Xl + 32),
            Pl(wu),
            Eu(Ju, wu),
            uu(Hl, Ju),
            Ou = 32; Ou < 64; Ou++)
                Hl[Ou] = Ol[Ou];
            for (hp(bu, Hl, Xl + 64),
            Pl(bu),
            Ou = 0; Ou < 64; Ou++)
                op[Ou] = 0;
            for (Ou = 0; Ou < 32; Ou++)
                op[Ou] = wu[Ou];
            for (Ou = 0; Ou < 32; Ou++)
                for (zu = 0; zu < 32; zu++)
                    op[Ou + zu] += bu[Ou] * tu[zu];
            return Bl(Hl.subarray(32), op),
            Ip
        }
        function Vl(Hl, Jl) {
            var Xl = as()
              , Ol = as()
              , tu = as()
              , bu = as()
              , wu = as()
              , Ou = as()
              , zu = as();
            return cu(Hl[2], Ws),
            Cu(Hl[1], Jl),
            Du(tu, Hl[1]),
            Au(bu, tu, ga),
            Lu(tu, tu, Hl[2]),
            ju(bu, Hl[2], bu),
            Du(wu, bu),
            Du(Ou, wu),
            Au(zu, Ou, wu),
            Au(Xl, zu, tu),
            Au(Xl, Xl, bu),
            fu(Xl, Xl),
            Au(Xl, Xl, tu),
            Au(Xl, Xl, bu),
            Au(Xl, Xl, bu),
            Au(Hl[0], Xl, bu),
            Du(Ol, Hl[0]),
            Au(Ol, Ol, bu),
            lu(Ol, tu) && Au(Hl[0], Hl[0], wl),
            Du(Ol, Hl[0]),
            Au(Ol, Ol, bu),
            lu(Ol, tu) ? -1 : (mu(Hl[0]) === Jl[31] >> 7 && Lu(Hl[0], Vs, Hl[0]),
            Au(Hl[3], Hl[0], Hl[1]),
            0)
        }
        function eu(Hl, Jl, Xl, Ol) {
            var tu, bu = new Uint8Array(32), wu = new Uint8Array(64), Ou = [as(), as(), as(), as()], zu = [as(), as(), as(), as()];
            if (Xl < 64 || Vl(zu, Ol))
                return -1;
            for (tu = 0; tu < Xl; tu++)
                Hl[tu] = Jl[tu];
            for (tu = 0; tu < 32; tu++)
                Hl[tu + 32] = Ol[tu];
            if (hp(wu, Hl, Xl),
            Pl(wu),
            gu(Ou, zu, wu),
            Eu(zu, Jl.subarray(32)),
            fp(Ou, zu),
            uu(bu, Ou),
            Xl -= 64,
            $l(Jl, 0, bu, 0)) {
                for (tu = 0; tu < Xl; tu++)
                    Hl[tu] = 0;
                return -1
            }
            for (tu = 0; tu < Xl; tu++)
                Hl[tu] = Jl[tu + 64];
            return Xl
        }
        var iu = 32
          , ou = 24
          , Tu = 32
          , Hu = 16
          , Mu = 32
          , Uu = 32
          , Yu = 32
          , Gu = 32
          , Tp = 32
          , Sp = ou
          , jp = Tu
          , Op = Hu
          , Gp = 64
          , Wp = 32
          , Zp = 64
          , Im = 32
          , gm = 64;
        Cn.lowlevel = {
            crypto_core_hsalsa20: Il,
            crypto_stream_xor: Ul,
            crypto_stream: Fl,
            crypto_stream_salsa20_xor: Nl,
            crypto_stream_salsa20: Ll,
            crypto_onetimeauth: Zl,
            crypto_onetimeauth_verify: Gl,
            crypto_verify_16: Cl,
            crypto_verify_32: $l,
            crypto_secretbox: Wl,
            crypto_secretbox_open: Ql,
            crypto_scalarmult: yu,
            crypto_scalarmult_base: vu,
            crypto_box_beforenm: xu,
            crypto_box_afternm: Ru,
            crypto_box: Ku,
            crypto_box_open: dp,
            crypto_box_keypair: _u,
            crypto_hash: hp,
            crypto_sign: Al,
            crypto_sign_keypair: nu,
            crypto_sign_open: eu,
            crypto_secretbox_KEYBYTES: iu,
            crypto_secretbox_NONCEBYTES: ou,
            crypto_secretbox_ZEROBYTES: Tu,
            crypto_secretbox_BOXZEROBYTES: Hu,
            crypto_scalarmult_BYTES: Mu,
            crypto_scalarmult_SCALARBYTES: Uu,
            crypto_box_PUBLICKEYBYTES: Yu,
            crypto_box_SECRETKEYBYTES: Gu,
            crypto_box_BEFORENMBYTES: Tp,
            crypto_box_NONCEBYTES: Sp,
            crypto_box_ZEROBYTES: jp,
            crypto_box_BOXZEROBYTES: Op,
            crypto_sign_BYTES: Gp,
            crypto_sign_PUBLICKEYBYTES: Wp,
            crypto_sign_SECRETKEYBYTES: Zp,
            crypto_sign_SEEDBYTES: Im,
            crypto_hash_BYTES: gm,
            gf: as,
            D: ga,
            L: Kl,
            pack25519: Yl,
            unpack25519: Cu,
            M: Au,
            A: ju,
            S: Du,
            Z: Lu,
            pow2523: fu,
            add: fp,
            set25519: cu,
            modL: Bl,
            scalarmult: gu,
            scalarbase: Eu
        };
        function ym(Hl, Jl) {
            if (Hl.length !== iu)
                throw new Error("bad key size");
            if (Jl.length !== ou)
                throw new Error("bad nonce size")
        }
        function Dm(Hl, Jl) {
            if (Hl.length !== Yu)
                throw new Error("bad public key size");
            if (Jl.length !== Gu)
                throw new Error("bad secret key size")
        }
        function Jp() {
            for (var Hl = 0; Hl < arguments.length; Hl++)
                if (!(arguments[Hl]instanceof Uint8Array))
                    throw new TypeError("unexpected type, use Uint8Array")
        }
        function L1(Hl) {
            for (var Jl = 0; Jl < Hl.length; Jl++)
                Hl[Jl] = 0
        }
        Cn.randomBytes = function(Hl) {
            var Jl = new Uint8Array(Hl);
            return cs(Jl, Hl),
            Jl
        }
        ,
        Cn.secretbox = function(Hl, Jl, Xl) {
            Jp(Hl, Jl, Xl),
            ym(Xl, Jl);
            for (var Ol = new Uint8Array(Tu + Hl.length), tu = new Uint8Array(Ol.length), bu = 0; bu < Hl.length; bu++)
                Ol[bu + Tu] = Hl[bu];
            return Wl(tu, Ol, Ol.length, Jl, Xl),
            tu.subarray(Hu)
        }
        ,
        Cn.secretbox.open = function(Hl, Jl, Xl) {
            Jp(Hl, Jl, Xl),
            ym(Xl, Jl);
            for (var Ol = new Uint8Array(Hu + Hl.length), tu = new Uint8Array(Ol.length), bu = 0; bu < Hl.length; bu++)
                Ol[bu + Hu] = Hl[bu];
            return Ol.length < 32 || Ql(tu, Ol, Ol.length, Jl, Xl) !== 0 ? null : tu.subarray(Tu)
        }
        ,
        Cn.secretbox.keyLength = iu,
        Cn.secretbox.nonceLength = ou,
        Cn.secretbox.overheadLength = Hu,
        Cn.scalarMult = function(Hl, Jl) {
            if (Jp(Hl, Jl),
            Hl.length !== Uu)
                throw new Error("bad n size");
            if (Jl.length !== Mu)
                throw new Error("bad p size");
            var Xl = new Uint8Array(Mu);
            return yu(Xl, Hl, Jl),
            Xl
        }
        ,
        Cn.scalarMult.base = function(Hl) {
            if (Jp(Hl),
            Hl.length !== Uu)
                throw new Error("bad n size");
            var Jl = new Uint8Array(Mu);
            return vu(Jl, Hl),
            Jl
        }
        ,
        Cn.scalarMult.scalarLength = Uu,
        Cn.scalarMult.groupElementLength = Mu,
        Cn.box = function(Hl, Jl, Xl, Ol) {
            var tu = Cn.box.before(Xl, Ol);
            return Cn.secretbox(Hl, Jl, tu)
        }
        ,
        Cn.box.before = function(Hl, Jl) {
            Jp(Hl, Jl),
            Dm(Hl, Jl);
            var Xl = new Uint8Array(Tp);
            return xu(Xl, Hl, Jl),
            Xl
        }
        ,
        Cn.box.after = Cn.secretbox,
        Cn.box.open = function(Hl, Jl, Xl, Ol) {
            var tu = Cn.box.before(Xl, Ol);
            return Cn.secretbox.open(Hl, Jl, tu)
        }
        ,
        Cn.box.open.after = Cn.secretbox.open,
        Cn.box.keyPair = function() {
            var Hl = new Uint8Array(Yu)
              , Jl = new Uint8Array(Gu);
            return _u(Hl, Jl),
            {
                publicKey: Hl,
                secretKey: Jl
            }
        }
        ,
        Cn.box.keyPair.fromSecretKey = function(Hl) {
            if (Jp(Hl),
            Hl.length !== Gu)
                throw new Error("bad secret key size");
            var Jl = new Uint8Array(Yu);
            return vu(Jl, Hl),
            {
                publicKey: Jl,
                secretKey: new Uint8Array(Hl)
            }
        }
        ,
        Cn.box.publicKeyLength = Yu,
        Cn.box.secretKeyLength = Gu,
        Cn.box.sharedKeyLength = Tp,
        Cn.box.nonceLength = Sp,
        Cn.box.overheadLength = Cn.secretbox.overheadLength,
        Cn.sign = function(Hl, Jl) {
            if (Jp(Hl, Jl),
            Jl.length !== Zp)
                throw new Error("bad secret key size");
            var Xl = new Uint8Array(Gp + Hl.length);
            return Al(Xl, Hl, Hl.length, Jl),
            Xl
        }
        ,
        Cn.sign.open = function(Hl, Jl) {
            if (Jp(Hl, Jl),
            Jl.length !== Wp)
                throw new Error("bad public key size");
            var Xl = new Uint8Array(Hl.length)
              , Ol = eu(Xl, Hl, Hl.length, Jl);
            if (Ol < 0)
                return null;
            for (var tu = new Uint8Array(Ol), bu = 0; bu < tu.length; bu++)
                tu[bu] = Xl[bu];
            return tu
        }
        ,
        Cn.sign.detached = function(Hl, Jl) {
            for (var Xl = Cn.sign(Hl, Jl), Ol = new Uint8Array(Gp), tu = 0; tu < Ol.length; tu++)
                Ol[tu] = Xl[tu];
            return Ol
        }
        ,
        Cn.sign.detached.verify = function(Hl, Jl, Xl) {
            if (Jp(Hl, Jl, Xl),
            Jl.length !== Gp)
                throw new Error("bad signature size");
            if (Xl.length !== Wp)
                throw new Error("bad public key size");
            var Ol = new Uint8Array(Gp + Hl.length), tu = new Uint8Array(Gp + Hl.length), bu;
            for (bu = 0; bu < Gp; bu++)
                Ol[bu] = Jl[bu];
            for (bu = 0; bu < Hl.length; bu++)
                Ol[bu + Gp] = Hl[bu];
            return eu(tu, Ol, Ol.length, Xl) >= 0
        }
        ,
        Cn.sign.keyPair = function() {
            var Hl = new Uint8Array(Wp)
              , Jl = new Uint8Array(Zp);
            return nu(Hl, Jl),
            {
                publicKey: Hl,
                secretKey: Jl
            }
        }
        ,
        Cn.sign.keyPair.fromSecretKey = function(Hl) {
            if (Jp(Hl),
            Hl.length !== Zp)
                throw new Error("bad secret key size");
            for (var Jl = new Uint8Array(Wp), Xl = 0; Xl < Jl.length; Xl++)
                Jl[Xl] = Hl[32 + Xl];
            return {
                publicKey: Jl,
                secretKey: new Uint8Array(Hl)
            }
        }
        ,
        Cn.sign.keyPair.fromSeed = function(Hl) {
            if (Jp(Hl),
            Hl.length !== Im)
                throw new Error("bad seed size");
            for (var Jl = new Uint8Array(Wp), Xl = new Uint8Array(Zp), Ol = 0; Ol < 32; Ol++)
                Xl[Ol] = Hl[Ol];
            return nu(Jl, Xl, !0),
            {
                publicKey: Jl,
                secretKey: Xl
            }
        }
        ,
        Cn.sign.publicKeyLength = Wp,
        Cn.sign.secretKeyLength = Zp,
        Cn.sign.seedLength = Im,
        Cn.sign.signatureLength = Gp,
        Cn.hash = function(Hl) {
            Jp(Hl);
            var Jl = new Uint8Array(gm);
            return hp(Jl, Hl, Hl.length),
            Jl
        }
        ,
        Cn.hash.hashLength = gm,
        Cn.verify = function(Hl, Jl) {
            return Jp(Hl, Jl),
            Hl.length === 0 || Jl.length === 0 || Hl.length !== Jl.length ? !1 : El(Hl, 0, Jl, 0, Hl.length) === 0
        }
        ,
        Cn.setPRNG = function(Hl) {
            cs = Hl
        }
        ,
        function() {
            var Hl = typeof self < "u" ? self.crypto || self.msCrypto : null;
            if (Hl && Hl.getRandomValues) {
                var Jl = 65536;
                Cn.setPRNG(function(Xl, Ol) {
                    var tu, bu = new Uint8Array(Ol);
                    for (tu = 0; tu < Ol; tu += Jl)
                        Hl.getRandomValues(bu.subarray(tu, tu + Math.min(Ol - tu, Jl)));
                    for (tu = 0; tu < Ol; tu++)
                        Xl[tu] = bu[tu];
                    L1(bu)
                })
            } else
                typeof commonjsRequire < "u" && (Hl = require$$0,
                Hl && Hl.randomBytes && Cn.setPRNG(function(Xl, Ol) {
                    var tu, bu = Hl.randomBytes(Ol);
                    for (tu = 0; tu < Ol; tu++)
                        Xl[tu] = bu[tu];
                    L1(bu)
                }))
        }()
    }
    )(xt.exports ? xt.exports : self.nacl = self.nacl || {})
}
)(naclFast);
var naclFastExports = naclFast.exports;
const nacl$1 = getDefaultExportFromCjs(naclFastExports);
var CONNECT_EVENT_ERROR_CODES;
(function(xt) {
    xt[xt.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    xt[xt.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR",
    xt[xt.MANIFEST_NOT_FOUND_ERROR = 2] = "MANIFEST_NOT_FOUND_ERROR",
    xt[xt.MANIFEST_CONTENT_ERROR = 3] = "MANIFEST_CONTENT_ERROR",
    xt[xt.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR",
    xt[xt.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR",
    xt[xt.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(CONNECT_EVENT_ERROR_CODES || (CONNECT_EVENT_ERROR_CODES = {}));
var CONNECT_ITEM_ERROR_CODES;
(function(xt) {
    xt[xt.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    xt[xt.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(CONNECT_ITEM_ERROR_CODES || (CONNECT_ITEM_ERROR_CODES = {}));
var SEND_TRANSACTION_ERROR_CODES;
(function(xt) {
    xt[xt.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    xt[xt.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR",
    xt[xt.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR",
    xt[xt.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR",
    xt[xt.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(SEND_TRANSACTION_ERROR_CODES || (SEND_TRANSACTION_ERROR_CODES = {}));
var SIGN_DATA_ERROR_CODES;
(function(xt) {
    xt[xt.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    xt[xt.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR",
    xt[xt.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR",
    xt[xt.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR",
    xt[xt.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(SIGN_DATA_ERROR_CODES || (SIGN_DATA_ERROR_CODES = {}));
var DISCONNECT_ERROR_CODES;
(function(xt) {
    xt[xt.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    xt[xt.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR",
    xt[xt.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR",
    xt[xt.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(DISCONNECT_ERROR_CODES || (DISCONNECT_ERROR_CODES = {}));
var CHAIN;
(function(xt) {
    xt.MAINNET = "-239",
    xt.TESTNET = "-3"
}
)(CHAIN || (CHAIN = {}));
function encodeUint8Array(xt, Cn) {
    const as = nacl$2.encodeBase64(xt);
    return Cn ? encodeURIComponent(as) : as
}
function decodeToUint8Array(xt, Cn) {
    return Cn && (xt = decodeURIComponent(xt)),
    nacl$2.decodeBase64(xt)
}
function encode(xt, Cn=!1) {
    let as;
    return xt instanceof Uint8Array ? as = xt : (typeof xt != "string" && (xt = JSON.stringify(xt)),
    as = nacl$2.decodeUTF8(xt)),
    encodeUint8Array(as, Cn)
}
function decode(xt, Cn=!1) {
    const as = decodeToUint8Array(xt, Cn);
    return {
        toString() {
            return nacl$2.encodeUTF8(as)
        },
        toObject() {
            try {
                return JSON.parse(nacl$2.encodeUTF8(as))
            } catch {
                return null
            }
        },
        toUint8Array() {
            return as
        }
    }
}
const Base64 = {
    encode,
    decode
};
function concatUint8Arrays(xt, Cn) {
    const as = new Uint8Array(xt.length + Cn.length);
    return as.set(xt),
    as.set(Cn, xt.length),
    as
}
function splitToUint8Arrays(xt, Cn) {
    if (Cn >= xt.length)
        throw new Error("Index is out of buffer");
    const as = xt.slice(0, Cn)
      , cs = xt.slice(Cn);
    return [as, cs]
}
function toHexString(xt) {
    let Cn = "";
    return xt.forEach(as => {
        Cn += ("0" + (as & 255).toString(16)).slice(-2)
    }
    ),
    Cn
}
function hexToByteArray(xt) {
    if (xt.length % 2 !== 0)
        throw new Error(`Cannot convert ${xt} to bytesArray`);
    const Cn = new Uint8Array(xt.length / 2);
    for (let as = 0; as < xt.length; as += 2)
        Cn[as / 2] = parseInt(xt.slice(as, as + 2), 16);
    return Cn
}
class SessionCrypto {
    constructor(Cn) {
        this.nonceLength = 24,
        this.keyPair = Cn ? this.createKeypairFromString(Cn) : this.createKeypair(),
        this.sessionId = toHexString(this.keyPair.publicKey)
    }
    createKeypair() {
        return nacl$1.box.keyPair()
    }
    createKeypairFromString(Cn) {
        return {
            publicKey: hexToByteArray(Cn.publicKey),
            secretKey: hexToByteArray(Cn.secretKey)
        }
    }
    createNonce() {
        return nacl$1.randomBytes(this.nonceLength)
    }
    encrypt(Cn, as) {
        const cs = new TextEncoder().encode(Cn)
          , Cs = this.createNonce()
          , Ls = nacl$1.box(cs, Cs, as, this.keyPair.secretKey);
        return concatUint8Arrays(Cs, Ls)
    }
    decrypt(Cn, as) {
        const [cs,Cs] = splitToUint8Arrays(Cn, this.nonceLength)
          , Ls = nacl$1.box.open(Cs, cs, as, this.keyPair.secretKey);
        if (!Ls)
            throw new Error(`Decryption error: 
 message: ${Cn.toString()} 
 sender pubkey: ${as.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`);
        return new TextDecoder().decode(Ls)
    }
    stringifyKeypair() {
        return {
            publicKey: toHexString(this.keyPair.publicKey),
            secretKey: toHexString(this.keyPair.secretKey)
        }
    }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __rest(xt, Cn) {
    var as = {};
    for (var cs in xt)
        Object.prototype.hasOwnProperty.call(xt, cs) && Cn.indexOf(cs) < 0 && (as[cs] = xt[cs]);
    if (xt != null && typeof Object.getOwnPropertySymbols == "function")
        for (var Cs = 0, cs = Object.getOwnPropertySymbols(xt); Cs < cs.length; Cs++)
            Cn.indexOf(cs[Cs]) < 0 && Object.prototype.propertyIsEnumerable.call(xt, cs[Cs]) && (as[cs[Cs]] = xt[cs[Cs]]);
    return as
}
function __awaiter$1(xt, Cn, as, cs) {
    function Cs(Ls) {
        return Ls instanceof as ? Ls : new as(function(Vs) {
            Vs(Ls)
        }
        )
    }
    return new (as || (as = Promise))(function(Ls, Vs) {
        function Ws(ba) {
            try {
                ga(cs.next(ba))
            } catch (yl) {
                Vs(yl)
            }
        }
        function Xs(ba) {
            try {
                ga(cs.throw(ba))
            } catch (yl) {
                Vs(yl)
            }
        }
        function ga(ba) {
            ba.done ? Ls(ba.value) : Cs(ba.value).then(Ws, Xs)
        }
        ga((cs = cs.apply(xt, [])).next())
    }
    )
}
class TonConnectError extends Error {
    constructor(Cn, as) {
        super(Cn, as),
        this.message = `${TonConnectError.prefix} ${this.constructor.name}${this.info ? ": " + this.info : ""}${Cn ? `
` + Cn : ""}`,
        Object.setPrototypeOf(this, TonConnectError.prototype)
    }
    get info() {
        return ""
    }
}
TonConnectError.prefix = "[TON_CONNECT_SDK_ERROR]";
class DappMetadataError extends TonConnectError {
    get info() {
        return "Passed DappMetadata is in incorrect format."
    }
    constructor(...Cn) {
        super(...Cn),
        Object.setPrototypeOf(this, DappMetadataError.prototype)
    }
}
class ManifestContentErrorError extends TonConnectError {
    get info() {
        return "Passed `tonconnect-manifest.json` contains errors. Check format of your manifest. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest"
    }
    constructor(...Cn) {
        super(...Cn),
        Object.setPrototypeOf(this, ManifestContentErrorError.prototype)
    }
}
class ManifestNotFoundError extends TonConnectError {
    get info() {
        return "Manifest not found. Make sure you added `tonconnect-manifest.json` to the root of your app or passed correct manifestUrl. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest"
    }
    constructor(...Cn) {
        super(...Cn),
        Object.setPrototypeOf(this, ManifestNotFoundError.prototype)
    }
}
class WalletAlreadyConnectedError extends TonConnectError {
    get info() {
        return "Wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection."
    }
    constructor(...Cn) {
        super(...Cn),
        Object.setPrototypeOf(this, WalletAlreadyConnectedError.prototype)
    }
}
class WalletNotConnectedError extends TonConnectError {
    get info() {
        return "Send transaction or other protocol methods called while wallet is not connected."
    }
    constructor(...Cn) {
        super(...Cn),
        Object.setPrototypeOf(this, WalletNotConnectedError.prototype)
    }
}
function isWalletConnectionSourceJS(xt) {
    return "jsBridgeKey"in xt
}
class UserRejectsError extends TonConnectError {
    get info() {
        return "User rejects the action in the wallet."
    }
    constructor(...Cn) {
        super(...Cn),
        Object.setPrototypeOf(this, UserRejectsError.prototype)
    }
}
class BadRequestError extends TonConnectError {
    get info() {
        return "Request to the wallet contains errors."
    }
    constructor(...Cn) {
        super(...Cn),
        Object.setPrototypeOf(this, BadRequestError.prototype)
    }
}
class UnknownAppError extends TonConnectError {
    get info() {
        return "App tries to send rpc request to the injected wallet while not connected."
    }
    constructor(...Cn) {
        super(...Cn),
        Object.setPrototypeOf(this, UnknownAppError.prototype)
    }
}
class WalletNotInjectedError extends TonConnectError {
    get info() {
        return "There is an attempt to connect to the injected wallet while it is not exists in the webpage."
    }
    constructor(...Cn) {
        super(...Cn),
        Object.setPrototypeOf(this, WalletNotInjectedError.prototype)
    }
}
class FetchWalletsError extends TonConnectError {
    get info() {
        return "An error occurred while fetching the wallets list."
    }
    constructor(...Cn) {
        super(...Cn),
        Object.setPrototypeOf(this, FetchWalletsError.prototype)
    }
}
class WrongAddressError extends TonConnectError {
    get info() {
        return "Passed address is in incorrect format."
    }
    constructor(...Cn) {
        super(...Cn),
        Object.setPrototypeOf(this, WrongAddressError.prototype)
    }
}
class ParseHexError extends TonConnectError {
    get info() {
        return "Passed hex is in incorrect format."
    }
    constructor(...Cn) {
        super(...Cn),
        Object.setPrototypeOf(this, ParseHexError.prototype)
    }
}
class UnknownError extends TonConnectError {
    constructor(...Cn) {
        super(...Cn),
        Object.setPrototypeOf(this, UnknownError.prototype)
    }
}
const connectEventErrorsCodes = {
    [CONNECT_EVENT_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,
    [CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,
    [CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,
    [CONNECT_EVENT_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError,
    [CONNECT_EVENT_ERROR_CODES.MANIFEST_NOT_FOUND_ERROR]: ManifestNotFoundError,
    [CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR]: ManifestContentErrorError
};
class ConnectErrorsParser {
    parseError(Cn) {
        let as = UnknownError;
        return Cn.code in connectEventErrorsCodes && (as = connectEventErrorsCodes[Cn.code] || UnknownError),
        new as(Cn.message)
    }
}
const connectErrorsParser = new ConnectErrorsParser;
class RpcParser {
    isError(Cn) {
        return "error"in Cn
    }
}
const sendTransactionErrors = {
    [SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,
    [SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,
    [SEND_TRANSACTION_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,
    [SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError
};
class SendTransactionParser extends RpcParser {
    convertToRpcRequest(Cn) {
        return {
            method: "sendTransaction",
            params: [JSON.stringify(Cn)]
        }
    }
    parseAndThrowError(Cn) {
        let as = UnknownError;
        throw Cn.error.code in sendTransactionErrors && (as = sendTransactionErrors[Cn.error.code] || UnknownError),
        new as(Cn.error.message)
    }
    convertFromRpcResponse(Cn) {
        return {
            boc: Cn.result
        }
    }
}
const sendTransactionParser = new SendTransactionParser;
class HttpBridgeGatewayStorage {
    constructor(Cn, as) {
        this.storage = Cn,
        this.storeKey = "ton-connect-storage_http-bridge-gateway::" + as
    }
    storeLastEventId(Cn) {
        return __awaiter$1(this, void 0, void 0, function*() {
            return this.storage.setItem(this.storeKey, Cn)
        })
    }
    removeLastEventId() {
        return __awaiter$1(this, void 0, void 0, function*() {
            return this.storage.removeItem(this.storeKey)
        })
    }
    getLastEventId() {
        return __awaiter$1(this, void 0, void 0, function*() {
            const Cn = yield this.storage.getItem(this.storeKey);
            return Cn || null
        })
    }
}
function removeUrlLastSlash(xt) {
    return xt.slice(-1) === "/" ? xt.slice(0, -1) : xt
}
function addPathToUrl(xt, Cn) {
    return removeUrlLastSlash(xt) + "/" + Cn
}
function isTelegramUrl(xt) {
    if (!xt)
        return !1;
    const Cn = new URL(xt);
    return Cn.protocol === "tg:" || Cn.hostname === "t.me"
}
function encodeTelegramUrlParameters(xt) {
    return xt.replaceAll(".", "%2E").replaceAll("-", "%2D").replaceAll("_", "%5F").replaceAll("&", "-").replaceAll("=", "__").replaceAll("%", "--")
}
function delay$1(xt, Cn) {
    return __awaiter$1(this, void 0, void 0, function*() {
        return new Promise( (as, cs) => {
            var Cs, Ls;
            if (!((Cs = void 0) === null || Cs === void 0) && Cs.aborted) {
                cs(new TonConnectError("Delay aborted"));
                return
            }
            const Vs = setTimeout( () => as(), xt);
            (Ls = void 0) === null || Ls === void 0 || Ls.addEventListener("abort", () => {
                clearTimeout(Vs),
                cs(new TonConnectError("Delay aborted"))
            }
            )
        }
        )
    })
}
function createAbortController(xt) {
    const Cn = new AbortController;
    return xt != null && xt.aborted ? Cn.abort() : xt == null || xt.addEventListener("abort", () => Cn.abort(), {
        once: !0
    }),
    Cn
}
function callForSuccess(xt, Cn) {
    var as, cs;
    return __awaiter$1(this, void 0, void 0, function*() {
        const Cs = (as = Cn == null ? void 0 : Cn.attempts) !== null && as !== void 0 ? as : 10
          , Ls = (cs = Cn == null ? void 0 : Cn.delayMs) !== null && cs !== void 0 ? cs : 200
          , Vs = createAbortController(Cn == null ? void 0 : Cn.signal);
        if (typeof xt != "function")
            throw new TonConnectError(`Expected a function, got ${typeof xt}`);
        let Ws = 0, Xs;
        for (; Ws < Cs; ) {
            if (Vs.signal.aborted)
                throw new TonConnectError(`Aborted after attempts ${Ws}`);
            try {
                return yield xt({
                    signal: Vs.signal
                })
            } catch (ga) {
                Xs = ga,
                Ws++,
                Ws < Cs && (yield delay$1(Ls))
            }
        }
        throw Xs
    })
}
function logDebug$1(...xt) {
    try {
        console.debug("[TON_CONNECT_SDK]", ...xt)
    } catch {}
}
function logError$2(...xt) {
    try {
        console.error("[TON_CONNECT_SDK]", ...xt)
    } catch {}
}
function logWarning$1(...xt) {
    try {
        console.warn("[TON_CONNECT_SDK]", ...xt)
    } catch {}
}
function createResource$1(xt, Cn) {
    let as = null
      , cs = null
      , Cs = null
      , Ls = null
      , Vs = null;
    const Ws = (yl, ...xl) => __awaiter$1(this, void 0, void 0, function*() {
        if (Ls = yl ?? null,
        Vs == null || Vs.abort(),
        Vs = createAbortController(yl),
        Vs.signal.aborted)
            throw new TonConnectError("Resource creation was aborted");
        cs = xl ?? null;
        const wl = xt(Vs.signal, ...xl);
        Cs = wl;
        const _l = yield wl;
        if (Cs !== wl && _l !== as)
            throw yield Cn(_l),
            new TonConnectError("Resource creation was aborted by a new resource creation");
        return as = _l,
        as
    });
    return {
        create: Ws,
        current: () => as ?? null,
        dispose: () => __awaiter$1(this, void 0, void 0, function*() {
            try {
                const yl = as;
                as = null;
                const xl = Cs;
                Cs = null;
                try {
                    Vs == null || Vs.abort()
                } catch {}
                yield Promise.allSettled([yl ? Cn(yl) : Promise.resolve(), xl ? Cn(yield xl) : Promise.resolve()])
            } catch {}
        }),
        recreate: yl => __awaiter$1(this, void 0, void 0, function*() {
            const xl = as
              , wl = Cs
              , _l = cs
              , El = Ls;
            if (yield delay$1(yl),
            xl === as && wl === Cs && _l === cs && El === Ls)
                return yield Ws(Ls, ..._l ?? []);
            throw new TonConnectError("Resource recreation was aborted by a new resource creation")
        })
    }
}
function timeout(xt, Cn) {
    const as = Cn == null ? void 0 : Cn.timeout
      , cs = Cn == null ? void 0 : Cn.signal
      , Cs = createAbortController(cs);
    return new Promise( (Ls, Vs) => __awaiter$1(this, void 0, void 0, function*() {
        if (Cs.signal.aborted) {
            Vs(new TonConnectError("Operation aborted"));
            return
        }
        let Ws;
        typeof as < "u" && (Ws = setTimeout( () => {
            Cs.abort(),
            Vs(new TonConnectError(`Timeout after ${as}ms`))
        }
        , as)),
        Cs.signal.addEventListener("abort", () => {
            clearTimeout(Ws),
            Vs(new TonConnectError("Operation aborted"))
        }
        , {
            once: !0
        });
        const Xs = {
            timeout: as,
            abort: Cs.signal
        };
        yield xt( (...ga) => {
            clearTimeout(Ws),
            Ls(...ga)
        }
        , () => {
            clearTimeout(Ws),
            Vs()
        }
        , Xs)
    }))
}
class BridgeGateway {
    constructor(Cn, as, cs, Cs, Ls) {
        this.bridgeUrl = as,
        this.sessionId = cs,
        this.listener = Cs,
        this.errorsListener = Ls,
        this.ssePath = "events",
        this.postPath = "message",
        this.heartbeatMessage = "heartbeat",
        this.defaultTtl = 300,
        this.defaultReconnectDelay = 2e3,
        this.defaultResendDelay = 5e3,
        this.eventSource = createResource$1( (Vs, Ws) => __awaiter$1(this, void 0, void 0, function*() {
            const Xs = {
                bridgeUrl: this.bridgeUrl,
                ssePath: this.ssePath,
                sessionId: this.sessionId,
                bridgeGatewayStorage: this.bridgeGatewayStorage,
                errorHandler: this.errorsHandler.bind(this),
                messageHandler: this.messagesHandler.bind(this),
                signal: Vs,
                openingDeadlineMS: Ws
            };
            return yield createEventSource(Xs)
        }), Vs => __awaiter$1(this, void 0, void 0, function*() {
            Vs.close()
        })),
        this.bridgeGatewayStorage = new HttpBridgeGatewayStorage(Cn,as)
    }
    get isReady() {
        const Cn = this.eventSource.current();
        return (Cn == null ? void 0 : Cn.readyState) === EventSource.OPEN
    }
    get isClosed() {
        const Cn = this.eventSource.current();
        return (Cn == null ? void 0 : Cn.readyState) !== EventSource.OPEN
    }
    get isConnecting() {
        const Cn = this.eventSource.current();
        return (Cn == null ? void 0 : Cn.readyState) === EventSource.CONNECTING
    }
    registerSession(Cn) {
        return __awaiter$1(this, void 0, void 0, function*() {
            yield this.eventSource.create(Cn == null ? void 0 : Cn.signal, Cn == null ? void 0 : Cn.openingDeadlineMS)
        })
    }
    send(Cn, as, cs, Cs) {
        var Ls;
        return __awaiter$1(this, void 0, void 0, function*() {
            const Vs = {};
            typeof Cs == "number" ? Vs.ttl = Cs : (Vs.ttl = Cs == null ? void 0 : Cs.ttl,
            Vs.signal = Cs == null ? void 0 : Cs.signal,
            Vs.attempts = Cs == null ? void 0 : Cs.attempts);
            const Ws = new URL(addPathToUrl(this.bridgeUrl, this.postPath));
            Ws.searchParams.append("client_id", this.sessionId),
            Ws.searchParams.append("to", as),
            Ws.searchParams.append("ttl", ((Vs == null ? void 0 : Vs.ttl) || this.defaultTtl).toString()),
            Ws.searchParams.append("topic", cs);
            const Xs = Base64.encode(Cn);
            yield callForSuccess(ga => __awaiter$1(this, void 0, void 0, function*() {
                const ba = yield this.post(Ws, Xs, ga.signal);
                if (!ba.ok)
                    throw new TonConnectError(`Bridge send failed, status ${ba.status}`)
            }), {
                attempts: (Ls = Vs == null ? void 0 : Vs.attempts) !== null && Ls !== void 0 ? Ls : Number.MAX_SAFE_INTEGER,
                delayMs: this.defaultResendDelay,
                signal: Vs == null ? void 0 : Vs.signal
            })
        })
    }
    pause() {
        this.eventSource.dispose().catch(Cn => logError$2(`Bridge pause failed, ${Cn}`))
    }
    unPause() {
        return __awaiter$1(this, void 0, void 0, function*() {
            yield this.eventSource.recreate(0)
        })
    }
    close() {
        return __awaiter$1(this, void 0, void 0, function*() {
            yield this.eventSource.dispose().catch(Cn => logError$2(`Bridge close failed, ${Cn}`))
        })
    }
    setListener(Cn) {
        this.listener = Cn
    }
    setErrorsListener(Cn) {
        this.errorsListener = Cn
    }
    post(Cn, as, cs) {
        return __awaiter$1(this, void 0, void 0, function*() {
            const Cs = yield fetch(Cn, {
                method: "post",
                body: as,
                signal: cs
            });
            if (!Cs.ok)
                throw new TonConnectError(`Bridge send failed, status ${Cs.status}`);
            return Cs
        })
    }
    errorsHandler(Cn, as) {
        return __awaiter$1(this, void 0, void 0, function*() {
            if (this.isConnecting)
                throw Cn.close(),
                new TonConnectError("Bridge error, failed to connect");
            if (this.isReady) {
                try {
                    this.errorsListener(as)
                } catch {}
                return
            }
            if (this.isClosed)
                return Cn.close(),
                logDebug$1(`Bridge reconnecting, ${this.defaultReconnectDelay}ms delay`),
                yield this.eventSource.recreate(this.defaultReconnectDelay);
            throw new TonConnectError("Bridge error, unknown state")
        })
    }
    messagesHandler(Cn) {
        return __awaiter$1(this, void 0, void 0, function*() {
            if (Cn.data === this.heartbeatMessage || (yield this.bridgeGatewayStorage.storeLastEventId(Cn.lastEventId),
            this.isClosed))
                return;
            let as;
            try {
                as = JSON.parse(Cn.data)
            } catch (cs) {
                throw new TonConnectError(`Bridge message parse failed, message ${cs.data}`)
            }
            this.listener(as)
        })
    }
}
function createEventSource(xt) {
    return __awaiter$1(this, void 0, void 0, function*() {
        return yield timeout( (Cn, as, cs) => __awaiter$1(this, void 0, void 0, function*() {
            var Cs;
            const Vs = createAbortController(cs.signal).signal;
            if (Vs.aborted) {
                as(new TonConnectError("Bridge connection aborted"));
                return
            }
            const Ws = new URL(addPathToUrl(xt.bridgeUrl, xt.ssePath));
            Ws.searchParams.append("client_id", xt.sessionId);
            const Xs = yield xt.bridgeGatewayStorage.getLastEventId();
            if (Xs && Ws.searchParams.append("last_event_id", Xs),
            Vs.aborted) {
                as(new TonConnectError("Bridge connection aborted"));
                return
            }
            const ga = new EventSource(Ws.toString());
            ga.onerror = ba => __awaiter$1(this, void 0, void 0, function*() {
                if (Vs.aborted) {
                    ga.close(),
                    as(new TonConnectError("Bridge connection aborted"));
                    return
                }
                try {
                    const yl = yield xt.errorHandler(ga, ba);
                    yl !== ga && ga.close(),
                    yl && yl !== ga && Cn(yl)
                } catch (yl) {
                    ga.close(),
                    as(yl)
                }
            }),
            ga.onopen = () => {
                if (Vs.aborted) {
                    ga.close(),
                    as(new TonConnectError("Bridge connection aborted"));
                    return
                }
                Cn(ga)
            }
            ,
            ga.onmessage = ba => {
                if (Vs.aborted) {
                    ga.close(),
                    as(new TonConnectError("Bridge connection aborted"));
                    return
                }
                xt.messageHandler(ba)
            }
            ,
            (Cs = xt.signal) === null || Cs === void 0 || Cs.addEventListener("abort", () => {
                ga.close(),
                as(new TonConnectError("Bridge connection aborted"))
            }
            )
        }), {
            timeout: xt.openingDeadlineMS,
            signal: xt.signal
        })
    })
}
function isPendingConnectionHttp(xt) {
    return !("connectEvent"in xt)
}
class BridgeConnectionStorage {
    constructor(Cn) {
        this.storage = Cn,
        this.storeKey = "ton-connect-storage_bridge-connection"
    }
    storeConnection(Cn) {
        return __awaiter$1(this, void 0, void 0, function*() {
            if (Cn.type === "injected")
                return this.storage.setItem(this.storeKey, JSON.stringify(Cn));
            if (!isPendingConnectionHttp(Cn)) {
                const cs = {
                    sessionKeyPair: Cn.session.sessionCrypto.stringifyKeypair(),
                    walletPublicKey: Cn.session.walletPublicKey,
                    bridgeUrl: Cn.session.bridgeUrl
                }
                  , Cs = {
                    type: "http",
                    connectEvent: Cn.connectEvent,
                    session: cs,
                    lastWalletEventId: Cn.lastWalletEventId,
                    nextRpcRequestId: Cn.nextRpcRequestId
                };
                return this.storage.setItem(this.storeKey, JSON.stringify(Cs))
            }
            const as = {
                type: "http",
                connectionSource: Cn.connectionSource,
                sessionCrypto: Cn.sessionCrypto.stringifyKeypair()
            };
            return this.storage.setItem(this.storeKey, JSON.stringify(as))
        })
    }
    removeConnection() {
        return __awaiter$1(this, void 0, void 0, function*() {
            return this.storage.removeItem(this.storeKey)
        })
    }
    getConnection() {
        return __awaiter$1(this, void 0, void 0, function*() {
            const Cn = yield this.storage.getItem(this.storeKey);
            if (!Cn)
                return null;
            const as = JSON.parse(Cn);
            if (as.type === "injected")
                return as;
            if ("connectEvent"in as) {
                const cs = new SessionCrypto(as.session.sessionKeyPair);
                return {
                    type: "http",
                    connectEvent: as.connectEvent,
                    lastWalletEventId: as.lastWalletEventId,
                    nextRpcRequestId: as.nextRpcRequestId,
                    session: {
                        sessionCrypto: cs,
                        bridgeUrl: as.session.bridgeUrl,
                        walletPublicKey: as.session.walletPublicKey
                    }
                }
            }
            return {
                type: "http",
                sessionCrypto: new SessionCrypto(as.sessionCrypto),
                connectionSource: as.connectionSource
            }
        })
    }
    getHttpConnection() {
        return __awaiter$1(this, void 0, void 0, function*() {
            const Cn = yield this.getConnection();
            if (!Cn)
                throw new TonConnectError("Trying to read HTTP connection source while nothing is stored");
            if (Cn.type === "injected")
                throw new TonConnectError("Trying to read HTTP connection source while injected connection is stored");
            return Cn
        })
    }
    getHttpPendingConnection() {
        return __awaiter$1(this, void 0, void 0, function*() {
            const Cn = yield this.getConnection();
            if (!Cn)
                throw new TonConnectError("Trying to read HTTP connection source while nothing is stored");
            if (Cn.type === "injected")
                throw new TonConnectError("Trying to read HTTP connection source while injected connection is stored");
            if (!isPendingConnectionHttp(Cn))
                throw new TonConnectError("Trying to read HTTP-pending connection while http connection is stored");
            return Cn
        })
    }
    getInjectedConnection() {
        return __awaiter$1(this, void 0, void 0, function*() {
            const Cn = yield this.getConnection();
            if (!Cn)
                throw new TonConnectError("Trying to read Injected bridge connection source while nothing is stored");
            if ((Cn == null ? void 0 : Cn.type) === "http")
                throw new TonConnectError("Trying to read Injected bridge connection source while HTTP connection is stored");
            return Cn
        })
    }
    storedConnectionType() {
        return __awaiter$1(this, void 0, void 0, function*() {
            const Cn = yield this.storage.getItem(this.storeKey);
            return Cn ? JSON.parse(Cn).type : null
        })
    }
    storeLastWalletEventId(Cn) {
        return __awaiter$1(this, void 0, void 0, function*() {
            const as = yield this.getConnection();
            if (as && as.type === "http" && !isPendingConnectionHttp(as))
                return as.lastWalletEventId = Cn,
                this.storeConnection(as)
        })
    }
    getLastWalletEventId() {
        return __awaiter$1(this, void 0, void 0, function*() {
            const Cn = yield this.getConnection();
            if (Cn && "lastWalletEventId"in Cn)
                return Cn.lastWalletEventId
        })
    }
    increaseNextRpcRequestId() {
        return __awaiter$1(this, void 0, void 0, function*() {
            const Cn = yield this.getConnection();
            if (Cn && "nextRpcRequestId"in Cn) {
                const as = Cn.nextRpcRequestId || 0;
                return Cn.nextRpcRequestId = as + 1,
                this.storeConnection(Cn)
            }
        })
    }
    getNextRpcRequestId() {
        return __awaiter$1(this, void 0, void 0, function*() {
            const Cn = yield this.getConnection();
            return Cn && "nextRpcRequestId"in Cn && Cn.nextRpcRequestId || 0
        })
    }
}
const PROTOCOL_VERSION = 2;
class BridgeProvider {
    constructor(Cn, as) {
        this.storage = Cn,
        this.walletConnectionSource = as,
        this.type = "http",
        this.standardUniversalLink = "tc://",
        this.pendingRequests = new Map,
        this.session = null,
        this.gateway = null,
        this.pendingGateways = [],
        this.listeners = [],
        this.defaultOpeningDeadlineMS = 12e3,
        this.defaultRetryTimeoutMS = 2e3,
        this.connectionStorage = new BridgeConnectionStorage(Cn)
    }
    static fromStorage(Cn) {
        return __awaiter$1(this, void 0, void 0, function*() {
            const cs = yield new BridgeConnectionStorage(Cn).getHttpConnection();
            return isPendingConnectionHttp(cs) ? new BridgeProvider(Cn,cs.connectionSource) : new BridgeProvider(Cn,{
                bridgeUrl: cs.session.bridgeUrl
            })
        })
    }
    connect(Cn, as) {
        var cs;
        const Cs = createAbortController(as == null ? void 0 : as.signal);
        (cs = this.abortController) === null || cs === void 0 || cs.abort(),
        this.abortController = Cs,
        this.closeGateways();
        const Ls = new SessionCrypto;
        this.session = {
            sessionCrypto: Ls,
            bridgeUrl: "bridgeUrl"in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
        },
        this.connectionStorage.storeConnection({
            type: "http",
            connectionSource: this.walletConnectionSource,
            sessionCrypto: Ls
        }).then( () => __awaiter$1(this, void 0, void 0, function*() {
            Cs.signal.aborted || (yield callForSuccess(Ws => {
                var Xs;
                return this.openGateways(Ls, {
                    openingDeadlineMS: (Xs = as == null ? void 0 : as.openingDeadlineMS) !== null && Xs !== void 0 ? Xs : this.defaultOpeningDeadlineMS,
                    signal: Ws == null ? void 0 : Ws.signal
                })
            }
            , {
                attempts: Number.MAX_SAFE_INTEGER,
                delayMs: this.defaultRetryTimeoutMS,
                signal: Cs.signal
            }))
        }));
        const Vs = "universalLink"in this.walletConnectionSource && this.walletConnectionSource.universalLink ? this.walletConnectionSource.universalLink : this.standardUniversalLink;
        return this.generateUniversalLink(Vs, Cn)
    }
    restoreConnection(Cn) {
        var as, cs;
        return __awaiter$1(this, void 0, void 0, function*() {
            const Cs = createAbortController(Cn == null ? void 0 : Cn.signal);
            if ((as = this.abortController) === null || as === void 0 || as.abort(),
            this.abortController = Cs,
            Cs.signal.aborted)
                return;
            this.closeGateways();
            const Ls = yield this.connectionStorage.getHttpConnection();
            if (!Ls || Cs.signal.aborted)
                return;
            const Vs = (cs = Cn == null ? void 0 : Cn.openingDeadlineMS) !== null && cs !== void 0 ? cs : this.defaultOpeningDeadlineMS;
            if (isPendingConnectionHttp(Ls))
                return this.session = {
                    sessionCrypto: Ls.sessionCrypto,
                    bridgeUrl: "bridgeUrl"in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
                },
                yield this.openGateways(Ls.sessionCrypto, {
                    openingDeadlineMS: Vs,
                    signal: Cs == null ? void 0 : Cs.signal
                });
            if (Array.isArray(this.walletConnectionSource))
                throw new TonConnectError("Internal error. Connection source is array while WalletConnectionSourceHTTP was expected.");
            if (this.session = Ls.session,
            this.gateway && (logDebug$1("Gateway is already opened, closing previous gateway"),
            yield this.gateway.close()),
            this.gateway = new BridgeGateway(this.storage,this.walletConnectionSource.bridgeUrl,Ls.session.sessionCrypto.sessionId,this.gatewayListener.bind(this),this.gatewayErrorsListener.bind(this)),
            !Cs.signal.aborted) {
                this.listeners.forEach(Ws => Ws(Ls.connectEvent));
                try {
                    yield callForSuccess(Ws => this.gateway.registerSession({
                        openingDeadlineMS: Vs,
                        signal: Ws.signal
                    }), {
                        attempts: Number.MAX_SAFE_INTEGER,
                        delayMs: this.defaultRetryTimeoutMS,
                        signal: Cs.signal
                    })
                } catch {
                    yield this.disconnect({
                        signal: Cs.signal
                    });
                    return
                }
            }
        })
    }
    sendRequest(Cn, as) {
        const cs = {};
        return typeof as == "function" ? cs.onRequestSent = as : (cs.onRequestSent = as == null ? void 0 : as.onRequestSent,
        cs.signal = as == null ? void 0 : as.signal,
        cs.attempts = as == null ? void 0 : as.attempts),
        new Promise( (Cs, Ls) => __awaiter$1(this, void 0, void 0, function*() {
            var Vs;
            if (!this.gateway || !this.session || !("walletPublicKey"in this.session))
                throw new TonConnectError("Trying to send bridge request without session");
            const Ws = (yield this.connectionStorage.getNextRpcRequestId()).toString();
            yield this.connectionStorage.increaseNextRpcRequestId(),
            logDebug$1("Send http-bridge request:", Object.assign(Object.assign({}, Cn), {
                id: Ws
            }));
            const Xs = this.session.sessionCrypto.encrypt(JSON.stringify(Object.assign(Object.assign({}, Cn), {
                id: Ws
            })), hexToByteArray(this.session.walletPublicKey));
            try {
                yield this.gateway.send(Xs, this.session.walletPublicKey, Cn.method, {
                    attempts: cs == null ? void 0 : cs.attempts,
                    signal: cs == null ? void 0 : cs.signal
                }),
                (Vs = cs == null ? void 0 : cs.onRequestSent) === null || Vs === void 0 || Vs.call(cs),
                this.pendingRequests.set(Ws.toString(), Cs)
            } catch (ga) {
                Ls(ga)
            }
        }))
    }
    closeConnection() {
        this.closeGateways(),
        this.listeners = [],
        this.session = null,
        this.gateway = null
    }
    disconnect(Cn) {
        return __awaiter$1(this, void 0, void 0, function*() {
            return new Promise(as => __awaiter$1(this, void 0, void 0, function*() {
                let cs = !1
                  , Cs = null;
                const Ls = () => {
                    cs || (cs = !0,
                    this.removeBridgeAndSession().then(as))
                }
                ;
                try {
                    this.closeGateways();
                    const Vs = createAbortController(Cn == null ? void 0 : Cn.signal);
                    Cs = setTimeout( () => {
                        Vs.abort()
                    }
                    , this.defaultOpeningDeadlineMS),
                    yield this.sendRequest({
                        method: "disconnect",
                        params: []
                    }, {
                        onRequestSent: Ls,
                        signal: Vs.signal,
                        attempts: 1
                    })
                } catch (Vs) {
                    logDebug$1("Disconnect error:", Vs),
                    cs || this.removeBridgeAndSession().then(as)
                } finally {
                    Cs && clearTimeout(Cs),
                    Ls()
                }
            }))
        })
    }
    listen(Cn) {
        return this.listeners.push(Cn),
        () => this.listeners = this.listeners.filter(as => as !== Cn)
    }
    pause() {
        var Cn;
        (Cn = this.gateway) === null || Cn === void 0 || Cn.pause(),
        this.pendingGateways.forEach(as => as.pause())
    }
    unPause() {
        return __awaiter$1(this, void 0, void 0, function*() {
            const Cn = this.pendingGateways.map(as => as.unPause());
            this.gateway && Cn.push(this.gateway.unPause()),
            yield Promise.all(Cn)
        })
    }
    pendingGatewaysListener(Cn, as, cs) {
        return __awaiter$1(this, void 0, void 0, function*() {
            if (!this.pendingGateways.includes(Cn)) {
                yield Cn.close();
                return
            }
            return this.closeGateways({
                except: Cn
            }),
            this.gateway && (logDebug$1("Gateway is already opened, closing previous gateway"),
            yield this.gateway.close()),
            this.session.bridgeUrl = as,
            this.gateway = Cn,
            this.gateway.setErrorsListener(this.gatewayErrorsListener.bind(this)),
            this.gateway.setListener(this.gatewayListener.bind(this)),
            this.gatewayListener(cs)
        })
    }
    gatewayListener(Cn) {
        return __awaiter$1(this, void 0, void 0, function*() {
            const as = JSON.parse(this.session.sessionCrypto.decrypt(Base64.decode(Cn.message).toUint8Array(), hexToByteArray(Cn.from)));
            if (logDebug$1("Wallet message received:", as),
            !("event"in as)) {
                const Cs = as.id.toString()
                  , Ls = this.pendingRequests.get(Cs);
                if (!Ls) {
                    logDebug$1(`Response id ${Cs} doesn't match any request's id`);
                    return
                }
                Ls(as),
                this.pendingRequests.delete(Cs);
                return
            }
            if (as.id !== void 0) {
                const Cs = yield this.connectionStorage.getLastWalletEventId();
                if (Cs !== void 0 && as.id <= Cs) {
                    logError$2(`Received event id (=${as.id}) must be greater than stored last wallet event id (=${Cs}) `);
                    return
                }
                as.event !== "connect" && (yield this.connectionStorage.storeLastWalletEventId(as.id))
            }
            const cs = this.listeners;
            as.event === "connect" && (yield this.updateSession(as, Cn.from)),
            as.event === "disconnect" && (logDebug$1("Removing bridge and session: received disconnect event"),
            yield this.removeBridgeAndSession()),
            cs.forEach(Cs => Cs(as))
        })
    }
    gatewayErrorsListener(Cn) {
        return __awaiter$1(this, void 0, void 0, function*() {
            throw new TonConnectError(`Bridge error ${JSON.stringify(Cn)}`)
        })
    }
    updateSession(Cn, as) {
        return __awaiter$1(this, void 0, void 0, function*() {
            this.session = Object.assign(Object.assign({}, this.session), {
                walletPublicKey: as
            });
            const cs = Cn.payload.items.find(Ls => Ls.name === "ton_addr")
              , Cs = Object.assign(Object.assign({}, Cn), {
                payload: Object.assign(Object.assign({}, Cn.payload), {
                    items: [cs]
                })
            });
            yield this.connectionStorage.storeConnection({
                type: "http",
                session: this.session,
                lastWalletEventId: Cn.id,
                connectEvent: Cs,
                nextRpcRequestId: 0
            })
        })
    }
    removeBridgeAndSession() {
        return __awaiter$1(this, void 0, void 0, function*() {
            this.closeConnection(),
            yield this.connectionStorage.removeConnection()
        })
    }
    generateUniversalLink(Cn, as) {
        return isTelegramUrl(Cn) ? this.generateTGUniversalLink(Cn, as) : this.generateRegularUniversalLink(Cn, as)
    }
    generateRegularUniversalLink(Cn, as) {
        const cs = new URL(Cn);
        return cs.searchParams.append("v", PROTOCOL_VERSION.toString()),
        cs.searchParams.append("id", this.session.sessionCrypto.sessionId),
        cs.searchParams.append("r", JSON.stringify(as)),
        cs.toString()
    }
    generateTGUniversalLink(Cn, as) {
        const Cs = this.generateRegularUniversalLink("about:blank", as).split("?")[1]
          , Ls = "tonconnect-" + encodeTelegramUrlParameters(Cs)
          , Vs = this.convertToDirectLink(Cn)
          , Ws = new URL(Vs);
        return Ws.searchParams.append("startapp", Ls),
        Ws.toString()
    }
    convertToDirectLink(Cn) {
        const as = new URL(Cn);
        return as.searchParams.has("attach") && (as.searchParams.delete("attach"),
        as.pathname += "/start"),
        as.toString()
    }
    openGateways(Cn, as) {
        return __awaiter$1(this, void 0, void 0, function*() {
            if (Array.isArray(this.walletConnectionSource)) {
                this.pendingGateways.map(cs => cs.close().catch()),
                this.pendingGateways = this.walletConnectionSource.map(cs => {
                    const Cs = new BridgeGateway(this.storage,cs.bridgeUrl,Cn.sessionId, () => {}
                    , () => {}
                    );
                    return Cs.setListener(Ls => this.pendingGatewaysListener(Cs, cs.bridgeUrl, Ls)),
                    Cs
                }
                ),
                yield Promise.allSettled(this.pendingGateways.map(cs => callForSuccess(Cs => {
                    var Ls;
                    return this.pendingGateways.some(Vs => Vs === cs) ? cs.registerSession({
                        openingDeadlineMS: (Ls = as == null ? void 0 : as.openingDeadlineMS) !== null && Ls !== void 0 ? Ls : this.defaultOpeningDeadlineMS,
                        signal: Cs.signal
                    }) : cs.close()
                }
                , {
                    attempts: Number.MAX_SAFE_INTEGER,
                    delayMs: this.defaultRetryTimeoutMS,
                    signal: as == null ? void 0 : as.signal
                })));
                return
            } else
                return this.gateway && (logDebug$1("Gateway is already opened, closing previous gateway"),
                yield this.gateway.close()),
                this.gateway = new BridgeGateway(this.storage,this.walletConnectionSource.bridgeUrl,Cn.sessionId,this.gatewayListener.bind(this),this.gatewayErrorsListener.bind(this)),
                yield this.gateway.registerSession({
                    openingDeadlineMS: as == null ? void 0 : as.openingDeadlineMS,
                    signal: as == null ? void 0 : as.signal
                })
        })
    }
    closeGateways(Cn) {
        var as;
        (as = this.gateway) === null || as === void 0 || as.close(),
        this.pendingGateways.filter(cs => cs !== (Cn == null ? void 0 : Cn.except)).forEach(cs => cs.close()),
        this.pendingGateways = []
    }
}
function hasProperty(xt, Cn) {
    return hasProperties(xt, [Cn])
}
function hasProperties(xt, Cn) {
    return !xt || typeof xt != "object" ? !1 : Cn.every(as => as in xt)
}
function isJSBridgeWithMetadata(xt) {
    try {
        return !hasProperty(xt, "tonconnect") || !hasProperty(xt.tonconnect, "walletInfo") ? !1 : hasProperties(xt.tonconnect.walletInfo, ["name", "app_name", "image", "about_url", "platforms"])
    } catch {
        return !1
    }
}
let InMemoryStorage$1 = class r1 {
    constructor() {
        this.storage = {}
    }
    static getInstance() {
        return r1.instance || (r1.instance = new r1),
        r1.instance
    }
    get length() {
        return Object.keys(this.storage).length
    }
    clear() {
        this.storage = {}
    }
    getItem(Cn) {
        var as;
        return (as = this.storage[Cn]) !== null && as !== void 0 ? as : null
    }
    key(Cn) {
        var as;
        const cs = Object.keys(this.storage);
        return Cn < 0 || Cn >= cs.length ? null : (as = cs[Cn]) !== null && as !== void 0 ? as : null
    }
    removeItem(Cn) {
        delete this.storage[Cn]
    }
    setItem(Cn, as) {
        this.storage[Cn] = as
    }
}
;
function getWindow$3() {
    if (!(typeof window > "u"))
        return window
}
function tryGetWindowKeys() {
    const xt = getWindow$3();
    if (!xt)
        return [];
    try {
        return Object.keys(xt)
    } catch {
        return []
    }
}
function getDocument() {
    if (!(typeof document > "u"))
        return document
}
function getWebPageManifest() {
    var xt;
    const Cn = (xt = getWindow$3()) === null || xt === void 0 ? void 0 : xt.location.origin;
    return Cn ? Cn + "/tonconnect-manifest.json" : ""
}
function tryGetLocalStorage$1() {
    if (isLocalStorageAvailable$1())
        return localStorage;
    if (isNodeJs$1())
        throw new TonConnectError("`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector");
    return InMemoryStorage$1.getInstance()
}
function isLocalStorageAvailable$1() {
    try {
        return typeof localStorage < "u"
    } catch {
        return !1
    }
}
function isNodeJs$1() {
    return typeof process < "u" && process.versions != null && process.versions.node != null
}
class InjectedProvider {
    constructor(Cn, as) {
        this.injectedWalletKey = as,
        this.type = "injected",
        this.unsubscribeCallback = null,
        this.listenSubscriptions = !1,
        this.listeners = [];
        const cs = InjectedProvider.window;
        if (!InjectedProvider.isWindowContainsWallet(cs, as))
            throw new WalletNotInjectedError;
        this.connectionStorage = new BridgeConnectionStorage(Cn),
        this.injectedWallet = cs[as].tonconnect
    }
    static fromStorage(Cn) {
        return __awaiter$1(this, void 0, void 0, function*() {
            const cs = yield new BridgeConnectionStorage(Cn).getInjectedConnection();
            return new InjectedProvider(Cn,cs.jsBridgeKey)
        })
    }
    static isWalletInjected(Cn) {
        return InjectedProvider.isWindowContainsWallet(this.window, Cn)
    }
    static isInsideWalletBrowser(Cn) {
        return InjectedProvider.isWindowContainsWallet(this.window, Cn) ? this.window[Cn].tonconnect.isWalletBrowser : !1
    }
    static getCurrentlyInjectedWallets() {
        return this.window ? tryGetWindowKeys().filter( ([cs,Cs]) => isJSBridgeWithMetadata(Cs)).map( ([cs,Cs]) => ({
            name: Cs.tonconnect.walletInfo.name,
            appName: Cs.tonconnect.walletInfo.app_name,
            aboutUrl: Cs.tonconnect.walletInfo.about_url,
            imageUrl: Cs.tonconnect.walletInfo.image,
            tondns: Cs.tonconnect.walletInfo.tondns,
            jsBridgeKey: cs,
            injected: !0,
            embedded: Cs.tonconnect.isWalletBrowser,
            platforms: Cs.tonconnect.walletInfo.platforms
        })) : []
    }
    static isWindowContainsWallet(Cn, as) {
        return !!Cn && as in Cn && typeof Cn[as] == "object" && "tonconnect"in Cn[as]
    }
    connect(Cn) {
        this._connect(PROTOCOL_VERSION, Cn)
    }
    restoreConnection() {
        return __awaiter$1(this, void 0, void 0, function*() {
            try {
                logDebug$1("Injected Provider restoring connection...");
                const Cn = yield this.injectedWallet.restoreConnection();
                logDebug$1("Injected Provider restoring connection response", Cn),
                Cn.event === "connect" ? (this.makeSubscriptions(),
                this.listeners.forEach(as => as(Cn))) : yield this.connectionStorage.removeConnection()
            } catch (Cn) {
                yield this.connectionStorage.removeConnection(),
                console.error(Cn)
            }
        })
    }
    closeConnection() {
        this.listenSubscriptions && this.injectedWallet.disconnect(),
        this.closeAllListeners()
    }
    disconnect() {
        return __awaiter$1(this, void 0, void 0, function*() {
            return new Promise(Cn => {
                const as = () => {
                    this.closeAllListeners(),
                    this.connectionStorage.removeConnection().then(Cn)
                }
                ;
                try {
                    this.injectedWallet.disconnect(),
                    as()
                } catch (cs) {
                    logDebug$1(cs),
                    this.sendRequest({
                        method: "disconnect",
                        params: []
                    }, as)
                }
            }
            )
        })
    }
    closeAllListeners() {
        var Cn;
        this.listenSubscriptions = !1,
        this.listeners = [],
        (Cn = this.unsubscribeCallback) === null || Cn === void 0 || Cn.call(this)
    }
    listen(Cn) {
        return this.listeners.push(Cn),
        () => this.listeners = this.listeners.filter(as => as !== Cn)
    }
    sendRequest(Cn, as) {
        var cs;
        return __awaiter$1(this, void 0, void 0, function*() {
            const Cs = {};
            typeof as == "function" ? Cs.onRequestSent = as : (Cs.onRequestSent = as == null ? void 0 : as.onRequestSent,
            Cs.signal = as == null ? void 0 : as.signal);
            const Ls = (yield this.connectionStorage.getNextRpcRequestId()).toString();
            yield this.connectionStorage.increaseNextRpcRequestId(),
            logDebug$1("Send injected-bridge request:", Object.assign(Object.assign({}, Cn), {
                id: Ls
            }));
            const Vs = this.injectedWallet.send(Object.assign(Object.assign({}, Cn), {
                id: Ls
            }));
            return Vs.then(Ws => logDebug$1("Wallet message received:", Ws)),
            (cs = Cs == null ? void 0 : Cs.onRequestSent) === null || cs === void 0 || cs.call(Cs),
            Vs
        })
    }
    _connect(Cn, as) {
        return __awaiter$1(this, void 0, void 0, function*() {
            try {
                logDebug$1(`Injected Provider connect request: protocolVersion: ${Cn}, message:`, as);
                const cs = yield this.injectedWallet.connect(Cn, as);
                logDebug$1("Injected Provider connect response:", cs),
                cs.event === "connect" && (yield this.updateSession(),
                this.makeSubscriptions()),
                this.listeners.forEach(Cs => Cs(cs))
            } catch (cs) {
                logDebug$1("Injected Provider connect error:", cs);
                const Cs = {
                    event: "connect_error",
                    payload: {
                        code: 0,
                        message: cs == null ? void 0 : cs.toString()
                    }
                };
                this.listeners.forEach(Ls => Ls(Cs))
            }
        })
    }
    makeSubscriptions() {
        this.listenSubscriptions = !0,
        this.unsubscribeCallback = this.injectedWallet.listen(Cn => {
            logDebug$1("Wallet message received:", Cn),
            this.listenSubscriptions && this.listeners.forEach(as => as(Cn)),
            Cn.event === "disconnect" && this.disconnect()
        }
        )
    }
    updateSession() {
        return this.connectionStorage.storeConnection({
            type: "injected",
            jsBridgeKey: this.injectedWalletKey,
            nextRpcRequestId: 0
        })
    }
}
InjectedProvider.window = getWindow$3();
class DefaultStorage {
    constructor() {
        this.localStorage = tryGetLocalStorage$1()
    }
    getItem(Cn) {
        return __awaiter$1(this, void 0, void 0, function*() {
            return this.localStorage.getItem(Cn)
        })
    }
    removeItem(Cn) {
        return __awaiter$1(this, void 0, void 0, function*() {
            this.localStorage.removeItem(Cn)
        })
    }
    setItem(Cn, as) {
        return __awaiter$1(this, void 0, void 0, function*() {
            this.localStorage.setItem(Cn, as)
        })
    }
}
function isWalletInfoCurrentlyInjected(xt) {
    return isWalletInfoInjectable(xt) && xt.injected
}
function isWalletInfoCurrentlyEmbedded(xt) {
    return isWalletInfoCurrentlyInjected(xt) && xt.embedded
}
function isWalletInfoInjectable(xt) {
    return "jsBridgeKey"in xt
}
function isWalletInfoRemote(xt) {
    return "bridgeUrl"in xt
}
const FALLBACK_WALLETS_LIST = [{
    app_name: "telegram-wallet",
    name: "Wallet",
    image: "https://wallet.tg/images/logo-288.png",
    about_url: "https://wallet.tg/",
    universal_url: "https://t.me/wallet?attach=wallet",
    bridge: [{
        type: "sse",
        url: "https://bridge.ton.space/bridge"
    }],
    platforms: ["ios", "android", "macos", "windows", "linux"]
}, {
    app_name: "tonkeeper",
    name: "Tonkeeper",
    image: "https://tonkeeper.com/assets/tonconnect-icon.png",
    tondns: "tonkeeper.ton",
    about_url: "https://tonkeeper.com",
    universal_url: "https://app.tonkeeper.com/ton-connect",
    deepLink: "tonkeeper-tc://",
    bridge: [{
        type: "sse",
        url: "https://bridge.tonapi.io/bridge"
    }, {
        type: "js",
        key: "tonkeeper"
    }],
    platforms: ["ios", "android", "chrome", "firefox", "macos"]
}, {
    app_name: "mytonwallet",
    name: "MyTonWallet",
    image: "https://static.mytonwallet.io/icon-256.png",
    about_url: "https://mytonwallet.io",
    universal_url: "https://connect.mytonwallet.org",
    bridge: [{
        type: "js",
        key: "mytonwallet"
    }, {
        type: "sse",
        url: "https://tonconnectbridge.mytonwallet.org/bridge/"
    }],
    platforms: ["chrome", "windows", "macos", "linux", "ios", "android", "firefox"]
}, {
    app_name: "openmask",
    name: "OpenMask",
    image: "https://raw.githubusercontent.com/OpenProduct/openmask-extension/main/public/openmask-logo-288.png",
    about_url: "https://www.openmask.app/",
    bridge: [{
        type: "js",
        key: "openmask"
    }],
    platforms: ["chrome"]
}, {
    app_name: "tonhub",
    name: "Tonhub",
    image: "https://tonhub.com/tonconnect_logo.png",
    about_url: "https://tonhub.com",
    universal_url: "https://tonhub.com/ton-connect",
    bridge: [{
        type: "js",
        key: "tonhub"
    }, {
        type: "sse",
        url: "https://connect.tonhubapi.com/tonconnect"
    }],
    platforms: ["ios", "android"]
}, {
    app_name: "dewallet",
    name: "DeWallet",
    image: "https://raw.githubusercontent.com/delab-team/manifests-images/main/WalletAvatar.png",
    about_url: "https://delabwallet.com",
    universal_url: "https://t.me/dewallet?attach=wallet",
    bridge: [{
        type: "sse",
        url: "https://sse-bridge.delab.team/bridge"
    }],
    platforms: ["ios", "android"]
}, {
    app_name: "xtonwallet",
    name: "XTONWallet",
    image: "https://xtonwallet.com/assets/img/icon-256-back.png",
    about_url: "https://xtonwallet.com",
    bridge: [{
        type: "js",
        key: "xtonwallet"
    }],
    platforms: ["chrome", "firefox"]
}, {
    app_name: "tonwallet",
    name: "TON Wallet",
    image: "https://wallet.ton.org/assets/ui/qr-logo.png",
    about_url: "https://chrome.google.com/webstore/detail/ton-wallet/nphplpgoakhhjchkkhmiggakijnkhfnd",
    bridge: [{
        type: "js",
        key: "tonwallet"
    }],
    platforms: ["chrome"]
}, {
    app_name: "bitgetTonWallet",
    name: "Bitget Wallet",
    image: "https://raw.githubusercontent.com/bitkeepwallet/download/main/logo/png/bitget_wallet_logo_0_gas_fee.png",
    about_url: "https://web3.bitget.com",
    deepLink: "bitkeep://",
    bridge: [{
        type: "js",
        key: "bitgetTonWallet"
    }, {
        type: "sse",
        url: "https://bridge.tonapi.io/bridge"
    }],
    platforms: ["ios", "android", "chrome"],
    universal_url: "https://bkcode.vip/ton-connect"
}, {
    app_name: "safepalwallet",
    name: "SafePal",
    image: "https://s.pvcliping.com/web/public_image/SafePal_x288.png",
    tondns: "",
    about_url: "https://www.safepal.com",
    universal_url: "https://link.safepal.io/ton-connect",
    deepLink: "safepal-tc://",
    bridge: [{
        type: "sse",
        url: "https://ton-bridge.safepal.com/tonbridge/v1/bridge"
    }, {
        type: "js",
        key: "safepalwallet"
    }],
    platforms: ["ios", "android", "chrome", "firefox"]
}, {
    app_name: "okxTonWallet",
    name: "OKX Wallet",
    image: "https://static.okx.com/cdn/assets/imgs/247/58E63FEA47A2B7D7.png",
    about_url: "https://www.okx.com/web3",
    universal_url: "https://www.okx.com/download?appendQuery=true&deeplink=okx://web3/wallet/tonconnect",
    bridge: [{
        type: "js",
        key: "okxTonWallet"
    }, {
        type: "sse",
        url: "https://www.okx.com/tonbridge/discover/rpc/bridge"
    }],
    platforms: ["chrome", "safari", "firefox", "ios", "android"]
}, {
    app_name: "okxTonWalletTr",
    name: "OKX TR Wallet",
    image: "https://static.okx.com/cdn/assets/imgs/247/587A8296F0BB640F.png",
    about_url: "https://tr.okx.com/web3",
    universal_url: "https://tr.okx.com/download?appendQuery=true&deeplink=okxtr://web3/wallet/tonconnect",
    bridge: [{
        type: "js",
        key: "okxTonWallet"
    }, {
        type: "sse",
        url: "https://www.okx.com/tonbridge/discover/rpc/bridge"
    }],
    platforms: ["chrome", "safari", "firefox", "ios", "android"]
}];
class WalletsListManager {
    constructor(Cn) {
        this.walletsListCache = null,
        this.walletsListCacheCreationTimestamp = null,
        this.walletsListSource = "https://raw.githubusercontent.com/ton-blockchain/wallets-list/main/wallets-v2.json",
        Cn != null && Cn.walletsListSource && (this.walletsListSource = Cn.walletsListSource),
        Cn != null && Cn.cacheTTLMs && (this.cacheTTLMs = Cn.cacheTTLMs)
    }
    getWallets() {
        return __awaiter$1(this, void 0, void 0, function*() {
            return this.cacheTTLMs && this.walletsListCacheCreationTimestamp && Date.now() > this.walletsListCacheCreationTimestamp + this.cacheTTLMs && (this.walletsListCache = null),
            this.walletsListCache || (this.walletsListCache = this.fetchWalletsList(),
            this.walletsListCache.then( () => {
                this.walletsListCacheCreationTimestamp = Date.now()
            }
            ).catch( () => {
                this.walletsListCache = null,
                this.walletsListCacheCreationTimestamp = null
            }
            )),
            this.walletsListCache
        })
    }
    getEmbeddedWallet() {
        return __awaiter$1(this, void 0, void 0, function*() {
            const as = (yield this.getWallets()).filter(isWalletInfoCurrentlyEmbedded);
            return as.length !== 1 ? null : as[0]
        })
    }
    fetchWalletsList() {
        return __awaiter$1(this, void 0, void 0, function*() {
            let Cn = [];
            try {
                if (Cn = yield(yield fetch(this.walletsListSource)).json(),
                !Array.isArray(Cn))
                    throw new FetchWalletsError("Wrong wallets list format, wallets list must be an array.");
                const Cs = Cn.filter(Ls => !this.isCorrectWalletConfigDTO(Ls));
                Cs.length && (logError$2(`Wallet(s) ${Cs.map(Ls => Ls.name).join(", ")} config format is wrong. They were removed from the wallets list.`),
                Cn = Cn.filter(Ls => this.isCorrectWalletConfigDTO(Ls)))
            } catch (cs) {
                logError$2(cs),
                Cn = FALLBACK_WALLETS_LIST
            }
            let as = [];
            try {
                as = InjectedProvider.getCurrentlyInjectedWallets()
            } catch (cs) {
                logError$2(cs)
            }
            return this.mergeWalletsLists(this.walletConfigDTOListToWalletConfigList(Cn), as)
        })
    }
    walletConfigDTOListToWalletConfigList(Cn) {
        return Cn.map(as => {
            const Cs = {
                name: as.name,
                appName: as.app_name,
                imageUrl: as.image,
                aboutUrl: as.about_url,
                tondns: as.tondns,
                platforms: as.platforms
            };
            return as.bridge.forEach(Ls => {
                if (Ls.type === "sse" && (Cs.bridgeUrl = Ls.url,
                Cs.universalLink = as.universal_url,
                Cs.deepLink = as.deepLink),
                Ls.type === "js") {
                    const Vs = Ls.key;
                    Cs.jsBridgeKey = Vs,
                    Cs.injected = InjectedProvider.isWalletInjected(Vs),
                    Cs.embedded = InjectedProvider.isInsideWalletBrowser(Vs)
                }
            }
            ),
            Cs
        }
        )
    }
    mergeWalletsLists(Cn, as) {
        return [...new Set(Cn.concat(as).map(Cs => Cs.name)).values()].map(Cs => {
            const Ls = Cn.find(Ws => Ws.name === Cs)
              , Vs = as.find(Ws => Ws.name === Cs);
            return Object.assign(Object.assign({}, Ls && Object.assign({}, Ls)), Vs && Object.assign({}, Vs))
        }
        )
    }
    isCorrectWalletConfigDTO(Cn) {
        if (!Cn || typeof Cn != "object")
            return !1;
        const as = "name"in Cn
          , cs = "app_name"in Cn
          , Cs = "image"in Cn
          , Ls = "about_url"in Cn
          , Vs = "platforms"in Cn;
        if (!as || !Cs || !Ls || !Vs || !cs || !Cn.platforms || !Array.isArray(Cn.platforms) || !Cn.platforms.length || !("bridge"in Cn) || !Array.isArray(Cn.bridge) || !Cn.bridge.length)
            return !1;
        const Ws = Cn.bridge;
        if (Ws.some(ba => !ba || typeof ba != "object" || !("type"in ba)))
            return !1;
        const Xs = Ws.find(ba => ba.type === "sse");
        if (Xs && (!("url"in Xs) || !Xs.url || !Cn.universal_url))
            return !1;
        const ga = Ws.find(ba => ba.type === "js");
        return !(ga && (!("key"in ga) || !ga.key))
    }
}
class WalletNotSupportFeatureError extends TonConnectError {
    get info() {
        return "Wallet doesn't support requested feature method."
    }
    constructor(...Cn) {
        super(...Cn),
        Object.setPrototypeOf(this, WalletNotSupportFeatureError.prototype)
    }
}
function checkSendTransactionSupport(xt, Cn) {
    const as = xt.includes("SendTransaction")
      , cs = xt.find(Cs => Cs && typeof Cs == "object" && Cs.name === "SendTransaction");
    if (!as && !cs)
        throw new WalletNotSupportFeatureError("Wallet doesn't support SendTransaction feature.");
    if (cs && cs.maxMessages !== void 0) {
        if (cs.maxMessages < Cn.requiredMessagesNumber)
            throw new WalletNotSupportFeatureError(`Wallet is not able to handle such SendTransaction request. Max support messages number is ${cs.maxMessages}, but ${Cn.requiredMessagesNumber} is required.`);
        return
    }
    logWarning$1("Connected wallet didn't provide information about max allowed messages in the SendTransaction request. Request may be rejected by the wallet.")
}
function createRequestVersionEvent() {
    return {
        type: "request-version"
    }
}
function createResponseVersionEvent(xt) {
    return {
        type: "response-version",
        version: xt
    }
}
function createVersionInfo(xt) {
    return {
        ton_connect_sdk_lib: xt.ton_connect_sdk_lib,
        ton_connect_ui_lib: xt.ton_connect_ui_lib
    }
}
function createConnectionInfo(xt, Cn) {
    var as, cs, Cs, Ls, Vs, Ws, Xs, ga;
    const yl = ((as = Cn == null ? void 0 : Cn.connectItems) === null || as === void 0 ? void 0 : as.tonProof) && "proof"in Cn.connectItems.tonProof ? "ton_proof" : "ton_addr";
    return {
        wallet_address: (Cs = (cs = Cn == null ? void 0 : Cn.account) === null || cs === void 0 ? void 0 : cs.address) !== null && Cs !== void 0 ? Cs : null,
        wallet_type: (Ls = Cn == null ? void 0 : Cn.device.appName) !== null && Ls !== void 0 ? Ls : null,
        wallet_version: (Vs = Cn == null ? void 0 : Cn.device.appVersion) !== null && Vs !== void 0 ? Vs : null,
        auth_type: yl,
        custom_data: Object.assign({
            chain_id: (Xs = (Ws = Cn == null ? void 0 : Cn.account) === null || Ws === void 0 ? void 0 : Ws.chain) !== null && Xs !== void 0 ? Xs : null,
            provider: (ga = Cn == null ? void 0 : Cn.provider) !== null && ga !== void 0 ? ga : null
        }, createVersionInfo(xt))
    }
}
function createConnectionStartedEvent(xt) {
    return {
        type: "connection-started",
        custom_data: createVersionInfo(xt)
    }
}
function createConnectionCompletedEvent(xt, Cn) {
    return Object.assign({
        type: "connection-completed",
        is_success: !0
    }, createConnectionInfo(xt, Cn))
}
function createConnectionErrorEvent(xt, Cn, as) {
    return {
        type: "connection-error",
        is_success: !1,
        error_message: Cn,
        error_code: as ?? null,
        custom_data: createVersionInfo(xt)
    }
}
function createConnectionRestoringStartedEvent(xt) {
    return {
        type: "connection-restoring-started",
        custom_data: createVersionInfo(xt)
    }
}
function createConnectionRestoringCompletedEvent(xt, Cn) {
    return Object.assign({
        type: "connection-restoring-completed",
        is_success: !0
    }, createConnectionInfo(xt, Cn))
}
function createConnectionRestoringErrorEvent(xt, Cn) {
    return {
        type: "connection-restoring-error",
        is_success: !1,
        error_message: Cn,
        custom_data: createVersionInfo(xt)
    }
}
function createTransactionInfo(xt, Cn) {
    var as, cs, Cs, Ls;
    return {
        valid_until: (as = String(Cn.validUntil)) !== null && as !== void 0 ? as : null,
        from: (Ls = (cs = Cn.from) !== null && cs !== void 0 ? cs : (Cs = xt == null ? void 0 : xt.account) === null || Cs === void 0 ? void 0 : Cs.address) !== null && Ls !== void 0 ? Ls : null,
        messages: Cn.messages.map(Vs => {
            var Ws, Xs;
            return {
                address: (Ws = Vs.address) !== null && Ws !== void 0 ? Ws : null,
                amount: (Xs = Vs.amount) !== null && Xs !== void 0 ? Xs : null
            }
        }
        )
    }
}
function createTransactionSentForSignatureEvent(xt, Cn, as) {
    return Object.assign(Object.assign({
        type: "transaction-sent-for-signature"
    }, createConnectionInfo(xt, Cn)), createTransactionInfo(Cn, as))
}
function createTransactionSignedEvent(xt, Cn, as, cs) {
    return Object.assign(Object.assign({
        type: "transaction-signed",
        is_success: !0,
        signed_transaction: cs.boc
    }, createConnectionInfo(xt, Cn)), createTransactionInfo(Cn, as))
}
function createTransactionSigningFailedEvent(xt, Cn, as, cs, Cs) {
    return Object.assign(Object.assign({
        type: "transaction-signing-failed",
        is_success: !1,
        error_message: cs,
        error_code: Cs ?? null
    }, createConnectionInfo(xt, Cn)), createTransactionInfo(Cn, as))
}
function createDisconnectionEvent(xt, Cn, as) {
    return Object.assign({
        type: "disconnection",
        scope: as
    }, createConnectionInfo(xt, Cn))
}
class BrowserEventDispatcher {
    constructor() {
        this.window = getWindow$3()
    }
    dispatchEvent(Cn, as) {
        var cs;
        return __awaiter$1(this, void 0, void 0, function*() {
            const Cs = new CustomEvent(Cn,{
                detail: as
            });
            (cs = this.window) === null || cs === void 0 || cs.dispatchEvent(Cs)
        })
    }
    addEventListener(Cn, as, cs) {
        var Cs;
        return __awaiter$1(this, void 0, void 0, function*() {
            return (Cs = this.window) === null || Cs === void 0 || Cs.addEventListener(Cn, as, cs),
            () => {
                var Ls;
                return (Ls = this.window) === null || Ls === void 0 ? void 0 : Ls.removeEventListener(Cn, as)
            }
        })
    }
}
class TonConnectTracker {
    constructor(Cn) {
        var as;
        this.eventPrefix = "ton-connect-",
        this.tonConnectUiVersion = null,
        this.eventDispatcher = (as = Cn == null ? void 0 : Cn.eventDispatcher) !== null && as !== void 0 ? as : new BrowserEventDispatcher,
        this.tonConnectSdkVersion = Cn.tonConnectSdkVersion,
        this.init().catch()
    }
    get version() {
        return createVersionInfo({
            ton_connect_sdk_lib: this.tonConnectSdkVersion,
            ton_connect_ui_lib: this.tonConnectUiVersion
        })
    }
    init() {
        return __awaiter$1(this, void 0, void 0, function*() {
            try {
                yield this.setRequestVersionHandler(),
                this.tonConnectUiVersion = yield this.requestTonConnectUiVersion()
            } catch {}
        })
    }
    setRequestVersionHandler() {
        return __awaiter$1(this, void 0, void 0, function*() {
            yield this.eventDispatcher.addEventListener("ton-connect-request-version", () => __awaiter$1(this, void 0, void 0, function*() {
                yield this.eventDispatcher.dispatchEvent("ton-connect-response-version", createResponseVersionEvent(this.tonConnectSdkVersion))
            }))
        })
    }
    requestTonConnectUiVersion() {
        return __awaiter$1(this, void 0, void 0, function*() {
            return new Promise( (Cn, as) => __awaiter$1(this, void 0, void 0, function*() {
                try {
                    yield this.eventDispatcher.addEventListener("ton-connect-ui-response-version", cs => {
                        Cn(cs.detail.version)
                    }
                    , {
                        once: !0
                    }),
                    yield this.eventDispatcher.dispatchEvent("ton-connect-ui-request-version", createRequestVersionEvent())
                } catch (cs) {
                    as(cs)
                }
            }))
        })
    }
    dispatchUserActionEvent(Cn) {
        try {
            this.eventDispatcher.dispatchEvent(`${this.eventPrefix}${Cn.type}`, Cn).catch()
        } catch {}
    }
    trackConnectionStarted(...Cn) {
        try {
            const as = createConnectionStartedEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
    trackConnectionCompleted(...Cn) {
        try {
            const as = createConnectionCompletedEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
    trackConnectionError(...Cn) {
        try {
            const as = createConnectionErrorEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
    trackConnectionRestoringStarted(...Cn) {
        try {
            const as = createConnectionRestoringStartedEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
    trackConnectionRestoringCompleted(...Cn) {
        try {
            const as = createConnectionRestoringCompletedEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
    trackConnectionRestoringError(...Cn) {
        try {
            const as = createConnectionRestoringErrorEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
    trackDisconnection(...Cn) {
        try {
            const as = createDisconnectionEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
    trackTransactionSentForSignature(...Cn) {
        try {
            const as = createTransactionSentForSignatureEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
    trackTransactionSigned(...Cn) {
        try {
            const as = createTransactionSignedEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
    trackTransactionSigningFailed(...Cn) {
        try {
            const as = createTransactionSigningFailedEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
}
const tonConnectSdkVersion = "3.0.5";
class TonConnect {
    constructor(Cn) {
        if (this.walletsList = new WalletsListManager,
        this._wallet = null,
        this.provider = null,
        this.statusChangeSubscriptions = [],
        this.statusChangeErrorSubscriptions = [],
        this.dappSettings = {
            manifestUrl: (Cn == null ? void 0 : Cn.manifestUrl) || getWebPageManifest(),
            storage: (Cn == null ? void 0 : Cn.storage) || new DefaultStorage
        },
        this.walletsList = new WalletsListManager({
            walletsListSource: Cn == null ? void 0 : Cn.walletsListSource,
            cacheTTLMs: Cn == null ? void 0 : Cn.walletsListCacheTTLMs
        }),
        this.tracker = new TonConnectTracker({
            eventDispatcher: Cn == null ? void 0 : Cn.eventDispatcher,
            tonConnectSdkVersion
        }),
        !this.dappSettings.manifestUrl)
            throw new DappMetadataError("Dapp tonconnect-manifest.json must be specified if window.location.origin is undefined. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest");
        this.bridgeConnectionStorage = new BridgeConnectionStorage(this.dappSettings.storage),
        Cn != null && Cn.disableAutoPauseConnection || this.addWindowFocusAndBlurSubscriptions()
    }
    static getWallets() {
        return this.walletsList.getWallets()
    }
    get connected() {
        return this._wallet !== null
    }
    get account() {
        var Cn;
        return ((Cn = this._wallet) === null || Cn === void 0 ? void 0 : Cn.account) || null
    }
    get wallet() {
        return this._wallet
    }
    set wallet(Cn) {
        this._wallet = Cn,
        this.statusChangeSubscriptions.forEach(as => as(this._wallet))
    }
    getWallets() {
        return this.walletsList.getWallets()
    }
    onStatusChange(Cn, as) {
        return this.statusChangeSubscriptions.push(Cn),
        as && this.statusChangeErrorSubscriptions.push(as),
        () => {
            this.statusChangeSubscriptions = this.statusChangeSubscriptions.filter(cs => cs !== Cn),
            as && (this.statusChangeErrorSubscriptions = this.statusChangeErrorSubscriptions.filter(cs => cs !== as))
        }
    }
    connect(Cn, as) {
        var cs, Cs;
        const Ls = {};
        if (typeof as == "object" && "tonProof"in as && (Ls.request = as),
        typeof as == "object" && ("openingDeadlineMS"in as || "signal"in as || "request"in as) && (Ls.request = as == null ? void 0 : as.request,
        Ls.openingDeadlineMS = as == null ? void 0 : as.openingDeadlineMS,
        Ls.signal = as == null ? void 0 : as.signal),
        this.connected)
            throw new WalletAlreadyConnectedError;
        const Vs = createAbortController(Ls == null ? void 0 : Ls.signal);
        if ((cs = this.abortController) === null || cs === void 0 || cs.abort(),
        this.abortController = Vs,
        Vs.signal.aborted)
            throw new TonConnectError("Connection was aborted");
        return (Cs = this.provider) === null || Cs === void 0 || Cs.closeConnection(),
        this.provider = this.createProvider(Cn),
        Vs.signal.addEventListener("abort", () => {
            var Ws;
            (Ws = this.provider) === null || Ws === void 0 || Ws.closeConnection(),
            this.provider = null
        }
        ),
        this.tracker.trackConnectionStarted(),
        this.provider.connect(this.createConnectRequest(Ls == null ? void 0 : Ls.request), {
            openingDeadlineMS: Ls == null ? void 0 : Ls.openingDeadlineMS,
            signal: Vs.signal
        })
    }
    restoreConnection(Cn) {
        var as, cs;
        return __awaiter$1(this, void 0, void 0, function*() {
            this.tracker.trackConnectionRestoringStarted();
            const Cs = createAbortController(Cn == null ? void 0 : Cn.signal);
            if ((as = this.abortController) === null || as === void 0 || as.abort(),
            this.abortController = Cs,
            Cs.signal.aborted) {
                this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
                return
            }
            const [Ls,Vs] = yield Promise.all([this.bridgeConnectionStorage.storedConnectionType(), this.walletsList.getEmbeddedWallet()]);
            if (Cs.signal.aborted) {
                this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
                return
            }
            let Ws = null;
            try {
                switch (Ls) {
                case "http":
                    Ws = yield BridgeProvider.fromStorage(this.dappSettings.storage);
                    break;
                case "injected":
                    Ws = yield InjectedProvider.fromStorage(this.dappSettings.storage);
                    break;
                default:
                    if (Vs)
                        Ws = this.createProvider(Vs);
                    else
                        return
                }
            } catch {
                this.tracker.trackConnectionRestoringError("Provider is not restored"),
                yield this.bridgeConnectionStorage.removeConnection(),
                Ws == null || Ws.closeConnection(),
                Ws = null;
                return
            }
            if (Cs.signal.aborted) {
                Ws == null || Ws.closeConnection(),
                this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
                return
            }
            if (!Ws) {
                logError$2("Provider is not restored"),
                this.tracker.trackConnectionRestoringError("Provider is not restored");
                return
            }
            (cs = this.provider) === null || cs === void 0 || cs.closeConnection(),
            this.provider = Ws,
            Ws.listen(this.walletEventsListener.bind(this));
            const Xs = () => {
                this.tracker.trackConnectionRestoringError("Connection restoring was aborted"),
                Ws == null || Ws.closeConnection(),
                Ws = null
            }
            ;
            Cs.signal.addEventListener("abort", Xs);
            const ga = callForSuccess(yl => __awaiter$1(this, void 0, void 0, function*() {
                yield Ws == null ? void 0 : Ws.restoreConnection({
                    openingDeadlineMS: Cn == null ? void 0 : Cn.openingDeadlineMS,
                    signal: yl.signal
                }),
                Cs.signal.removeEventListener("abort", Xs),
                this.connected ? this.tracker.trackConnectionRestoringCompleted(this.wallet) : this.tracker.trackConnectionRestoringError("Connection restoring failed")
            }), {
                attempts: Number.MAX_SAFE_INTEGER,
                delayMs: 2e3,
                signal: Cn == null ? void 0 : Cn.signal
            })
              , ba = new Promise(yl => setTimeout( () => yl(), 12e3));
            return Promise.race([ga, ba])
        })
    }
    sendTransaction(Cn, as) {
        return __awaiter$1(this, void 0, void 0, function*() {
            const cs = {};
            typeof as == "function" ? cs.onRequestSent = as : (cs.onRequestSent = as == null ? void 0 : as.onRequestSent,
            cs.signal = as == null ? void 0 : as.signal);
            const Cs = createAbortController(cs == null ? void 0 : cs.signal);
            if (Cs.signal.aborted)
                throw new TonConnectError("Transaction sending was aborted");
            this.checkConnection(),
            checkSendTransactionSupport(this.wallet.device.features, {
                requiredMessagesNumber: Cn.messages.length
            }),
            this.tracker.trackTransactionSentForSignature(this.wallet, Cn);
            const {validUntil: Ls} = Cn
              , Vs = __rest(Cn, ["validUntil"])
              , Ws = Cn.from || this.account.address
              , Xs = Cn.network || this.account.chain
              , ga = yield this.provider.sendRequest(sendTransactionParser.convertToRpcRequest(Object.assign(Object.assign({}, Vs), {
                valid_until: Ls,
                from: Ws,
                network: Xs
            })), {
                onRequestSent: cs.onRequestSent,
                signal: Cs.signal
            });
            if (sendTransactionParser.isError(ga))
                return this.tracker.trackTransactionSigningFailed(this.wallet, Cn, ga.error.message, ga.error.code),
                sendTransactionParser.parseAndThrowError(ga);
            const ba = sendTransactionParser.convertFromRpcResponse(ga);
            return this.tracker.trackTransactionSigned(this.wallet, Cn, ba),
            ba
        })
    }
    disconnect(Cn) {
        var as;
        return __awaiter$1(this, void 0, void 0, function*() {
            if (!this.connected)
                throw new WalletNotConnectedError;
            const cs = createAbortController(Cn == null ? void 0 : Cn.signal)
              , Cs = this.abortController;
            if (this.abortController = cs,
            cs.signal.aborted)
                throw new TonConnectError("Disconnect was aborted");
            this.onWalletDisconnected("dapp"),
            yield(as = this.provider) === null || as === void 0 ? void 0 : as.disconnect({
                signal: cs.signal
            }),
            Cs == null || Cs.abort()
        })
    }
    pauseConnection() {
        var Cn;
        ((Cn = this.provider) === null || Cn === void 0 ? void 0 : Cn.type) === "http" && this.provider.pause()
    }
    unPauseConnection() {
        var Cn;
        return ((Cn = this.provider) === null || Cn === void 0 ? void 0 : Cn.type) !== "http" ? Promise.resolve() : this.provider.unPause()
    }
    addWindowFocusAndBlurSubscriptions() {
        const Cn = getDocument();
        if (Cn)
            try {
                Cn.addEventListener("visibilitychange", () => {
                    Cn.hidden ? this.pauseConnection() : this.unPauseConnection().catch()
                }
                )
            } catch (as) {
                logError$2("Cannot subscribe to the document.visibilitychange: ", as)
            }
    }
    createProvider(Cn) {
        let as;
        return !Array.isArray(Cn) && isWalletConnectionSourceJS(Cn) ? as = new InjectedProvider(this.dappSettings.storage,Cn.jsBridgeKey) : as = new BridgeProvider(this.dappSettings.storage,Cn),
        as.listen(this.walletEventsListener.bind(this)),
        as
    }
    walletEventsListener(Cn) {
        switch (Cn.event) {
        case "connect":
            this.onWalletConnected(Cn.payload);
            break;
        case "connect_error":
            this.onWalletConnectError(Cn.payload);
            break;
        case "disconnect":
            this.onWalletDisconnected("wallet")
        }
    }
    onWalletConnected(Cn) {
        const as = Cn.items.find(Ls => Ls.name === "ton_addr")
          , cs = Cn.items.find(Ls => Ls.name === "ton_proof");
        if (!as)
            throw new TonConnectError("ton_addr connection item was not found");
        const Cs = {
            device: Cn.device,
            provider: this.provider.type,
            account: {
                address: as.address,
                chain: as.network,
                walletStateInit: as.walletStateInit,
                publicKey: as.publicKey
            }
        };
        cs && (Cs.connectItems = {
            tonProof: cs
        }),
        this.wallet = Cs,
        this.tracker.trackConnectionCompleted(Cs)
    }
    onWalletConnectError(Cn) {
        const as = connectErrorsParser.parseError(Cn);
        if (this.statusChangeErrorSubscriptions.forEach(cs => cs(as)),
        logDebug$1(as),
        this.tracker.trackConnectionError(Cn.message, Cn.code),
        as instanceof ManifestNotFoundError || as instanceof ManifestContentErrorError)
            throw logError$2(as),
            as
    }
    onWalletDisconnected(Cn) {
        this.tracker.trackDisconnection(this.wallet, Cn),
        this.wallet = null
    }
    checkConnection() {
        if (!this.connected)
            throw new WalletNotConnectedError
    }
    createConnectRequest(Cn) {
        const as = [{
            name: "ton_addr"
        }];
        return Cn != null && Cn.tonProof && as.push({
            name: "ton_proof",
            payload: Cn.tonProof
        }),
        {
            manifestUrl: this.dappSettings.manifestUrl,
            items: as
        }
    }
}
TonConnect.walletsList = new WalletsListManager;
TonConnect.isWalletInjected = xt => InjectedProvider.isWalletInjected(xt);
TonConnect.isInsideWalletBrowser = xt => InjectedProvider.isInsideWalletBrowser(xt);
const noBounceableTag = 81
  , testOnlyTag = 128;
function toUserFriendlyAddress(xt, Cn=!1) {
    const {wc: as, hex: cs} = parseHexAddress(xt);
    let Cs = noBounceableTag;
    Cn && (Cs |= testOnlyTag);
    const Ls = new Int8Array(34);
    Ls[0] = Cs,
    Ls[1] = as,
    Ls.set(cs, 2);
    const Vs = new Uint8Array(36);
    return Vs.set(Ls),
    Vs.set(crc16$3(Ls), 34),
    Base64.encode(Vs).replace(/\+/g, "-").replace(/\//g, "_")
}
function parseHexAddress(xt) {
    if (!xt.includes(":"))
        throw new WrongAddressError(`Wrong address ${xt}. Address must include ":".`);
    const Cn = xt.split(":");
    if (Cn.length !== 2)
        throw new WrongAddressError(`Wrong address ${xt}. Address must include ":" only once.`);
    const as = parseInt(Cn[0]);
    if (as !== 0 && as !== -1)
        throw new WrongAddressError(`Wrong address ${xt}. WC must be eq 0 or -1, but ${as} received.`);
    const cs = Cn[1];
    if ((cs == null ? void 0 : cs.length) !== 64)
        throw new WrongAddressError(`Wrong address ${xt}. Hex part must be 64bytes length, but ${cs == null ? void 0 : cs.length} received.`);
    return {
        wc: as,
        hex: hexToBytes(cs)
    }
}
function crc16$3(xt) {
    let as = 0;
    const cs = new Uint8Array(xt.length + 2);
    cs.set(xt);
    for (let Cs of cs) {
        let Ls = 128;
        for (; Ls > 0; )
            as <<= 1,
            Cs & Ls && (as += 1),
            Ls >>= 1,
            as > 65535 && (as &= 65535,
            as ^= 4129)
    }
    return new Uint8Array([Math.floor(as / 256), as % 256])
}
const toByteMap = {};
for (let xt = 0; xt <= 255; xt++) {
    let Cn = xt.toString(16);
    Cn.length < 2 && (Cn = "0" + Cn),
    toByteMap[Cn] = xt
}
function hexToBytes(xt) {
    xt = xt.toLowerCase();
    const Cn = xt.length;
    if (Cn % 2 !== 0)
        throw new ParseHexError("Hex string must have length a multiple of 2: " + xt);
    const as = Cn / 2
      , cs = new Uint8Array(as);
    for (let Cs = 0; Cs < as; Cs++) {
        const Ls = Cs * 2
          , Vs = xt.substring(Ls, Ls + 2);
        if (!toByteMap.hasOwnProperty(Vs))
            throw new ParseHexError("Invalid hex character: " + Vs);
        cs[Cs] = toByteMap[Vs]
    }
    return cs
}
var uaParser = {
    exports: {}
};
(function(xt, Cn) {
    (function(as, cs) {
        var Cs = "1.0.40"
          , Ls = ""
          , Vs = "?"
          , Ws = "function"
          , Xs = "undefined"
          , ga = "object"
          , ba = "string"
          , yl = "major"
          , xl = "model"
          , wl = "name"
          , _l = "type"
          , El = "vendor"
          , Cl = "version"
          , $l = "architecture"
          , Sl = "console"
          , Tl = "mobile"
          , Rl = "tablet"
          , Il = "smarttv"
          , Ml = "wearable"
          , Nl = "embedded"
          , Ll = 500
          , Fl = "Amazon"
          , Ul = "Apple"
          , Dl = "ASUS"
          , Zl = "BlackBerry"
          , Gl = "Browser"
          , Wl = "Chrome"
          , Ql = "Edge"
          , cu = "Firefox"
          , pu = "Google"
          , zl = "Huawei"
          , Yl = "LG"
          , lu = "Microsoft"
          , mu = "Motorola"
          , Cu = "Opera"
          , ju = "Samsung"
          , Lu = "Sharp"
          , Au = "Sony"
          , Du = "Xiaomi"
          , Qu = "Zebra"
          , fu = "Facebook"
          , yu = "Chromium OS"
          , vu = "Mac OS"
          , _u = " Browser"
          , xu = function(Kl, Bl) {
            var Pl = {};
            for (var Al in Kl)
                Bl[Al] && Bl[Al].length % 2 === 0 ? Pl[Al] = Bl[Al].concat(Kl[Al]) : Pl[Al] = Kl[Al];
            return Pl
        }
          , Ru = function(Kl) {
            for (var Bl = {}, Pl = 0; Pl < Kl.length; Pl++)
                Bl[Kl[Pl].toUpperCase()] = Kl[Pl];
            return Bl
        }
          , Iu = function(Kl, Bl) {
            return typeof Kl === ba ? Ku(Bl).indexOf(Ku(Kl)) !== -1 : !1
        }
          , Ku = function(Kl) {
            return Kl.toLowerCase()
        }
          , dp = function(Kl) {
            return typeof Kl === ba ? Kl.replace(/[^\d\.]/g, Ls).split(".")[0] : cs
        }
          , lp = function(Kl, Bl) {
            if (typeof Kl === ba)
                return Kl = Kl.replace(/^\s\s*/, Ls),
                typeof Bl === Xs ? Kl : Kl.substring(0, Ll)
        }
          , qu = function(Kl, Bl) {
            for (var Pl = 0, Al, Vl, eu, iu, ou, Tu; Pl < Bl.length && !ou; ) {
                var Hu = Bl[Pl]
                  , Mu = Bl[Pl + 1];
                for (Al = Vl = 0; Al < Hu.length && !ou && Hu[Al]; )
                    if (ou = Hu[Al++].exec(Kl),
                    ou)
                        for (eu = 0; eu < Mu.length; eu++)
                            Tu = ou[++Vl],
                            iu = Mu[eu],
                            typeof iu === ga && iu.length > 0 ? iu.length === 2 ? typeof iu[1] == Ws ? this[iu[0]] = iu[1].call(this, Tu) : this[iu[0]] = iu[1] : iu.length === 3 ? typeof iu[1] === Ws && !(iu[1].exec && iu[1].test) ? this[iu[0]] = Tu ? iu[1].call(this, Tu, iu[2]) : cs : this[iu[0]] = Tu ? Tu.replace(iu[1], iu[2]) : cs : iu.length === 4 && (this[iu[0]] = Tu ? iu[3].call(this, Tu.replace(iu[1], iu[2])) : cs) : this[iu] = Tu || cs;
                Pl += 2
            }
        }
          , hp = function(Kl, Bl) {
            for (var Pl in Bl)
                if (typeof Bl[Pl] === ga && Bl[Pl].length > 0) {
                    for (var Al = 0; Al < Bl[Pl].length; Al++)
                        if (Iu(Bl[Pl][Al], Kl))
                            return Pl === Vs ? cs : Pl
                } else if (Iu(Bl[Pl], Kl))
                    return Pl === Vs ? cs : Pl;
            return Bl.hasOwnProperty("*") ? Bl["*"] : Kl
        }
          , fp = {
            "1.0": "/8",
            "1.2": "/1",
            "1.3": "/3",
            "2.0": "/412",
            "2.0.2": "/416",
            "2.0.3": "/417",
            "2.0.4": "/419",
            "?": "/"
        }
          , Lp = {
            ME: "4.90",
            "NT 3.11": "NT3.51",
            "NT 4.0": "NT4.0",
            2e3: "NT 5.0",
            XP: ["NT 5.1", "NT 5.2"],
            Vista: "NT 6.0",
            7: "NT 6.1",
            8: "NT 6.2",
            "8.1": "NT 6.3",
            10: ["NT 6.4", "NT 10.0"],
            RT: "ARM"
        }
          , uu = {
            browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [Cl, [wl, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [Cl, [wl, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [wl, Cl], [/opios[\/ ]+([\w\.]+)/i], [Cl, [wl, Cu + " Mini"]], [/\bop(?:rg)?x\/([\w\.]+)/i], [Cl, [wl, Cu + " GX"]], [/\bopr\/([\w\.]+)/i], [Cl, [wl, Cu]], [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i], [Cl, [wl, "Baidu"]], [/\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i], [Cl, [wl, "Maxthon"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i, /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon)\/([-\w\.]+)/i, /(heytap|ovi|115)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i], [wl, Cl], [/quark(?:pc)?\/([-\w\.]+)/i], [Cl, [wl, "Quark"]], [/\bddg\/([\w\.]+)/i], [Cl, [wl, "DuckDuckGo"]], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [Cl, [wl, "UC" + Gl]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i], [Cl, [wl, "WeChat"]], [/konqueror\/([\w\.]+)/i], [Cl, [wl, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [Cl, [wl, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [Cl, [wl, "Yandex"]], [/slbrowser\/([\w\.]+)/i], [Cl, [wl, "Smart Lenovo " + Gl]], [/(avast|avg)\/([\w\.]+)/i], [[wl, /(.+)/, "$1 Secure " + Gl], Cl], [/\bfocus\/([\w\.]+)/i], [Cl, [wl, cu + " Focus"]], [/\bopt\/([\w\.]+)/i], [Cl, [wl, Cu + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [Cl, [wl, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [Cl, [wl, "Dolphin"]], [/coast\/([\w\.]+)/i], [Cl, [wl, Cu + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [Cl, [wl, "MIUI" + _u]], [/fxios\/([\w\.-]+)/i], [Cl, [wl, cu]], [/\bqihoobrowser\/?([\w\.]*)/i], [Cl, [wl, "360"]], [/\b(qq)\/([\w\.]+)/i], [[wl, /(.+)/, "$1Browser"], Cl], [/(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i], [[wl, /(.+)/, "$1" + _u], Cl], [/samsungbrowser\/([\w\.]+)/i], [Cl, [wl, ju + " Internet"]], [/metasr[\/ ]?([\d\.]+)/i], [Cl, [wl, "Sogou Explorer"]], [/(sogou)mo\w+\/([\d\.]+)/i], [[wl, "Sogou Mobile"], Cl], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i], [wl, Cl], [/(lbbrowser|rekonq)/i, /\[(linkedin)app\]/i], [wl], [/ome\/([\w\.]+) \w* ?(iron) saf/i, /ome\/([\w\.]+).+qihu (360)[es]e/i], [Cl, wl], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[wl, fu], Cl], [/(Klarna)\/([\w\.]+)/i, /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(alipay)client\/([\w\.]+)/i, /(twitter)(?:and| f.+e\/([\w\.]+))/i, /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i], [wl, Cl], [/\bgsa\/([\w\.]+) .*safari\//i], [Cl, [wl, "GSA"]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [Cl, [wl, "TikTok"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [Cl, [wl, Wl + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[wl, Wl + " WebView"], Cl], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [Cl, [wl, "Android " + Gl]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [wl, Cl], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [Cl, [wl, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [Cl, wl], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [wl, [Cl, hp, fp]], [/(webkit|khtml)\/([\w\.]+)/i], [wl, Cl], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[wl, "Netscape"], Cl], [/(wolvic|librewolf)\/([\w\.]+)/i], [wl, Cl], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [Cl, [wl, cu + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i], [wl, [Cl, /_/g, "."]], [/(cobalt)\/([\w\.]+)/i], [wl, [Cl, /master.|lts./, ""]]],
            cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[$l, "amd64"]], [/(ia32(?=;))/i], [[$l, Ku]], [/((?:i[346]|x)86)[;\)]/i], [[$l, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[$l, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[$l, "armhf"]], [/windows (ce|mobile); ppc;/i], [[$l, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[$l, /ower/, Ls, Ku]], [/(sun4\w)[;\)]/i], [[$l, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[$l, Ku]]],
            device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [xl, [El, ju], [_l, Rl]], [/\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]((?!sm-[lr])[-\w]+)/i, /sec-(sgh\w+)/i], [xl, [El, ju], [_l, Tl]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [xl, [El, Ul], [_l, Tl]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [xl, [El, Ul], [_l, Rl]], [/(macintosh);/i], [xl, [El, Ul]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [xl, [El, Lu], [_l, Tl]], [/(?:honor)([-\w ]+)[;\)]/i], [xl, [El, "Honor"], [_l, Tl]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [xl, [El, zl], [_l, Rl]], [/(?:huawei)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [xl, [El, zl], [_l, Tl]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i], [[xl, /_/g, " "], [El, Du], [_l, Tl]], [/oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i, /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[xl, /_/g, " "], [El, Du], [_l, Rl]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [xl, [El, "OPPO"], [_l, Tl]], [/\b(opd2\d{3}a?) bui/i], [xl, [El, "OPPO"], [_l, Rl]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [xl, [El, "Vivo"], [_l, Tl]], [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [xl, [El, "Realme"], [_l, Tl]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [xl, [El, mu], [_l, Tl]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [xl, [El, mu], [_l, Rl]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [xl, [El, Yl], [_l, Rl]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [xl, [El, Yl], [_l, Tl]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [xl, [El, "Lenovo"], [_l, Rl]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[xl, /_/g, " "], [El, "Nokia"], [_l, Tl]], [/(pixel c)\b/i], [xl, [El, pu], [_l, Rl]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [xl, [El, pu], [_l, Tl]], [/droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [xl, [El, Au], [_l, Tl]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[xl, "Xperia Tablet"], [El, Au], [_l, Rl]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [xl, [El, "OnePlus"], [_l, Tl]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [xl, [El, Fl], [_l, Rl]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[xl, /(.+)/g, "Fire Phone $1"], [El, Fl], [_l, Tl]], [/(playbook);[-\w\),; ]+(rim)/i], [xl, El, [_l, Rl]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [xl, [El, Zl], [_l, Tl]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [xl, [El, Dl], [_l, Rl]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [xl, [El, Dl], [_l, Tl]], [/(nexus 9)/i], [xl, [El, "HTC"], [_l, Rl]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [El, [xl, /_/g, " "], [_l, Tl]], [/droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\w*(\)| bui)/i], [xl, [El, "TCL"], [_l, Rl]], [/(itel) ((\w+))/i], [[El, Ku], xl, [_l, hp, {
                tablet: ["p10001l", "w7001"],
                "*": "mobile"
            }]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [xl, [El, "Acer"], [_l, Rl]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [xl, [El, "Meizu"], [_l, Tl]], [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [xl, [El, "Ulefone"], [_l, Tl]], [/; (energy ?\w+)(?: bui|\))/i, /; energizer ([\w ]+)(?: bui|\))/i], [xl, [El, "Energizer"], [_l, Tl]], [/; cat (b35);/i, /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i], [xl, [El, "Cat"], [_l, Tl]], [/((?:new )?andromax[\w- ]+)(?: bui|\))/i], [xl, [El, "Smartfren"], [_l, Tl]], [/droid.+; (a(?:015|06[35]|142p?))/i], [xl, [El, "Nothing"], [_l, Tl]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\w]*)/i, /; (imo) ((?!tab)[\w ]+?)(?: bui|\))/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [El, xl, [_l, Tl]], [/(imo) (tab \w+)/i, /(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [El, xl, [_l, Rl]], [/(surface duo)/i], [xl, [El, lu], [_l, Rl]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [xl, [El, "Fairphone"], [_l, Tl]], [/(u304aa)/i], [xl, [El, "AT&T"], [_l, Tl]], [/\bsie-(\w*)/i], [xl, [El, "Siemens"], [_l, Tl]], [/\b(rct\w+) b/i], [xl, [El, "RCA"], [_l, Rl]], [/\b(venue[\d ]{2,7}) b/i], [xl, [El, "Dell"], [_l, Rl]], [/\b(q(?:mv|ta)\w+) b/i], [xl, [El, "Verizon"], [_l, Rl]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [xl, [El, "Barnes & Noble"], [_l, Rl]], [/\b(tm\d{3}\w+) b/i], [xl, [El, "NuVision"], [_l, Rl]], [/\b(k88) b/i], [xl, [El, "ZTE"], [_l, Rl]], [/\b(nx\d{3}j) b/i], [xl, [El, "ZTE"], [_l, Tl]], [/\b(gen\d{3}) b.+49h/i], [xl, [El, "Swiss"], [_l, Tl]], [/\b(zur\d{3}) b/i], [xl, [El, "Swiss"], [_l, Rl]], [/\b((zeki)?tb.*\b) b/i], [xl, [El, "Zeki"], [_l, Rl]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[El, "Dragon Touch"], xl, [_l, Rl]], [/\b(ns-?\w{0,9}) b/i], [xl, [El, "Insignia"], [_l, Rl]], [/\b((nxa|next)-?\w{0,9}) b/i], [xl, [El, "NextBook"], [_l, Rl]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[El, "Voice"], xl, [_l, Tl]], [/\b(lvtel\-)?(v1[12]) b/i], [[El, "LvTel"], xl, [_l, Tl]], [/\b(ph-1) /i], [xl, [El, "Essential"], [_l, Tl]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [xl, [El, "Envizen"], [_l, Rl]], [/\b(trio[-\w\. ]+) b/i], [xl, [El, "MachSpeed"], [_l, Rl]], [/\btu_(1491) b/i], [xl, [El, "Rotor"], [_l, Rl]], [/(shield[\w ]+) b/i], [xl, [El, "Nvidia"], [_l, Rl]], [/(sprint) (\w+)/i], [El, xl, [_l, Tl]], [/(kin\.[onetw]{3})/i], [[xl, /\./g, " "], [El, lu], [_l, Tl]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [xl, [El, Qu], [_l, Rl]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [xl, [El, Qu], [_l, Tl]], [/smart-tv.+(samsung)/i], [El, [_l, Il]], [/hbbtv.+maple;(\d+)/i], [[xl, /^/, "SmartTV"], [El, ju], [_l, Il]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[El, Yl], [_l, Il]], [/(apple) ?tv/i], [El, [xl, Ul + " TV"], [_l, Il]], [/crkey/i], [[xl, Wl + "cast"], [El, pu], [_l, Il]], [/droid.+aft(\w+)( bui|\))/i], [xl, [El, Fl], [_l, Il]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [xl, [El, Lu], [_l, Il]], [/(bravia[\w ]+)( bui|\))/i], [xl, [El, Au], [_l, Il]], [/(mitv-\w{5}) bui/i], [xl, [El, Du], [_l, Il]], [/Hbbtv.*(technisat) (.*);/i], [El, xl, [_l, Il]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[El, lp], [xl, lp], [_l, Il]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[_l, Il]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [El, xl, [_l, Sl]], [/droid.+; (shield) bui/i], [xl, [El, "Nvidia"], [_l, Sl]], [/(playstation [345portablevi]+)/i], [xl, [El, Au], [_l, Sl]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [xl, [El, lu], [_l, Sl]], [/\b(sm-[lr]\d\d[05][fnuw]?s?)\b/i], [xl, [El, ju], [_l, Ml]], [/((pebble))app/i], [El, xl, [_l, Ml]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [xl, [El, Ul], [_l, Ml]], [/droid.+; (glass) \d/i], [xl, [El, pu], [_l, Ml]], [/droid.+; (wt63?0{2,3})\)/i], [xl, [El, Qu], [_l, Ml]], [/droid.+; (glass) \d/i], [xl, [El, pu], [_l, Ml]], [/(pico) (4|neo3(?: link|pro)?)/i], [El, xl, [_l, Ml]], [/; (quest( \d| pro)?)/i], [xl, [El, fu], [_l, Ml]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [El, [_l, Nl]], [/(aeobc)\b/i], [xl, [El, Fl], [_l, Nl]], [/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i], [xl, [_l, Tl]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [xl, [_l, Rl]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[_l, Rl]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[_l, Tl]], [/(android[-\w\. ]{0,9});.+buil/i], [xl, [El, "Generic"]]],
            engine: [[/windows.+ edge\/([\w\.]+)/i], [Cl, [wl, Ql + "HTML"]], [/(arkweb)\/([\w\.]+)/i], [wl, Cl], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [Cl, [wl, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [wl, Cl], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [Cl, wl]],
            os: [[/microsoft (windows) (vista|xp)/i], [wl, Cl], [/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i], [wl, [Cl, hp, Lp]], [/windows nt 6\.2; (arm)/i, /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[Cl, hp, Lp], [wl, "Windows"]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[Cl, /_/g, "."], [wl, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[wl, vu], [Cl, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [Cl, wl], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish|openharmony)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [wl, Cl], [/\(bb(10);/i], [Cl, [wl, Zl]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [Cl, [wl, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [Cl, [wl, cu + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [Cl, [wl, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [Cl, [wl, "watchOS"]], [/crkey\/([\d\.]+)/i], [Cl, [wl, Wl + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[wl, yu], Cl], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [wl, Cl], [/(sunos) ?([\w\.\d]*)/i], [[wl, "Solaris"], Cl], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [wl, Cl]]
        }
          , gu = function(Kl, Bl) {
            if (typeof Kl === ga && (Bl = Kl,
            Kl = cs),
            !(this instanceof gu))
                return new gu(Kl,Bl).getResult();
            var Pl = typeof as !== Xs && as.navigator ? as.navigator : cs
              , Al = Kl || (Pl && Pl.userAgent ? Pl.userAgent : Ls)
              , Vl = Pl && Pl.userAgentData ? Pl.userAgentData : cs
              , eu = Bl ? xu(uu, Bl) : uu
              , iu = Pl && Pl.userAgent == Al;
            return this.getBrowser = function() {
                var ou = {};
                return ou[wl] = cs,
                ou[Cl] = cs,
                qu.call(ou, Al, eu.browser),
                ou[yl] = dp(ou[Cl]),
                iu && Pl && Pl.brave && typeof Pl.brave.isBrave == Ws && (ou[wl] = "Brave"),
                ou
            }
            ,
            this.getCPU = function() {
                var ou = {};
                return ou[$l] = cs,
                qu.call(ou, Al, eu.cpu),
                ou
            }
            ,
            this.getDevice = function() {
                var ou = {};
                return ou[El] = cs,
                ou[xl] = cs,
                ou[_l] = cs,
                qu.call(ou, Al, eu.device),
                iu && !ou[_l] && Vl && Vl.mobile && (ou[_l] = Tl),
                iu && ou[xl] == "Macintosh" && Pl && typeof Pl.standalone !== Xs && Pl.maxTouchPoints && Pl.maxTouchPoints > 2 && (ou[xl] = "iPad",
                ou[_l] = Rl),
                ou
            }
            ,
            this.getEngine = function() {
                var ou = {};
                return ou[wl] = cs,
                ou[Cl] = cs,
                qu.call(ou, Al, eu.engine),
                ou
            }
            ,
            this.getOS = function() {
                var ou = {};
                return ou[wl] = cs,
                ou[Cl] = cs,
                qu.call(ou, Al, eu.os),
                iu && !ou[wl] && Vl && Vl.platform && Vl.platform != "Unknown" && (ou[wl] = Vl.platform.replace(/chrome os/i, yu).replace(/macos/i, vu)),
                ou
            }
            ,
            this.getResult = function() {
                return {
                    ua: this.getUA(),
                    browser: this.getBrowser(),
                    engine: this.getEngine(),
                    os: this.getOS(),
                    device: this.getDevice(),
                    cpu: this.getCPU()
                }
            }
            ,
            this.getUA = function() {
                return Al
            }
            ,
            this.setUA = function(ou) {
                return Al = typeof ou === ba && ou.length > Ll ? lp(ou, Ll) : ou,
                this
            }
            ,
            this.setUA(Al),
            this
        };
        gu.VERSION = Cs,
        gu.BROWSER = Ru([wl, Cl, yl]),
        gu.CPU = Ru([$l]),
        gu.DEVICE = Ru([xl, El, _l, Sl, Tl, Il, Rl, Ml, Nl]),
        gu.ENGINE = gu.OS = Ru([wl, Cl]),
        xt.exports && (Cn = xt.exports = gu),
        Cn.UAParser = gu;
        var Eu = typeof as !== Xs && (as.jQuery || as.Zepto);
        if (Eu && !Eu.ua) {
            var nu = new gu;
            Eu.ua = nu.getResult(),
            Eu.ua.get = function() {
                return nu.getUA()
            }
            ,
            Eu.ua.set = function(Kl) {
                nu.setUA(Kl);
                var Bl = nu.getResult();
                for (var Pl in Bl)
                    Eu.ua[Pl] = Bl[Pl]
            }
        }
    }
    )(typeof window == "object" ? window : commonjsGlobal)
}
)(uaParser, uaParser.exports);
var uaParserExports = uaParser.exports;
const UAParser$1 = getDefaultExportFromCjs(uaParserExports);
var isMergeableObject = function(Cn) {
    return isNonNullObject(Cn) && !isSpecial(Cn)
};
function isNonNullObject(xt) {
    return !!xt && typeof xt == "object"
}
function isSpecial(xt) {
    var Cn = Object.prototype.toString.call(xt);
    return Cn === "[object RegExp]" || Cn === "[object Date]" || isReactElement(xt)
}
var canUseSymbol = typeof Symbol == "function" && Symbol.for
  , REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(xt) {
    return xt.$$typeof === REACT_ELEMENT_TYPE
}
function emptyTarget(xt) {
    return Array.isArray(xt) ? [] : {}
}
function cloneUnlessOtherwiseSpecified(xt, Cn) {
    return Cn.clone !== !1 && Cn.isMergeableObject(xt) ? deepmerge(emptyTarget(xt), xt, Cn) : xt
}
function defaultArrayMerge(xt, Cn, as) {
    return xt.concat(Cn).map(function(cs) {
        return cloneUnlessOtherwiseSpecified(cs, as)
    })
}
function getMergeFunction(xt, Cn) {
    if (!Cn.customMerge)
        return deepmerge;
    var as = Cn.customMerge(xt);
    return typeof as == "function" ? as : deepmerge
}
function getEnumerableOwnPropertySymbols(xt) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(xt).filter(function(Cn) {
        return Object.propertyIsEnumerable.call(xt, Cn)
    }) : []
}
function getKeys(xt) {
    return Object.keys(xt).concat(getEnumerableOwnPropertySymbols(xt))
}
function propertyIsOnObject(xt, Cn) {
    try {
        return Cn in xt
    } catch {
        return !1
    }
}
function propertyIsUnsafe(xt, Cn) {
    return propertyIsOnObject(xt, Cn) && !(Object.hasOwnProperty.call(xt, Cn) && Object.propertyIsEnumerable.call(xt, Cn))
}
function mergeObject(xt, Cn, as) {
    var cs = {};
    return as.isMergeableObject(xt) && getKeys(xt).forEach(function(Cs) {
        cs[Cs] = cloneUnlessOtherwiseSpecified(xt[Cs], as)
    }),
    getKeys(Cn).forEach(function(Cs) {
        propertyIsUnsafe(xt, Cs) || (propertyIsOnObject(xt, Cs) && as.isMergeableObject(Cn[Cs]) ? cs[Cs] = getMergeFunction(Cs, as)(xt[Cs], Cn[Cs], as) : cs[Cs] = cloneUnlessOtherwiseSpecified(Cn[Cs], as))
    }),
    cs
}
function deepmerge(xt, Cn, as) {
    as = as || {},
    as.arrayMerge = as.arrayMerge || defaultArrayMerge,
    as.isMergeableObject = as.isMergeableObject || isMergeableObject,
    as.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var cs = Array.isArray(Cn)
      , Cs = Array.isArray(xt)
      , Ls = cs === Cs;
    return Ls ? cs ? as.arrayMerge(xt, Cn, as) : mergeObject(xt, Cn, as) : cloneUnlessOtherwiseSpecified(Cn, as)
}
deepmerge.all = function(Cn, as) {
    if (!Array.isArray(Cn))
        throw new Error("first argument should be an array");
    return Cn.reduce(function(cs, Cs) {
        return deepmerge(cs, Cs, as)
    }, {})
}
;
var deepmerge_1 = deepmerge
  , cjs = deepmerge_1;
const deepmerge$1 = getDefaultExportFromCjs(cjs);
var classnames = {
    exports: {}
};
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(xt) {
    (function() {
        var Cn = {}.hasOwnProperty;
        function as() {
            for (var Ls = "", Vs = 0; Vs < arguments.length; Vs++) {
                var Ws = arguments[Vs];
                Ws && (Ls = Cs(Ls, cs(Ws)))
            }
            return Ls
        }
        function cs(Ls) {
            if (typeof Ls == "string" || typeof Ls == "number")
                return Ls;
            if (typeof Ls != "object")
                return "";
            if (Array.isArray(Ls))
                return as.apply(null, Ls);
            if (Ls.toString !== Object.prototype.toString && !Ls.toString.toString().includes("[native code]"))
                return Ls.toString();
            var Vs = "";
            for (var Ws in Ls)
                Cn.call(Ls, Ws) && Ls[Ws] && (Vs = Cs(Vs, Ws));
            return Vs
        }
        function Cs(Ls, Vs) {
            return Vs ? Ls ? Ls + " " + Vs : Ls + Vs : Ls
        }
        xt.exports ? (as.default = as,
        xt.exports = as) : window.classNames = as
    }
    )()
}
)(classnames);
var classnamesExports = classnames.exports;
const classNames$1 = getDefaultExportFromCjs(classnamesExports);
var __defProp$1 = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (xt, Cn, as) => Cn in xt ? __defProp$1(xt, Cn, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: as
}) : xt[Cn] = as, __spreadValues$1 = (xt, Cn) => {
    for (var as in Cn || (Cn = {}))
        __hasOwnProp$1.call(Cn, as) && __defNormalProp$1(xt, as, Cn[as]);
    if (__getOwnPropSymbols$1)
        for (var as of __getOwnPropSymbols$1(Cn))
            __propIsEnum$1.call(Cn, as) && __defNormalProp$1(xt, as, Cn[as]);
    return xt
}
, __spreadProps = (xt, Cn) => __defProps(xt, __getOwnPropDescs(Cn)), __publicField = (xt, Cn, as) => (__defNormalProp$1(xt, typeof Cn != "symbol" ? Cn + "" : Cn, as),
as), __async = (xt, Cn, as) => new Promise( (cs, Cs) => {
    var Ls = Xs => {
        try {
            Ws(as.next(Xs))
        } catch (ga) {
            Cs(ga)
        }
    }
      , Vs = Xs => {
        try {
            Ws(as.throw(Xs))
        } catch (ga) {
            Cs(ga)
        }
    }
      , Ws = Xs => Xs.done ? cs(Xs.value) : Promise.resolve(Xs.value).then(Ls, Vs);
    Ws((as = as.apply(xt, Cn)).next())
}
), _a$3, _b, _c, _d, _e$1, _f, _g, _h;
const sharedConfig = {};
function setHydrateContext(xt) {
    sharedConfig.context = xt
}
const equalFn = (xt, Cn) => xt === Cn
  , $PROXY = Symbol("solid-proxy")
  , $TRACK = Symbol("solid-track")
  , signalOptions = {
    equals: equalFn
};
let runEffects = runQueue;
const STALE = 1
  , PENDING = 2
  , UNOWNED = {
    owned: null,
    cleanups: null,
    context: null,
    owner: null
}
  , NO_INIT = {};
var Owner = null;
let Transition$1 = null
  , Listener = null
  , Updates = null
  , Effects = null
  , ExecCount = 0;
function createRoot(xt, Cn) {
    const as = Listener
      , cs = Owner
      , Cs = xt.length === 0
      , Ls = Cs ? UNOWNED : {
        owned: null,
        cleanups: null,
        context: null,
        owner: Cn === void 0 ? cs : Cn
    }
      , Vs = Cs ? xt : () => xt( () => untrack( () => cleanNode(Ls)));
    Owner = Ls,
    Listener = null;
    try {
        return runUpdates(Vs, !0)
    } finally {
        Listener = as,
        Owner = cs
    }
}
function createSignal(xt, Cn) {
    Cn = Cn ? Object.assign({}, signalOptions, Cn) : signalOptions;
    const as = {
        value: xt,
        observers: null,
        observerSlots: null,
        comparator: Cn.equals || void 0
    }
      , cs = Cs => (typeof Cs == "function" && (Cs = Cs(as.value)),
    writeSignal(as, Cs));
    return [readSignal.bind(as), cs]
}
function createComputed(xt, Cn, as) {
    const cs = createComputation(xt, Cn, !0, STALE);
    updateComputation(cs)
}
function createRenderEffect(xt, Cn, as) {
    const cs = createComputation(xt, Cn, !1, STALE);
    updateComputation(cs)
}
function createEffect(xt, Cn, as) {
    runEffects = runUserEffects;
    const cs = createComputation(xt, Cn, !1, STALE);
    cs.user = !0,
    Effects ? Effects.push(cs) : updateComputation(cs)
}
function createMemo(xt, Cn, as) {
    as = as ? Object.assign({}, signalOptions, as) : signalOptions;
    const cs = createComputation(xt, Cn, !0, 0);
    return cs.observers = null,
    cs.observerSlots = null,
    cs.comparator = as.equals || void 0,
    updateComputation(cs),
    readSignal.bind(cs)
}
function createResource(xt, Cn, as) {
    let cs, Cs, Ls;
    arguments.length === 1 ? (cs = !0,
    Cs = xt,
    Ls = {}) : (cs = xt,
    Cs = Cn,
    Ls = {});
    let Vs = null
      , Ws = NO_INIT
      , Xs = null
      , ga = !1
      , ba = "initialValue"in Ls
      , yl = typeof cs == "function" && createMemo(cs);
    const xl = new Set
      , [wl,_l] = (Ls.storage || createSignal)(Ls.initialValue)
      , [El,Cl] = createSignal(void 0)
      , [$l,Sl] = createSignal(void 0, {
        equals: !1
    })
      , [Tl,Rl] = createSignal(ba ? "ready" : "unresolved");
    if (sharedConfig.context) {
        Xs = `${sharedConfig.context.id}${sharedConfig.context.count++}`;
        let Fl;
        Ls.ssrLoadFrom === "initial" ? Ws = Ls.initialValue : sharedConfig.load && (Fl = sharedConfig.load(Xs)) && (Ws = Fl[0])
    }
    function Il(Fl, Ul, Dl, Zl) {
        return Vs === Fl && (Vs = null,
        ba = !0,
        (Fl === Ws || Ul === Ws) && Ls.onHydrated && queueMicrotask( () => Ls.onHydrated(Zl, {
            value: Ul
        })),
        Ws = NO_INIT,
        Ml(Ul, Dl)),
        Ul
    }
    function Ml(Fl, Ul) {
        runUpdates( () => {
            Ul === void 0 && _l( () => Fl),
            Rl(Ul !== void 0 ? "errored" : "ready"),
            Cl(Ul);
            for (const Dl of xl.keys())
                Dl.decrement();
            xl.clear()
        }
        , !1)
    }
    function Nl() {
        const Fl = SuspenseContext
          , Ul = wl()
          , Dl = El();
        if (Dl !== void 0 && !Vs)
            throw Dl;
        return Listener && Listener.user,
        Ul
    }
    function Ll(Fl=!0) {
        if (Fl !== !1 && ga)
            return;
        ga = !1;
        const Ul = yl ? yl() : cs;
        if (Ul == null || Ul === !1) {
            Il(Vs, untrack(wl));
            return
        }
        const Dl = Ws !== NO_INIT ? Ws : untrack( () => Cs(Ul, {
            value: wl(),
            refetching: Fl
        }));
        return typeof Dl != "object" || !(Dl && "then"in Dl) ? (Il(Vs, Dl, void 0, Ul),
        Dl) : (Vs = Dl,
        ga = !0,
        queueMicrotask( () => ga = !1),
        runUpdates( () => {
            Rl(ba ? "refreshing" : "pending"),
            Sl()
        }
        , !1),
        Dl.then(Zl => Il(Dl, Zl, void 0, Ul), Zl => Il(Dl, void 0, castError(Zl), Ul)))
    }
    return Object.defineProperties(Nl, {
        state: {
            get: () => Tl()
        },
        error: {
            get: () => El()
        },
        loading: {
            get() {
                const Fl = Tl();
                return Fl === "pending" || Fl === "refreshing"
            }
        },
        latest: {
            get() {
                if (!ba)
                    return Nl();
                const Fl = El();
                if (Fl && !Vs)
                    throw Fl;
                return wl()
            }
        }
    }),
    yl ? createComputed( () => Ll(!1)) : Ll(!1),
    [Nl, {
        refetch: Ll,
        mutate: _l
    }]
}
function batch(xt) {
    return runUpdates(xt, !1)
}
function untrack(xt) {
    if (Listener === null)
        return xt();
    const Cn = Listener;
    Listener = null;
    try {
        return xt()
    } finally {
        Listener = Cn
    }
}
function on(xt, Cn, as) {
    const cs = Array.isArray(xt);
    let Cs;
    return Ls => {
        let Vs;
        if (cs) {
            Vs = Array(xt.length);
            for (let Xs = 0; Xs < xt.length; Xs++)
                Vs[Xs] = xt[Xs]()
        } else
            Vs = xt();
        const Ws = untrack( () => Cn(Vs, Cs, Ls));
        return Cs = Vs,
        Ws
    }
}
function onMount(xt) {
    createEffect( () => untrack(xt))
}
function onCleanup(xt) {
    return Owner === null || (Owner.cleanups === null ? Owner.cleanups = [xt] : Owner.cleanups.push(xt)),
    xt
}
function getListener() {
    return Listener
}
function getOwner() {
    return Owner
}
function createContext(xt, Cn) {
    const as = Symbol("context");
    return {
        id: as,
        Provider: createProvider(as),
        defaultValue: xt
    }
}
function useContext(xt) {
    let Cn;
    return (Cn = lookup(Owner, xt.id)) !== void 0 ? Cn : xt.defaultValue
}
function children(xt) {
    const Cn = createMemo(xt)
      , as = createMemo( () => resolveChildren(Cn()));
    return as.toArray = () => {
        const cs = as();
        return Array.isArray(cs) ? cs : cs != null ? [cs] : []
    }
    ,
    as
}
let SuspenseContext;
function readSignal() {
    const xt = Transition$1;
    if (this.sources && (this.state || xt))
        if (this.state === STALE || xt)
            updateComputation(this);
        else {
            const Cn = Updates;
            Updates = null,
            runUpdates( () => lookUpstream(this), !1),
            Updates = Cn
        }
    if (Listener) {
        const Cn = this.observers ? this.observers.length : 0;
        Listener.sources ? (Listener.sources.push(this),
        Listener.sourceSlots.push(Cn)) : (Listener.sources = [this],
        Listener.sourceSlots = [Cn]),
        this.observers ? (this.observers.push(Listener),
        this.observerSlots.push(Listener.sources.length - 1)) : (this.observers = [Listener],
        this.observerSlots = [Listener.sources.length - 1])
    }
    return this.value
}
function writeSignal(xt, Cn, as) {
    let cs = xt.value;
    return (!xt.comparator || !xt.comparator(cs, Cn)) && (xt.value = Cn,
    xt.observers && xt.observers.length && runUpdates( () => {
        for (let Cs = 0; Cs < xt.observers.length; Cs += 1) {
            const Ls = xt.observers[Cs]
              , Vs = Transition$1 && Transition$1.running;
            Vs && Transition$1.disposed.has(Ls),
            (Vs && !Ls.tState || !Vs && !Ls.state) && (Ls.pure ? Updates.push(Ls) : Effects.push(Ls),
            Ls.observers && markDownstream(Ls)),
            Vs || (Ls.state = STALE)
        }
        if (Updates.length > 1e6)
            throw Updates = [],
            new Error
    }
    , !1)),
    Cn
}
function updateComputation(xt) {
    if (!xt.fn)
        return;
    cleanNode(xt);
    const Cn = Owner
      , as = Listener
      , cs = ExecCount;
    Listener = Owner = xt,
    runComputation(xt, xt.value, cs),
    Listener = as,
    Owner = Cn
}
function runComputation(xt, Cn, as) {
    let cs;
    try {
        cs = xt.fn(Cn)
    } catch (Cs) {
        xt.pure && (xt.state = STALE,
        xt.owned && xt.owned.forEach(cleanNode),
        xt.owned = null),
        handleError(Cs)
    }
    (!xt.updatedAt || xt.updatedAt <= as) && (xt.updatedAt != null && "observers"in xt ? writeSignal(xt, cs) : xt.value = cs,
    xt.updatedAt = as)
}
function createComputation(xt, Cn, as, cs=STALE, Cs) {
    const Ls = {
        fn: xt,
        state: cs,
        updatedAt: null,
        owned: null,
        sources: null,
        sourceSlots: null,
        cleanups: null,
        value: Cn,
        owner: Owner,
        context: null,
        pure: as
    };
    return Owner === null || Owner !== UNOWNED && (Owner.owned ? Owner.owned.push(Ls) : Owner.owned = [Ls]),
    Ls
}
function runTop(xt) {
    const Cn = Transition$1;
    if (xt.state === 0 || Cn)
        return;
    if (xt.state === PENDING || Cn)
        return lookUpstream(xt);
    if (xt.suspense && untrack(xt.suspense.inFallback))
        return xt.suspense.effects.push(xt);
    const as = [xt];
    for (; (xt = xt.owner) && (!xt.updatedAt || xt.updatedAt < ExecCount); )
        (xt.state || Cn) && as.push(xt);
    for (let cs = as.length - 1; cs >= 0; cs--)
        if (xt = as[cs],
        xt.state === STALE || Cn)
            updateComputation(xt);
        else if (xt.state === PENDING || Cn) {
            const Cs = Updates;
            Updates = null,
            runUpdates( () => lookUpstream(xt, as[0]), !1),
            Updates = Cs
        }
}
function runUpdates(xt, Cn) {
    if (Updates)
        return xt();
    let as = !1;
    Cn || (Updates = []),
    Effects ? as = !0 : Effects = [],
    ExecCount++;
    try {
        const cs = xt();
        return completeUpdates(as),
        cs
    } catch (cs) {
        as || (Effects = null),
        Updates = null,
        handleError(cs)
    }
}
function completeUpdates(xt) {
    if (Updates && (runQueue(Updates),
    Updates = null),
    xt)
        return;
    const Cn = Effects;
    Effects = null,
    Cn.length && runUpdates( () => runEffects(Cn), !1)
}
function runQueue(xt) {
    for (let Cn = 0; Cn < xt.length; Cn++)
        runTop(xt[Cn])
}
function runUserEffects(xt) {
    let Cn, as = 0;
    for (Cn = 0; Cn < xt.length; Cn++) {
        const cs = xt[Cn];
        cs.user ? xt[as++] = cs : runTop(cs)
    }
    for (sharedConfig.context && setHydrateContext(),
    Cn = 0; Cn < as; Cn++)
        runTop(xt[Cn])
}
function lookUpstream(xt, Cn) {
    const as = Transition$1;
    xt.state = 0;
    for (let cs = 0; cs < xt.sources.length; cs += 1) {
        const Cs = xt.sources[cs];
        Cs.sources && (Cs.state === STALE || as ? Cs !== Cn && runTop(Cs) : (Cs.state === PENDING || as) && lookUpstream(Cs, Cn))
    }
}
function markDownstream(xt) {
    const Cn = Transition$1;
    for (let as = 0; as < xt.observers.length; as += 1) {
        const cs = xt.observers[as];
        (!cs.state || Cn) && (cs.state = PENDING,
        cs.pure ? Updates.push(cs) : Effects.push(cs),
        cs.observers && markDownstream(cs))
    }
}
function cleanNode(xt) {
    let Cn;
    if (xt.sources)
        for (; xt.sources.length; ) {
            const as = xt.sources.pop()
              , cs = xt.sourceSlots.pop()
              , Cs = as.observers;
            if (Cs && Cs.length) {
                const Ls = Cs.pop()
                  , Vs = as.observerSlots.pop();
                cs < Cs.length && (Ls.sourceSlots[Vs] = cs,
                Cs[cs] = Ls,
                as.observerSlots[cs] = Vs)
            }
        }
    if (xt.owned) {
        for (Cn = 0; Cn < xt.owned.length; Cn++)
            cleanNode(xt.owned[Cn]);
        xt.owned = null
    }
    if (xt.cleanups) {
        for (Cn = 0; Cn < xt.cleanups.length; Cn++)
            xt.cleanups[Cn]();
        xt.cleanups = null
    }
    xt.state = 0,
    xt.context = null
}
function castError(xt) {
    return xt instanceof Error || typeof xt == "string" ? xt : new Error("Unknown error")
}
function handleError(xt) {
    throw xt = castError(xt),
    xt
}
function lookup(xt, Cn) {
    return xt ? xt.context && xt.context[Cn] !== void 0 ? xt.context[Cn] : lookup(xt.owner, Cn) : void 0
}
function resolveChildren(xt) {
    if (typeof xt == "function" && !xt.length)
        return resolveChildren(xt());
    if (Array.isArray(xt)) {
        const Cn = [];
        for (let as = 0; as < xt.length; as++) {
            const cs = resolveChildren(xt[as]);
            Array.isArray(cs) ? Cn.push.apply(Cn, cs) : Cn.push(cs)
        }
        return Cn
    }
    return xt
}
function createProvider(xt, Cn) {
    return function(cs) {
        let Cs;
        return createRenderEffect( () => Cs = untrack( () => (Owner.context = {
            [xt]: cs.value
        },
        children( () => cs.children))), void 0),
        Cs
    }
}
const FALLBACK = Symbol("fallback");
function dispose(xt) {
    for (let Cn = 0; Cn < xt.length; Cn++)
        xt[Cn]()
}
function mapArray(xt, Cn, as={}) {
    let cs = []
      , Cs = []
      , Ls = []
      , Vs = 0
      , Ws = Cn.length > 1 ? [] : null;
    return onCleanup( () => dispose(Ls)),
    () => {
        let Xs = xt() || [], ga, ba;
        return Xs[$TRACK],
        untrack( () => {
            let xl = Xs.length, wl, _l, El, Cl, $l, Sl, Tl, Rl, Il;
            if (xl === 0)
                Vs !== 0 && (dispose(Ls),
                Ls = [],
                cs = [],
                Cs = [],
                Vs = 0,
                Ws && (Ws = [])),
                as.fallback && (cs = [FALLBACK],
                Cs[0] = createRoot(Ml => (Ls[0] = Ml,
                as.fallback())),
                Vs = 1);
            else if (Vs === 0) {
                for (Cs = new Array(xl),
                ba = 0; ba < xl; ba++)
                    cs[ba] = Xs[ba],
                    Cs[ba] = createRoot(yl);
                Vs = xl
            } else {
                for (El = new Array(xl),
                Cl = new Array(xl),
                Ws && ($l = new Array(xl)),
                Sl = 0,
                Tl = Math.min(Vs, xl); Sl < Tl && cs[Sl] === Xs[Sl]; Sl++)
                    ;
                for (Tl = Vs - 1,
                Rl = xl - 1; Tl >= Sl && Rl >= Sl && cs[Tl] === Xs[Rl]; Tl--,
                Rl--)
                    El[Rl] = Cs[Tl],
                    Cl[Rl] = Ls[Tl],
                    Ws && ($l[Rl] = Ws[Tl]);
                for (wl = new Map,
                _l = new Array(Rl + 1),
                ba = Rl; ba >= Sl; ba--)
                    Il = Xs[ba],
                    ga = wl.get(Il),
                    _l[ba] = ga === void 0 ? -1 : ga,
                    wl.set(Il, ba);
                for (ga = Sl; ga <= Tl; ga++)
                    Il = cs[ga],
                    ba = wl.get(Il),
                    ba !== void 0 && ba !== -1 ? (El[ba] = Cs[ga],
                    Cl[ba] = Ls[ga],
                    Ws && ($l[ba] = Ws[ga]),
                    ba = _l[ba],
                    wl.set(Il, ba)) : Ls[ga]();
                for (ba = Sl; ba < xl; ba++)
                    ba in El ? (Cs[ba] = El[ba],
                    Ls[ba] = Cl[ba],
                    Ws && (Ws[ba] = $l[ba],
                    Ws[ba](ba))) : Cs[ba] = createRoot(yl);
                Cs = Cs.slice(0, Vs = xl),
                cs = Xs.slice(0)
            }
            return Cs
        }
        );
        function yl(xl) {
            if (Ls[ba] = xl,
            Ws) {
                const [wl,_l] = createSignal(ba);
                return Ws[ba] = _l,
                Cn(Xs[ba], wl)
            }
            return Cn(Xs[ba])
        }
    }
}
function createComponent(xt, Cn) {
    return untrack( () => xt(Cn || {}))
}
function trueFn() {
    return !0
}
const propTraps = {
    get(xt, Cn, as) {
        return Cn === $PROXY ? as : xt.get(Cn)
    },
    has(xt, Cn) {
        return Cn === $PROXY ? !0 : xt.has(Cn)
    },
    set: trueFn,
    deleteProperty: trueFn,
    getOwnPropertyDescriptor(xt, Cn) {
        return {
            configurable: !0,
            enumerable: !0,
            get() {
                return xt.get(Cn)
            },
            set: trueFn,
            deleteProperty: trueFn
        }
    },
    ownKeys(xt) {
        return xt.keys()
    }
};
function resolveSource(xt) {
    return (xt = typeof xt == "function" ? xt() : xt) ? xt : {}
}
function mergeProps$1(...xt) {
    let Cn = !1;
    for (let cs = 0; cs < xt.length; cs++) {
        const Cs = xt[cs];
        Cn = Cn || !!Cs && $PROXY in Cs,
        xt[cs] = typeof Cs == "function" ? (Cn = !0,
        createMemo(Cs)) : Cs
    }
    if (Cn)
        return new Proxy({
            get(cs) {
                for (let Cs = xt.length - 1; Cs >= 0; Cs--) {
                    const Ls = resolveSource(xt[Cs])[cs];
                    if (Ls !== void 0)
                        return Ls
                }
            },
            has(cs) {
                for (let Cs = xt.length - 1; Cs >= 0; Cs--)
                    if (cs in resolveSource(xt[Cs]))
                        return !0;
                return !1
            },
            keys() {
                const cs = [];
                for (let Cs = 0; Cs < xt.length; Cs++)
                    cs.push(...Object.keys(resolveSource(xt[Cs])));
                return [...new Set(cs)]
            }
        },propTraps);
    const as = {};
    for (let cs = xt.length - 1; cs >= 0; cs--)
        if (xt[cs]) {
            const Cs = Object.getOwnPropertyDescriptors(xt[cs]);
            for (const Ls in Cs)
                Ls in as || Object.defineProperty(as, Ls, {
                    enumerable: !0,
                    get() {
                        for (let Vs = xt.length - 1; Vs >= 0; Vs--) {
                            const Ws = (xt[Vs] || {})[Ls];
                            if (Ws !== void 0)
                                return Ws
                        }
                    }
                })
        }
    return as
}
function splitProps(xt, ...Cn) {
    const as = new Set(Cn.flat());
    if ($PROXY in xt) {
        const Cs = Cn.map(Ls => new Proxy({
            get(Vs) {
                return Ls.includes(Vs) ? xt[Vs] : void 0
            },
            has(Vs) {
                return Ls.includes(Vs) && Vs in xt
            },
            keys() {
                return Ls.filter(Vs => Vs in xt)
            }
        },propTraps));
        return Cs.push(new Proxy({
            get(Ls) {
                return as.has(Ls) ? void 0 : xt[Ls]
            },
            has(Ls) {
                return as.has(Ls) ? !1 : Ls in xt
            },
            keys() {
                return Object.keys(xt).filter(Ls => !as.has(Ls))
            }
        },propTraps)),
        Cs
    }
    const cs = Object.getOwnPropertyDescriptors(xt);
    return Cn.push(Object.keys(cs).filter(Cs => !as.has(Cs))),
    Cn.map(Cs => {
        const Ls = {};
        for (let Vs = 0; Vs < Cs.length; Vs++) {
            const Ws = Cs[Vs];
            Ws in xt && Object.defineProperty(Ls, Ws, cs[Ws] ? cs[Ws] : {
                get() {
                    return xt[Ws]
                },
                set() {
                    return !0
                },
                enumerable: !0
            })
        }
        return Ls
    }
    )
}
function For(xt) {
    const Cn = "fallback"in xt && {
        fallback: () => xt.fallback
    };
    return createMemo(mapArray( () => xt.each, xt.children, Cn || void 0))
}
function Show(xt) {
    let Cn = !1;
    const as = xt.keyed
      , cs = createMemo( () => xt.when, void 0, {
        equals: (Cs, Ls) => Cn ? Cs === Ls : !Cs == !Ls
    });
    return createMemo( () => {
        const Cs = cs();
        if (Cs) {
            const Ls = xt.children
              , Vs = typeof Ls == "function" && Ls.length > 0;
            return Cn = as || Vs,
            Vs ? untrack( () => Ls(Cs)) : Ls
        }
        return xt.fallback
    }
    , void 0, void 0)
}
function Switch(xt) {
    let Cn = !1
      , as = !1;
    const cs = (Vs, Ws) => Vs[0] === Ws[0] && (Cn ? Vs[1] === Ws[1] : !Vs[1] == !Ws[1]) && Vs[2] === Ws[2]
      , Cs = children( () => xt.children)
      , Ls = createMemo( () => {
        let Vs = Cs();
        Array.isArray(Vs) || (Vs = [Vs]);
        for (let Ws = 0; Ws < Vs.length; Ws++) {
            const Xs = Vs[Ws].when;
            if (Xs)
                return as = !!Vs[Ws].keyed,
                [Ws, Xs, Vs[Ws]]
        }
        return [-1]
    }
    , void 0, {
        equals: cs
    });
    return createMemo( () => {
        const [Vs,Ws,Xs] = Ls();
        if (Vs < 0)
            return xt.fallback;
        const ga = Xs.children
          , ba = typeof ga == "function" && ga.length > 0;
        return Cn = as || ba,
        ba ? untrack( () => ga(Ws)) : ga
    }
    , void 0, void 0)
}
function Match(xt) {
    return xt
}
const booleans = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "hidden", "indeterminate", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected"]
  , Properties = new Set(["className", "value", "readOnly", "formNoValidate", "isMap", "noModule", "playsInline", ...booleans])
  , ChildProperties = new Set(["innerHTML", "textContent", "innerText", "children"])
  , Aliases = Object.assign(Object.create(null), {
    className: "class",
    htmlFor: "for"
})
  , PropAliases = Object.assign(Object.create(null), {
    class: "className",
    formnovalidate: "formNoValidate",
    ismap: "isMap",
    nomodule: "noModule",
    playsinline: "playsInline",
    readonly: "readOnly"
})
  , DelegatedEvents = new Set(["beforeinput", "click", "dblclick", "contextmenu", "focusin", "focusout", "input", "keydown", "keyup", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "pointerdown", "pointermove", "pointerout", "pointerover", "pointerup", "touchend", "touchmove", "touchstart"])
  , SVGElements = new Set(["altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "circle", "clipPath", "color-profile", "cursor", "defs", "desc", "ellipse", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignObject", "g", "glyph", "glyphRef", "hkern", "image", "line", "linearGradient", "marker", "mask", "metadata", "missing-glyph", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "set", "stop", "svg", "switch", "symbol", "text", "textPath", "tref", "tspan", "use", "view", "vkern"])
  , SVGNamespace = {
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace"
};
function reconcileArrays(xt, Cn, as) {
    let cs = as.length
      , Cs = Cn.length
      , Ls = cs
      , Vs = 0
      , Ws = 0
      , Xs = Cn[Cs - 1].nextSibling
      , ga = null;
    for (; Vs < Cs || Ws < Ls; ) {
        if (Cn[Vs] === as[Ws]) {
            Vs++,
            Ws++;
            continue
        }
        for (; Cn[Cs - 1] === as[Ls - 1]; )
            Cs--,
            Ls--;
        if (Cs === Vs) {
            const ba = Ls < cs ? Ws ? as[Ws - 1].nextSibling : as[Ls - Ws] : Xs;
            for (; Ws < Ls; )
                xt.insertBefore(as[Ws++], ba)
        } else if (Ls === Ws)
            for (; Vs < Cs; )
                (!ga || !ga.has(Cn[Vs])) && Cn[Vs].remove(),
                Vs++;
        else if (Cn[Vs] === as[Ls - 1] && as[Ws] === Cn[Cs - 1]) {
            const ba = Cn[--Cs].nextSibling;
            xt.insertBefore(as[Ws++], Cn[Vs++].nextSibling),
            xt.insertBefore(as[--Ls], ba),
            Cn[Cs] = as[Ls]
        } else {
            if (!ga) {
                ga = new Map;
                let yl = Ws;
                for (; yl < Ls; )
                    ga.set(as[yl], yl++)
            }
            const ba = ga.get(Cn[Vs]);
            if (ba != null)
                if (Ws < ba && ba < Ls) {
                    let yl = Vs, xl = 1, wl;
                    for (; ++yl < Cs && yl < Ls && !((wl = ga.get(Cn[yl])) == null || wl !== ba + xl); )
                        xl++;
                    if (xl > ba - Ws) {
                        const _l = Cn[Vs];
                        for (; Ws < ba; )
                            xt.insertBefore(as[Ws++], _l)
                    } else
                        xt.replaceChild(as[Ws++], Cn[Vs++])
                } else
                    Vs++;
            else
                Cn[Vs++].remove()
        }
    }
}
const $$EVENTS = "_$DX_DELEGATE";
function render(xt, Cn, as, cs={}) {
    let Cs;
    return createRoot(Ls => {
        Cs = Ls,
        Cn === document ? xt() : insert(Cn, xt(), Cn.firstChild ? null : void 0, as)
    }
    , cs.owner),
    () => {
        Cs(),
        Cn.textContent = ""
    }
}
function template$1(xt, Cn, as) {
    if (typeof window > "u")
        return null;
    const cs = document.createElement("template");
    cs.innerHTML = xt;
    let Cs = cs.content.firstChild;
    return as && (Cs = Cs.firstChild),
    Cs
}
function delegateEvents(xt, Cn=window.document) {
    const as = Cn[$$EVENTS] || (Cn[$$EVENTS] = new Set);
    for (let cs = 0, Cs = xt.length; cs < Cs; cs++) {
        const Ls = xt[cs];
        as.has(Ls) || (as.add(Ls),
        Cn.addEventListener(Ls, eventHandler))
    }
}
function setAttribute(xt, Cn, as) {
    as == null ? xt.removeAttribute(Cn) : xt.setAttribute(Cn, as)
}
function setAttributeNS(xt, Cn, as, cs) {
    cs == null ? xt.removeAttributeNS(Cn, as) : xt.setAttributeNS(Cn, as, cs)
}
function className(xt, Cn) {
    Cn == null ? xt.removeAttribute("class") : xt.className = Cn
}
function addEventListener(xt, Cn, as, cs) {
    if (cs)
        Array.isArray(as) ? (xt[`$$${Cn}`] = as[0],
        xt[`$$${Cn}Data`] = as[1]) : xt[`$$${Cn}`] = as;
    else if (Array.isArray(as)) {
        const Cs = as[0];
        xt.addEventListener(Cn, as[0] = Ls => Cs.call(xt, as[1], Ls))
    } else
        xt.addEventListener(Cn, as)
}
function classList(xt, Cn, as={}) {
    const cs = Object.keys(Cn || {})
      , Cs = Object.keys(as);
    let Ls, Vs;
    for (Ls = 0,
    Vs = Cs.length; Ls < Vs; Ls++) {
        const Ws = Cs[Ls];
        !Ws || Ws === "undefined" || Cn[Ws] || (toggleClassKey(xt, Ws, !1),
        delete as[Ws])
    }
    for (Ls = 0,
    Vs = cs.length; Ls < Vs; Ls++) {
        const Ws = cs[Ls]
          , Xs = !!Cn[Ws];
        !Ws || Ws === "undefined" || as[Ws] === Xs || !Xs || (toggleClassKey(xt, Ws, !0),
        as[Ws] = Xs)
    }
    return as
}
function style(xt, Cn, as) {
    if (!Cn)
        return as ? setAttribute(xt, "style") : Cn;
    const cs = xt.style;
    if (typeof Cn == "string")
        return cs.cssText = Cn;
    typeof as == "string" && (cs.cssText = as = void 0),
    as || (as = {}),
    Cn || (Cn = {});
    let Cs, Ls;
    for (Ls in as)
        Cn[Ls] == null && cs.removeProperty(Ls),
        delete as[Ls];
    for (Ls in Cn)
        Cs = Cn[Ls],
        Cs !== as[Ls] && (cs.setProperty(Ls, Cs),
        as[Ls] = Cs);
    return as
}
function spread(xt, Cn={}, as, cs) {
    const Cs = {};
    return createRenderEffect( () => Cs.children = insertExpression(xt, Cn.children, Cs.children)),
    createRenderEffect( () => Cn.ref && Cn.ref(xt)),
    createRenderEffect( () => assign(xt, Cn, as, !0, Cs, !0)),
    Cs
}
function use(xt, Cn, as) {
    return untrack( () => xt(Cn, as))
}
function insert(xt, Cn, as, cs) {
    if (as !== void 0 && !cs && (cs = []),
    typeof Cn != "function")
        return insertExpression(xt, Cn, cs, as);
    createRenderEffect(Cs => insertExpression(xt, Cn(), Cs, as), cs)
}
function assign(xt, Cn, as, cs, Cs={}, Ls=!1) {
    Cn || (Cn = {});
    for (const Vs in Cs)
        if (!(Vs in Cn)) {
            if (Vs === "children")
                continue;
            Cs[Vs] = assignProp(xt, Vs, null, Cs[Vs], as, Ls)
        }
    for (const Vs in Cn) {
        if (Vs === "children")
            continue;
        const Ws = Cn[Vs];
        Cs[Vs] = assignProp(xt, Vs, Ws, Cs[Vs], as, Ls)
    }
}
function getNextElement(xt) {
    let Cn, as;
    return !sharedConfig.context || !(Cn = sharedConfig.registry.get(as = getHydrationKey())) ? xt.cloneNode(!0) : (sharedConfig.completed && sharedConfig.completed.add(Cn),
    sharedConfig.registry.delete(as),
    Cn)
}
function toPropertyName(xt) {
    return xt.toLowerCase().replace(/-([a-z])/g, (Cn, as) => as.toUpperCase())
}
function toggleClassKey(xt, Cn, as) {
    const cs = Cn.trim().split(/\s+/);
    for (let Cs = 0, Ls = cs.length; Cs < Ls; Cs++)
        xt.classList.toggle(cs[Cs], as)
}
function assignProp(xt, Cn, as, cs, Cs, Ls) {
    let Vs, Ws, Xs;
    if (Cn === "style")
        return style(xt, as, cs);
    if (Cn === "classList")
        return classList(xt, as, cs);
    if (as === cs)
        return cs;
    if (Cn === "ref")
        Ls || as(xt);
    else if (Cn.slice(0, 3) === "on:") {
        const ga = Cn.slice(3);
        cs && xt.removeEventListener(ga, cs),
        as && xt.addEventListener(ga, as)
    } else if (Cn.slice(0, 10) === "oncapture:") {
        const ga = Cn.slice(10);
        cs && xt.removeEventListener(ga, cs, !0),
        as && xt.addEventListener(ga, as, !0)
    } else if (Cn.slice(0, 2) === "on") {
        const ga = Cn.slice(2).toLowerCase()
          , ba = DelegatedEvents.has(ga);
        if (!ba && cs) {
            const yl = Array.isArray(cs) ? cs[0] : cs;
            xt.removeEventListener(ga, yl)
        }
        (ba || as) && (addEventListener(xt, ga, as, ba),
        ba && delegateEvents([ga]))
    } else if ((Xs = ChildProperties.has(Cn)) || !Cs && (PropAliases[Cn] || (Ws = Properties.has(Cn))) || (Vs = xt.nodeName.includes("-")))
        Cn === "class" || Cn === "className" ? className(xt, as) : Vs && !Ws && !Xs ? xt[toPropertyName(Cn)] = as : xt[PropAliases[Cn] || Cn] = as;
    else {
        const ga = Cs && Cn.indexOf(":") > -1 && SVGNamespace[Cn.split(":")[0]];
        ga ? setAttributeNS(xt, ga, Cn, as) : setAttribute(xt, Aliases[Cn] || Cn, as)
    }
    return as
}
function eventHandler(xt) {
    const Cn = `$$${xt.type}`;
    let as = xt.composedPath && xt.composedPath()[0] || xt.target;
    for (xt.target !== as && Object.defineProperty(xt, "target", {
        configurable: !0,
        value: as
    }),
    Object.defineProperty(xt, "currentTarget", {
        configurable: !0,
        get() {
            return as || document
        }
    }),
    sharedConfig.registry && !sharedConfig.done && (sharedConfig.done = !0,
    document.querySelectorAll("[id^=pl-]").forEach(cs => {
        for (; cs && cs.nodeType !== 8 && cs.nodeValue !== "pl-" + xt; ) {
            let Cs = cs.nextSibling;
            cs.remove(),
            cs = Cs
        }
        cs && cs.remove()
    }
    )); as; ) {
        const cs = as[Cn];
        if (cs && !as.disabled) {
            const Cs = as[`${Cn}Data`];
            if (Cs !== void 0 ? cs.call(as, Cs, xt) : cs.call(as, xt),
            xt.cancelBubble)
                return
        }
        as = as._$host || as.parentNode || as.host
    }
}
function insertExpression(xt, Cn, as, cs, Cs) {
    for (sharedConfig.context && !as && (as = [...xt.childNodes]); typeof as == "function"; )
        as = as();
    if (Cn === as)
        return as;
    const Ls = typeof Cn
      , Vs = cs !== void 0;
    if (xt = Vs && as[0] && as[0].parentNode || xt,
    Ls === "string" || Ls === "number") {
        if (sharedConfig.context)
            return as;
        if (Ls === "number" && (Cn = Cn.toString()),
        Vs) {
            let Ws = as[0];
            Ws && Ws.nodeType === 3 ? Ws.data = Cn : Ws = document.createTextNode(Cn),
            as = cleanChildren(xt, as, cs, Ws)
        } else
            as !== "" && typeof as == "string" ? as = xt.firstChild.data = Cn : as = xt.textContent = Cn
    } else if (Cn == null || Ls === "boolean") {
        if (sharedConfig.context)
            return as;
        as = cleanChildren(xt, as, cs)
    } else {
        if (Ls === "function")
            return createRenderEffect( () => {
                let Ws = Cn();
                for (; typeof Ws == "function"; )
                    Ws = Ws();
                as = insertExpression(xt, Ws, as, cs)
            }
            ),
            () => as;
        if (Array.isArray(Cn)) {
            const Ws = []
              , Xs = as && Array.isArray(as);
            if (normalizeIncomingArray(Ws, Cn, as, Cs))
                return createRenderEffect( () => as = insertExpression(xt, Ws, as, cs, !0)),
                () => as;
            if (sharedConfig.context) {
                if (!Ws.length)
                    return as;
                for (let ga = 0; ga < Ws.length; ga++)
                    if (Ws[ga].parentNode)
                        return as = Ws
            }
            if (Ws.length === 0) {
                if (as = cleanChildren(xt, as, cs),
                Vs)
                    return as
            } else
                Xs ? as.length === 0 ? appendNodes(xt, Ws, cs) : reconcileArrays(xt, as, Ws) : (as && cleanChildren(xt),
                appendNodes(xt, Ws));
            as = Ws
        } else if (Cn instanceof Node) {
            if (sharedConfig.context && Cn.parentNode)
                return as = Vs ? [Cn] : Cn;
            if (Array.isArray(as)) {
                if (Vs)
                    return as = cleanChildren(xt, as, cs, Cn);
                cleanChildren(xt, as, null, Cn)
            } else
                as == null || as === "" || !xt.firstChild ? xt.appendChild(Cn) : xt.replaceChild(Cn, xt.firstChild);
            as = Cn
        }
    }
    return as
}
function normalizeIncomingArray(xt, Cn, as, cs) {
    let Cs = !1;
    for (let Ls = 0, Vs = Cn.length; Ls < Vs; Ls++) {
        let Ws = Cn[Ls]
          , Xs = as && as[Ls];
        if (Ws instanceof Node)
            xt.push(Ws);
        else if (!(Ws == null || Ws === !0 || Ws === !1))
            if (Array.isArray(Ws))
                Cs = normalizeIncomingArray(xt, Ws, Xs) || Cs;
            else if (typeof Ws == "function")
                if (cs) {
                    for (; typeof Ws == "function"; )
                        Ws = Ws();
                    Cs = normalizeIncomingArray(xt, Array.isArray(Ws) ? Ws : [Ws], Array.isArray(Xs) ? Xs : [Xs]) || Cs
                } else
                    xt.push(Ws),
                    Cs = !0;
            else {
                const ga = String(Ws);
                Xs && Xs.nodeType === 3 && Xs.data === ga ? xt.push(Xs) : xt.push(document.createTextNode(ga))
            }
    }
    return Cs
}
function appendNodes(xt, Cn, as=null) {
    for (let cs = 0, Cs = Cn.length; cs < Cs; cs++)
        xt.insertBefore(Cn[cs], as)
}
function cleanChildren(xt, Cn, as, cs) {
    if (as === void 0)
        return xt.textContent = "";
    const Cs = cs || document.createTextNode("");
    if (Cn.length) {
        let Ls = !1;
        for (let Vs = Cn.length - 1; Vs >= 0; Vs--) {
            const Ws = Cn[Vs];
            if (Cs !== Ws) {
                const Xs = Ws.parentNode === xt;
                !Ls && !Vs ? Xs ? xt.replaceChild(Cs, Ws) : xt.insertBefore(Cs, as) : Xs && Ws.remove()
            } else
                Ls = !0
        }
    } else
        xt.insertBefore(Cs, as);
    return [Cs]
}
function getHydrationKey() {
    const xt = sharedConfig.context;
    return `${xt.id}${xt.count++}`
}
const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
function createElement(xt, Cn=!1) {
    return Cn ? document.createElementNS(SVG_NAMESPACE, xt) : document.createElement(xt)
}
function Portal(xt) {
    const {useShadow: Cn} = xt
      , as = document.createTextNode("")
      , cs = xt.mount || document.body;
    function Cs() {
        if (sharedConfig.context) {
            const [Ls,Vs] = createSignal(!1);
            return queueMicrotask( () => Vs(!0)),
            () => Ls() && xt.children
        } else
            return () => xt.children
    }
    if (cs instanceof HTMLHeadElement) {
        const [Ls,Vs] = createSignal(!1)
          , Ws = () => Vs(!0);
        createRoot(Xs => insert(cs, () => Ls() ? Xs() : Cs()(), null)),
        onCleanup( () => {
            sharedConfig.context ? queueMicrotask(Ws) : Ws()
        }
        )
    } else {
        const Ls = createElement(xt.isSVG ? "g" : "div", xt.isSVG)
          , Vs = Cn && Ls.attachShadow ? Ls.attachShadow({
            mode: "open"
        }) : Ls;
        Object.defineProperty(Ls, "_$host", {
            get() {
                return as.parentNode
            },
            configurable: !0
        }),
        insert(Vs, Cs()),
        cs.appendChild(Ls),
        xt.ref && xt.ref(Ls),
        onCleanup( () => cs.removeChild(Ls))
    }
    return as
}
function Dynamic(xt) {
    const [Cn,as] = splitProps(xt, ["component"])
      , cs = createMemo( () => Cn.component);
    return createMemo( () => {
        const Cs = cs();
        switch (typeof Cs) {
        case "function":
            return untrack( () => Cs(as));
        case "string":
            const Ls = SVGElements.has(Cs)
              , Vs = sharedConfig.context ? getNextElement() : createElement(Cs, Ls);
            return spread(Vs, as, Ls),
            Vs
        }
    }
    )
}
var THEME = (xt => (xt.DARK = "DARK",
xt.LIGHT = "LIGHT",
xt))(THEME || {});
let e$9 = {
    data: ""
}
  , t$5 = xt => typeof window == "object" ? ((xt ? xt.querySelector("#_goober") : window._goober) || Object.assign((xt || document.head).appendChild(document.createElement("style")), {
    innerHTML: " ",
    id: "_goober"
})).firstChild : xt || e$9
  , l$6 = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g
  , a$b = /\/\*[^]*?\*\/|  +/g
  , n$7 = /\n+/g
  , o$9 = (xt, Cn) => {
    let as = ""
      , cs = ""
      , Cs = "";
    for (let Ls in xt) {
        let Vs = xt[Ls];
        Ls[0] == "@" ? Ls[1] == "i" ? as = Ls + " " + Vs + ";" : cs += Ls[1] == "f" ? o$9(Vs, Ls) : Ls + "{" + o$9(Vs, Ls[1] == "k" ? "" : Cn) + "}" : typeof Vs == "object" ? cs += o$9(Vs, Cn ? Cn.replace(/([^,])+/g, Ws => Ls.replace(/(^:.*)|([^,])+/g, Xs => /&/.test(Xs) ? Xs.replace(/&/g, Ws) : Ws ? Ws + " " + Xs : Xs)) : Ls) : Vs != null && (Ls = /^--/.test(Ls) ? Ls : Ls.replace(/[A-Z]/g, "-$&").toLowerCase(),
        Cs += o$9.p ? o$9.p(Ls, Vs) : Ls + ":" + Vs + ";")
    }
    return as + (Cn && Cs ? Cn + "{" + Cs + "}" : Cs) + cs
}
  , c$8 = {}
  , s$b = xt => {
    if (typeof xt == "object") {
        let Cn = "";
        for (let as in xt)
            Cn += as + s$b(xt[as]);
        return Cn
    }
    return xt
}
  , i$7 = (xt, Cn, as, cs, Cs) => {
    let Ls = s$b(xt)
      , Vs = c$8[Ls] || (c$8[Ls] = (Xs => {
        let ga = 0
          , ba = 11;
        for (; ga < Xs.length; )
            ba = 101 * ba + Xs.charCodeAt(ga++) >>> 0;
        return "go" + ba
    }
    )(Ls));
    if (!c$8[Vs]) {
        let Xs = Ls !== xt ? xt : (ga => {
            let ba, yl, xl = [{}];
            for (; ba = l$6.exec(ga.replace(a$b, "")); )
                ba[4] ? xl.shift() : ba[3] ? (yl = ba[3].replace(n$7, " ").trim(),
                xl.unshift(xl[0][yl] = xl[0][yl] || {})) : xl[0][ba[1]] = ba[2].replace(n$7, " ").trim();
            return xl[0]
        }
        )(xt);
        c$8[Vs] = o$9(Cs ? {
            ["@keyframes " + Vs]: Xs
        } : Xs, as ? "" : "." + Vs)
    }
    let Ws = as && c$8.g ? c$8.g : null;
    return as && (c$8.g = c$8[Vs]),
    ( (Xs, ga, ba, yl) => {
        yl ? ga.data = ga.data.replace(yl, Xs) : ga.data.indexOf(Xs) === -1 && (ga.data = ba ? Xs + ga.data : ga.data + Xs)
    }
    )(c$8[Vs], Cn, cs, Ws),
    Vs
}
  , p$5 = (xt, Cn, as) => xt.reduce( (cs, Cs, Ls) => {
    let Vs = Cn[Ls];
    if (Vs && Vs.call) {
        let Ws = Vs(as)
          , Xs = Ws && Ws.props && Ws.props.className || /^go/.test(Ws) && Ws;
        Vs = Xs ? "." + Xs : Ws && typeof Ws == "object" ? Ws.props ? "" : o$9(Ws, "") : Ws === !1 ? "" : Ws
    }
    return cs + Cs + (Vs ?? "")
}
, "");
function u$9(xt) {
    let Cn = this || {}
      , as = xt.call ? xt(Cn.p) : xt;
    return i$7(as.unshift ? as.raw ? p$5(as, [].slice.call(arguments, 1), Cn.p) : as.reduce( (cs, Cs) => Object.assign(cs, Cs && Cs.call ? Cs(Cn.p) : Cs), {}) : as, t$5(Cn.target), Cn.g, Cn.o, Cn.k)
}
u$9.bind({
    g: 1
});
let h$3 = u$9.bind({
    k: 1
});
const ThemeContext = createContext();
function ThemeProvider(xt) {
    return createComponent(ThemeContext.Provider, {
        value: xt.theme,
        get children() {
            return xt.children
        }
    })
}
function useTheme() {
    return useContext(ThemeContext)
}
function makeStyled(xt) {
    let Cn = this || {};
    return (...as) => {
        const cs = Cs => {
            const Ls = useContext(ThemeContext)
              , Vs = mergeProps$1(Cs, {
                theme: Ls
            })
              , Ws = mergeProps$1(Vs, {
                get class() {
                    const wl = Vs.class
                      , _l = "class"in Vs && /^go[0-9]+/.test(wl);
                    let El = u$9.apply({
                        target: Cn.target,
                        o: _l,
                        p: Vs,
                        g: Cn.g
                    }, as);
                    return [wl, El].filter(Boolean).join(" ")
                }
            })
              , [Xs,ga] = splitProps(Ws, ["as", "theme"])
              , ba = ga
              , yl = Xs.as || xt;
            let xl;
            return typeof yl == "function" ? xl = yl(ba) : Cn.g == 1 ? (xl = document.createElement(yl),
            spread(xl, ba)) : xl = Dynamic(mergeProps$1({
                component: yl
            }, ba)),
            xl
        }
        ;
        return cs.class = Cs => untrack( () => u$9.apply({
            target: Cn.target,
            p: Cs,
            g: Cn.g
        }, as)),
        cs
    }
}
const styled = new Proxy(makeStyled,{
    get(xt, Cn) {
        return xt(Cn)
    }
});
function createGlobalStyles() {
    const xt = makeStyled.call({
        g: 1
    }, "div").apply(null, arguments);
    return function(as) {
        return xt(as),
        null
    }
}
const globalStylesTag = "tc-root"
  , disableScrollClass = "tc-disable-scroll"
  , usingMouseClass = "tc-using-mouse"
  , GlobalStyles = () => {
    document.body.addEventListener("mousedown", () => document.body.classList.add(usingMouseClass)),
    document.body.addEventListener("keydown", Cn => {
        Cn.key === "Tab" && document.body.classList.remove(usingMouseClass)
    }
    );
    const xt = createGlobalStyles`
    ${globalStylesTag} * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        
        font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Helvetica Neue', Arial, Tahoma, Verdana, sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;        
        -webkit-tap-highlight-color: transparent;
    }
    
    ${globalStylesTag} img {
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }   
 
    ${globalStylesTag} *:focus {
        outline: #08f auto 2px;
    }
    
    ${globalStylesTag} li {
        list-style: none;
    }
    
    ${globalStylesTag} button {
        outline: none;
    }
    
    body.${disableScrollClass} {
        position: fixed; 
        overflow-y: scroll;
        right: 0;
        left: 0;
    }
    
    body.${usingMouseClass} ${globalStylesTag} *:focus {
        outline: none;
    }
`;
    return createComponent(xt, {})
}
;
function hexToRgb(xt) {
    xt[0] === "#" && (xt = xt.slice(1));
    const Cn = parseInt(xt, 16)
      , as = Cn >> 16 & 255
      , cs = Cn >> 8 & 255
      , Cs = Cn & 255;
    return [as, cs, Cs].join(",")
}
function rgba$1(xt, Cn) {
    return xt[0] === "#" && (xt = hexToRgb(xt)),
    `rgba(${xt}, ${Cn})`
}
function toPx(xt) {
    return xt.toString() + "px"
}
const _InMemoryStorage = class {
    constructor() {
        __publicField(this, "storage", {})
    }
    static getInstance() {
        return _InMemoryStorage.instance || (_InMemoryStorage.instance = new _InMemoryStorage),
        _InMemoryStorage.instance
    }
    get length() {
        return Object.keys(this.storage).length
    }
    clear() {
        this.storage = {}
    }
    getItem(xt) {
        var Cn;
        return (Cn = this.storage[xt]) != null ? Cn : null
    }
    key(xt) {
        var Cn;
        const as = Object.keys(this.storage);
        return xt < 0 || xt >= as.length ? null : (Cn = as[xt]) != null ? Cn : null
    }
    removeItem(xt) {
        delete this.storage[xt]
    }
    setItem(xt, Cn) {
        this.storage[xt] = Cn
    }
}
;
let InMemoryStorage = _InMemoryStorage;
__publicField(InMemoryStorage, "instance");
class TonConnectUIError extends TonConnectError {
    constructor(...Cn) {
        super(...Cn),
        Object.setPrototypeOf(this, TonConnectUIError.prototype)
    }
}
function logDebug(...xt) {
    try {
        console.debug("[TON_CONNECT_UI]", ...xt)
    } catch {}
}
function logError$1(...xt) {
    try {
        console.error("[TON_CONNECT_UI]", ...xt)
    } catch {}
}
function logWarning(...xt) {
    try {
        console.warn("[TON_CONNECT_UI]", ...xt)
    } catch {}
}
function openLink(xt, Cn="_self") {
    logDebug("openLink", xt, Cn),
    window.open(xt, Cn, "noopener noreferrer")
}
function openLinkBlank(xt) {
    openLink(xt, "_blank")
}
function openDeeplinkWithFallback(xt, Cn) {
    const as = () => {
        isBrowser$2("safari") || isOS("android") && isBrowser$2("firefox") || Cn()
    }
      , cs = setTimeout( () => as(), 200);
    window.addEventListener("blur", () => clearTimeout(cs), {
        once: !0
    }),
    openLink(xt, "_self")
}
function getSystemTheme() {
    return window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches ? THEME.LIGHT : THEME.DARK
}
function subscribeToThemeChange(xt) {
    const Cn = as => xt(as.matches ? THEME.DARK : THEME.LIGHT);
    return window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", Cn),
    () => window.matchMedia("(prefers-color-scheme: dark)").removeEventListener("change", Cn)
}
function disableScroll() {
    document.documentElement.scrollHeight !== document.documentElement.clientHeight && (document.body.style.top = toPx(-document.documentElement.scrollTop),
    document.body.classList.add(disableScrollClass))
}
function enableScroll() {
    document.body.classList.remove(disableScrollClass),
    document.documentElement.scrollTo({
        top: -parseFloat(getComputedStyle(document.body).top)
    }),
    document.body.style.top = "auto"
}
function fixMobileSafariActiveTransition() {
    document.body.hasAttribute("ontouchstart") || document.body.setAttribute("ontouchstart", "")
}
function defineStylesRoot() {
    customElements.define(globalStylesTag, class extends HTMLElement {
    }
    )
}
function createMacrotask(xt) {
    return __async(this, null, function*() {
        yield new Promise(Cn => requestAnimationFrame(Cn)),
        xt()
    })
}
function createMacrotaskAsync(xt) {
    return __async(this, null, function*() {
        return yield new Promise(Cn => requestAnimationFrame(Cn)),
        xt()
    })
}
function preloadImages(xt) {
    document.readyState !== "complete" ? window.addEventListener("load", () => createMacrotask( () => preloadImages(xt)), {
        once: !0
    }) : xt.forEach(Cn => {
        const as = new window.Image;
        as.src = Cn
    }
    )
}
function getWindow$1() {
    if (typeof window < "u")
        return window
}
function tryGetLocalStorage() {
    if (isLocalStorageAvailable())
        return localStorage;
    if (isNodeJs())
        throw new TonConnectUIError("`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector");
    return InMemoryStorage.getInstance()
}
function isLocalStorageAvailable() {
    try {
        return typeof localStorage < "u"
    } catch {
        return !1
    }
}
function isNodeJs() {
    return typeof process < "u" && process.versions != null && process.versions.node != null
}
function getUserAgent$1() {
    var xt, Cn, as;
    const cs = new UAParser$1().getResult()
      , Cs = (xt = cs.os.name) == null ? void 0 : xt.toLowerCase()
      , Ls = (Cn = cs.device.model) == null ? void 0 : Cn.toLowerCase();
    let Vs;
    switch (!0) {
    case Ls === "ipad":
        Vs = "ipad";
        break;
    case Cs === "ios":
        Vs = "ios";
        break;
    case Cs === "android":
        Vs = "android";
        break;
    case Cs === "mac os":
        Vs = "macos";
        break;
    case Cs === "linux":
        Vs = "linux";
        break;
    case (Cs == null ? void 0 : Cs.includes("windows")):
        Vs = "windows";
        break
    }
    const Ws = (as = cs.browser.name) == null ? void 0 : as.toLowerCase();
    let Xs;
    switch (!0) {
    case Ws === "chrome":
        Xs = "chrome";
        break;
    case Ws === "firefox":
        Xs = "firefox";
        break;
    case (Ws == null ? void 0 : Ws.includes("safari")):
        Xs = "safari";
        break;
    case (Ws == null ? void 0 : Ws.includes("opera")):
        Xs = "opera";
        break
    }
    return {
        os: Vs,
        browser: Xs
    }
}
function isOS(...xt) {
    return xt.includes(getUserAgent$1().os)
}
function isBrowser$2(...xt) {
    return xt.includes(getUserAgent$1().browser)
}
function toDeeplink(xt, Cn) {
    const as = new URL(xt);
    return Cn + as.search
}
class WalletInfoStorage {
    constructor() {
        __publicField(this, "localStorage"),
        __publicField(this, "storageKey", "ton-connect-ui_wallet-info"),
        this.localStorage = tryGetLocalStorage()
    }
    setWalletInfo(Cn) {
        this.localStorage.setItem(this.storageKey, JSON.stringify(Cn))
    }
    getWalletInfo() {
        const Cn = this.localStorage.getItem(this.storageKey);
        return Cn ? JSON.parse(Cn) : null
    }
    removeWalletInfo() {
        this.localStorage.removeItem(this.storageKey)
    }
}
class PreferredWalletStorage {
    constructor() {
        __publicField(this, "localStorage"),
        __publicField(this, "storageKey", "ton-connect-ui_preferred-wallet"),
        this.localStorage = tryGetLocalStorage()
    }
    setPreferredWalletAppName(Cn) {
        this.localStorage.setItem(this.storageKey, Cn)
    }
    getPreferredWalletAppName() {
        return this.localStorage.getItem(this.storageKey) || void 0
    }
}
class LastSelectedWalletInfoStorage {
    constructor() {
        __publicField(this, "localStorage"),
        __publicField(this, "storageKey", "ton-connect-ui_last-selected-wallet-info"),
        this.localStorage = tryGetLocalStorage()
    }
    setLastSelectedWalletInfo(Cn) {
        this.localStorage.setItem(this.storageKey, JSON.stringify(Cn))
    }
    getLastSelectedWalletInfo() {
        const Cn = this.localStorage.getItem(this.storageKey);
        return Cn ? JSON.parse(Cn) : null
    }
    removeLastSelectedWalletInfo() {
        this.localStorage.removeItem(this.storageKey)
    }
}
const [walletsModalState,setWalletsModalState] = createSignal({
    status: "closed",
    closeReason: null
})
  , getWalletsModalIsOpened = createMemo( () => walletsModalState().status === "opened")
  , [singleWalletModalState,setSingleWalletModalState] = createSignal({
    status: "closed",
    closeReason: null
})
  , getSingleWalletModalIsOpened = createMemo( () => singleWalletModalState().status === "opened")
  , getSingleWalletModalWalletInfo = createMemo( () => {
    const xt = singleWalletModalState();
    return xt.status === "opened" ? xt.walletInfo : null
}
);
let lastSelectedWalletInfoStorage = typeof window < "u" ? new LastSelectedWalletInfoStorage : void 0;
const [lastSelectedWalletInfo,_setLastSelectedWalletInfo] = createSignal((lastSelectedWalletInfoStorage == null ? void 0 : lastSelectedWalletInfoStorage.getLastSelectedWalletInfo()) || null)
  , setLastSelectedWalletInfo = xt => {
    lastSelectedWalletInfoStorage || (lastSelectedWalletInfoStorage = new LastSelectedWalletInfoStorage),
    xt ? lastSelectedWalletInfoStorage.setLastSelectedWalletInfo(xt) : lastSelectedWalletInfoStorage.removeLastSelectedWalletInfo(),
    _setLastSelectedWalletInfo(xt)
}
  , [action$2,setAction] = createSignal(null)
  , common$1 = {
    close: "Close",
    openWallet: "Open wallet",
    copyLink: "Copy Link",
    linkCopied: "Link Copied",
    copied: "Copied",
    yourWallet: "Your Wallet",
    retry: "Retry",
    get: "GET",
    mobile: "Mobile",
    browserExtension: "Browser Extension",
    desktop: "Desktop"
}
  , button$1$1 = {
    connectWallet: "Connect Wallet",
    dropdown: {
        copy: "Copy address",
        copied: "Address copied!",
        disconnect: "Disconnect"
    }
}
  , notifications$1 = {
    confirm: {
        header: "Open {{ name }} toconfirm thetransaction."
    },
    transactionSent: {
        header: "Transaction sent",
        text: "Your transactionwill beprocessed inafew seconds."
    },
    transactionCanceled: {
        header: "Transaction canceled",
        text: "There will be no changes toyour account."
    }
}
  , walletItem$1 = {
    walletOn: "Wallet On",
    recent: "Recent",
    installed: "Installed",
    popular: "Popular"
}
  , walletModal$1 = {
    loading: "Loading wallets",
    wallets: "Wallets",
    mobileUniversalModal: {
        connectYourWallet: "Connect your wallet",
        openWalletOnTelegramOrSelect: "Open Wallet in Telegram or select your wallet to connect",
        openWalletOnTelegram: "Open Wallet in Telegram",
        openLink: "Open Link",
        scan: "Scan with your mobile wallet"
    },
    desktopUniversalModal: {
        connectYourWallet: "Connect your wallet",
        scan: "Scan with your mobile wallet",
        availableWallets: "Available wallets"
    },
    mobileConnectionModal: {
        showQR: "Show QR Code",
        scanQR: "Scan theQR code below with your phonesor{{ name }}s camera",
        continueIn: "Continue in {{ name }}",
        connectionDeclined: "Connection declined"
    },
    desktopConnectionModal: {
        scanQR: "Scan theQR code below with your phonesor{{ name }}s camera",
        continueInExtension: "Continue in{{ name }} browser extension",
        dontHaveExtension: "Seems you don't have installed {{ name }}browserextension",
        getWallet: "Get {{ name }}",
        continueOnDesktop: "Continue in{{ name }} on desktop",
        openWalletOnTelegram: "Open Wallet in Telegram on desktop",
        connectionDeclined: "Connection declined"
    },
    infoModal: {
        whatIsAWallet: "What is a wallet",
        secureDigitalAssets: "Secure digital assets storage",
        walletProtects: "A wallet protects and manages your digital assetsincluding TON, tokens and collectables.",
        controlIdentity: "Control your Web3 identity",
        manageIdentity: "Manage your digital identity and access decentralized applications with ease. Maintain control over your data and engage securely intheblockchain ecosystem.",
        effortlessCryptoTransactions: "Effortless crypto transactions",
        easilySend: "Easily send, receive, monitor your cryptocurrencies.Streamline your operations withdecentralized applications.",
        getAWallet: "Get a Wallet"
    }
}
  , actionModal$1 = {
    confirmTransaction: {
        header: "Confirm thetransaction in{{ name }}",
        text: "It will only take amoment."
    },
    transactionSent: "$notifications.transactionSent",
    transactionCanceled: "$notifications.transactionCanceled"
}
  , en = {
    common: common$1,
    button: button$1$1,
    notifications: notifications$1,
    walletItem: walletItem$1,
    walletModal: walletModal$1,
    actionModal: actionModal$1
}
  , common = {
    close: "",
    openWallet: " ",
    copyLink: " ",
    linkCopied: " ",
    copied: " ",
    yourWallet: " ",
    retry: "",
    get: "",
    mobile: "",
    browserExtension: "",
    desktop: ""
}
  , button$5 = {
    connectWallet: " ",
    dropdown: {
        copy: " ",
        copied: " !",
        disconnect: " "
    }
}
  , notifications = {
    confirm: {
        header: " {{ name }},  ."
    },
    transactionSent: {
        header: " ",
        text: "    ."
    },
    transactionCanceled: {
        header: " ",
        text: "   ."
    }
}
  , walletItem = {
    walletOn: "Wallet ",
    recent: "",
    installed: "",
    popular: ""
}
  , walletModal = {
    loading: " ",
    wallets: "",
    mobileUniversalModal: {
        connectYourWallet: " ",
        openWalletOnTelegramOrSelect: " Wallet Telegram   ",
        openWalletOnTelegram: " Wallet  Telegram",
        openLink: " ",
        scan: "  "
    },
    desktopUniversalModal: {
        connectYourWallet: " ",
        scan: " QR-  ",
        availableWallets: " "
    },
    mobileConnectionModal: {
        showQR: " QR-",
        scanQR: " QR-    {{ name }},  ",
        continueIn: "  {{ name }}",
        connectionDeclined: " "
    },
    desktopConnectionModal: {
        scanQR: " QR-    {{ name }},  ",
        continueInExtension: "   {{ name }}",
        dontHaveExtension: ",    {{ name }}",
        getWallet: " {{ name }}",
        continueOnDesktop: " {{ name }} ",
        openWalletOnTelegram: " Wallet Telegram",
        connectionDeclined: " "
    },
    infoModal: {
        whatIsAWallet: "  ?",
        secureDigitalAssets: "   ",
        walletProtects: "    ,  TON,   ,  .",
        controlIdentity: "   Web3",
        manageIdentity: "        .       .",
        effortlessCryptoTransactions: " ",
        easilySend: " ,    .      .",
        getAWallet: " "
    }
}
  , actionModal = {
    confirmTransaction: {
        header: "  {{ name }}",
        text: "   ."
    },
    transactionSent: "$notifications.transactionSent",
    transactionCanceled: "$notifications.transactionCanceled"
}
  , ru$1 = {
    common,
    button: button$5,
    notifications,
    walletItem,
    walletModal,
    actionModal
}
  , i18nDictionary = {
    en: parseDictionary(en),
    ru: parseDictionary(ru$1)
};
function parseDictionary(xt) {
    const Cn = "$"
      , as = cs => {
        Object.entries(cs).forEach( ([Cs,Ls]) => {
            if (typeof Ls == "object" && Ls)
                return as(Ls);
            if (typeof Ls == "string") {
                if (Ls[0] === Cn) {
                    const Vs = Ls.slice(1).split(".");
                    let Ws = xt;
                    Vs.forEach(Xs => {
                        if (Xs in Ws)
                            Ws = Ws[Xs];
                        else
                            throw new Error(`Cannot parse translations: there is no property ${Xs} in translation`)
                    }
                    ),
                    cs[Cs] = Ws
                }
                Ls.slice(0, 2) === `\\${Cn}` && (cs[Cs] = Ls.slice(1))
            }
        }
        )
    }
    ;
    return as(xt),
    xt
}
const ConnectorContext = createContext()
  , $RAW = Symbol("store-raw")
  , $NODE = Symbol("store-node")
  , $NAME = Symbol("store-name");
function wrap$1(xt, Cn) {
    let as = xt[$PROXY];
    if (!as && (Object.defineProperty(xt, $PROXY, {
        value: as = new Proxy(xt,proxyTraps$1)
    }),
    !Array.isArray(xt))) {
        const cs = Object.keys(xt)
          , Cs = Object.getOwnPropertyDescriptors(xt);
        for (let Ls = 0, Vs = cs.length; Ls < Vs; Ls++) {
            const Ws = cs[Ls];
            Cs[Ws].get && Object.defineProperty(xt, Ws, {
                enumerable: Cs[Ws].enumerable,
                get: Cs[Ws].get.bind(as)
            })
        }
    }
    return as
}
function isWrappable(xt) {
    let Cn;
    return xt != null && typeof xt == "object" && (xt[$PROXY] || !(Cn = Object.getPrototypeOf(xt)) || Cn === Object.prototype || Array.isArray(xt))
}
function unwrap(xt, Cn=new Set) {
    let as, cs, Cs, Ls;
    if (as = xt != null && xt[$RAW])
        return as;
    if (!isWrappable(xt) || Cn.has(xt))
        return xt;
    if (Array.isArray(xt)) {
        Object.isFrozen(xt) ? xt = xt.slice(0) : Cn.add(xt);
        for (let Vs = 0, Ws = xt.length; Vs < Ws; Vs++)
            Cs = xt[Vs],
            (cs = unwrap(Cs, Cn)) !== Cs && (xt[Vs] = cs)
    } else {
        Object.isFrozen(xt) ? xt = Object.assign({}, xt) : Cn.add(xt);
        const Vs = Object.keys(xt)
          , Ws = Object.getOwnPropertyDescriptors(xt);
        for (let Xs = 0, ga = Vs.length; Xs < ga; Xs++)
            Ls = Vs[Xs],
            !Ws[Ls].get && (Cs = xt[Ls],
            (cs = unwrap(Cs, Cn)) !== Cs && (xt[Ls] = cs))
    }
    return xt
}
function getDataNodes(xt) {
    let Cn = xt[$NODE];
    return Cn || Object.defineProperty(xt, $NODE, {
        value: Cn = {}
    }),
    Cn
}
function getDataNode(xt, Cn, as) {
    return xt[Cn] || (xt[Cn] = createDataNode(as))
}
function proxyDescriptor$1(xt, Cn) {
    const as = Reflect.getOwnPropertyDescriptor(xt, Cn);
    return !as || as.get || !as.configurable || Cn === $PROXY || Cn === $NODE || Cn === $NAME || (delete as.value,
    delete as.writable,
    as.get = () => xt[$PROXY][Cn]),
    as
}
function trackSelf(xt) {
    if (getListener()) {
        const Cn = getDataNodes(xt);
        (Cn._ || (Cn._ = createDataNode()))()
    }
}
function ownKeys$3(xt) {
    return trackSelf(xt),
    Reflect.ownKeys(xt)
}
function createDataNode(xt) {
    const [Cn,as] = createSignal(xt, {
        equals: !1,
        internal: !0
    });
    return Cn.$ = as,
    Cn
}
const proxyTraps$1 = {
    get(xt, Cn, as) {
        if (Cn === $RAW)
            return xt;
        if (Cn === $PROXY)
            return as;
        if (Cn === $TRACK)
            return trackSelf(xt),
            as;
        const cs = getDataNodes(xt)
          , Cs = cs.hasOwnProperty(Cn);
        let Ls = Cs ? cs[Cn]() : xt[Cn];
        if (Cn === $NODE || Cn === "__proto__")
            return Ls;
        if (!Cs) {
            const Vs = Object.getOwnPropertyDescriptor(xt, Cn);
            getListener() && (typeof Ls != "function" || xt.hasOwnProperty(Cn)) && !(Vs && Vs.get) && (Ls = getDataNode(cs, Cn, Ls)())
        }
        return isWrappable(Ls) ? wrap$1(Ls) : Ls
    },
    has(xt, Cn) {
        return Cn === $RAW || Cn === $PROXY || Cn === $TRACK || Cn === $NODE || Cn === "__proto__" ? !0 : (this.get(xt, Cn, xt),
        Cn in xt)
    },
    set() {
        return !0
    },
    deleteProperty() {
        return !0
    },
    ownKeys: ownKeys$3,
    getOwnPropertyDescriptor: proxyDescriptor$1
};
function setProperty(xt, Cn, as, cs=!1) {
    if (!cs && xt[Cn] === as)
        return;
    const Cs = xt[Cn]
      , Ls = xt.length;
    as === void 0 ? delete xt[Cn] : xt[Cn] = as;
    let Vs = getDataNodes(xt), Ws;
    (Ws = getDataNode(Vs, Cn, Cs)) && Ws.$( () => as),
    Array.isArray(xt) && xt.length !== Ls && (Ws = getDataNode(Vs, "length", Ls)) && Ws.$(xt.length),
    (Ws = Vs._) && Ws.$()
}
function mergeStoreNode(xt, Cn) {
    const as = Object.keys(Cn);
    for (let cs = 0; cs < as.length; cs += 1) {
        const Cs = as[cs];
        setProperty(xt, Cs, Cn[Cs])
    }
}
function updateArray(xt, Cn) {
    if (typeof Cn == "function" && (Cn = Cn(xt)),
    Cn = unwrap(Cn),
    Array.isArray(Cn)) {
        if (xt === Cn)
            return;
        let as = 0
          , cs = Cn.length;
        for (; as < cs; as++) {
            const Cs = Cn[as];
            xt[as] !== Cs && setProperty(xt, as, Cs)
        }
        setProperty(xt, "length", cs)
    } else
        mergeStoreNode(xt, Cn)
}
function updatePath(xt, Cn, as=[]) {
    let cs, Cs = xt;
    if (Cn.length > 1) {
        cs = Cn.shift();
        const Vs = typeof cs
          , Ws = Array.isArray(xt);
        if (Array.isArray(cs)) {
            for (let Xs = 0; Xs < cs.length; Xs++)
                updatePath(xt, [cs[Xs]].concat(Cn), as);
            return
        } else if (Ws && Vs === "function") {
            for (let Xs = 0; Xs < xt.length; Xs++)
                cs(xt[Xs], Xs) && updatePath(xt, [Xs].concat(Cn), as);
            return
        } else if (Ws && Vs === "object") {
            const {from: Xs=0, to: ga=xt.length - 1, by: ba=1} = cs;
            for (let yl = Xs; yl <= ga; yl += ba)
                updatePath(xt, [yl].concat(Cn), as);
            return
        } else if (Cn.length > 1) {
            updatePath(xt[cs], Cn, [cs].concat(as));
            return
        }
        Cs = xt[cs],
        as = [cs].concat(as)
    }
    let Ls = Cn[0];
    typeof Ls == "function" && (Ls = Ls(Cs, as),
    Ls === Cs) || cs === void 0 && Ls == null || (Ls = unwrap(Ls),
    cs === void 0 || isWrappable(Cs) && isWrappable(Ls) && !Array.isArray(Ls) ? mergeStoreNode(Cs, Ls) : setProperty(xt, cs, Ls))
}
function createStore$1(...[xt,Cn]) {
    const as = unwrap(xt || {})
      , cs = Array.isArray(as)
      , Cs = wrap$1(as);
    function Ls(...Vs) {
        batch( () => {
            cs && Vs.length === 1 ? updateArray(as, Vs[0]) : updatePath(as, Vs)
        }
        )
    }
    return [Cs, Ls]
}
const defaultLightColorsSet = {
    constant: {
        black: "#000000",
        white: "#FFFFFF"
    },
    connectButton: {
        background: "#0098EA",
        foreground: "#FFFFFF"
    },
    accent: "#0098EA",
    telegramButton: "#0098EA",
    icon: {
        primary: "#0F0F0F",
        secondary: "#7A8999",
        tertiary: "#C1CAD2",
        success: "#29CC6A",
        error: "#F5A73B"
    },
    background: {
        primary: "#FFFFFF",
        secondary: "#F1F3F5",
        segment: "#FFFFFF",
        tint: "#F1F3F5",
        qr: "#F1F3F5"
    },
    text: {
        primary: "#0F0F0F",
        secondary: "#6A7785"
    }
}
  , defaultDarkColorsSet = {
    constant: {
        black: "#000000",
        white: "#FFFFFF"
    },
    connectButton: {
        background: "#0098EA",
        foreground: "#FFFFFF"
    },
    accent: "#E5E5EA",
    telegramButton: "#31A6F5",
    icon: {
        primary: "#E5E5EA",
        secondary: "#909099",
        tertiary: "#434347",
        success: "#29CC6A",
        error: "#F5A73B"
    },
    background: {
        primary: "#121214",
        secondary: "#18181A",
        segment: "#262629",
        tint: "#222224",
        qr: "#FFFFFF"
    },
    text: {
        primary: "#E5E5EA",
        secondary: "#7D7D85"
    }
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function isObject$1(xt) {
    return Object.prototype.toString.call(xt) === "[object Object]"
}
function isPlainObject$2(xt) {
    var Cn, as;
    return isObject$1(xt) === !1 ? !1 : (Cn = xt.constructor,
    Cn === void 0 ? !0 : (as = Cn.prototype,
    !(isObject$1(as) === !1 || as.hasOwnProperty("isPrototypeOf") === !1)))
}
function mergeOptions(xt, Cn) {
    return xt ? deepmerge$1(Cn, xt, {
        arrayMerge: (cs, Cs, Ls) => Cs,
        isMergeableObject: isPlainObject$2
    }) : Cn
}
const [themeState,setThemeState] = createStore$1({
    theme: THEME.LIGHT,
    colors: defaultLightColorsSet,
    borderRadius: "m"
})
  , themeColorsMappingDefault = {
    [THEME.LIGHT]: defaultLightColorsSet,
    [THEME.DARK]: defaultDarkColorsSet
}
  , themeCustomColors = {
    [THEME.LIGHT]: void 0,
    [THEME.DARK]: void 0
};
function setTheme(xt, Cn) {
    Cn && (themeCustomColors[THEME.DARK] = mergeOptions(Cn[THEME.DARK], themeCustomColors[THEME.DARK]),
    themeCustomColors[THEME.LIGHT] = mergeOptions(Cn[THEME.LIGHT], themeCustomColors[THEME.LIGHT])),
    setThemeState({
        theme: xt,
        colors: mergeOptions(themeCustomColors[xt], themeColorsMappingDefault[xt])
    })
}
function setBorderRadius(xt) {
    setThemeState({
        borderRadius: xt
    })
}
function setColors(xt) {
    themeCustomColors[THEME.DARK] = mergeOptions(xt[THEME.DARK], themeCustomColors[THEME.DARK]),
    themeCustomColors[THEME.LIGHT] = mergeOptions(xt[THEME.LIGHT], themeCustomColors[THEME.LIGHT]),
    setThemeState(Cn => ({
        colors: mergeOptions(themeCustomColors[Cn.theme], themeColorsMappingDefault[Cn.theme])
    }))
}
const ImagePlaceholder = styled.div`
    background-color: ${xt => xt.theme.colors.background.secondary};
`
  , Image$1 = xt => {
    let Cn;
    const [as,cs] = createSignal(null);
    return createEffect( () => {
        const Cs = new window.Image;
        return Cs.src = xt.src,
        Cs.alt = xt.alt || "",
        Cs.setAttribute("draggable", "false"),
        xt.class && Cs.classList.add(xt.class),
        Cs.complete ? cs(Cs) : (Cs.addEventListener("load", () => cs(Cs)),
        () => Cs.removeEventListener("load", () => cs(Cs)))
    }
    ),
    [createComponent(Show, {
        get when() {
            return as()
        },
        get children() {
            return as()
        }
    }), createComponent(Show, {
        get when() {
            return !as()
        },
        get children() {
            return createComponent(ImagePlaceholder, {
                get class() {
                    return xt.class
                },
                ref(Cs) {
                    const Ls = Cn;
                    typeof Ls == "function" ? Ls(Cs) : Cn = Cs
                }
            })
        }
    })]
}
;
let initParams = {};
try {
    let xt = location.hash.toString();
    initParams = urlParseHashParams(xt)
} catch {}
let tmaPlatform = "unknown";
initParams != null && initParams.tgWebAppPlatform && (tmaPlatform = (_a$3 = initParams.tgWebAppPlatform) != null ? _a$3 : "unknown");
if (tmaPlatform === "unknown") {
    const xt = getWindow$1();
    tmaPlatform = (_d = (_c = (_b = xt == null ? void 0 : xt.Telegram) == null ? void 0 : _b.WebApp) == null ? void 0 : _c.platform) != null ? _d : "unknown"
}
let webAppVersion = "6.0";
initParams != null && initParams.tgWebAppVersion && (webAppVersion = initParams.tgWebAppVersion);
if (!webAppVersion) {
    const xt = getWindow$1();
    webAppVersion = (_g = (_f = (_e$1 = xt == null ? void 0 : xt.Telegram) == null ? void 0 : _e$1.WebApp) == null ? void 0 : _f.version) != null ? _g : "6.0"
}
function isTmaPlatform(...xt) {
    return xt.includes(tmaPlatform)
}
function isInTMA() {
    var xt;
    return tmaPlatform !== "unknown" || !!((xt = getWindow$1()) != null && xt.TelegramWebviewProxy)
}
function isInTelegramBrowser() {
    var xt;
    const Cn = !!((xt = getWindow$1()) != null && xt.TelegramWebview);
    return (isInTMA() || Cn) && tmaPlatform === "unknown"
}
function sendExpand() {
    postEvent("web_app_expand", {})
}
function sendOpenTelegramLink(xt, Cn) {
    const as = new URL(xt);
    if (as.protocol !== "http:" && as.protocol !== "https:") {
        if (Cn)
            return Cn();
        throw new TonConnectUIError(`Url protocol is not supported: ${as}`)
    }
    if (as.hostname !== "t.me") {
        if (Cn)
            return Cn();
        throw new TonConnectUIError(`Url host is not supported: ${as}`)
    }
    const cs = as.pathname + as.search;
    isIframe() || versionAtLeast("6.1") ? postEvent("web_app_open_tg_link", {
        path_full: cs
    }) : openLinkBlank("https://t.me" + cs)
}
function isIframe() {
    try {
        const xt = getWindow$1();
        return xt ? xt.parent != null && xt !== xt.parent : !1
    } catch {
        return !1
    }
}
function postEvent(xt, Cn) {
    try {
        const as = getWindow$1();
        if (!as)
            throw new TonConnectUIError("Can't post event to parent window: window is not defined");
        if (as.TelegramWebviewProxy !== void 0)
            logDebug("postEvent", xt, Cn),
            as.TelegramWebviewProxy.postEvent(xt, JSON.stringify(Cn));
        else if (as.external && "notify"in as.external)
            logDebug("postEvent", xt, Cn),
            as.external.notify(JSON.stringify({
                eventType: xt,
                eventData: Cn
            }));
        else if (isIframe()) {
            const cs = "*"
              , Cs = JSON.stringify({
                eventType: xt,
                eventData: Cn
            });
            logDebug("postEvent", xt, Cn),
            as.parent.postMessage(Cs, cs)
        } else
            throw new TonConnectUIError("Can't post event to TMA")
    } catch (as) {
        logError$1(`Can't post event to parent window: ${as}`)
    }
}
function urlParseHashParams(xt) {
    xt = xt.replace(/^#/, "");
    let Cn = {};
    if (!xt.length)
        return Cn;
    if (xt.indexOf("=") < 0 && xt.indexOf("?") < 0)
        return Cn._path = urlSafeDecode(xt),
        Cn;
    let as = xt.indexOf("?");
    if (as >= 0) {
        let Cs = xt.substr(0, as);
        Cn._path = urlSafeDecode(Cs),
        xt = xt.substr(as + 1)
    }
    let cs = urlParseQueryString(xt);
    for (let Cs in cs)
        Cn[Cs] = cs[Cs];
    return Cn
}
function urlSafeDecode(xt) {
    try {
        return xt = xt.replace(/\+/g, "%20"),
        decodeURIComponent(xt)
    } catch {
        return xt
    }
}
function urlParseQueryString(xt) {
    let Cn = {};
    if (!xt.length)
        return Cn;
    let as = xt.split("&"), cs, Cs, Ls, Vs;
    for (cs = 0; cs < as.length; cs++)
        Cs = as[cs].split("="),
        Ls = urlSafeDecode(Cs[0]),
        Vs = Cs[1] == null ? null : urlSafeDecode(Cs[1]),
        Cn[Ls] = Vs;
    return Cn
}
function versionCompare(xt, Cn) {
    typeof xt != "string" && (xt = "");
    let as = xt.replace(/^\s+|\s+$/g, "").split("."), cs = Cn.replace(/^\s+|\s+$/g, "").split("."), Cs, Ls, Vs, Ws;
    for (Cs = Math.max(as.length, cs.length),
    Ls = 0; Ls < Cs; Ls++)
        if (Vs = parseInt(as[Ls]) || 0,
        Ws = parseInt(cs[Ls]) || 0,
        Vs !== Ws)
            return Vs > Ws ? 1 : -1;
    return 0
}
function versionAtLeast(xt) {
    return versionCompare(webAppVersion, xt) >= 0
}
const maxWidth = {
    mobile: 440,
    tablet: 1020
};
function isDevice(xt) {
    const Cn = getWindow$1();
    if (!Cn)
        return xt === "desktop";
    if (isTmaPlatform("weba"))
        return !0;
    const as = Cn.innerWidth;
    switch (xt) {
    case "desktop":
        return as > maxWidth.tablet;
    case "tablet":
        return as > maxWidth.mobile;
    default:
    case "mobile":
        return as <= maxWidth.mobile || isOS("ios", "android", "ipad")
    }
}
function media(xt) {
    switch (xt) {
    case "mobile":
        return `@media (max-width: ${maxWidth.mobile}px)`;
    case "tablet":
        return `@media (max-width: ${maxWidth.tablet}px) (min-width: ${maxWidth.mobile}px)`;
    default:
    case "desktop":
        return `@media (min-width: ${maxWidth.tablet}px)`
    }
}
const mediaTouch = "@media (hover: none)"
  , mediaNotTouch = "@media not all and (hover: none)"
  , borders$5 = {
    m: "100vh",
    s: "8px",
    none: "0"
}
  , scaleValues = {
    s: .02,
    m: .04
}
  , ButtonStyled$1 = styled.button`
    display: ${xt => xt.leftIcon || xt.rightIcon ? "flex" : "inline-block"};
    gap: ${xt => xt.leftIcon || xt.rightIcon ? "6px" : "unset"};
    align-items: ${xt => xt.leftIcon || xt.rightIcon ? "center" : "unset"};
    justify-content: ${xt => xt.leftIcon || xt.rightIcon ? "space-between" : "unset"};
    background-color: ${xt => xt.appearance === "flat" ? "transparent" : xt.appearance === "secondary" ? xt.theme.colors.background.tint : rgba$1(xt.theme.colors.accent, .12)};
    color: ${xt => xt.appearance === "secondary" ? xt.theme.colors.text.primary : xt.theme.colors.accent};

    padding: ${xt => xt.appearance === "flat" ? "0" : "9px 16px"};
    padding-left: ${xt => xt.leftIcon && xt.appearance !== "flat" ? "12px" : "16px"};
    padding-right: ${xt => xt.rightIcon && xt.appearance !== "flat" ? "12px" : "16px"};
    border: none;
    border-radius: ${xt => borders$5[xt.theme.borderRadius]};
    cursor: ${xt => xt.disabled ? "not-allowed" : "pointer"};

    font-size: 14px;
    font-weight: 510;
    line-height: 18px;

    transition: transform 0.125s ease-in-out;

    ${mediaNotTouch} {
        &:hover {
            transform: ${xt => xt.disabled ? "unset" : `scale(${1 + scaleValues[xt.scale]})`};
        }
    }

    &:active {
        transform: ${xt => xt.disabled ? "unset" : `scale(${1 - scaleValues[xt.scale]})`};
    }

    ${mediaTouch} {
        &:active {
            transform: ${xt => xt.disabled ? "unset" : `scale(${1 - scaleValues[xt.scale] * 2})`};
        }
    }
`;
function useDataAttributes(xt) {
    const Cn = untrack( () => Object.keys(xt).filter(cs => cs.startsWith("data-")))
      , [as] = splitProps(xt, Cn);
    return as
}
const Button$1 = xt => {
    const Cn = useDataAttributes(xt);
    return createComponent(ButtonStyled$1, mergeProps$1({
        get appearance() {
            return xt.appearance || "primary"
        },
        get class() {
            return xt.class
        },
        onClick: as => {
            var cs;
            return (cs = xt.onClick) == null ? void 0 : cs.call(xt, as)
        }
        ,
        onMouseEnter: as => {
            var cs;
            return (cs = xt.onMouseEnter) == null ? void 0 : cs.call(xt, as)
        }
        ,
        onMouseLeave: as => {
            var cs;
            return (cs = xt.onMouseLeave) == null ? void 0 : cs.call(xt, as)
        }
        ,
        ref(as) {
            const cs = xt.ref;
            typeof cs == "function" ? cs(as) : xt.ref = as
        },
        get disabled() {
            return xt.disabled
        },
        get scale() {
            return xt.scale || "m"
        },
        get leftIcon() {
            return !!xt.leftIcon
        },
        get rightIcon() {
            return !!xt.rightIcon
        },
        "data-tc-button": "true"
    }, Cn, {
        get children() {
            return [createMemo( () => xt.leftIcon), createMemo( () => xt.children), createMemo( () => xt.rightIcon)]
        }
    }))
}
;
function nextFrame(xt) {
    requestAnimationFrame( () => {
        requestAnimationFrame(xt)
    }
    )
}
const Transition = xt => {
    let Cn, as = !0;
    const [cs,Cs] = createSignal()
      , [Ls,Vs] = createSignal()
      , Ws = children( () => xt.children)
      , {onBeforeEnter: Xs, onEnter: ga, onAfterEnter: ba, onBeforeExit: yl, onExit: xl, onAfterExit: wl} = xt
      , _l = createMemo( () => {
        const $l = xt.name || "s";
        return {
            enterActiveClass: xt.enterActiveClass || $l + "-enter-active",
            enterClass: xt.enterClass || $l + "-enter",
            enterToClass: xt.enterToClass || $l + "-enter-to",
            exitActiveClass: xt.exitActiveClass || $l + "-exit-active",
            exitClass: xt.exitClass || $l + "-exit",
            exitToClass: xt.exitToClass || $l + "-exit-to"
        }
    }
    );
    function El($l, Sl) {
        if (!as || xt.appear) {
            let Tl = function(Nl) {
                $l && (!Nl || Nl.target === $l) && ($l.removeEventListener("transitionend", Tl),
                $l.removeEventListener("animationend", Tl),
                $l.classList.remove(...Il),
                $l.classList.remove(...Ml),
                batch( () => {
                    cs() !== $l && Cs($l),
                    Ls() === $l && Vs(void 0)
                }
                ),
                ba && ba($l),
                xt.mode === "inout" && Cl($l, Sl))
            };
            const Rl = _l().enterClass.split(" ")
              , Il = _l().enterActiveClass.split(" ")
              , Ml = _l().enterToClass.split(" ");
            Xs && Xs($l),
            $l.classList.add(...Rl),
            $l.classList.add(...Il),
            nextFrame( () => {
                $l.classList.remove(...Rl),
                $l.classList.add(...Ml),
                ga && ga($l, () => Tl()),
                (!ga || ga.length < 2) && ($l.addEventListener("transitionend", Tl),
                $l.addEventListener("animationend", Tl))
            }
            )
        }
        Sl && !xt.mode ? Vs($l) : Cs($l)
    }
    function Cl($l, Sl) {
        const Tl = _l().exitClass.split(" ")
          , Rl = _l().exitActiveClass.split(" ")
          , Il = _l().exitToClass.split(" ");
        if (!Sl.parentNode)
            return Ml();
        yl && yl(Sl),
        Sl.classList.add(...Tl),
        Sl.classList.add(...Rl),
        nextFrame( () => {
            Sl.classList.remove(...Tl),
            Sl.classList.add(...Il)
        }
        ),
        xl && xl(Sl, () => Ml()),
        (!xl || xl.length < 2) && (Sl.addEventListener("transitionend", Ml),
        Sl.addEventListener("animationend", Ml));
        function Ml(Nl) {
            (!Nl || Nl.target === Sl) && (Sl.removeEventListener("transitionend", Ml),
            Sl.removeEventListener("animationend", Ml),
            Sl.classList.remove(...Rl),
            Sl.classList.remove(...Il),
            cs() === Sl && Cs(void 0),
            wl && wl(Sl),
            xt.mode === "outin" && El($l, Sl))
        }
    }
    return createComputed($l => {
        for (Cn = Ws(); typeof Cn == "function"; )
            Cn = Cn();
        return untrack( () => (Cn && Cn !== $l && (xt.mode !== "outin" ? El(Cn, $l) : as && Cs(Cn)),
        $l && $l !== Cn && xt.mode !== "inout" && Cl(Cn, $l),
        as = !1,
        Cn))
    }
    ),
    [cs, Ls]
}
;
function getRect(xt) {
    const {top: Cn, bottom: as, left: cs, right: Cs, width: Ls, height: Vs} = xt.getBoundingClientRect()
      , Ws = xt.parentNode.getBoundingClientRect();
    return {
        top: Cn - Ws.top,
        bottom: as,
        left: cs - Ws.left,
        right: Cs,
        width: Ls,
        height: Vs
    }
}
const TransitionGroup = xt => {
    const Cn = children( () => xt.children)
      , as = createMemo( () => {
        const wl = xt.name || "s";
        return {
            enterActiveClass: xt.enterActiveClass || wl + "-enter-active",
            enterClass: xt.enterClass || wl + "-enter",
            enterToClass: xt.enterToClass || wl + "-enter-to",
            exitActiveClass: xt.exitActiveClass || wl + "-exit-active",
            exitClass: xt.exitClass || wl + "-exit",
            exitToClass: xt.exitToClass || wl + "-exit-to",
            moveClass: xt.moveClass || wl + "-move"
        }
    }
    )
      , {onBeforeEnter: cs, onEnter: Cs, onAfterEnter: Ls, onBeforeExit: Vs, onExit: Ws, onAfterExit: Xs} = xt
      , [ga,ba] = createSignal();
    let yl = []
      , xl = !0;
    return createComputed( () => {
        const wl = Cn()
          , _l = [...wl]
          , El = new Set(wl)
          , Cl = new Set(yl)
          , $l = as().enterClass.split(" ")
          , Sl = as().enterActiveClass.split(" ")
          , Tl = as().enterToClass.split(" ")
          , Rl = as().exitClass.split(" ")
          , Il = as().exitActiveClass.split(" ")
          , Ml = as().exitToClass.split(" ");
        for (let Nl = 0; Nl < wl.length; Nl++) {
            const Ll = wl[Nl];
            if (!xl && !Cl.has(Ll)) {
                let Fl = function(Ul) {
                    Ll && (!Ul || Ul.target === Ll) && (Ll.removeEventListener("transitionend", Fl),
                    Ll.removeEventListener("animationend", Fl),
                    Ll.classList.remove(...Sl),
                    Ll.classList.remove(...Tl),
                    Ls && Ls(Ll))
                };
                cs && cs(Ll),
                Ll.classList.add(...$l),
                Ll.classList.add(...Sl),
                nextFrame( () => {
                    Ll.classList.remove(...$l),
                    Ll.classList.add(...Tl),
                    Cs && Cs(Ll, () => Fl()),
                    (!Cs || Cs.length < 2) && (Ll.addEventListener("transitionend", Fl),
                    Ll.addEventListener("animationend", Fl))
                }
                )
            }
        }
        for (let Nl = 0; Nl < yl.length; Nl++) {
            const Ll = yl[Nl];
            if (!El.has(Ll) && Ll.parentNode) {
                let Fl = function(Ul) {
                    (!Ul || Ul.target === Ll) && (Ll.removeEventListener("transitionend", Fl),
                    Ll.removeEventListener("animationend", Fl),
                    Ll.classList.remove(...Il),
                    Ll.classList.remove(...Ml),
                    Xs && Xs(Ll),
                    yl = yl.filter(Dl => Dl !== Ll),
                    ba(yl))
                };
                _l.splice(Nl, 0, Ll),
                Vs && Vs(Ll),
                Ll.classList.add(...Rl),
                Ll.classList.add(...Il),
                nextFrame( () => {
                    Ll.classList.remove(...Rl),
                    Ll.classList.add(...Ml)
                }
                ),
                Ws && Ws(Ll, () => Fl()),
                (!Ws || Ws.length < 2) && (Ll.addEventListener("transitionend", Fl),
                Ll.addEventListener("animationend", Fl))
            }
        }
        yl = _l,
        ba(_l)
    }
    ),
    createEffect(wl => {
        const _l = ga();
        return _l.forEach(El => {
            let Cl;
            (Cl = wl.get(El)) ? Cl.new && (Cl.new = !1,
            Cl.newPos = getRect(El)) : wl.set(El, Cl = {
                pos: getRect(El),
                new: !xl
            }),
            Cl.new && El.addEventListener("transitionend", () => {
                Cl.new = !1,
                El.parentNode && (Cl.newPos = getRect(El))
            }
            , {
                once: !0
            }),
            Cl.newPos && (Cl.pos = Cl.newPos),
            Cl.newPos = getRect(El)
        }
        ),
        xl ? (xl = !1,
        wl) : (_l.forEach(El => {
            const Cl = wl.get(El)
              , $l = Cl.pos
              , Sl = Cl.newPos
              , Tl = $l.left - Sl.left
              , Rl = $l.top - Sl.top;
            if (Tl || Rl) {
                Cl.moved = !0;
                const Il = El.style;
                Il.transform = `translate(${Tl}px,${Rl}px)`,
                Il.transitionDuration = "0s"
            }
        }
        ),
        document.body.offsetHeight,
        _l.forEach(El => {
            const Cl = wl.get(El);
            if (Cl.moved) {
                let $l = function(Rl) {
                    Rl && Rl.target !== El || !El.parentNode || (!Rl || /transform$/.test(Rl.propertyName)) && (El.removeEventListener("transitionend", $l),
                    El.classList.remove(...Tl))
                };
                Cl.moved = !1;
                const Sl = El.style
                  , Tl = as().moveClass.split(" ");
                El.classList.add(...Tl),
                Sl.transform = Sl.transitionDuration = "",
                El.addEventListener("transitionend", $l)
            }
        }
        ),
        wl)
    }
    , new Map),
    ga
}
;
function clickOutside$1(xt, Cn) {
    const as = cs => {
        var Cs;
        return !xt.contains(cs.target) && ((Cs = Cn()) == null ? void 0 : Cs())
    }
    ;
    document.body.addEventListener("click", as),
    onCleanup( () => document.body.removeEventListener("click", as))
}
function escPressed(xt, Cn) {
    const as = cs => {
        var Cs, Ls;
        cs.key === "Escape" && ((Cs = document.activeElement) == null || Cs.blur(),
        (Ls = Cn()) == null || Ls())
    }
    ;
    document.body.addEventListener("keydown", as),
    onCleanup( () => document.body.removeEventListener("keydown", as))
}
function androidBackHandler$1(xt, Cn) {
    const {isEnabled: as, onClose: cs} = Cn();
    if (!as || !(getUserAgent$1().os === "android"))
        return;
    window.history.pushState(ROUTE_STATE, "");
    const Ls = Vs => {
        Vs.preventDefault(),
        cs()
    }
    ;
    window.addEventListener("popstate", Ls, {
        once: !0
    }),
    onCleanup( () => {
        window.removeEventListener("popstate", Ls),
        createMacrotask( () => {
            var Vs;
            ((Vs = window.history.state) == null ? void 0 : Vs[ROUTE_STATE_KEY]) === !0 && window.history.back()
        }
        )
    }
    )
}
const ROUTE_STATE_KEY = "androidBackHandler"
  , ROUTE_STATE = {
    [ROUTE_STATE_KEY]: !0
}
  , _tmpl$$w = template$1('<svg><path fill-rule="evenodd" clip-rule="evenodd" d="M10.2122 14.3407C10.5384 14.0854 10.5959 13.614 10.3406 13.2878L6.20237 8.00003L10.3406 2.71227C10.5959 2.38607 10.5384 1.91469 10.2122 1.6594C9.88604 1.40412 9.41465 1.46161 9.15937 1.7878L4.65937 7.5378C4.44688 7.80932 4.44688 8.19074 4.65937 8.46226L9.15937 14.2123C9.41465 14.5385 9.88604 14.5959 10.2122 14.3407Z"></path></svg>', 4, !0)
  , rotationDegrees = {
    left: 0,
    top: 90,
    right: 180,
    bottom: 270
}
  , ArrowIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.icon.secondary
      , cs = () => xt.direction || "left"
      , Cs = styled("svg")`
        transform: rotate(${Ls => rotationDegrees[Ls.svgDirection]}deg);
        transition: transform 0.1s ease-in-out;
    `;
    return createComponent(Cs, {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 16 16",
        fill: "none",
        get svgDirection() {
            return cs()
        },
        get children() {
            const Ls = _tmpl$$w.cloneNode(!0);
            return createRenderEffect( () => setAttribute(Ls, "fill", as())),
            Ls
        }
    })
}
  , _tmpl$$v = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M2.71966 2.71968C3.01255 2.42678 3.48743 2.42677 3.78032 2.71966L8.00002 6.93925L12.2197 2.71967C12.5126 2.42677 12.9874 2.42678 13.2803 2.71967C13.5732 3.01257 13.5732 3.48744 13.2803 3.78033L9.06068 7.99991L13.2803 12.2197C13.5732 12.5126 13.5732 12.9874 13.2803 13.2803C12.9874 13.5732 12.5126 13.5732 12.2197 13.2803L8.00002 9.06057L3.78033 13.2803C3.48744 13.5732 3.01257 13.5732 2.71967 13.2803C2.42678 12.9874 2.42677 12.5126 2.71967 12.2197L6.93936 7.99991L2.71968 3.78034C2.42678 3.48745 2.42677 3.01257 2.71966 2.71968Z"></path></svg>')
  , CloseIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.icon.secondary;
    return ( () => {
        const cs = _tmpl$$v.cloneNode(!0)
          , Cs = cs.firstChild;
        return createRenderEffect( () => setAttribute(Cs, "fill", as())),
        cs
    }
    )()
}
  , IconButtonStyled = styled.button`
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: ${xt => xt.theme.colors.background.tint};
    border: none;
    cursor: pointer;

    transition: transform 0.125s ease-in-out;

    ${mediaNotTouch} {
        &:hover {
            transform: scale(1.04);
        }
    }

    &:active {
        transform: scale(0.96);
    }

    ${mediaTouch} {
        &:active {
            transform: scale(0.92);
        }
    }
`
  , IconButton = xt => {
    const Cn = useDataAttributes(xt)
      , as = () => xt.icon || "close";
    return createComponent(IconButtonStyled, mergeProps$1({
        get class() {
            return xt.class
        },
        onClick: () => xt.onClick(),
        "data-tc-icon-button": "true"
    }, Cn, {
        get children() {
            return [createComponent(Show, {
                get when() {
                    return !!xt.children
                },
                get children() {
                    return xt.children
                }
            }), createComponent(Show, {
                get when() {
                    return !xt.children
                },
                get children() {
                    return createComponent(Switch, {
                        get children() {
                            return [createComponent(Match, {
                                get when() {
                                    return as() === "close"
                                },
                                get children() {
                                    return createComponent(CloseIcon, {
                                        get fill() {
                                            return xt.fill
                                        }
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return as() === "arrow"
                                },
                                get children() {
                                    return createComponent(ArrowIcon, {
                                        get fill() {
                                            return xt.fill
                                        }
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return as() === "question"
                                },
                                get children() {
                                    return createComponent(QuestionIcon, {
                                        get fill() {
                                            return xt.fill
                                        }
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return typeof as() != "string"
                                },
                                get children() {
                                    return as()
                                }
                            })]
                        }
                    })
                }
            })]
        }
    }))
}
  , borders$4 = {
    m: "24px",
    s: "16px",
    none: "0"
}
  , ModalBackgroundStyled = styled.div`
    display: flex;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.4);
    padding: 20px 0;
    overflow-y: auto;

    ${media("mobile")} {
        padding-bottom: 0;
    }
`
  , ModalWrapperClass = u$9`
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08), 0 16px 64px rgba(0, 0, 0, 0.16);
    width: fit-content;
    margin: auto;

    ${media("mobile")} {
        width: 100%;
        height: fit-content;
        margin: auto 0 0 0;
    }
`
  , ModalBodyStyled = styled.div`
    position: relative;
    min-height: 100px;
    width: 416px;
    padding: 44px 56px 24px;

    box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.04);

    background-color: ${xt => xt.theme.colors.background.primary};
    border-radius: ${xt => borders$4[xt.theme.borderRadius]};

    ${media("mobile")} {
        width: 100%;
    }
`
  , CloseButtonStyled = styled(IconButton)`
    position: absolute;
    right: 16px;
    top: 16px;
`
  , ModalFooterStyled = styled.div`
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 16px 16px 18px;
    border-radius: 0 0 ${xt => borders$4[xt.theme.borderRadius]}
        ${xt => borders$4[xt.theme.borderRadius]};
`
  , QuestionButtonStyled = styled(IconButton)`
    background-color: ${xt => rgba$1(xt.theme.colors.icon.secondary, .12)};
`;
class AnimationTimelineNoop {
    constructor() {
        __publicField(this, "currentTime", 0)
    }
}
const _AnimationNoop = class {
    constructor() {
        __publicField(this, "currentTime", 0),
        __publicField(this, "playbackRate", 1),
        __publicField(this, "startTime", null),
        __publicField(this, "timeline", new AnimationTimelineNoop),
        __publicField(this, "finished", Promise.resolve(this)),
        __publicField(this, "effect", null),
        __publicField(this, "id", ""),
        __publicField(this, "pending", !1),
        __publicField(this, "playState", "finished"),
        __publicField(this, "replaceState", "active"),
        __publicField(this, "ready", Promise.resolve(this)),
        __publicField(this, "oncancel", null),
        __publicField(this, "onfinish", null),
        __publicField(this, "onremove", null)
    }
    static create() {
        return _AnimationNoop._instance || (logWarning("Animation is not supported in this environment: please consider using the `web-animations-js` polyfill to provide a fallback implementation of the Web Animations API."),
        _AnimationNoop._instance = new _AnimationNoop),
        _AnimationNoop._instance
    }
    cancel() {}
    finish() {}
    pause() {}
    play() {}
    reverse() {}
    addEventListener(xt, Cn, as) {}
    dispatchEvent(xt) {
        return !1
    }
    removeEventListener(xt, Cn, as) {}
    updatePlaybackRate(xt) {}
    commitStyles() {}
    persist() {}
}
;
let AnimationNoop = _AnimationNoop;
__publicField(AnimationNoop, "_instance", null);
function animate(xt, Cn, as) {
    return "animate"in xt ? xt.animate(Cn, as) : AnimationNoop.create()
}
const _tmpl$$u = template$1("<div></div>")
  , clickOutside = clickOutside$1
  , keyPressed = escPressed
  , androidBackHandler = androidBackHandler$1
  , Modal = xt => {
    const Cn = useTheme()
      , as = useDataAttributes(xt);
    return createEffect( () => {
        xt.opened ? disableScroll() : enableScroll()
    }
    ),
    createComponent(Transition, {
        onBeforeEnter: cs => {
            const Cs = isDevice("mobile") ? 200 : 100;
            animate(cs, [{
                opacity: 0
            }, {
                opacity: 1
            }], {
                duration: Cs
            }),
            isDevice("mobile") && animate(cs.firstElementChild, [{
                transform: "translateY(390px)"
            }, {
                transform: "translateY(0)"
            }], {
                duration: Cs
            })
        }
        ,
        onExit: (cs, Cs) => {
            const Ls = isDevice("mobile") ? 200 : 100
              , Vs = animate(cs, [{
                opacity: 1
            }, {
                opacity: 0
            }], {
                duration: Ls
            });
            if (isDevice("mobile")) {
                const Ws = animate(cs.firstElementChild, [{
                    transform: "translateY(0)"
                }, {
                    transform: "translateY(390px)"
                }], {
                    duration: Ls
                });
                Promise.all([Vs.finished, Ws.finished]).then(Cs)
            } else
                Vs.finished.then(Cs)
        }
        ,
        get children() {
            return createComponent(Show, {
                get when() {
                    return xt.opened
                },
                get children() {
                    return createComponent(ModalBackgroundStyled, mergeProps$1({
                        "data-tc-modal": "true"
                    }, as, {
                        get children() {
                            const cs = _tmpl$$u.cloneNode(!0);
                            return use(androidBackHandler, cs, () => ({
                                isEnabled: xt.enableAndroidBackHandler,
                                onClose: () => xt.onClose()
                            })),
                            use(keyPressed, cs, () => () => xt.onClose()),
                            use(clickOutside, cs, () => () => xt.onClose()),
                            insert(cs, createComponent(ModalBodyStyled, {
                                get class() {
                                    return xt.class
                                },
                                get children() {
                                    return [createComponent(CloseButtonStyled, {
                                        icon: "close",
                                        onClick: () => xt.onClose()
                                    }), createMemo( () => xt.children)]
                                }
                            }), null),
                            insert(cs, createComponent(Show, {
                                get when() {
                                    return xt.onClickQuestion
                                },
                                get children() {
                                    return createComponent(ModalFooterStyled, {
                                        get children() {
                                            return [createComponent(TonConnectBrand, {}), createComponent(QuestionButtonStyled, {
                                                get onClick() {
                                                    return xt.onClickQuestion
                                                },
                                                icon: "question"
                                            })]
                                        }
                                    })
                                }
                            }), null),
                            createRenderEffect( () => className(cs, classNames$1(ModalWrapperClass, u$9`
                                border-radius: ${borders$4[Cn.borderRadius]};
                                background-color: ${Cn.colors.background.tint};

                                ${media("mobile")} {
                                    border-radius: ${borders$4[Cn.borderRadius]}
                                        ${borders$4[Cn.borderRadius]} 0 0;
                                }
                            `))),
                            cs
                        }
                    }))
                }
            })
        }
    })
}
  , wrapperBorderRadius = {
    m: "22px",
    s: "12px",
    none: "0"
}
  , sliderBorderRadius = {
    m: "18px",
    s: "8px",
    none: "0"
}
  , TabBarStyled = styled.div`
    display: grid;
    grid-template: 1fr / 1fr 1fr;
    width: fit-content;
    justify-items: center;
    gap: 4px;

    position: relative;
    padding: 4px;
    border-radius: ${xt => wrapperBorderRadius[xt.theme.borderRadius]};

    background-color: ${xt => xt.theme.colors.background.secondary};
`
  , SliderStyled = styled.div`
    position: absolute;
    top: 4px;
    left: 4px;

    height: calc(100% - 8px);
    width: calc(50% - 4px);

    border-radius: ${xt => sliderBorderRadius[xt.theme.borderRadius]};
    background-color: ${xt => xt.theme.colors.background.segment};

    transform: ${xt => xt.right ? "translateX(100%)" : "translateX(0)"};

    transition: transform 0.13s ease-in-out;
`
  , InputStyled = styled.input`
    display: none;
`
  , LabelStyled = styled.label`
    padding: 9px 12px;
    z-index: 1;

    cursor: ${xt => xt.isActive ? "default" : "pointer"};

    transition: transform 0.13s ease-in-out;

    &:hover {
        transform: ${xt => xt.isActive ? "none" : "scale(1.025)"};
    }

    > * {
        ${xt => xt.isActive ? "" : `color: ${xt.theme.colors.text.secondary};`}
    }
`
  , TabBar = xt => {
    const Cn = "tabBar" + Math.floor(Math.random() * 1e4);
    return createComponent(TabBarStyled, {
        get class() {
            return xt.class
        },
        "data-tc-tab-bar": "true",
        get children() {
            return [createComponent(SliderStyled, {
                get right() {
                    return xt.selectedTabIndex === 1
                }
            }), createComponent(LabelStyled, {
                get isActive() {
                    return xt.selectedTabIndex === 0
                },
                get children() {
                    return [createComponent(InputStyled, {
                        type: "radio",
                        name: Cn,
                        get checked() {
                            return xt.selectedTabIndex === 0
                        },
                        onInput: () => {
                            var as;
                            return (as = xt.onSelectedTabIndexChange) == null ? void 0 : as.call(xt, 0)
                        }
                    }), createMemo( () => xt.tab1)]
                }
            }), createComponent(LabelStyled, {
                get isActive() {
                    return xt.selectedTabIndex === 1
                },
                get children() {
                    return [createComponent(InputStyled, {
                        type: "radio",
                        get checked() {
                            return xt.selectedTabIndex === 1
                        },
                        name: Cn,
                        onInput: () => {
                            var as;
                            return (as = xt.onSelectedTabIndexChange) == null ? void 0 : as.call(xt, 1)
                        }
                    }), createMemo( () => xt.tab2)]
                }
            })]
        }
    })
}
  , backgroundBorders = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , imageBorders = {
    m: "12px",
    s: "8px",
    none: "0"
}
  , qrNormalSize = 256
  , imgSizeDefault = 60
  , picSizeDefault = 48
  , qrPaddingTop = 24
  , CopyIconButton = styled.div`
    width: 52px;
    height: 52px;
    background: transparent;
    position: absolute;
    right: 0;
    bottom: 0;

    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.125s ease-in-out;
`
  , QrCodeBackground = styled.button`
    display: flex;
    align-items: center;
    position: relative;
    background-color: ${xt => xt.theme.colors.background.qr};
    border-radius: ${xt => backgroundBorders[xt.theme.borderRadius]};
    padding: ${toPx(qrPaddingTop)} 0;
    height: ${toPx(qrNormalSize + qrPaddingTop * 2)};
    width: 100%;

    overflow: hidden;
    cursor: pointer;
    border: none;

    ${mediaNotTouch} {
        &:hover {
            ${CopyIconButton.class} {
                transform: scale(1.04);
            }
        }
    }

    &:active {
        ${CopyIconButton.class} {
            transform: scale(0.96);
        }
    }

    ${mediaTouch} {
        &:active {
            ${CopyIconButton.class} {
                transform: scale(0.92);
            }
        }
    }
`
  , QrCodeWrapper$2 = styled.div`
    position: relative;

    width: fit-content;
    margin: 0 auto;

    > div:first-child {
        display: flex;
        align-items: center;
        justify-content: center;
    }

    rect {
        fill: transparent;
    }

    path {
        fill: ${xt => xt.theme.colors.constant.black};
    }
`
  , ImageBackground = styled.div`
    position: absolute;
    width: ${toPx(imgSizeDefault)};
    height: ${toPx(imgSizeDefault)};
    background: ${xt => xt.theme.colors.background.qr};

    display: flex;
    align-items: center;
    justify-content: center;
`
  , ImageStyled$3 = styled(Image$1)`
    width: ${xt => toPx(xt.size)};
    height: ${xt => toPx(xt.size)};
    border-radius: ${xt => imageBorders[xt.theme.borderRadius]};
    background-color: ${xt => xt.theme.colors.background.qr};
`
  , CopiedBoxStyled = styled.div`
    position: absolute;
    bottom: 14px;
    left: 50%;
    transform: translate(-50%, 0);

    display: flex;
    gap: 6px;
    align-items: center;
    border-radius: 18px;
    min-width: 126px;
    padding: 9px 16px 9px 10px;

    filter: drop-shadow(0px 2px 8px rgba(0, 0, 0, 0.08));
    background-color: ${xt => xt.theme.colors.background.segment};
`;
var qrcode$1 = {
    exports: {}
};
(function(xt, Cn) {
    var as = function() {
        var cs = function(Il, Ml) {
            var Nl = 236
              , Ll = 17
              , Fl = Il
              , Ul = Ls[Ml]
              , Dl = null
              , Zl = 0
              , Gl = null
              , Wl = []
              , Ql = {}
              , cu = function(fu, yu) {
                Zl = Fl * 4 + 17,
                Dl = function(vu) {
                    for (var _u = new Array(vu), xu = 0; xu < vu; xu += 1) {
                        _u[xu] = new Array(vu);
                        for (var Ru = 0; Ru < vu; Ru += 1)
                            _u[xu][Ru] = null
                    }
                    return _u
                }(Zl),
                pu(0, 0),
                pu(Zl - 7, 0),
                pu(0, Zl - 7),
                lu(),
                Yl(),
                Cu(fu, yu),
                Fl >= 7 && mu(fu),
                Gl == null && (Gl = Au(Fl, Ul, Wl)),
                ju(Gl, yu)
            }
              , pu = function(fu, yu) {
                for (var vu = -1; vu <= 7; vu += 1)
                    if (!(fu + vu <= -1 || Zl <= fu + vu))
                        for (var _u = -1; _u <= 7; _u += 1)
                            yu + _u <= -1 || Zl <= yu + _u || (0 <= vu && vu <= 6 && (_u == 0 || _u == 6) || 0 <= _u && _u <= 6 && (vu == 0 || vu == 6) || 2 <= vu && vu <= 4 && 2 <= _u && _u <= 4 ? Dl[fu + vu][yu + _u] = !0 : Dl[fu + vu][yu + _u] = !1)
            }
              , zl = function() {
                for (var fu = 0, yu = 0, vu = 0; vu < 8; vu += 1) {
                    cu(!0, vu);
                    var _u = Ws.getLostPoint(Ql);
                    (vu == 0 || fu > _u) && (fu = _u,
                    yu = vu)
                }
                return yu
            }
              , Yl = function() {
                for (var fu = 8; fu < Zl - 8; fu += 1)
                    Dl[fu][6] == null && (Dl[fu][6] = fu % 2 == 0);
                for (var yu = 8; yu < Zl - 8; yu += 1)
                    Dl[6][yu] == null && (Dl[6][yu] = yu % 2 == 0)
            }
              , lu = function() {
                for (var fu = Ws.getPatternPosition(Fl), yu = 0; yu < fu.length; yu += 1)
                    for (var vu = 0; vu < fu.length; vu += 1) {
                        var _u = fu[yu]
                          , xu = fu[vu];
                        if (Dl[_u][xu] == null)
                            for (var Ru = -2; Ru <= 2; Ru += 1)
                                for (var Iu = -2; Iu <= 2; Iu += 1)
                                    Ru == -2 || Ru == 2 || Iu == -2 || Iu == 2 || Ru == 0 && Iu == 0 ? Dl[_u + Ru][xu + Iu] = !0 : Dl[_u + Ru][xu + Iu] = !1
                    }
            }
              , mu = function(fu) {
                for (var yu = Ws.getBCHTypeNumber(Fl), vu = 0; vu < 18; vu += 1) {
                    var _u = !fu && (yu >> vu & 1) == 1;
                    Dl[Math.floor(vu / 3)][vu % 3 + Zl - 8 - 3] = _u
                }
                for (var vu = 0; vu < 18; vu += 1) {
                    var _u = !fu && (yu >> vu & 1) == 1;
                    Dl[vu % 3 + Zl - 8 - 3][Math.floor(vu / 3)] = _u
                }
            }
              , Cu = function(fu, yu) {
                for (var vu = Ul << 3 | yu, _u = Ws.getBCHTypeInfo(vu), xu = 0; xu < 15; xu += 1) {
                    var Ru = !fu && (_u >> xu & 1) == 1;
                    xu < 6 ? Dl[xu][8] = Ru : xu < 8 ? Dl[xu + 1][8] = Ru : Dl[Zl - 15 + xu][8] = Ru
                }
                for (var xu = 0; xu < 15; xu += 1) {
                    var Ru = !fu && (_u >> xu & 1) == 1;
                    xu < 8 ? Dl[8][Zl - xu - 1] = Ru : xu < 9 ? Dl[8][15 - xu - 1 + 1] = Ru : Dl[8][15 - xu - 1] = Ru
                }
                Dl[Zl - 8][8] = !fu
            }
              , ju = function(fu, yu) {
                for (var vu = -1, _u = Zl - 1, xu = 7, Ru = 0, Iu = Ws.getMaskFunction(yu), Ku = Zl - 1; Ku > 0; Ku -= 2)
                    for (Ku == 6 && (Ku -= 1); ; ) {
                        for (var dp = 0; dp < 2; dp += 1)
                            if (Dl[_u][Ku - dp] == null) {
                                var lp = !1;
                                Ru < fu.length && (lp = (fu[Ru] >>> xu & 1) == 1);
                                var qu = Iu(_u, Ku - dp);
                                qu && (lp = !lp),
                                Dl[_u][Ku - dp] = lp,
                                xu -= 1,
                                xu == -1 && (Ru += 1,
                                xu = 7)
                            }
                        if (_u += vu,
                        _u < 0 || Zl <= _u) {
                            _u -= vu,
                            vu = -vu;
                            break
                        }
                    }
            }
              , Lu = function(fu, yu) {
                for (var vu = 0, _u = 0, xu = 0, Ru = new Array(yu.length), Iu = new Array(yu.length), Ku = 0; Ku < yu.length; Ku += 1) {
                    var dp = yu[Ku].dataCount
                      , lp = yu[Ku].totalCount - dp;
                    _u = Math.max(_u, dp),
                    xu = Math.max(xu, lp),
                    Ru[Ku] = new Array(dp);
                    for (var qu = 0; qu < Ru[Ku].length; qu += 1)
                        Ru[Ku][qu] = 255 & fu.getBuffer()[qu + vu];
                    vu += dp;
                    var hp = Ws.getErrorCorrectPolynomial(lp)
                      , fp = ga(Ru[Ku], hp.getLength() - 1)
                      , Lp = fp.mod(hp);
                    Iu[Ku] = new Array(hp.getLength() - 1);
                    for (var qu = 0; qu < Iu[Ku].length; qu += 1) {
                        var uu = qu + Lp.getLength() - Iu[Ku].length;
                        Iu[Ku][qu] = uu >= 0 ? Lp.getAt(uu) : 0
                    }
                }
                for (var gu = 0, qu = 0; qu < yu.length; qu += 1)
                    gu += yu[qu].totalCount;
                for (var Eu = new Array(gu), nu = 0, qu = 0; qu < _u; qu += 1)
                    for (var Ku = 0; Ku < yu.length; Ku += 1)
                        qu < Ru[Ku].length && (Eu[nu] = Ru[Ku][qu],
                        nu += 1);
                for (var qu = 0; qu < xu; qu += 1)
                    for (var Ku = 0; Ku < yu.length; Ku += 1)
                        qu < Iu[Ku].length && (Eu[nu] = Iu[Ku][qu],
                        nu += 1);
                return Eu
            }
              , Au = function(fu, yu, vu) {
                for (var _u = ba.getRSBlocks(fu, yu), xu = yl(), Ru = 0; Ru < vu.length; Ru += 1) {
                    var Iu = vu[Ru];
                    xu.put(Iu.getMode(), 4),
                    xu.put(Iu.getLength(), Ws.getLengthInBits(Iu.getMode(), fu)),
                    Iu.write(xu)
                }
                for (var Ku = 0, Ru = 0; Ru < _u.length; Ru += 1)
                    Ku += _u[Ru].dataCount;
                if (xu.getLengthInBits() > Ku * 8)
                    throw "code length overflow. (" + xu.getLengthInBits() + ">" + Ku * 8 + ")";
                for (xu.getLengthInBits() + 4 <= Ku * 8 && xu.put(0, 4); xu.getLengthInBits() % 8 != 0; )
                    xu.putBit(!1);
                for (; !(xu.getLengthInBits() >= Ku * 8 || (xu.put(Nl, 8),
                xu.getLengthInBits() >= Ku * 8)); )
                    xu.put(Ll, 8);
                return Lu(xu, _u)
            };
            Ql.addData = function(fu, yu) {
                yu = yu || "Byte";
                var vu = null;
                switch (yu) {
                case "Numeric":
                    vu = xl(fu);
                    break;
                case "Alphanumeric":
                    vu = wl(fu);
                    break;
                case "Byte":
                    vu = _l(fu);
                    break;
                case "Kanji":
                    vu = El(fu);
                    break;
                default:
                    throw "mode:" + yu
                }
                Wl.push(vu),
                Gl = null
            }
            ,
            Ql.isDark = function(fu, yu) {
                if (fu < 0 || Zl <= fu || yu < 0 || Zl <= yu)
                    throw fu + "," + yu;
                return Dl[fu][yu]
            }
            ,
            Ql.getModuleCount = function() {
                return Zl
            }
            ,
            Ql.make = function() {
                if (Fl < 1) {
                    for (var fu = 1; fu < 40; fu++) {
                        for (var yu = ba.getRSBlocks(fu, Ul), vu = yl(), _u = 0; _u < Wl.length; _u++) {
                            var xu = Wl[_u];
                            vu.put(xu.getMode(), 4),
                            vu.put(xu.getLength(), Ws.getLengthInBits(xu.getMode(), fu)),
                            xu.write(vu)
                        }
                        for (var Ru = 0, _u = 0; _u < yu.length; _u++)
                            Ru += yu[_u].dataCount;
                        if (vu.getLengthInBits() <= Ru * 8)
                            break
                    }
                    Fl = fu
                }
                cu(!1, zl())
            }
            ,
            Ql.createTableTag = function(fu, yu) {
                fu = fu || 2,
                yu = typeof yu > "u" ? fu * 4 : yu;
                var vu = "";
                vu += '<table style="',
                vu += " border-width: 0px; border-style: none;",
                vu += " border-collapse: collapse;",
                vu += " padding: 0px; margin: " + yu + "px;",
                vu += '">',
                vu += "<tbody>";
                for (var _u = 0; _u < Ql.getModuleCount(); _u += 1) {
                    vu += "<tr>";
                    for (var xu = 0; xu < Ql.getModuleCount(); xu += 1)
                        vu += '<td style="',
                        vu += " border-width: 0px; border-style: none;",
                        vu += " border-collapse: collapse;",
                        vu += " padding: 0px; margin: 0px;",
                        vu += " width: " + fu + "px;",
                        vu += " height: " + fu + "px;",
                        vu += " background-color: ",
                        vu += Ql.isDark(_u, xu) ? "#000000" : "#ffffff",
                        vu += ";",
                        vu += '"/>';
                    vu += "</tr>"
                }
                return vu += "</tbody>",
                vu += "</table>",
                vu
            }
            ,
            Ql.createSvgTag = function(fu, yu, vu, _u) {
                var xu = {};
                typeof arguments[0] == "object" && (xu = arguments[0],
                fu = xu.cellSize,
                yu = xu.margin,
                vu = xu.alt,
                _u = xu.title),
                fu = fu || 2,
                yu = typeof yu > "u" ? fu * 4 : yu,
                vu = typeof vu == "string" ? {
                    text: vu
                } : vu || {},
                vu.text = vu.text || null,
                vu.id = vu.text ? vu.id || "qrcode-description" : null,
                _u = typeof _u == "string" ? {
                    text: _u
                } : _u || {},
                _u.text = _u.text || null,
                _u.id = _u.text ? _u.id || "qrcode-title" : null;
                var Ru = Ql.getModuleCount() * fu + yu * 2, Iu, Ku, dp, lp, qu = "", hp;
                for (hp = "l" + fu + ",0 0," + fu + " -" + fu + ",0 0,-" + fu + "z ",
                qu += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"',
                qu += xu.scalable ? "" : ' width="' + Ru + 'px" height="' + Ru + 'px"',
                qu += ' viewBox="0 0 ' + Ru + " " + Ru + '" ',
                qu += ' preserveAspectRatio="xMinYMin meet"',
                qu += _u.text || vu.text ? ' role="img" aria-labelledby="' + Du([_u.id, vu.id].join(" ").trim()) + '"' : "",
                qu += ">",
                qu += _u.text ? '<title id="' + Du(_u.id) + '">' + Du(_u.text) + "</title>" : "",
                qu += vu.text ? '<description id="' + Du(vu.id) + '">' + Du(vu.text) + "</description>" : "",
                qu += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>',
                qu += '<path d="',
                dp = 0; dp < Ql.getModuleCount(); dp += 1)
                    for (lp = dp * fu + yu,
                    Iu = 0; Iu < Ql.getModuleCount(); Iu += 1)
                        Ql.isDark(dp, Iu) && (Ku = Iu * fu + yu,
                        qu += "M" + Ku + "," + lp + hp);
                return qu += '" stroke="transparent" fill="black"/>',
                qu += "</svg>",
                qu
            }
            ,
            Ql.createDataURL = function(fu, yu) {
                fu = fu || 2,
                yu = typeof yu > "u" ? fu * 4 : yu;
                var vu = Ql.getModuleCount() * fu + yu * 2
                  , _u = yu
                  , xu = vu - yu;
                return Rl(vu, vu, function(Ru, Iu) {
                    if (_u <= Ru && Ru < xu && _u <= Iu && Iu < xu) {
                        var Ku = Math.floor((Ru - _u) / fu)
                          , dp = Math.floor((Iu - _u) / fu);
                        return Ql.isDark(dp, Ku) ? 0 : 1
                    } else
                        return 1
                })
            }
            ,
            Ql.createImgTag = function(fu, yu, vu) {
                fu = fu || 2,
                yu = typeof yu > "u" ? fu * 4 : yu;
                var _u = Ql.getModuleCount() * fu + yu * 2
                  , xu = "";
                return xu += "<img",
                xu += ' src="',
                xu += Ql.createDataURL(fu, yu),
                xu += '"',
                xu += ' width="',
                xu += _u,
                xu += '"',
                xu += ' height="',
                xu += _u,
                xu += '"',
                vu && (xu += ' alt="',
                xu += Du(vu),
                xu += '"'),
                xu += "/>",
                xu
            }
            ;
            var Du = function(fu) {
                for (var yu = "", vu = 0; vu < fu.length; vu += 1) {
                    var _u = fu.charAt(vu);
                    switch (_u) {
                    case "<":
                        yu += "&lt;";
                        break;
                    case ">":
                        yu += "&gt;";
                        break;
                    case "&":
                        yu += "&amp;";
                        break;
                    case '"':
                        yu += "&quot;";
                        break;
                    default:
                        yu += _u;
                        break
                    }
                }
                return yu
            }
              , Qu = function(fu) {
                var yu = 1;
                fu = typeof fu > "u" ? yu * 2 : fu;
                var vu = Ql.getModuleCount() * yu + fu * 2, _u = fu, xu = vu - fu, Ru, Iu, Ku, dp, lp, qu = {
                    "": "",
                    " ": "",
                    " ": "",
                    "  ": " "
                }, hp = {
                    "": "",
                    " ": "",
                    " ": " ",
                    "  ": " "
                }, fp = "";
                for (Ru = 0; Ru < vu; Ru += 2) {
                    for (Ku = Math.floor((Ru - _u) / yu),
                    dp = Math.floor((Ru + 1 - _u) / yu),
                    Iu = 0; Iu < vu; Iu += 1)
                        lp = "",
                        _u <= Iu && Iu < xu && _u <= Ru && Ru < xu && Ql.isDark(Ku, Math.floor((Iu - _u) / yu)) && (lp = " "),
                        _u <= Iu && Iu < xu && _u <= Ru + 1 && Ru + 1 < xu && Ql.isDark(dp, Math.floor((Iu - _u) / yu)) ? lp += " " : lp += "",
                        fp += fu < 1 && Ru + 1 >= xu ? hp[lp] : qu[lp];
                    fp += `
`
                }
                return vu % 2 && fu > 0 ? fp.substring(0, fp.length - vu - 1) + Array(vu + 1).join("") : fp.substring(0, fp.length - 1)
            };
            return Ql.createASCII = function(fu, yu) {
                if (fu = fu || 1,
                fu < 2)
                    return Qu(yu);
                fu -= 1,
                yu = typeof yu > "u" ? fu * 2 : yu;
                var vu = Ql.getModuleCount() * fu + yu * 2, _u = yu, xu = vu - yu, Ru, Iu, Ku, dp, lp = Array(fu + 1).join(""), qu = Array(fu + 1).join("  "), hp = "", fp = "";
                for (Ru = 0; Ru < vu; Ru += 1) {
                    for (Ku = Math.floor((Ru - _u) / fu),
                    fp = "",
                    Iu = 0; Iu < vu; Iu += 1)
                        dp = 1,
                        _u <= Iu && Iu < xu && _u <= Ru && Ru < xu && Ql.isDark(Ku, Math.floor((Iu - _u) / fu)) && (dp = 0),
                        fp += dp ? lp : qu;
                    for (Ku = 0; Ku < fu; Ku += 1)
                        hp += fp + `
`
                }
                return hp.substring(0, hp.length - 1)
            }
            ,
            Ql.renderTo2dContext = function(fu, yu) {
                yu = yu || 2;
                for (var vu = Ql.getModuleCount(), _u = 0; _u < vu; _u++)
                    for (var xu = 0; xu < vu; xu++)
                        fu.fillStyle = Ql.isDark(_u, xu) ? "black" : "white",
                        fu.fillRect(_u * yu, xu * yu, yu, yu)
            }
            ,
            Ql
        };
        cs.stringToBytesFuncs = {
            default: function(Il) {
                for (var Ml = [], Nl = 0; Nl < Il.length; Nl += 1) {
                    var Ll = Il.charCodeAt(Nl);
                    Ml.push(Ll & 255)
                }
                return Ml
            }
        },
        cs.stringToBytes = cs.stringToBytesFuncs.default,
        cs.createStringToBytes = function(Il, Ml) {
            var Nl = function() {
                for (var Fl = Sl(Il), Ul = function() {
                    var Yl = Fl.read();
                    if (Yl == -1)
                        throw "eof";
                    return Yl
                }, Dl = 0, Zl = {}; ; ) {
                    var Gl = Fl.read();
                    if (Gl == -1)
                        break;
                    var Wl = Ul()
                      , Ql = Ul()
                      , cu = Ul()
                      , pu = String.fromCharCode(Gl << 8 | Wl)
                      , zl = Ql << 8 | cu;
                    Zl[pu] = zl,
                    Dl += 1
                }
                if (Dl != Ml)
                    throw Dl + " != " + Ml;
                return Zl
            }()
              , Ll = 63;
            return function(Fl) {
                for (var Ul = [], Dl = 0; Dl < Fl.length; Dl += 1) {
                    var Zl = Fl.charCodeAt(Dl);
                    if (Zl < 128)
                        Ul.push(Zl);
                    else {
                        var Gl = Nl[Fl.charAt(Dl)];
                        typeof Gl == "number" ? (Gl & 255) == Gl ? Ul.push(Gl) : (Ul.push(Gl >>> 8),
                        Ul.push(Gl & 255)) : Ul.push(Ll)
                    }
                }
                return Ul
            }
        }
        ;
        var Cs = {
            MODE_NUMBER: 1,
            MODE_ALPHA_NUM: 2,
            MODE_8BIT_BYTE: 4,
            MODE_KANJI: 8
        }
          , Ls = {
            L: 1,
            M: 0,
            Q: 3,
            H: 2
        }
          , Vs = {
            PATTERN000: 0,
            PATTERN001: 1,
            PATTERN010: 2,
            PATTERN011: 3,
            PATTERN100: 4,
            PATTERN101: 5,
            PATTERN110: 6,
            PATTERN111: 7
        }
          , Ws = function() {
            var Il = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]]
              , Ml = 1335
              , Nl = 7973
              , Ll = 21522
              , Fl = {}
              , Ul = function(Dl) {
                for (var Zl = 0; Dl != 0; )
                    Zl += 1,
                    Dl >>>= 1;
                return Zl
            };
            return Fl.getBCHTypeInfo = function(Dl) {
                for (var Zl = Dl << 10; Ul(Zl) - Ul(Ml) >= 0; )
                    Zl ^= Ml << Ul(Zl) - Ul(Ml);
                return (Dl << 10 | Zl) ^ Ll
            }
            ,
            Fl.getBCHTypeNumber = function(Dl) {
                for (var Zl = Dl << 12; Ul(Zl) - Ul(Nl) >= 0; )
                    Zl ^= Nl << Ul(Zl) - Ul(Nl);
                return Dl << 12 | Zl
            }
            ,
            Fl.getPatternPosition = function(Dl) {
                return Il[Dl - 1]
            }
            ,
            Fl.getMaskFunction = function(Dl) {
                switch (Dl) {
                case Vs.PATTERN000:
                    return function(Zl, Gl) {
                        return (Zl + Gl) % 2 == 0
                    }
                    ;
                case Vs.PATTERN001:
                    return function(Zl, Gl) {
                        return Zl % 2 == 0
                    }
                    ;
                case Vs.PATTERN010:
                    return function(Zl, Gl) {
                        return Gl % 3 == 0
                    }
                    ;
                case Vs.PATTERN011:
                    return function(Zl, Gl) {
                        return (Zl + Gl) % 3 == 0
                    }
                    ;
                case Vs.PATTERN100:
                    return function(Zl, Gl) {
                        return (Math.floor(Zl / 2) + Math.floor(Gl / 3)) % 2 == 0
                    }
                    ;
                case Vs.PATTERN101:
                    return function(Zl, Gl) {
                        return Zl * Gl % 2 + Zl * Gl % 3 == 0
                    }
                    ;
                case Vs.PATTERN110:
                    return function(Zl, Gl) {
                        return (Zl * Gl % 2 + Zl * Gl % 3) % 2 == 0
                    }
                    ;
                case Vs.PATTERN111:
                    return function(Zl, Gl) {
                        return (Zl * Gl % 3 + (Zl + Gl) % 2) % 2 == 0
                    }
                    ;
                default:
                    throw "bad maskPattern:" + Dl
                }
            }
            ,
            Fl.getErrorCorrectPolynomial = function(Dl) {
                for (var Zl = ga([1], 0), Gl = 0; Gl < Dl; Gl += 1)
                    Zl = Zl.multiply(ga([1, Xs.gexp(Gl)], 0));
                return Zl
            }
            ,
            Fl.getLengthInBits = function(Dl, Zl) {
                if (1 <= Zl && Zl < 10)
                    switch (Dl) {
                    case Cs.MODE_NUMBER:
                        return 10;
                    case Cs.MODE_ALPHA_NUM:
                        return 9;
                    case Cs.MODE_8BIT_BYTE:
                        return 8;
                    case Cs.MODE_KANJI:
                        return 8;
                    default:
                        throw "mode:" + Dl
                    }
                else if (Zl < 27)
                    switch (Dl) {
                    case Cs.MODE_NUMBER:
                        return 12;
                    case Cs.MODE_ALPHA_NUM:
                        return 11;
                    case Cs.MODE_8BIT_BYTE:
                        return 16;
                    case Cs.MODE_KANJI:
                        return 10;
                    default:
                        throw "mode:" + Dl
                    }
                else if (Zl < 41)
                    switch (Dl) {
                    case Cs.MODE_NUMBER:
                        return 14;
                    case Cs.MODE_ALPHA_NUM:
                        return 13;
                    case Cs.MODE_8BIT_BYTE:
                        return 16;
                    case Cs.MODE_KANJI:
                        return 12;
                    default:
                        throw "mode:" + Dl
                    }
                else
                    throw "type:" + Zl
            }
            ,
            Fl.getLostPoint = function(Dl) {
                for (var Zl = Dl.getModuleCount(), Gl = 0, Wl = 0; Wl < Zl; Wl += 1)
                    for (var Ql = 0; Ql < Zl; Ql += 1) {
                        for (var cu = 0, pu = Dl.isDark(Wl, Ql), zl = -1; zl <= 1; zl += 1)
                            if (!(Wl + zl < 0 || Zl <= Wl + zl))
                                for (var Yl = -1; Yl <= 1; Yl += 1)
                                    Ql + Yl < 0 || Zl <= Ql + Yl || zl == 0 && Yl == 0 || pu == Dl.isDark(Wl + zl, Ql + Yl) && (cu += 1);
                        cu > 5 && (Gl += 3 + cu - 5)
                    }
                for (var Wl = 0; Wl < Zl - 1; Wl += 1)
                    for (var Ql = 0; Ql < Zl - 1; Ql += 1) {
                        var lu = 0;
                        Dl.isDark(Wl, Ql) && (lu += 1),
                        Dl.isDark(Wl + 1, Ql) && (lu += 1),
                        Dl.isDark(Wl, Ql + 1) && (lu += 1),
                        Dl.isDark(Wl + 1, Ql + 1) && (lu += 1),
                        (lu == 0 || lu == 4) && (Gl += 3)
                    }
                for (var Wl = 0; Wl < Zl; Wl += 1)
                    for (var Ql = 0; Ql < Zl - 6; Ql += 1)
                        Dl.isDark(Wl, Ql) && !Dl.isDark(Wl, Ql + 1) && Dl.isDark(Wl, Ql + 2) && Dl.isDark(Wl, Ql + 3) && Dl.isDark(Wl, Ql + 4) && !Dl.isDark(Wl, Ql + 5) && Dl.isDark(Wl, Ql + 6) && (Gl += 40);
                for (var Ql = 0; Ql < Zl; Ql += 1)
                    for (var Wl = 0; Wl < Zl - 6; Wl += 1)
                        Dl.isDark(Wl, Ql) && !Dl.isDark(Wl + 1, Ql) && Dl.isDark(Wl + 2, Ql) && Dl.isDark(Wl + 3, Ql) && Dl.isDark(Wl + 4, Ql) && !Dl.isDark(Wl + 5, Ql) && Dl.isDark(Wl + 6, Ql) && (Gl += 40);
                for (var mu = 0, Ql = 0; Ql < Zl; Ql += 1)
                    for (var Wl = 0; Wl < Zl; Wl += 1)
                        Dl.isDark(Wl, Ql) && (mu += 1);
                var Cu = Math.abs(100 * mu / Zl / Zl - 50) / 5;
                return Gl += Cu * 10,
                Gl
            }
            ,
            Fl
        }()
          , Xs = function() {
            for (var Il = new Array(256), Ml = new Array(256), Nl = 0; Nl < 8; Nl += 1)
                Il[Nl] = 1 << Nl;
            for (var Nl = 8; Nl < 256; Nl += 1)
                Il[Nl] = Il[Nl - 4] ^ Il[Nl - 5] ^ Il[Nl - 6] ^ Il[Nl - 8];
            for (var Nl = 0; Nl < 255; Nl += 1)
                Ml[Il[Nl]] = Nl;
            var Ll = {};
            return Ll.glog = function(Fl) {
                if (Fl < 1)
                    throw "glog(" + Fl + ")";
                return Ml[Fl]
            }
            ,
            Ll.gexp = function(Fl) {
                for (; Fl < 0; )
                    Fl += 255;
                for (; Fl >= 256; )
                    Fl -= 255;
                return Il[Fl]
            }
            ,
            Ll
        }();
        function ga(Il, Ml) {
            if (typeof Il.length > "u")
                throw Il.length + "/" + Ml;
            var Nl = function() {
                for (var Fl = 0; Fl < Il.length && Il[Fl] == 0; )
                    Fl += 1;
                for (var Ul = new Array(Il.length - Fl + Ml), Dl = 0; Dl < Il.length - Fl; Dl += 1)
                    Ul[Dl] = Il[Dl + Fl];
                return Ul
            }()
              , Ll = {};
            return Ll.getAt = function(Fl) {
                return Nl[Fl]
            }
            ,
            Ll.getLength = function() {
                return Nl.length
            }
            ,
            Ll.multiply = function(Fl) {
                for (var Ul = new Array(Ll.getLength() + Fl.getLength() - 1), Dl = 0; Dl < Ll.getLength(); Dl += 1)
                    for (var Zl = 0; Zl < Fl.getLength(); Zl += 1)
                        Ul[Dl + Zl] ^= Xs.gexp(Xs.glog(Ll.getAt(Dl)) + Xs.glog(Fl.getAt(Zl)));
                return ga(Ul, 0)
            }
            ,
            Ll.mod = function(Fl) {
                if (Ll.getLength() - Fl.getLength() < 0)
                    return Ll;
                for (var Ul = Xs.glog(Ll.getAt(0)) - Xs.glog(Fl.getAt(0)), Dl = new Array(Ll.getLength()), Zl = 0; Zl < Ll.getLength(); Zl += 1)
                    Dl[Zl] = Ll.getAt(Zl);
                for (var Zl = 0; Zl < Fl.getLength(); Zl += 1)
                    Dl[Zl] ^= Xs.gexp(Xs.glog(Fl.getAt(Zl)) + Ul);
                return ga(Dl, 0).mod(Fl)
            }
            ,
            Ll
        }
        var ba = function() {
            var Il = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]]
              , Ml = function(Fl, Ul) {
                var Dl = {};
                return Dl.totalCount = Fl,
                Dl.dataCount = Ul,
                Dl
            }
              , Nl = {}
              , Ll = function(Fl, Ul) {
                switch (Ul) {
                case Ls.L:
                    return Il[(Fl - 1) * 4 + 0];
                case Ls.M:
                    return Il[(Fl - 1) * 4 + 1];
                case Ls.Q:
                    return Il[(Fl - 1) * 4 + 2];
                case Ls.H:
                    return Il[(Fl - 1) * 4 + 3];
                default:
                    return
                }
            };
            return Nl.getRSBlocks = function(Fl, Ul) {
                var Dl = Ll(Fl, Ul);
                if (typeof Dl > "u")
                    throw "bad rs block @ typeNumber:" + Fl + "/errorCorrectionLevel:" + Ul;
                for (var Zl = Dl.length / 3, Gl = [], Wl = 0; Wl < Zl; Wl += 1)
                    for (var Ql = Dl[Wl * 3 + 0], cu = Dl[Wl * 3 + 1], pu = Dl[Wl * 3 + 2], zl = 0; zl < Ql; zl += 1)
                        Gl.push(Ml(cu, pu));
                return Gl
            }
            ,
            Nl
        }()
          , yl = function() {
            var Il = []
              , Ml = 0
              , Nl = {};
            return Nl.getBuffer = function() {
                return Il
            }
            ,
            Nl.getAt = function(Ll) {
                var Fl = Math.floor(Ll / 8);
                return (Il[Fl] >>> 7 - Ll % 8 & 1) == 1
            }
            ,
            Nl.put = function(Ll, Fl) {
                for (var Ul = 0; Ul < Fl; Ul += 1)
                    Nl.putBit((Ll >>> Fl - Ul - 1 & 1) == 1)
            }
            ,
            Nl.getLengthInBits = function() {
                return Ml
            }
            ,
            Nl.putBit = function(Ll) {
                var Fl = Math.floor(Ml / 8);
                Il.length <= Fl && Il.push(0),
                Ll && (Il[Fl] |= 128 >>> Ml % 8),
                Ml += 1
            }
            ,
            Nl
        }
          , xl = function(Il) {
            var Ml = Cs.MODE_NUMBER
              , Nl = Il
              , Ll = {};
            Ll.getMode = function() {
                return Ml
            }
            ,
            Ll.getLength = function(Dl) {
                return Nl.length
            }
            ,
            Ll.write = function(Dl) {
                for (var Zl = Nl, Gl = 0; Gl + 2 < Zl.length; )
                    Dl.put(Fl(Zl.substring(Gl, Gl + 3)), 10),
                    Gl += 3;
                Gl < Zl.length && (Zl.length - Gl == 1 ? Dl.put(Fl(Zl.substring(Gl, Gl + 1)), 4) : Zl.length - Gl == 2 && Dl.put(Fl(Zl.substring(Gl, Gl + 2)), 7))
            }
            ;
            var Fl = function(Dl) {
                for (var Zl = 0, Gl = 0; Gl < Dl.length; Gl += 1)
                    Zl = Zl * 10 + Ul(Dl.charAt(Gl));
                return Zl
            }
              , Ul = function(Dl) {
                if ("0" <= Dl && Dl <= "9")
                    return Dl.charCodeAt(0) - 48;
                throw "illegal char :" + Dl
            };
            return Ll
        }
          , wl = function(Il) {
            var Ml = Cs.MODE_ALPHA_NUM
              , Nl = Il
              , Ll = {};
            Ll.getMode = function() {
                return Ml
            }
            ,
            Ll.getLength = function(Ul) {
                return Nl.length
            }
            ,
            Ll.write = function(Ul) {
                for (var Dl = Nl, Zl = 0; Zl + 1 < Dl.length; )
                    Ul.put(Fl(Dl.charAt(Zl)) * 45 + Fl(Dl.charAt(Zl + 1)), 11),
                    Zl += 2;
                Zl < Dl.length && Ul.put(Fl(Dl.charAt(Zl)), 6)
            }
            ;
            var Fl = function(Ul) {
                if ("0" <= Ul && Ul <= "9")
                    return Ul.charCodeAt(0) - 48;
                if ("A" <= Ul && Ul <= "Z")
                    return Ul.charCodeAt(0) - 65 + 10;
                switch (Ul) {
                case " ":
                    return 36;
                case "$":
                    return 37;
                case "%":
                    return 38;
                case "*":
                    return 39;
                case "+":
                    return 40;
                case "-":
                    return 41;
                case ".":
                    return 42;
                case "/":
                    return 43;
                case ":":
                    return 44;
                default:
                    throw "illegal char :" + Ul
                }
            };
            return Ll
        }
          , _l = function(Il) {
            var Ml = Cs.MODE_8BIT_BYTE
              , Nl = cs.stringToBytes(Il)
              , Ll = {};
            return Ll.getMode = function() {
                return Ml
            }
            ,
            Ll.getLength = function(Fl) {
                return Nl.length
            }
            ,
            Ll.write = function(Fl) {
                for (var Ul = 0; Ul < Nl.length; Ul += 1)
                    Fl.put(Nl[Ul], 8)
            }
            ,
            Ll
        }
          , El = function(Il) {
            var Ml = Cs.MODE_KANJI
              , Nl = cs.stringToBytesFuncs.SJIS;
            if (!Nl)
                throw "sjis not supported.";
            (function(Ul, Dl) {
                var Zl = Nl(Ul);
                if (Zl.length != 2 || (Zl[0] << 8 | Zl[1]) != Dl)
                    throw "sjis not supported."
            }
            )("", 38726);
            var Ll = Nl(Il)
              , Fl = {};
            return Fl.getMode = function() {
                return Ml
            }
            ,
            Fl.getLength = function(Ul) {
                return ~~(Ll.length / 2)
            }
            ,
            Fl.write = function(Ul) {
                for (var Dl = Ll, Zl = 0; Zl + 1 < Dl.length; ) {
                    var Gl = (255 & Dl[Zl]) << 8 | 255 & Dl[Zl + 1];
                    if (33088 <= Gl && Gl <= 40956)
                        Gl -= 33088;
                    else if (57408 <= Gl && Gl <= 60351)
                        Gl -= 49472;
                    else
                        throw "illegal char at " + (Zl + 1) + "/" + Gl;
                    Gl = (Gl >>> 8 & 255) * 192 + (Gl & 255),
                    Ul.put(Gl, 13),
                    Zl += 2
                }
                if (Zl < Dl.length)
                    throw "illegal char at " + (Zl + 1)
            }
            ,
            Fl
        }
          , Cl = function() {
            var Il = []
              , Ml = {};
            return Ml.writeByte = function(Nl) {
                Il.push(Nl & 255)
            }
            ,
            Ml.writeShort = function(Nl) {
                Ml.writeByte(Nl),
                Ml.writeByte(Nl >>> 8)
            }
            ,
            Ml.writeBytes = function(Nl, Ll, Fl) {
                Ll = Ll || 0,
                Fl = Fl || Nl.length;
                for (var Ul = 0; Ul < Fl; Ul += 1)
                    Ml.writeByte(Nl[Ul + Ll])
            }
            ,
            Ml.writeString = function(Nl) {
                for (var Ll = 0; Ll < Nl.length; Ll += 1)
                    Ml.writeByte(Nl.charCodeAt(Ll))
            }
            ,
            Ml.toByteArray = function() {
                return Il
            }
            ,
            Ml.toString = function() {
                var Nl = "";
                Nl += "[";
                for (var Ll = 0; Ll < Il.length; Ll += 1)
                    Ll > 0 && (Nl += ","),
                    Nl += Il[Ll];
                return Nl += "]",
                Nl
            }
            ,
            Ml
        }
          , $l = function() {
            var Il = 0
              , Ml = 0
              , Nl = 0
              , Ll = ""
              , Fl = {}
              , Ul = function(Zl) {
                Ll += String.fromCharCode(Dl(Zl & 63))
            }
              , Dl = function(Zl) {
                if (!(Zl < 0)) {
                    if (Zl < 26)
                        return 65 + Zl;
                    if (Zl < 52)
                        return 97 + (Zl - 26);
                    if (Zl < 62)
                        return 48 + (Zl - 52);
                    if (Zl == 62)
                        return 43;
                    if (Zl == 63)
                        return 47
                }
                throw "n:" + Zl
            };
            return Fl.writeByte = function(Zl) {
                for (Il = Il << 8 | Zl & 255,
                Ml += 8,
                Nl += 1; Ml >= 6; )
                    Ul(Il >>> Ml - 6),
                    Ml -= 6
            }
            ,
            Fl.flush = function() {
                if (Ml > 0 && (Ul(Il << 6 - Ml),
                Il = 0,
                Ml = 0),
                Nl % 3 != 0)
                    for (var Zl = 3 - Nl % 3, Gl = 0; Gl < Zl; Gl += 1)
                        Ll += "="
            }
            ,
            Fl.toString = function() {
                return Ll
            }
            ,
            Fl
        }
          , Sl = function(Il) {
            var Ml = Il
              , Nl = 0
              , Ll = 0
              , Fl = 0
              , Ul = {};
            Ul.read = function() {
                for (; Fl < 8; ) {
                    if (Nl >= Ml.length) {
                        if (Fl == 0)
                            return -1;
                        throw "unexpected end of file./" + Fl
                    }
                    var Zl = Ml.charAt(Nl);
                    if (Nl += 1,
                    Zl == "=")
                        return Fl = 0,
                        -1;
                    if (Zl.match(/^\s$/))
                        continue;
                    Ll = Ll << 6 | Dl(Zl.charCodeAt(0)),
                    Fl += 6
                }
                var Gl = Ll >>> Fl - 8 & 255;
                return Fl -= 8,
                Gl
            }
            ;
            var Dl = function(Zl) {
                if (65 <= Zl && Zl <= 90)
                    return Zl - 65;
                if (97 <= Zl && Zl <= 122)
                    return Zl - 97 + 26;
                if (48 <= Zl && Zl <= 57)
                    return Zl - 48 + 52;
                if (Zl == 43)
                    return 62;
                if (Zl == 47)
                    return 63;
                throw "c:" + Zl
            };
            return Ul
        }
          , Tl = function(Il, Ml) {
            var Nl = Il
              , Ll = Ml
              , Fl = new Array(Il * Ml)
              , Ul = {};
            Ul.setPixel = function(Wl, Ql, cu) {
                Fl[Ql * Nl + Wl] = cu
            }
            ,
            Ul.write = function(Wl) {
                Wl.writeString("GIF87a"),
                Wl.writeShort(Nl),
                Wl.writeShort(Ll),
                Wl.writeByte(128),
                Wl.writeByte(0),
                Wl.writeByte(0),
                Wl.writeByte(0),
                Wl.writeByte(0),
                Wl.writeByte(0),
                Wl.writeByte(255),
                Wl.writeByte(255),
                Wl.writeByte(255),
                Wl.writeString(","),
                Wl.writeShort(0),
                Wl.writeShort(0),
                Wl.writeShort(Nl),
                Wl.writeShort(Ll),
                Wl.writeByte(0);
                var Ql = 2
                  , cu = Zl(Ql);
                Wl.writeByte(Ql);
                for (var pu = 0; cu.length - pu > 255; )
                    Wl.writeByte(255),
                    Wl.writeBytes(cu, pu, 255),
                    pu += 255;
                Wl.writeByte(cu.length - pu),
                Wl.writeBytes(cu, pu, cu.length - pu),
                Wl.writeByte(0),
                Wl.writeString(";")
            }
            ;
            var Dl = function(Wl) {
                var Ql = Wl
                  , cu = 0
                  , pu = 0
                  , zl = {};
                return zl.write = function(Yl, lu) {
                    if (Yl >>> lu)
                        throw "length over";
                    for (; cu + lu >= 8; )
                        Ql.writeByte(255 & (Yl << cu | pu)),
                        lu -= 8 - cu,
                        Yl >>>= 8 - cu,
                        pu = 0,
                        cu = 0;
                    pu = Yl << cu | pu,
                    cu = cu + lu
                }
                ,
                zl.flush = function() {
                    cu > 0 && Ql.writeByte(pu)
                }
                ,
                zl
            }
              , Zl = function(Wl) {
                for (var Ql = 1 << Wl, cu = (1 << Wl) + 1, pu = Wl + 1, zl = Gl(), Yl = 0; Yl < Ql; Yl += 1)
                    zl.add(String.fromCharCode(Yl));
                zl.add(String.fromCharCode(Ql)),
                zl.add(String.fromCharCode(cu));
                var lu = Cl()
                  , mu = Dl(lu);
                mu.write(Ql, pu);
                var Cu = 0
                  , ju = String.fromCharCode(Fl[Cu]);
                for (Cu += 1; Cu < Fl.length; ) {
                    var Lu = String.fromCharCode(Fl[Cu]);
                    Cu += 1,
                    zl.contains(ju + Lu) ? ju = ju + Lu : (mu.write(zl.indexOf(ju), pu),
                    zl.size() < 4095 && (zl.size() == 1 << pu && (pu += 1),
                    zl.add(ju + Lu)),
                    ju = Lu)
                }
                return mu.write(zl.indexOf(ju), pu),
                mu.write(cu, pu),
                mu.flush(),
                lu.toByteArray()
            }
              , Gl = function() {
                var Wl = {}
                  , Ql = 0
                  , cu = {};
                return cu.add = function(pu) {
                    if (cu.contains(pu))
                        throw "dup key:" + pu;
                    Wl[pu] = Ql,
                    Ql += 1
                }
                ,
                cu.size = function() {
                    return Ql
                }
                ,
                cu.indexOf = function(pu) {
                    return Wl[pu]
                }
                ,
                cu.contains = function(pu) {
                    return typeof Wl[pu] < "u"
                }
                ,
                cu
            };
            return Ul
        }
          , Rl = function(Il, Ml, Nl) {
            for (var Ll = Tl(Il, Ml), Fl = 0; Fl < Ml; Fl += 1)
                for (var Ul = 0; Ul < Il; Ul += 1)
                    Ll.setPixel(Ul, Fl, Nl(Ul, Fl));
            var Dl = Cl();
            Ll.write(Dl);
            for (var Zl = $l(), Gl = Dl.toByteArray(), Wl = 0; Wl < Gl.length; Wl += 1)
                Zl.writeByte(Gl[Wl]);
            return Zl.flush(),
            "data:image/gif;base64," + Zl
        };
        return cs
    }();
    (function() {
        as.stringToBytesFuncs["UTF-8"] = function(cs) {
            function Cs(Ls) {
                for (var Vs = [], Ws = 0; Ws < Ls.length; Ws++) {
                    var Xs = Ls.charCodeAt(Ws);
                    Xs < 128 ? Vs.push(Xs) : Xs < 2048 ? Vs.push(192 | Xs >> 6, 128 | Xs & 63) : Xs < 55296 || Xs >= 57344 ? Vs.push(224 | Xs >> 12, 128 | Xs >> 6 & 63, 128 | Xs & 63) : (Ws++,
                    Xs = 65536 + ((Xs & 1023) << 10 | Ls.charCodeAt(Ws) & 1023),
                    Vs.push(240 | Xs >> 18, 128 | Xs >> 12 & 63, 128 | Xs >> 6 & 63, 128 | Xs & 63))
                }
                return Vs
            }
            return Cs(cs)
        }
    }
    )(),
    function(cs) {
        xt.exports = cs()
    }(function() {
        return as
    })
}
)(qrcode$1);
const qrcode = qrcode$1.exports;
function copyToClipboard(xt) {
    return __async(this, null, function*() {
        try {
            if (!(navigator != null && navigator.clipboard))
                throw new TonConnectUIError("Clipboard API not available");
            return yield navigator.clipboard.writeText(xt)
        } catch {}
        fallbackCopyTextToClipboard(xt)
    })
}
function fallbackCopyTextToClipboard(xt) {
    const Cn = document.createElement("textarea");
    Cn.value = xt,
    Cn.style.top = "0",
    Cn.style.left = "0",
    Cn.style.position = "fixed",
    document.body.appendChild(Cn),
    Cn.focus(),
    Cn.select();
    try {
        document.execCommand("copy")
    } finally {
        document.body.removeChild(Cn)
    }
}
const _tmpl$$t = template$1("<div></div>")
  , QRCode = xt => {
    let Cn, as, cs;
    const [Cs,Ls] = createSignal(!1)
      , [Vs,Ws] = createSignal(picSizeDefault);
    createEffect( () => {
        const xl = qrcode(0, "L");
        xl.addData(xt.sourceUrl),
        xl.make(),
        Cn.innerHTML = xl.createSvgTag(4, 0);
        const wl = Cn.firstElementChild.clientWidth
          , _l = Math.round(qrNormalSize / wl * 1e5) / 1e5;
        if (cs) {
            const El = Math.ceil(imgSizeDefault / (_l * 4)) * 4
              , Cl = toPx(Math.ceil((wl - El) / (2 * 4)) * 4);
            cs.style.top = Cl,
            cs.style.left = Cl,
            cs.style.height = toPx(El),
            cs.style.width = toPx(El),
            Ws(Math.round(picSizeDefault / _l))
        }
        as.style.transform = `scale(${_l})`
    }
    );
    let Xs = null;
    return createComponent(QrCodeBackground, {
        get class() {
            return xt.class
        },
        onClick: () => {
            Ls(!0),
            copyToClipboard(xt.sourceUrl),
            Xs != null && clearTimeout(Xs),
            Xs = setTimeout( () => Ls(!1), 1500)
        }
        ,
        get children() {
            return [createComponent(QrCodeWrapper$2, {
                ref(ba) {
                    const yl = as;
                    typeof yl == "function" ? yl(ba) : as = ba
                },
                get children() {
                    return [( () => {
                        const ba = _tmpl$$t.cloneNode(!0)
                          , yl = Cn;
                        return typeof yl == "function" ? use(yl, ba) : Cn = ba,
                        ba
                    }
                    )(), createComponent(Show, {
                        get when() {
                            return xt.imageUrl
                        },
                        get children() {
                            return createComponent(ImageBackground, {
                                ref(ba) {
                                    const yl = cs;
                                    typeof yl == "function" ? yl(ba) : cs = ba
                                },
                                get children() {
                                    return createComponent(ImageStyled$3, {
                                        get src() {
                                            return xt.imageUrl
                                        },
                                        alt: "",
                                        get size() {
                                            return Vs()
                                        }
                                    })
                                }
                            })
                        }
                    })]
                }
            }), createComponent(Transition, {
                onBeforeEnter: ba => {
                    animate(ba, [{
                        opacity: 0,
                        transform: "translate(-50%, 44px)"
                    }, {
                        opacity: 1,
                        transform: "translate(-50%, 0)"
                    }], {
                        duration: 150,
                        easing: "ease-out"
                    })
                }
                ,
                onExit: (ba, yl) => {
                    animate(ba, [{
                        opacity: 1,
                        transform: "translate(-50%, 0)"
                    }, {
                        opacity: 0,
                        transform: "translate(-50%, 44px)"
                    }], {
                        duration: 150,
                        easing: "ease-out"
                    }).finished.then( () => {
                        yl()
                    }
                    )
                }
                ,
                get children() {
                    return createComponent(Show, {
                        get when() {
                            return Cs() && !xt.disableCopy
                        },
                        get children() {
                            return createComponent(CopiedBoxStyled, {
                                get children() {
                                    return [createComponent(SuccessIcon, {
                                        size: "xs"
                                    }), createComponent(Text, {
                                        translationKey: "common.linkCopied",
                                        children: "Link Copied"
                                    })]
                                }
                            })
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return !xt.disableCopy
                },
                get children() {
                    return createComponent(CopyIconButton, {
                        get children() {
                            return createComponent(CopyLightIcon, {})
                        }
                    })
                }
            })]
        }
    })
}
;
var deepReadObject = (xt, Cn, as) => {
    const cs = Cn.trim().split(".").reduce( (Cs, Ls) => Cs ? Cs[Ls] : void 0, xt);
    return cs !== void 0 ? cs : as
}
  , template = (xt, Cn, as=/{{(.*?)}}/g) => xt.replace(as, (cs, Cs) => deepReadObject(Cn, Cs, ""))
  , createI18nContext = (xt={}, Cn=navigator.language in xt ? navigator.language : Object.keys(xt)[0]) => {
    const [as,cs] = createSignal(Cn)
      , [Cs,Ls] = createStore$1(xt);
    return [ (Xs, ga, ba) => {
        const yl = deepReadObject(Cs[as()], Xs, ba || "");
        return typeof yl == "function" ? yl(ga) : typeof yl == "string" ? template(yl, ga || {}) : yl
    }
    , {
        add(Xs, ga) {
            Ls(Xs, ba => Object.assign(ba || {}, ga))
        },
        locale: Xs => Xs ? cs(Xs) : as(),
        dict: Xs => deepReadObject(Cs, Xs)
    }]
}
  , I18nContext = createContext({})
  , useI18n = () => useContext(I18nContext);
const TextStyled$3 = styled.div`
    font-style: normal;
    font-weight: ${xt => xt.fontWeight};
    font-size: ${xt => xt.fontSize};
    line-height: ${xt => xt.lineHeight};

    color: ${xt => xt.color};
`
  , Text = xt => {
    const Cn = useTheme()
      , [as] = useI18n();
    let cs;
    const Cs = () => xt.color || Cn.colors.text.primary
      , Ls = mergeProps$1({
        fontSize: "14px",
        fontWeight: "510",
        lineHeight: "130%"
    }, xt);
    return createEffect( () => {
        cs && Ls.cursor !== "unset" && getComputedStyle(cs).cursor !== "pointer" && (cs.style.cursor = "default")
    }
    ),
    createComponent(TextStyled$3, {
        get fontSize() {
            return Ls.fontSize
        },
        get fontWeight() {
            return Ls.fontWeight
        },
        get lineHeight() {
            return Ls.lineHeight
        },
        get color() {
            return Cs()
        },
        get class() {
            return Ls.class
        },
        ref(Vs) {
            const Ws = cs;
            typeof Ws == "function" ? Ws(Vs) : cs = Vs
        },
        "data-tc-text": "true",
        get children() {
            var Vs;
            return createMemo( () => !!Ls.translationKey)() ? as(Ls.translationKey, Ls.translationValues, (Vs = Ls.children) == null ? void 0 : Vs.toString()) : Ls.children
        }
    })
}
  , ImageContainer = styled.div`
    position: relative;

    &::after {
        content: '';
        display: block;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        border: 0.5px solid rgba(0, 0, 0, 0.08);

        border-radius: inherit;
    }
`
  , ImageStyled$2 = styled(Image$1)`
    width: 100%;
    height: 100%;
    border-radius: inherit;
`
  , WalletImage = xt => createComponent(ImageContainer, {
    get class() {
        return xt.class
    },
    get children() {
        return createComponent(ImageStyled$2, {
            get src() {
                return xt.src
            }
        })
    }
})
  , borders$3 = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , badgeBorders = {
    m: "6px",
    s: "6px",
    none: "0"
}
  , WalletItemStyled = styled.button`
    position: relative;
    cursor: pointer;
    border: none;
    background-color: unset;
    padding: 8px 4px;
    width: 92px;
    display: flex;
    flex-direction: column;
    align-items: center;

    transition: transform 0.125s ease-in-out;

    ${mediaNotTouch} {
        &:hover {
            transform: scale(1.04);
        }
    }

    &:active {
        transform: scale(0.96);
    }

    ${media("mobile")} {
        padding: 8px 4px;
        width: 82px;
    }

    ${mediaTouch} {
        &:active {
            transform: scale(0.92);
        }
    }
`
  , ImageStyled$1 = styled(WalletImage)`
    width: 60px;
    height: 60px;
    border-radius: ${xt => borders$3[xt.theme.borderRadius]};

    margin-bottom: 8px;
`
  , BadgeStyled = styled(Image$1)`
    position: absolute;
    right: 10px;
    top: 50px;
    width: 24px;
    height: 24px;
    border-radius: ${xt => badgeBorders[xt.theme.borderRadius]};
    box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.08);
`
  , StyledText = styled(Text)`
    max-width: 90px;
    font-weight: 510;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;

    ${media("mobile")} {
        max-width: 80px;
    }
`
  , StyledSecondLine = styled(Text)`
    font-weight: ${xt => xt.colorPrimary ? "510" : "400"};
    max-width: 90px;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
    color: ${xt => xt.colorPrimary ? xt.theme.colors.text.primary : xt.theme.colors.text.secondary};

    ${media("mobile")} {
        max-width: 80px;
    }
`
  , _tmpl$$s = template$1("<div></div>")
  , WalletItem = xt => {
    let Cn = null;
    const as = () => {
        const cs = Cn == null ? void 0 : Cn.querySelector("div");
        if (cs && cs.scrollWidth > cs.clientWidth) {
            let Cs = 0;
            const Ls = -.4
              , Vs = .05;
            for (; cs.scrollWidth > cs.clientWidth && Cs >= Ls; )
                Cs -= Vs,
                cs.style.letterSpacing = `${Cs}px`;
            Cs !== 0 && (Cs -= Vs,
            cs.style.letterSpacing = `${Cs}px`)
        }
    }
    ;
    return onMount( () => as()),
    createEffect( () => {
        as()
    }
    ),
    createComponent(WalletItemStyled, {
        get class() {
            return xt.class
        },
        onClick: () => xt.onClick(),
        "data-tc-wallet-item": "true",
        get children() {
            return [createMemo( () => createMemo( () => typeof xt.icon == "string")() ? createComponent(ImageStyled$1, {
                get src() {
                    return xt.icon
                }
            }) : xt.icon), createMemo( () => createMemo( () => !!xt.badgeUrl)() && createComponent(BadgeStyled, {
                get src() {
                    return xt.badgeUrl
                }
            })), ( () => {
                const cs = _tmpl$$s.cloneNode(!0);
                return use(Cs => Cn = Cs, cs),
                insert(cs, createComponent(StyledText, {
                    get children() {
                        return xt.name
                    }
                })),
                cs
            }
            )(), createMemo( () => createMemo( () => !!xt.secondLine)() && createComponent(StyledSecondLine, {
                get colorPrimary() {
                    var cs;
                    return (cs = xt.secondLineColorPrimary) != null ? cs : !0
                },
                get children() {
                    return xt.secondLine
                }
            }))]
        }
    })
}
  , H1Styled$9 = styled.h1`
    font-style: normal;
    font-weight: 590;
    font-size: 20px;
    line-height: 28px;

    text-align: center;

    color: ${xt => xt.theme.colors.text.primary};

    margin-top: 0;
    margin-bottom: 0;

    cursor: default;
`
  , H1 = xt => {
    const [Cn] = useI18n();
    return createComponent(H1Styled$9, {
        get class() {
            return xt.class
        },
        "data-tc-h1": "true",
        get children() {
            var as;
            return createMemo( () => !!xt.translationKey)() ? Cn(xt.translationKey, xt.translationValues, (as = xt.children) == null ? void 0 : as.toString()) : xt.children
        }
    })
}
  , H2Styled$5 = styled.h2`
    font-style: normal;
    font-weight: 400;
    font-size: 16px;
    line-height: 22px;

    text-align: center;

    color: ${xt => xt.theme.colors.text.secondary};

    margin-top: 0;
    margin-bottom: 32px;

    cursor: default;
`
  , H2 = xt => {
    const [Cn] = useI18n();
    return createComponent(H2Styled$5, {
        get class() {
            return xt.class
        },
        "data-tc-h2": "true",
        get children() {
            var as;
            return createMemo( () => !!xt.translationKey)() ? Cn(xt.translationKey, xt.translationValues, (as = xt.children) == null ? void 0 : as.toString()) : xt.children
        }
    })
}
  , H3Styled$1 = styled.h3`
    font-style: normal;
    font-weight: 510;
    font-size: 16px;
    line-height: 20px;

    color: ${xt => xt.theme.colors.text.primary};

    margin-top: 0;
    margin-bottom: 0;

    cursor: default;
`
  , H3 = xt => {
    const [Cn] = useI18n();
    return createComponent(H3Styled$1, {
        "data-tc-h3": "true",
        get class() {
            return xt.class
        },
        get children() {
            var as;
            return createMemo( () => !!xt.translationKey)() ? Cn(xt.translationKey, xt.translationValues, (as = xt.children) == null ? void 0 : as.toString()) : xt.children
        }
    })
}
  , _tmpl$$r = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.75 7.5C9.33579 7.5 9 7.16421 9 6.75C9 6.33579 9.33579 6 9.75 6H21.25C21.6642 6 22 6.33579 22 6.75V18.25C22 18.6642 21.6642 19 21.25 19C20.8358 19 20.5 18.6642 20.5 18.25V8.56066L6.28033 22.7803C5.98744 23.0732 5.51256 23.0732 5.21967 22.7803C4.92678 22.4874 4.92678 22.0126 5.21967 21.7197L19.4393 7.5H9.75Z"></path></svg>')
  , LongArrowIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.icon.secondary;
    return ( () => {
        const cs = _tmpl$$r.cloneNode(!0)
          , Cs = cs.firstChild;
        return createRenderEffect(Ls => {
            const Vs = as()
              , Ws = as();
            return Vs !== Ls._v$ && setAttribute(cs, "fill", Ls._v$ = Vs),
            Ws !== Ls._v$2 && setAttribute(Cs, "fill", Ls._v$2 = Ws),
            Ls
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        cs
    }
    )()
}
  , _tmpl$$q = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M14.1839 17.7069C13.6405 18.6507 13.3688 19.1226 13.0591 19.348C12.4278 19.8074 11.5723 19.8074 10.941 19.348C10.6312 19.1226 10.3595 18.6507 9.81613 17.7069L5.52066 10.2464C4.76864 8.94024 4.39263 8.28717 4.33762 7.75894C4.2255 6.68236 4.81894 5.65591 5.80788 5.21589C6.29309 5 7.04667 5 8.55383 5H15.4462C16.9534 5 17.7069 5 18.1922 5.21589C19.1811 5.65591 19.7745 6.68236 19.6624 7.75894C19.6074 8.28717 19.2314 8.94024 18.4794 10.2464L14.1839 17.7069ZM11.1 16.3412L6.56139 8.48002C6.31995 8.06185 6.19924 7.85276 6.18146 7.68365C6.14523 7.33896 6.33507 7.01015 6.65169 6.86919C6.80703 6.80002 7.04847 6.80002 7.53133 6.80002H7.53134L11.1 6.80002V16.3412ZM12.9 16.3412L17.4387 8.48002C17.6801 8.06185 17.8008 7.85276 17.8186 7.68365C17.8548 7.33896 17.665 7.01015 17.3484 6.86919C17.193 6.80002 16.9516 6.80002 16.4687 6.80002L12.9 6.80002V16.3412Z"></path></svg>')
  , TonIcon$1 = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.icon.primary;
    return ( () => {
        const cs = _tmpl$$q.cloneNode(!0)
          , Cs = cs.firstChild;
        return createRenderEffect( () => setAttribute(Cs, "fill", as())),
        cs
    }
    )()
}
  , _tmpl$$p = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><g clip-path="url(#clip0_3783_2045)"><circle cx="8" cy="8.00098" r="8"></circle><path d="M4.75 8.50098L7 10.751L11.75 6.00098" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></g><defs><clipPath id="clip0_3783_2045"><rect width="16" height="16" fill="white" transform="translate(0 0.000976562)"></rect></clipPath></defs></svg>')
  , _tmpl$2$3 = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="11"></circle><path d="M17.1364 9.6364C17.4879 9.28493 17.4879 8.71508 17.1364 8.36361C16.7849 8.01214 16.2151 8.01214 15.8636 8.36361L10 14.2272L8.1364 12.3636C7.78493 12.0121 7.21508 12.0121 6.86361 12.3636C6.51214 12.7151 6.51214 13.2849 6.86361 13.6364L9.36361 16.1364C9.71508 16.4879 10.2849 16.4879 10.6364 16.1364L17.1364 9.6364Z"></path></svg>')
  , _tmpl$3$2 = template$1('<svg width="72" height="72" viewBox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="36" cy="36" r="33"></circle><path d="M50.9142 28.4142C51.6953 27.6332 51.6953 26.3668 50.9142 25.5858C50.1332 24.8047 48.8668 24.8047 48.0858 25.5858L30 43.6716L23.9142 37.5858C23.1332 36.8047 21.8668 36.8047 21.0858 37.5858C20.3047 38.3668 20.3047 39.6332 21.0858 40.4142L28.5858 47.9142C29.3668 48.6953 30.6332 48.6953 31.4142 47.9142L50.9142 28.4142Z"></path></svg>')
  , SuccessIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.size || "s"
      , cs = () => xt.fill || Cn.colors.icon.success;
    return createMemo(( () => {
        const Cs = createMemo( () => as() === "xs");
        return () => Cs() ? ( () => {
            const Ls = _tmpl$$p.cloneNode(!0)
              , Vs = Ls.firstChild
              , Ws = Vs.firstChild
              , Xs = Ws.nextSibling;
            return createRenderEffect(ga => {
                const ba = xt.class
                  , yl = cs()
                  , xl = Cn.colors.constant.white;
                return ba !== ga._v$ && setAttribute(Ls, "class", ga._v$ = ba),
                yl !== ga._v$2 && setAttribute(Ws, "fill", ga._v$2 = yl),
                xl !== ga._v$3 && setAttribute(Xs, "stroke", ga._v$3 = xl),
                ga
            }
            , {
                _v$: void 0,
                _v$2: void 0,
                _v$3: void 0
            }),
            Ls
        }
        )() : ( () => {
            const Ls = createMemo( () => as() === "s");
            return () => Ls() ? ( () => {
                const Vs = _tmpl$2$3.cloneNode(!0)
                  , Ws = Vs.firstChild
                  , Xs = Ws.nextSibling;
                return createRenderEffect(ga => {
                    const ba = xt.class
                      , yl = cs()
                      , xl = Cn.colors.constant.white;
                    return ba !== ga._v$4 && setAttribute(Vs, "class", ga._v$4 = ba),
                    yl !== ga._v$5 && setAttribute(Ws, "fill", ga._v$5 = yl),
                    xl !== ga._v$6 && setAttribute(Xs, "fill", ga._v$6 = xl),
                    ga
                }
                , {
                    _v$4: void 0,
                    _v$5: void 0,
                    _v$6: void 0
                }),
                Vs
            }
            )() : ( () => {
                const Vs = _tmpl$3$2.cloneNode(!0)
                  , Ws = Vs.firstChild
                  , Xs = Ws.nextSibling;
                return createRenderEffect(ga => {
                    const ba = xt.class
                      , yl = cs()
                      , xl = Cn.colors.constant.white;
                    return ba !== ga._v$7 && setAttribute(Vs, "class", ga._v$7 = ba),
                    yl !== ga._v$8 && setAttribute(Ws, "fill", ga._v$8 = yl),
                    xl !== ga._v$9 && setAttribute(Xs, "fill", ga._v$9 = xl),
                    ga
                }
                , {
                    _v$7: void 0,
                    _v$8: void 0,
                    _v$9: void 0
                }),
                Vs
            }
            )()
        }
        )()
    }
    )())
}
  , _tmpl$$o = template$1('<svg width="72" height="72" viewBox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="36" cy="36" r="33"></circle><path d="M24.0858 26.9142C23.3047 26.1332 23.3047 24.8668 24.0858 24.0858C24.8668 23.3047 26.1332 23.3047 26.9142 24.0858L36 33.1716L45.0858 24.0858C45.8668 23.3047 47.1332 23.3047 47.9142 24.0858C48.6953 24.8668 48.6953 26.1332 47.9142 26.9142L38.8284 36L47.9142 45.0858C48.6953 45.8668 48.6953 47.1332 47.9142 47.9142C47.1332 48.6953 45.8668 48.6953 45.0858 47.9142L36 38.8284L26.9142 47.9142C26.1332 48.6953 24.8668 48.6953 24.0858 47.9142C23.3047 47.1332 23.3047 45.8668 24.0858 45.0858L33.1716 36L24.0858 26.9142Z"></path></svg>')
  , _tmpl$2$2 = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><circle cx="24" cy="24.001" r="22"></circle><path d="M24 24.001L31.5 16.501M24 24.001L16.5 16.501M24 24.001L16.5 31.501M24 24.001L31.5 31.501" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"></path></svg>')
  , _tmpl$3$1 = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="11"></circle><path d="M7.86361 9.1364C7.51214 8.78493 7.51214 8.21508 7.86361 7.86361C8.21508 7.51214 8.78493 7.51214 9.1364 7.86361L12 10.7272L14.8636 7.86361C15.2151 7.51214 15.7849 7.51214 16.1364 7.86361C16.4879 8.21508 16.4879 8.78493 16.1364 9.1364L13.2728 12L16.1364 14.8636C16.4879 15.2151 16.4879 15.7849 16.1364 16.1364C15.7849 16.4879 15.2151 16.4879 14.8636 16.1364L12 13.2728L9.1364 16.1364C8.78493 16.4879 8.21508 16.4879 7.86361 16.1364C7.51214 15.7849 7.51214 15.2151 7.86361 14.8636L10.7272 12L7.86361 9.1364Z"></path></svg>')
  , ErrorIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.size || "m"
      , cs = () => xt.fill || Cn.colors.icon.error;
    return createMemo(( () => {
        const Cs = createMemo( () => as() === "m");
        return () => Cs() ? ( () => {
            const Ls = _tmpl$$o.cloneNode(!0)
              , Vs = Ls.firstChild
              , Ws = Vs.nextSibling;
            return createRenderEffect(Xs => {
                const ga = xt.class
                  , ba = cs()
                  , yl = Cn.colors.constant.white;
                return ga !== Xs._v$ && setAttribute(Ls, "class", Xs._v$ = ga),
                ba !== Xs._v$2 && setAttribute(Vs, "fill", Xs._v$2 = ba),
                yl !== Xs._v$3 && setAttribute(Ws, "fill", Xs._v$3 = yl),
                Xs
            }
            , {
                _v$: void 0,
                _v$2: void 0,
                _v$3: void 0
            }),
            Ls
        }
        )() : ( () => {
            const Ls = createMemo( () => as() === "s");
            return () => Ls() ? ( () => {
                const Vs = _tmpl$2$2.cloneNode(!0)
                  , Ws = Vs.firstChild
                  , Xs = Ws.nextSibling;
                return createRenderEffect(ga => {
                    const ba = xt.class
                      , yl = cs()
                      , xl = Cn.colors.constant.white;
                    return ba !== ga._v$4 && setAttribute(Vs, "class", ga._v$4 = ba),
                    yl !== ga._v$5 && setAttribute(Ws, "fill", ga._v$5 = yl),
                    xl !== ga._v$6 && setAttribute(Xs, "stroke", ga._v$6 = xl),
                    ga
                }
                , {
                    _v$4: void 0,
                    _v$5: void 0,
                    _v$6: void 0
                }),
                Vs
            }
            )() : ( () => {
                const Vs = _tmpl$3$1.cloneNode(!0)
                  , Ws = Vs.firstChild
                  , Xs = Ws.nextSibling;
                return createRenderEffect(ga => {
                    const ba = xt.class
                      , yl = cs()
                      , xl = Cn.colors.constant.white;
                    return ba !== ga._v$7 && setAttribute(Vs, "class", ga._v$7 = ba),
                    yl !== ga._v$8 && setAttribute(Ws, "fill", ga._v$8 = yl),
                    xl !== ga._v$9 && setAttribute(Xs, "fill", ga._v$9 = xl),
                    ga
                }
                , {
                    _v$7: void 0,
                    _v$8: void 0,
                    _v$9: void 0
                }),
                Vs
            }
            )()
        }
        )()
    }
    )())
}
  , _tmpl$$n = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15.55 5.85123C18.9459 7.81184 20.1094 12.1541 18.1488 15.55C16.1882 18.9459 11.8459 20.1094 8.44998 18.1488C8.01952 17.9003 7.46909 18.0478 7.22056 18.4782C6.97203 18.9087 7.11952 19.4591 7.54998 19.7076C11.8068 22.1653 17.2499 20.7068 19.7076 16.45C22.1653 12.1932 20.7068 6.75005 16.45 4.29239C12.1932 1.83472 6.75003 3.29321 4.29236 7.55001C4.04383 7.98047 4.19132 8.53091 4.62178 8.77943C5.05224 9.02796 5.60268 8.88048 5.8512 8.45001C7.81181 5.05413 12.1541 3.89062 15.55 5.85123Z"></path></svg>')
  , _tmpl$2$1 = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="44" height="44" viewBox="0 0 44 44" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M22 2.99951C11.5066 2.99951 3 11.5061 3 21.9995C3 32.4929 11.5066 40.9995 22 40.9995C22.8284 40.9995 23.5 41.6711 23.5 42.4995C23.5 43.3279 22.8284 43.9995 22 43.9995C9.84974 43.9995 0 34.1498 0 21.9995C0 9.84925 9.84974 -0.000488281 22 -0.000488281C34.1503 -0.000488281 44 9.84925 44 21.9995C44 22.8279 43.3284 23.4995 42.5 23.4995C41.6716 23.4995 41 22.8279 41 21.9995C41 11.5061 32.4934 2.99951 22 2.99951Z"></path></svg>')
  , _tmpl$3 = template$1('<svg width="72" height="72" viewBox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M24 56.7846C35.479 63.412 50.1572 59.479 56.7846 47.9999C63.412 36.5209 59.479 21.8427 48 15.2153C36.521 8.58791 21.8428 12.5209 15.2154 23.9999" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"></path></svg>')
  , LoaderIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.size || "xs"
      , cs = () => xt.fill || Cn.colors.icon.tertiary
      , Cs = h$3`
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
    `
      , Ls = u$9`
        animation: ${Cs} 1s linear infinite;
    `;
    return createMemo(( () => {
        const Vs = createMemo( () => as() === "xs");
        return () => Vs() ? ( () => {
            const Ws = _tmpl$$n.cloneNode(!0)
              , Xs = Ws.firstChild;
            return createRenderEffect(ga => {
                const ba = classNames$1(Ls, xt.class)
                  , yl = cs();
                return ba !== ga._v$ && setAttribute(Ws, "class", ga._v$ = ba),
                yl !== ga._v$2 && setAttribute(Xs, "fill", ga._v$2 = yl),
                ga
            }
            , {
                _v$: void 0,
                _v$2: void 0
            }),
            Ws
        }
        )() : ( () => {
            const Ws = createMemo( () => as() === "s");
            return () => Ws() ? ( () => {
                const Xs = _tmpl$2$1.cloneNode(!0)
                  , ga = Xs.firstChild;
                return createRenderEffect(ba => {
                    const yl = classNames$1(Ls, xt.class)
                      , xl = cs();
                    return yl !== ba._v$3 && setAttribute(Xs, "class", ba._v$3 = yl),
                    xl !== ba._v$4 && setAttribute(ga, "fill", ba._v$4 = xl),
                    ba
                }
                , {
                    _v$3: void 0,
                    _v$4: void 0
                }),
                Xs
            }
            )() : ( () => {
                const Xs = _tmpl$3.cloneNode(!0)
                  , ga = Xs.firstChild;
                return createRenderEffect(ba => {
                    const yl = classNames$1(Ls, xt.class)
                      , xl = cs();
                    return yl !== ba._v$5 && setAttribute(Xs, "class", ba._v$5 = yl),
                    xl !== ba._v$6 && setAttribute(ga, "stroke", ba._v$6 = xl),
                    ba
                }
                , {
                    _v$5: void 0,
                    _v$6: void 0
                }),
                Xs
            }
            )()
        }
        )()
    }
    )())
}
  , _tmpl$$m = template$1('<svg width="158" height="28" viewBox="0 0 158 28" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M28 14.001C28 21.733 21.732 28.001 14 28.001C6.26801 28.001 0 21.733 0 14.001C0 6.26899 6.26801 0.000976562 14 0.000976562C21.732 0.000976562 28 6.26899 28 14.001ZM9.21931 8.00098H18.7801H18.7813C20.538 8.00098 21.6522 9.89966 20.7691 11.4302L14.8672 21.6576C14.4822 22.3254 13.5172 22.3254 13.1322 21.6576L7.23158 11.4302C6.34721 9.89726 7.4614 8.00098 9.21931 8.00098ZM13.1262 18.5882V9.74806H9.21811C8.78976 9.74806 8.53708 10.2029 8.74163 10.5578L11.8423 16.1035L13.1262 18.5882ZM16.1559 16.1047L19.2554 10.5566C19.4599 10.2017 19.2073 9.74685 18.7789 9.74685H14.8709V18.5906L16.1559 16.1047Z" fill="#0098EA"></path><path d="M18.7802 8.00098H9.21936C7.46145 8.00098 6.34727 9.89726 7.23164 11.4302L13.1322 21.6576C13.5173 22.3254 14.4823 22.3254 14.8673 21.6576L20.7691 11.4302C21.6523 9.89966 20.5381 8.00098 18.7814 8.00098H18.7802ZM13.1274 18.5906L11.8424 16.1035L8.74168 10.5578C8.53714 10.2029 8.78981 9.74806 9.21816 9.74806H13.1262V18.5918L13.1274 18.5906ZM19.2555 10.5566L16.156 16.1047L14.8709 18.5906V9.74685H18.779C19.2073 9.74685 19.46 10.2017 19.2555 10.5566Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M51.7483 22.1967C55.7182 22.1967 58.9609 18.954 58.9609 14.9841C58.9609 11.0142 55.7182 7.77148 51.7483 7.77148C47.7588 7.77148 44.5357 11.0142 44.5357 14.9841C44.5357 18.954 47.7588 22.1967 51.7483 22.1967ZM51.7483 19.1702C49.4686 19.1702 47.6802 17.2442 47.6802 14.9841C47.6802 12.724 49.4686 10.798 51.7483 10.798C54.0084 10.798 55.7968 12.724 55.7968 14.9841C55.7968 17.2442 54.0084 19.1702 51.7483 19.1702ZM37.0698 21.9609H40.2142V10.9946H44.2843V8.00732H33V10.9946H37.0698V21.9609ZM69.9379 8.00732H73.0823V21.9609H70.3899L63.59 13.3333V21.9609H60.4652V8.00732H63.1576L69.9379 16.6153V8.00732ZM79.2259 14.9887C79.2259 10.9202 82.351 7.77539 86.4982 7.77539C89.8592 7.77539 92.5519 9.95709 93.2202 12.6891H90.7437C90.154 11.0971 88.4637 9.9964 86.4982 9.9964C83.5893 9.9964 81.5452 12.1781 81.5452 14.9887C81.5452 17.7994 83.5893 19.9811 86.4982 19.9811C88.4637 19.9811 90.154 18.8804 90.7437 17.2884H93.2202C92.5519 20.0204 89.8592 22.2021 86.4982 22.2021C82.351 22.2021 79.2259 19.0573 79.2259 14.9887ZM104.584 17.0525C104.584 19.9025 102.343 22.1628 99.4342 22.1628C96.5253 22.1628 94.2846 19.9025 94.2846 17.0525C94.2846 14.2025 96.5253 11.9422 99.4342 11.9422C102.343 11.9422 104.584 14.2025 104.584 17.0525ZM96.4663 17.0525C96.4663 18.8018 97.6849 20.158 99.4342 20.158C101.164 20.158 102.382 18.8018 102.382 17.0525C102.382 15.3032 101.164 13.947 99.4342 13.947C97.6849 13.947 96.4663 15.3032 96.4663 17.0525ZM108.626 12.1388H106.463V21.9662H108.626V17.1311C108.626 15.0281 109.726 13.9077 111.161 13.9077C112.419 13.9077 113.205 14.8512 113.205 16.4039V21.9662H115.367V16.0501C115.367 13.5539 113.893 11.9422 111.613 11.9422C110.335 11.9422 109.215 12.4926 108.626 13.4753V12.1388ZM117.839 12.1388H120.001V13.4753C120.59 12.4926 121.711 11.9422 122.988 11.9422C125.268 11.9422 126.742 13.5539 126.742 16.0501V21.9662H124.58V16.4039C124.58 14.8512 123.794 13.9077 122.536 13.9077C121.101 13.9077 120.001 15.0281 120.001 17.1311V21.9662H117.839V12.1388ZM133.558 22.1628C136.054 22.1628 137.823 20.728 138.373 18.8804H136.113C135.661 19.8238 134.717 20.2563 133.636 20.2563C131.887 20.2563 130.747 19.077 130.668 17.5832H138.491C138.688 14.2419 136.585 11.9422 133.577 11.9422C130.551 11.9422 128.526 14.1436 128.526 17.0525C128.526 20.0007 130.629 22.1628 133.558 22.1628ZM130.747 16.0501C131.042 14.5367 132.162 13.7505 133.518 13.7505C134.717 13.7505 135.838 14.4581 136.172 16.0501H130.747ZM149.851 18.3694C149.32 20.5511 147.453 22.1628 144.859 22.1628C141.871 22.1628 139.709 19.8828 139.709 17.0525C139.709 14.2222 141.871 11.9422 144.859 11.9422C147.453 11.9422 149.32 13.5539 149.851 15.7356H147.571C147.178 14.6743 146.215 13.9077 144.859 13.9077C143.109 13.9077 141.91 15.2246 141.91 17.0525C141.91 18.8804 143.109 20.1973 144.859 20.1973C146.215 20.1973 147.178 19.4307 147.571 18.3694H149.851ZM155.75 22.0645C156.418 22.0645 156.929 21.9859 157.362 21.8483V19.9221C157.047 20.0401 156.615 20.1187 156.202 20.1187C155.082 20.1187 154.551 19.6666 154.551 18.448V14.065H157.362V12.1388H154.551V9.40675H152.389V12.1388H150.345V14.065H152.389V18.8018C152.389 21.0228 153.863 22.0645 155.75 22.0645Z"></path></svg>')
  , TonConnectBrand = () => {
    const xt = useTheme()
      , Cn = () => xt.theme === THEME.DARK ? xt.colors.constant.white : xt.colors.constant.black;
    return ( () => {
        const as = _tmpl$$m.cloneNode(!0)
          , cs = as.firstChild
          , Cs = cs.nextSibling
          , Ls = Cs.nextSibling;
        return createRenderEffect( () => setAttribute(Ls, "fill", Cn())),
        as
    }
    )()
}
  , _tmpl$$l = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M5.56608 4.42584C5.82527 3.32158 6.8176 2.5 8.00001 2.5C9.38072 2.5 10.5 3.61929 10.5 5C10.5 5.63026 10.3391 6.0386 10.1264 6.34455C9.90018 6.66993 9.58561 6.92478 9.18864 7.20877C9.12579 7.25372 9.05873 7.30025 8.9887 7.34883C8.27392 7.84472 7.25001 8.55507 7.25001 10V10.25C7.25001 10.6642 7.5858 11 8.00001 11C8.41422 11 8.75001 10.6642 8.75001 10.25V10C8.75001 9.36502 9.10777 9.1096 9.94554 8.51149L10.0614 8.42873C10.4769 8.13147 10.9748 7.75194 11.358 7.20076C11.7547 6.63015 12 5.91973 12 5C12 2.79086 10.2091 1 8.00001 1C6.10564 1 4.5205 2.31615 4.10577 4.08308C4.01112 4.48634 4.26129 4.88997 4.66454 4.98462C5.0678 5.07927 5.47143 4.8291 5.56608 4.42584ZM8.00001 15C8.60752 15 9.10001 14.5075 9.10001 13.9C9.10001 13.2925 8.60752 12.8 8.00001 12.8C7.39249 12.8 6.90001 13.2925 6.90001 13.9C6.90001 14.5075 7.39249 15 8.00001 15Z"></path></svg>')
  , QuestionIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.icon.secondary;
    return ( () => {
        const cs = _tmpl$$l.cloneNode(!0)
          , Cs = cs.firstChild;
        return createRenderEffect( () => setAttribute(Cs, "fill", as())),
        cs
    }
    )()
}
  , _tmpl$$k = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.98156 8.75C9.84854 11.4328 9.01206 13.5 8 13.5C6.98794 13.5 6.15146 11.4328 6.01844 8.75H9.98156ZM11.4832 8.75C11.4217 10.1155 11.1929 11.3869 10.8239 12.4017C10.7734 12.5405 10.7188 12.6789 10.6595 12.8154C12.1454 11.993 13.2103 10.5029 13.4493 8.75H11.4832ZM13.4493 7.25H11.4832C11.4217 5.88453 11.1929 4.61314 10.8239 3.5983C10.7734 3.4595 10.7188 3.32111 10.6595 3.18459C12.1454 4.00697 13.2103 5.49709 13.4493 7.25ZM9.98156 7.25H6.01844C6.15144 4.56764 6.98769 2.50062 7.99955 2.5H8C9.01206 2.5 9.84854 4.56724 9.98156 7.25ZM4.51678 7.25C4.57826 5.88453 4.80706 4.61314 5.1761 3.5983C5.22657 3.4595 5.28124 3.32111 5.3405 3.18459C3.85463 4.00697 2.78972 5.49709 2.55071 7.25H4.51678ZM2.55071 8.75C2.78972 10.5029 3.85463 11.993 5.3405 12.8154C5.28124 12.6789 5.22657 12.5405 5.1761 12.4017C4.80706 11.3869 4.57826 10.1155 4.51678 8.75H2.55071ZM15 8C15 11.866 11.866 15 8 15C4.13401 15 1 11.866 1 8C1 4.13401 4.13401 1 8 1C11.866 1 15 4.13401 15 8Z"></path></svg>')
  , BrowserIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.icon.primary;
    return ( () => {
        const cs = _tmpl$$k.cloneNode(!0)
          , Cs = cs.firstChild;
        return createRenderEffect( () => setAttribute(Cs, "fill", as())),
        cs
    }
    )()
}
  , _tmpl$$j = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M2.5 4.8C2.5 3.11984 2.5 2.27976 2.82698 1.63803C3.1146 1.07354 3.57354 0.614601 4.13803 0.32698C4.77976 0 5.61984 0 7.3 0H8.7C10.3802 0 11.2202 0 11.862 0.32698C12.4265 0.614601 12.8854 1.07354 13.173 1.63803C13.5 2.27976 13.5 3.11984 13.5 4.8V11.2C13.5 12.8802 13.5 13.7202 13.173 14.362C12.8854 14.9265 12.4265 15.3854 11.862 15.673C11.2202 16 10.3802 16 8.7 16H7.3C5.61984 16 4.77976 16 4.13803 15.673C3.57354 15.3854 3.1146 14.9265 2.82698 14.362C2.5 13.7202 2.5 12.8802 2.5 11.2V4.8ZM4 3.9C4 3.05992 4 2.63988 4.16349 2.31901C4.3073 2.03677 4.53677 1.8073 4.81901 1.66349C5.13988 1.5 5.55992 1.5 6.4 1.5H9.6C10.4401 1.5 10.8601 1.5 11.181 1.66349C11.4632 1.8073 11.6927 2.03677 11.8365 2.31901C12 2.63988 12 3.05992 12 3.9V12.1C12 12.9401 12 13.3601 11.8365 13.681C11.6927 13.9632 11.4632 14.1927 11.181 14.3365C10.8601 14.5 10.4401 14.5 9.6 14.5H6.4C5.55992 14.5 5.13988 14.5 4.81901 14.3365C4.53677 14.1927 4.3073 13.9632 4.16349 13.681C4 13.3601 4 12.9401 4 12.1V3.9ZM7 2.5C6.58579 2.5 6.25 2.83579 6.25 3.25C6.25 3.66421 6.58579 4 7 4H9C9.41421 4 9.75 3.66421 9.75 3.25C9.75 2.83579 9.41421 2.5 9 2.5H7Z"></path></svg>')
  , MobileIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.icon.primary;
    return ( () => {
        const cs = _tmpl$$j.cloneNode(!0)
          , Cs = cs.firstChild;
        return createRenderEffect( () => setAttribute(Cs, "fill", as())),
        cs
    }
    )()
}
  , _tmpl$$i = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 6.8C1.5 5.11984 1.5 4.27976 1.82698 3.63803C2.1146 3.07354 2.57354 2.6146 3.13803 2.32698C3.77976 2 4.61984 2 6.3 2H9.7C11.3802 2 12.2202 2 12.862 2.32698C13.4265 2.6146 13.8854 3.07354 14.173 3.63803C14.5 4.27976 14.5 5.11984 14.5 6.8V11.5H15.25C15.6642 11.5 16 11.8358 16 12.25C16 12.6642 15.6642 13 15.25 13H0.75C0.335786 13 0 12.6642 0 12.25C0 11.8358 0.335786 11.5 0.75 11.5H1.5V6.8ZM3 11.5H13V5.9C13 5.05992 13 4.63988 12.8365 4.31901C12.6927 4.03677 12.4632 3.8073 12.181 3.66349C11.8601 3.5 11.4401 3.5 10.6 3.5H5.4C4.55992 3.5 4.13988 3.5 3.81901 3.66349C3.53677 3.8073 3.3073 4.03677 3.16349 4.31901C3 4.63988 3 5.05992 3 5.9V11.5Z"></path></svg>')
  , DesktopIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.icon.primary;
    return ( () => {
        const cs = _tmpl$$i.cloneNode(!0)
          , Cs = cs.firstChild;
        return createRenderEffect( () => setAttribute(Cs, "fill", as())),
        cs
    }
    )()
}
  , _tmpl$$h = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="17" height="16" viewBox="0 0 17 16" fill="none"><g clip-path="url(#clip0_3676_1603)"><path fill-rule="evenodd" clip-rule="evenodd" d="M15.5 1.25049C15.5 0.836275 15.1642 0.500488 14.75 0.500488C14.3358 0.500488 14 0.836275 14 1.25049V3.67012C12.7187 2.04487 10.7318 1.00049 8.5 1.00049C4.63401 1.00049 1.5 4.1345 1.5 8.00049C1.5 11.8665 4.63401 15.0005 8.5 15.0005C11.6844 15.0005 14.3703 12.8748 15.2199 9.96661C15.3361 9.56902 15.1079 9.15254 14.7103 9.03638C14.3127 8.92023 13.8962 9.14838 13.7801 9.54597C13.1123 11.8319 11 13.5005 8.5 13.5005C5.46243 13.5005 3 11.0381 3 8.00049C3 4.96292 5.46243 2.50049 8.5 2.50049C10.321 2.50049 11.9363 3.3855 12.9377 4.75049H10.5C10.0858 4.75049 9.75 5.08627 9.75 5.50049C9.75 5.9147 10.0858 6.25049 10.5 6.25049H14.75C15.1642 6.25049 15.5 5.9147 15.5 5.50049V1.25049Z"></path></g><defs><clipPath id="clip0_3676_1603"><rect width="16" height="16" fill="white" transform="translate(0.5 0.000488281)"></rect></clipPath></defs></svg>')
  , RetryIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.accent;
    return ( () => {
        const cs = _tmpl$$h.cloneNode(!0)
          , Cs = cs.firstChild
          , Ls = Cs.firstChild;
        return createRenderEffect( () => setAttribute(Ls, "fill", as())),
        cs
    }
    )()
}
  , _tmpl$$g = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M13 4.06119V6.75053C13 7.16474 13.3358 7.50053 13.75 7.50053C14.1642 7.50053 14.5 7.16474 14.5 6.75053V2.75053L14.5 2.72807C14.5001 2.63191 14.5003 2.49627 14.4842 2.37627C14.4638 2.22503 14.4063 1.99261 14.2071 1.79342C14.0079 1.59423 13.7755 1.5367 13.6243 1.51637C13.5043 1.50023 13.3686 1.50039 13.2725 1.50051L13.25 1.50053H9.25C8.83579 1.50053 8.5 1.83631 8.5 2.25053C8.5 2.66474 8.83579 3.00053 9.25 3.00053H11.9393L7.21967 7.7202C6.92678 8.01309 6.92678 8.48796 7.21967 8.78086C7.51256 9.07375 7.98744 9.07375 8.28033 8.78086L13 4.06119ZM5.85 1.50053H5.81903H5.81899C5.21528 1.50052 4.71702 1.50051 4.31113 1.53367C3.88956 1.56812 3.50203 1.64204 3.13803 1.82751C2.57354 2.11513 2.1146 2.57407 1.82698 3.13856C1.64151 3.50256 1.56759 3.89009 1.53315 4.31166C1.49998 4.71755 1.49999 5.21581 1.5 5.81953V5.81955V5.85053V10.1505V10.1815V10.1815C1.49999 10.7852 1.49998 11.2835 1.53315 11.6894C1.56759 12.111 1.64151 12.4985 1.82698 12.8625C2.1146 13.427 2.57354 13.8859 3.13803 14.1735C3.50203 14.359 3.88956 14.4329 4.31113 14.4674C4.71702 14.5005 5.21527 14.5005 5.81897 14.5005H5.81901H5.85H10.15H10.181H10.181C10.7847 14.5005 11.283 14.5005 11.6889 14.4674C12.1104 14.4329 12.498 14.359 12.862 14.1735C13.4265 13.8859 13.8854 13.427 14.173 12.8625C14.3585 12.4985 14.4324 12.111 14.4669 11.6894C14.5 11.2835 14.5 10.7853 14.5 10.1816V10.1815V10.1505V9.75053C14.5 9.33631 14.1642 9.00053 13.75 9.00053C13.3358 9.00053 13 9.33631 13 9.75053V10.1505C13 10.793 12.9994 11.2297 12.9718 11.5672C12.945 11.8961 12.8963 12.0642 12.8365 12.1815C12.6927 12.4638 12.4632 12.6932 12.181 12.837C12.0637 12.8968 11.8955 12.9455 11.5667 12.9724C11.2292 12.9999 10.7924 13.0005 10.15 13.0005H5.85C5.20757 13.0005 4.77085 12.9999 4.43328 12.9724C4.10447 12.9455 3.93632 12.8968 3.81902 12.837C3.53677 12.6932 3.3073 12.4638 3.16349 12.1815C3.10372 12.0642 3.05503 11.8961 3.02816 11.5672C3.00058 11.2297 3 10.793 3 10.1505V5.85053C3 5.20809 3.00058 4.77137 3.02816 4.43381C3.05503 4.10499 3.10372 3.93684 3.16349 3.81954C3.3073 3.5373 3.53677 3.30783 3.81902 3.16402C3.93632 3.10425 4.10447 3.05556 4.43328 3.02869C4.77085 3.00111 5.20757 3.00053 5.85 3.00053H6.25C6.66422 3.00053 7 2.66474 7 2.25053C7 1.83631 6.66422 1.50053 6.25 1.50053H5.85Z"></path></svg>')
  , LinkIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.accent;
    return ( () => {
        const cs = _tmpl$$g.cloneNode(!0)
          , Cs = cs.firstChild;
        return createRenderEffect( () => setAttribute(Cs, "fill", as())),
        cs
    }
    )()
}
  , _tmpl$$f = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="17" height="16" viewBox="0 0 17 16" fill="none"><g clip-path="url(#clip0_3676_1274)"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.82698 2.63901C1.5 3.28074 1.5 4.12082 1.5 5.80098V8.80098V9.00098V10.201C1.5 11.8811 1.5 12.7212 1.82698 13.3629C2.1146 13.9274 2.57354 14.3864 3.13803 14.674C3.77976 15.001 4.61984 15.001 6.3 15.001H11.7C13.3802 15.001 14.2202 15.001 14.862 14.674C15.4265 14.3864 15.8854 13.9274 16.173 13.3629C16.5 12.7212 16.5 11.8811 16.5 10.201V8.80098C16.5 7.12082 16.5 6.28074 16.173 5.63901C15.8854 5.07452 15.4265 4.61558 14.862 4.32796C14.743 4.26733 14.6172 4.21795 14.4805 4.17772C14.4501 3.49449 14.3722 3.02994 14.173 2.63901C13.8854 2.07452 13.4265 1.61558 12.862 1.32796C12.2202 1.00098 11.3802 1.00098 9.7 1.00098H6.3C4.61984 1.00098 3.77976 1.00098 3.13803 1.32796C2.57354 1.61558 2.1146 2.07452 1.82698 2.63901ZM12.9861 4.00942C12.9684 3.7108 12.9281 3.49982 12.8365 3.31999C12.6927 3.03775 12.4632 2.80828 12.181 2.66447C11.8601 2.50098 11.4401 2.50098 10.6 2.50098H5.4C4.55992 2.50098 4.13988 2.50098 3.81901 2.66447C3.53677 2.80828 3.3073 3.03775 3.16349 3.31999C3.03615 3.56991 3.00799 3.88 3.00177 4.40188C3.04646 4.37612 3.09189 4.35146 3.13803 4.32796C3.77976 4.00098 4.61984 4.00098 6.3 4.00098H11.7C12.1966 4.00098 12.6197 4.00098 12.9861 4.00942ZM3 7.90098V8.10098C3 8.47468 3 8.76527 3.01439 9.00098H3V11.101C3 11.9411 3 12.3611 3.16349 12.682C3.3073 12.9642 3.53677 13.1937 3.81901 13.3375C4.13988 13.501 4.55992 13.501 5.4 13.501H12.6C13.4401 13.501 13.8601 13.501 14.181 13.3375C14.4632 13.1937 14.6927 12.9642 14.8365 12.682C15 12.3611 15 11.9411 15 11.101V7.90098C15 7.0609 15 6.64086 14.8365 6.31999C14.6927 6.03775 14.4632 5.80828 14.181 5.66447C13.8601 5.50098 13.4401 5.50098 12.6 5.50098H5.4C4.55992 5.50098 4.13988 5.50098 3.81901 5.66447C3.53677 5.80828 3.3073 6.03775 3.16349 6.31999C3 6.64086 3 7.0609 3 7.90098ZM10.5 9.75098C10.5 9.33676 10.8358 9.00098 11.25 9.00098H12.75C13.1642 9.00098 13.5 9.33676 13.5 9.75098C13.5 10.1652 13.1642 10.501 12.75 10.501H11.25C10.8358 10.501 10.5 10.1652 10.5 9.75098Z"></path></g><defs><clipPath id="clip0_3676_1274"><rect width="16" height="16" fill="white" transform="translate(0.5 0.000976562)"></rect></clipPath></defs></svg>')
  , WalletIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.accent;
    return ( () => {
        const cs = _tmpl$$f.cloneNode(!0)
          , Cs = cs.firstChild
          , Ls = Cs.firstChild;
        return createRenderEffect( () => setAttribute(Ls, "fill", as())),
        cs
    }
    )()
}
  , _tmpl$$e = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M39.6319 16.8719C38.3212 16.2041 36.7002 16.0478 34 16.0112V11C34 5.47715 29.5228 1 24 1C18.4772 1 14 5.47715 14 11V16.0112C11.2998 16.0478 9.6788 16.2041 8.36808 16.8719C6.86278 17.6389 5.63893 18.8628 4.87195 20.3681C4 22.0794 4 24.3196 4 28.8V32.2C4 36.6804 4 38.9206 4.87195 40.6319C5.63893 42.1372 6.86278 43.3611 8.36808 44.1281C10.0794 45 12.3196 45 16.8 45H31.2C35.6804 45 37.9206 45 39.6319 44.1281C41.1372 43.3611 42.3611 42.1372 43.1281 40.6319C44 38.9206 44 36.6804 44 32.2V28.8C44 24.3196 44 22.0794 43.1281 20.3681C42.3611 18.8628 41.1372 17.6389 39.6319 16.8719ZM31 11V16H17V11C17 7.13401 20.134 4 24 4C27.866 4 31 7.13401 31 11ZM7.54497 21.73C7 22.7996 7 24.1997 7 27V34C7 36.8003 7 38.2004 7.54497 39.27C8.02433 40.2108 8.78924 40.9757 9.73005 41.455C10.7996 42 12.1997 42 15 42H33C35.8003 42 37.2004 42 38.27 41.455C39.2108 40.9757 39.9757 40.2108 40.455 39.27C41 38.2004 41 36.8003 41 34V27C41 24.1997 41 22.7996 40.455 21.73C39.9757 20.7892 39.2108 20.0243 38.27 19.545C37.2004 19 35.8003 19 33 19H15C12.1997 19 10.7996 19 9.73005 19.545C8.78924 20.0243 8.02433 20.7892 7.54497 21.73ZM24 24C23.1716 24 22.5 24.6716 22.5 25.5V29.5C22.5 30.3284 23.1716 31 24 31C24.8284 31 25.5 30.3284 25.5 29.5V25.5C25.5 24.6716 24.8284 24 24 24Z"></path></svg>')
  , SecurityIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.icon.secondary;
    return ( () => {
        const cs = _tmpl$$e.cloneNode(!0)
          , Cs = cs.firstChild;
        return createRenderEffect(Ls => {
            const Vs = xt.class
              , Ws = as();
            return Vs !== Ls._v$ && setAttribute(cs, "class", Ls._v$ = Vs),
            Ws !== Ls._v$2 && setAttribute(Cs, "fill", Ls._v$2 = Ws),
            Ls
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        cs
    }
    )()
}
  , _tmpl$$d = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M37.485 37.3849C40.894 33.9506 43 29.2212 43 24C43 13.5066 34.4934 5 24 5C13.5066 5 5 13.5066 5 24C5 29.2213 7.1061 33.9507 10.5151 37.385C13.3583 32.9438 18.3354 30 24.0001 30C29.6647 30 34.6418 32.9437 37.485 37.3849ZM35.1809 39.3635C32.9143 35.5532 28.7554 33 24.0001 33C19.2448 33 15.0858 35.5533 12.8193 39.3636C15.9564 41.6506 19.8206 43 24 43C28.1795 43 32.0437 41.6505 35.1809 39.3635ZM24 46C36.1503 46 46 36.1503 46 24C46 11.8497 36.1503 2 24 2C11.8497 2 2 11.8497 2 24C2 36.1503 11.8497 46 24 46ZM24 24C26.7614 24 29 21.7614 29 19C29 16.2386 26.7614 14 24 14C21.2386 14 19 16.2386 19 19C19 21.7614 21.2386 24 24 24ZM24 27C28.4183 27 32 23.4183 32 19C32 14.5817 28.4183 11 24 11C19.5817 11 16 14.5817 16 19C16 23.4183 19.5817 27 24 27Z"></path></svg>')
  , PersonalityIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.icon.secondary;
    return ( () => {
        const cs = _tmpl$$d.cloneNode(!0)
          , Cs = cs.firstChild;
        return createRenderEffect(Ls => {
            const Vs = xt.class
              , Ws = as();
            return Vs !== Ls._v$ && setAttribute(cs, "class", Ls._v$ = Vs),
            Ws !== Ls._v$2 && setAttribute(Cs, "fill", Ls._v$2 = Ws),
            Ls
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        cs
    }
    )()
}
  , _tmpl$$c = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M34.5607 4.43934C33.9749 3.85355 33.0251 3.85355 32.4393 4.43934C31.8536 5.02513 31.8536 5.97487 32.4393 6.56066L37.8787 12H10.5C9.67157 12 9 12.6716 9 13.5C9 14.3284 9.67157 15 10.5 15H37.8787L32.4393 20.4393C31.8536 21.0251 31.8536 21.9749 32.4393 22.5607C33.0251 23.1464 33.9749 23.1464 34.5607 22.5607L42.5607 14.5607C43.1464 13.9749 43.1464 13.0251 42.5607 12.4393L34.5607 4.43934ZM13.4393 25.4393C14.0251 24.8536 14.9749 24.8536 15.5607 25.4393C16.1464 26.0251 16.1464 26.9749 15.5607 27.5607L10.1213 33H37.5C38.3284 33 39 33.6716 39 34.5C39 35.3284 38.3284 36 37.5 36H10.1213L15.5607 41.4393C16.1464 42.0251 16.1464 42.9749 15.5607 43.5607C14.9749 44.1464 14.0251 44.1464 13.4393 43.5607L5.43934 35.5607C4.85355 34.9749 4.85355 34.0251 5.43934 33.4393L13.4393 25.4393Z"></path></svg>')
  , SwapIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.icon.secondary;
    return ( () => {
        const cs = _tmpl$$c.cloneNode(!0)
          , Cs = cs.firstChild;
        return createRenderEffect(Ls => {
            const Vs = xt.class
              , Ws = as();
            return Vs !== Ls._v$ && setAttribute(cs, "class", Ls._v$ = Vs),
            Ws !== Ls._v$2 && setAttribute(Cs, "fill", Ls._v$2 = Ws),
            Ls
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        cs
    }
    )()
}
  , _tmpl$$b = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="29" viewBox="0 0 28 29" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.75 12.002C1.75 9.20169 1.75 7.80156 2.29497 6.732C2.77433 5.79119 3.53924 5.02629 4.48005 4.54692C5.54961 4.00195 6.94974 4.00195 9.75 4.00195H17.25C20.0503 4.00195 21.4504 4.00195 22.52 4.54692C23.4608 5.02629 24.2257 5.79119 24.705 6.732C24.8256 6.96861 24.9195 7.2214 24.9926 7.50195H21.5C19.6377 7.50195 18.7065 7.50195 17.9609 7.77334C16.711 8.22828 15.7263 9.21291 15.2714 10.4629C15 11.2085 15 12.1396 15 14.002C15 15.8643 15 16.7954 15.2714 17.541C15.7263 18.791 16.711 19.7756 17.9609 20.2306C18.7065 20.502 19.6377 20.502 21.5 20.502H24.9926C24.9195 20.7825 24.8256 21.0353 24.705 21.2719C24.2257 22.2127 23.4608 22.9776 22.52 23.457C21.4504 24.002 20.0503 24.002 17.25 24.002H9.75C6.94974 24.002 5.54961 24.002 4.48005 23.457C3.53924 22.9776 2.77433 22.2127 2.29497 21.2719C1.75 20.2023 1.75 18.8022 1.75 16.002V12.002ZM16.4999 13.802C16.4999 12.1218 16.4999 11.2817 16.8269 10.64C17.1145 10.0755 17.5735 9.61656 18.138 9.32894C18.7797 9.00196 19.6198 9.00196 21.2999 9.00196H23.1999C24.8801 9.00196 25.7202 9.00196 26.3619 9.32894C26.9264 9.61656 27.3853 10.0755 27.673 10.64C27.9999 11.2817 27.9999 12.1218 27.9999 13.802V14.202C27.9999 15.8821 27.9999 16.7222 27.673 17.3639C27.3853 17.9284 26.9264 18.3874 26.3619 18.675C25.7202 19.002 24.8801 19.002 23.1999 19.002H21.2999C19.6198 19.002 18.7797 19.002 18.138 18.675C17.5735 18.3874 17.1145 17.9284 16.8269 17.3639C16.4999 16.7222 16.4999 15.8821 16.4999 14.202V13.802ZM22.4999 14.002C22.4999 14.9685 21.7164 15.752 20.7499 15.752C19.7834 15.752 18.9999 14.9685 18.9999 14.002C18.9999 13.0355 19.7834 12.252 20.7499 12.252C21.7164 12.252 22.4999 13.0355 22.4999 14.002Z"></path></svg>')
  , AtWalletIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.constant.white;
    return ( () => {
        const cs = _tmpl$$b.cloneNode(!0)
          , Cs = cs.firstChild;
        return createRenderEffect(Ls => {
            const Vs = xt.class
              , Ws = as();
            return Vs !== Ls._v$ && setAttribute(cs, "class", Ls._v$ = Vs),
            Ws !== Ls._v$2 && setAttribute(Cs, "fill", Ls._v$2 = Ws),
            Ls
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        cs
    }
    )()
}
  , _tmpl$$a = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M24.7803 7.21967C25.0732 7.51256 25.0732 7.98744 24.7803 8.28033L11.5303 21.5303C11.2374 21.8232 10.7626 21.8232 10.4697 21.5303L4.21967 15.2803C3.92678 14.9874 3.92678 14.5126 4.21967 14.2197C4.51256 13.9268 4.98744 13.9268 5.28033 14.2197L11 19.9393L23.7197 7.21967C24.0126 6.92678 24.4874 6.92678 24.7803 7.21967Z"></path></svg>')
  , DoneIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.icon.secondary;
    return ( () => {
        const cs = _tmpl$$a.cloneNode(!0)
          , Cs = cs.firstChild;
        return createRenderEffect(Ls => {
            const Vs = xt.class
              , Ws = as();
            return Vs !== Ls._v$ && setAttribute(cs, "class", Ls._v$ = Vs),
            Ws !== Ls._v$2 && setAttribute(Cs, "fill", Ls._v$2 = Ws),
            Ls
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        cs
    }
    )()
}
  , _tmpl$$9 = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.0001 10.0001C10.0016 8.02333 10.0267 6.98719 10.436 6.18404C10.8195 5.43139 11.4314 4.81947 12.184 4.43597C13.0397 4 14.1598 4 16.4 4H17.6C19.8402 4 20.9603 4 21.816 4.43597C22.5686 4.81947 23.1805 5.43139 23.564 6.18404C24 7.03969 24 8.15979 24 10.4V11.6C24 13.8402 24 14.9603 23.564 15.816C23.1805 16.5686 22.5686 17.1805 21.816 17.564C21.0128 17.9733 19.9767 17.9984 17.9999 17.9999C17.9984 19.9767 17.9733 21.0128 17.564 21.816C17.1805 22.5686 16.5686 23.1805 15.816 23.564C14.9603 24 13.8402 24 11.6 24H10.4C8.15979 24 7.03969 24 6.18404 23.564C5.43139 23.1805 4.81947 22.5686 4.43597 21.816C4 20.9603 4 19.8402 4 17.6V16.4C4 14.1598 4 13.0397 4.43597 12.184C4.81947 11.4314 5.43139 10.8195 6.18404 10.436C6.98719 10.0267 8.02333 10.0016 10.0001 10.0001ZM10 11.5H9.5C8.09987 11.5 7.3998 11.5 6.86502 11.7725C6.39462 12.0122 6.01217 12.3946 5.77248 12.865C5.5 13.3998 5.5 14.0999 5.5 15.5V18.5C5.5 19.9001 5.5 20.6002 5.77248 21.135C6.01217 21.6054 6.39462 21.9878 6.86502 22.2275C7.3998 22.5 8.09987 22.5 9.5 22.5H12.5C13.9001 22.5 14.6002 22.5 15.135 22.2275C15.6054 21.9878 15.9878 21.6054 16.2275 21.135C16.5 20.6002 16.5 19.9001 16.5 18.5V18H16.4C14.1598 18 13.0397 18 12.184 17.564C11.4314 17.1805 10.8195 16.5686 10.436 15.816C10 14.9603 10 13.8402 10 11.6V11.5ZM11.5 9.5C11.5 8.09987 11.5 7.3998 11.7725 6.86502C12.0122 6.39462 12.3946 6.01217 12.865 5.77248C13.3998 5.5 14.0999 5.5 15.5 5.5H18.5C19.9001 5.5 20.6002 5.5 21.135 5.77248C21.6054 6.01217 21.9878 6.39462 22.2275 6.86502C22.5 7.3998 22.5 8.09987 22.5 9.5V12.5C22.5 13.9001 22.5 14.6002 22.2275 15.135C21.9878 15.6054 21.6054 15.9878 21.135 16.2275C20.6002 16.5 19.9001 16.5 18.5 16.5H15.5C14.0999 16.5 13.3998 16.5 12.865 16.2275C12.3946 15.9878 12.0122 15.6054 11.7725 15.135C11.5 14.6002 11.5 13.9001 11.5 12.5V9.5Z"></path></svg>')
  , CopyLightIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.icon.secondary;
    return ( () => {
        const cs = _tmpl$$9.cloneNode(!0)
          , Cs = cs.firstChild;
        return createRenderEffect(Ls => {
            const Vs = as()
              , Ws = as();
            return Vs !== Ls._v$ && setAttribute(cs, "fill", Ls._v$ = Vs),
            Ws !== Ls._v$2 && setAttribute(Cs, "fill", Ls._v$2 = Ws),
            Ls
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        cs
    }
    )()
}
  , _tmpl$$8 = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="17" viewBox="0 0 16 17" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 4.12695C1 3.07754 1 2.55284 1.19202 2.14684C1.38986 1.72856 1.7266 1.39181 2.14489 1.19397C2.55088 1.00195 3.07559 1.00195 4.125 1.00195C5.17441 1.00195 5.69912 1.00195 6.10511 1.19397C6.5234 1.39181 6.86014 1.72856 7.05798 2.14684C7.25 2.55284 7.25 3.07754 7.25 4.12695C7.25 5.17636 7.25 5.70107 7.05798 6.10706C6.86014 6.52535 6.5234 6.8621 6.10511 7.05993C5.69912 7.25195 5.17441 7.25195 4.125 7.25195C3.07559 7.25195 2.55088 7.25195 2.14489 7.05993C1.7266 6.8621 1.38986 6.52535 1.19202 6.10706C1 5.70107 1 5.17636 1 4.12695ZM2.5 3.30195C2.5 3.02193 2.5 2.88191 2.5545 2.77496C2.60243 2.68088 2.67892 2.60439 2.773 2.55645C2.87996 2.50195 3.01997 2.50195 3.3 2.50195H4.95C5.23003 2.50195 5.37004 2.50195 5.477 2.55645C5.57108 2.60439 5.64757 2.68088 5.6955 2.77496C5.75 2.88191 5.75 3.02193 5.75 3.30195V4.95195C5.75 5.23198 5.75 5.37199 5.6955 5.47895C5.64757 5.57303 5.57108 5.64952 5.477 5.69746C5.37004 5.75195 5.23003 5.75195 4.95 5.75195H3.3C3.01997 5.75195 2.87996 5.75195 2.773 5.69746C2.67892 5.64952 2.60243 5.57303 2.5545 5.47895C2.5 5.37199 2.5 5.23198 2.5 4.95195V3.30195ZM1 11.877C1 10.8275 1 10.3028 1.19202 9.89684C1.38986 9.47856 1.7266 9.14181 2.14489 8.94397C2.55088 8.75195 3.07559 8.75195 4.125 8.75195C5.17441 8.75195 5.69912 8.75195 6.10511 8.94397C6.5234 9.14181 6.86014 9.47856 7.05798 9.89684C7.25 10.3028 7.25 10.8275 7.25 11.877C7.25 12.9264 7.25 13.4511 7.05798 13.8571C6.86014 14.2753 6.5234 14.6121 6.10511 14.8099C5.69912 15.002 5.17441 15.002 4.125 15.002C3.07559 15.002 2.55088 15.002 2.14489 14.8099C1.7266 14.6121 1.38986 14.2753 1.19202 13.8571C1 13.4511 1 12.9264 1 11.877ZM2.5 11.052C2.5 10.7719 2.5 10.6319 2.5545 10.525C2.60243 10.4309 2.67892 10.3544 2.773 10.3064C2.87996 10.252 3.01997 10.252 3.3 10.252H4.95C5.23003 10.252 5.37004 10.252 5.477 10.3064C5.57108 10.3544 5.64757 10.4309 5.6955 10.525C5.75 10.6319 5.75 10.7719 5.75 11.052V12.702C5.75 12.982 5.75 13.122 5.6955 13.2289C5.64757 13.323 5.57108 13.3995 5.477 13.4475C5.37004 13.502 5.23003 13.502 4.95 13.502H3.3C3.01997 13.502 2.87996 13.502 2.773 13.4475C2.67892 13.3995 2.60243 13.323 2.5545 13.2289C2.5 13.122 2.5 12.982 2.5 12.702V11.052ZM8.94202 2.14684C8.75 2.55284 8.75 3.07754 8.75 4.12695C8.75 5.17636 8.75 5.70107 8.94202 6.10706C9.13986 6.52535 9.4766 6.8621 9.89489 7.05993C10.3009 7.25195 10.8256 7.25195 11.875 7.25195C12.9244 7.25195 13.4491 7.25195 13.8551 7.05993C14.2734 6.8621 14.6101 6.52535 14.808 6.10706C15 5.70107 15 5.17636 15 4.12695C15 3.07754 15 2.55284 14.808 2.14684C14.6101 1.72856 14.2734 1.39181 13.8551 1.19397C13.4491 1.00195 12.9244 1.00195 11.875 1.00195C10.8256 1.00195 10.3009 1.00195 9.89489 1.19397C9.4766 1.39181 9.13986 1.72856 8.94202 2.14684ZM10.3045 2.77496C10.25 2.88191 10.25 3.02193 10.25 3.30195V4.95195C10.25 5.23198 10.25 5.37199 10.3045 5.47895C10.3524 5.57303 10.4289 5.64952 10.523 5.69746C10.63 5.75195 10.77 5.75195 11.05 5.75195H12.7C12.98 5.75195 13.12 5.75195 13.227 5.69746C13.3211 5.64952 13.3976 5.57303 13.4455 5.47895C13.5 5.37199 13.5 5.23198 13.5 4.95195V3.30195C13.5 3.02193 13.5 2.88191 13.4455 2.77496C13.3976 2.68088 13.3211 2.60439 13.227 2.55645C13.12 2.50195 12.98 2.50195 12.7 2.50195H11.05C10.77 2.50195 10.63 2.50195 10.523 2.55645C10.4289 2.60439 10.3524 2.68088 10.3045 2.77496ZM8.80727 9.13518C8.75 9.26242 8.75 9.4256 8.75 9.75195C8.75 10.0783 8.75 10.2415 8.80727 10.3687C8.87245 10.5136 8.9884 10.6295 9.13323 10.6947C9.26047 10.752 9.42365 10.752 9.75 10.752C10.0764 10.752 10.2395 10.752 10.3668 10.6947C10.5116 10.6295 10.6276 10.5136 10.6927 10.3687C10.75 10.2415 10.75 10.0783 10.75 9.75195C10.75 9.4256 10.75 9.26242 10.6927 9.13518C10.6276 8.99035 10.5116 8.8744 10.3668 8.80922C10.2395 8.75195 10.0764 8.75195 9.75 8.75195C9.42365 8.75195 9.26047 8.75195 9.13323 8.80922C8.9884 8.8744 8.87245 8.99035 8.80727 9.13518ZM10.87 11.8771C10.87 11.546 10.87 11.3805 10.9289 11.2517C10.9938 11.1098 11.1077 10.9959 11.2497 10.931C11.3784 10.8721 11.5439 10.8721 11.875 10.8721C12.2061 10.8721 12.3716 10.8721 12.5003 10.931C12.6423 10.9959 12.7562 11.1098 12.8211 11.2517C12.88 11.3805 12.88 11.546 12.88 11.8771C12.88 12.2081 12.88 12.3737 12.8211 12.5024C12.7562 12.6444 12.6423 12.7583 12.5003 12.8232C12.3716 12.8821 12.2061 12.8821 11.875 12.8821C11.5439 12.8821 11.3784 12.8821 11.2497 12.8232C11.1077 12.7583 10.9938 12.6444 10.9289 12.5024C10.87 12.3737 10.87 12.2081 10.87 11.8771ZM8.80727 13.3852C8.75 13.5124 8.75 13.6756 8.75 14.002C8.75 14.3283 8.75 14.4915 8.80727 14.6187C8.87245 14.7636 8.9884 14.8795 9.13323 14.9447C9.26047 15.002 9.42365 15.002 9.75 15.002C10.0764 15.002 10.2395 15.002 10.3668 14.9447C10.5116 14.8795 10.6276 14.7636 10.6927 14.6187C10.75 14.4915 10.75 14.3283 10.75 14.002C10.75 13.6756 10.75 13.5124 10.6927 13.3852C10.6276 13.2404 10.5116 13.1244 10.3668 13.0592C10.2395 13.002 10.0764 13.002 9.75 13.002C9.42365 13.002 9.26047 13.002 9.13323 13.0592C8.9884 13.1244 8.87245 13.2404 8.80727 13.3852ZM13 9.75195C13 9.4256 13 9.26242 13.0573 9.13518C13.1224 8.99035 13.2384 8.8744 13.3832 8.80922C13.5105 8.75195 13.6736 8.75195 14 8.75195C14.3264 8.75195 14.4895 8.75195 14.6168 8.80922C14.7616 8.8744 14.8776 8.99035 14.9427 9.13518C15 9.26242 15 9.4256 15 9.75195C15 10.0783 15 10.2415 14.9427 10.3687C14.8776 10.5136 14.7616 10.6295 14.6168 10.6947C14.4895 10.752 14.3264 10.752 14 10.752C13.6736 10.752 13.5105 10.752 13.3832 10.6947C13.2384 10.6295 13.1224 10.5136 13.0573 10.3687C13 10.2415 13 10.0783 13 9.75195ZM13.0573 13.3852C13 13.5124 13 13.6756 13 14.002C13 14.3283 13 14.4915 13.0573 14.6187C13.1224 14.7636 13.2384 14.8795 13.3832 14.9447C13.5105 15.002 13.6736 15.002 14 15.002C14.3264 15.002 14.4895 15.002 14.6168 14.9447C14.7616 14.8795 14.8776 14.7636 14.9427 14.6187C15 14.4915 15 14.3283 15 14.002C15 13.6756 15 13.5124 14.9427 13.3852C14.8776 13.2404 14.7616 13.1244 14.6168 13.0592C14.4895 13.002 14.3264 13.002 14 13.002C13.6736 13.002 13.5105 13.002 13.3832 13.0592C13.2384 13.1244 13.1224 13.2404 13.0573 13.3852Z"></path></svg>')
  , QRIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.icon.secondary;
    return ( () => {
        const cs = _tmpl$$8.cloneNode(!0)
          , Cs = cs.firstChild;
        return createRenderEffect( () => setAttribute(Cs, "fill", as())),
        cs
    }
    )()
}
  , containerBorders = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , walletBorders = {
    m: "6px",
    s: "6px",
    none: "0"
}
  , FourWalletsCard = styled.div`
    width: 60px;
    height: 60px;
    padding: 8px;
    margin-bottom: 8px;
    border-radius: ${xt => containerBorders[xt.theme.borderRadius]};
    background-color: ${xt => xt.theme.colors.background.tint};
    display: grid;
    grid-template: 1fr 1fr / 1fr 1fr;
    gap: 4px;
`
  , FourWalletsImage = styled(WalletImage)`
    width: 20px;
    height: 20px;
    border-radius: ${xt => walletBorders[xt.theme.borderRadius]};
`
  , FourWalletsItem = xt => createComponent(WalletItem, {
    get name() {
        return xt.labelLine1
    },
    get secondLine() {
        return xt.labelLine2
    },
    get icon() {
        return createComponent(FourWalletsCard, {
            get children() {
                return createComponent(For, {
                    each: [0, 1, 2, 3],
                    children: Cn => createComponent(FourWalletsImage, {
                        get src() {
                            return xt.images[Cn]
                        }
                    })
                })
            }
        })
    },
    onClick: () => xt.onClick()
})
  , AT_WALLET_APP_NAME = "telegram-wallet"
  , IMG = {
    TON: "https://raw.githubusercontent.com/ton-connect/sdk/main/assets/ton-icon-48.png",
    TG: "https://raw.githubusercontent.com/ton-connect/sdk/main/assets/tg.png"
}
  , WalletLabeledItem = xt => {
    const [Cn] = useI18n()
      , as = () => {
        if (xt.wallet.appName !== AT_WALLET_APP_NAME) {
            if ("isPreferred"in xt.wallet && xt.wallet.isPreferred)
                return Cn("walletItem.recent", {}, "Recent");
            if (isWalletInfoCurrentlyInjected(xt.wallet))
                return Cn("walletItem.installed", {}, "Installed");
            if (xt.wallet.name === "Tonkeeper")
                return Cn("walletItem.popular", {}, "Popular")
        }
    }
    ;
    return createMemo(( () => {
        const cs = createMemo( () => xt.wallet.appName === AT_WALLET_APP_NAME);
        return () => cs() ? createComponent(WalletItem, {
            get icon() {
                return xt.wallet.imageUrl
            },
            get name() {
                return Cn("walletItem.walletOn", {}, "Wallet On")
            },
            secondLine: "Telegram",
            get badgeUrl() {
                return IMG.TG
            },
            onClick: () => xt.onClick()
        }) : createComponent(WalletItem, {
            get icon() {
                return xt.wallet.imageUrl
            },
            get name() {
                return xt.wallet.name
            },
            get secondLine() {
                return as()
            },
            secondLineColorPrimary: !1,
            onClick: () => xt.onClick()
        })
    }
    )())
}
  , ScrollContainerStyled = styled.div`
    width: 100%;
    overflow-y: auto;
    max-height: ${xt => xt.maxHeight};

    scrollbar-width: none;
    &&::-webkit-scrollbar {
        display: none;
    }

    &&::-webkit-scrollbar-track {
        background: transparent;
    }

    &&::-webkit-scrollbar-thumb {
        display: none;
    }
`
  , ScrollDivider = styled.div`
    height: 1px;
    margin: 0 -24px;
    width: calc(100% + 48px);
    opacity: 0.08;
    background: ${xt => xt.isShown ? xt.theme.colors.icon.secondary : "transparent"};
    transition: background 0.15s ease-in-out;

    ${media("mobile")} {
        width: 100%;
        margin: 0;
    }
`
  , [windowHeight,setWindowHeight] = createSignal(((_h = getWindow$1()) == null ? void 0 : _h.innerHeight) || 0);
getWindow$1() && window.addEventListener("resize", () => setWindowHeight(window.innerHeight));
const [isMobile$1,setIsMobile] = createSignal(isDevice("mobile"))
  , updateIsMobile = () => setIsMobile(isDevice("mobile"));
getWindow$1() && (window.addEventListener("resize", () => updateIsMobile()),
window.addEventListener("load", () => updateIsMobile(), {
    once: !0
}));
const ScrollContainer = xt => {
    const [Cn,as] = createSignal(!1)
      , cs = Vs => {
        as(Vs.target.scrollTop > 0)
    }
      , Cs = () => isMobile$1() ? 150 : 200
      , Ls = () => xt.maxHeight !== void 0 ? `${xt.maxHeight}px` : `${windowHeight() - Cs()}px`;
    return [createComponent(ScrollDivider, {
        get isShown() {
            return Cn()
        }
    }), createComponent(ScrollContainerStyled, {
        get maxHeight() {
            return Ls()
        },
        onScroll: cs,
        get class() {
            return xt.class
        },
        get children() {
            return xt.children
        }
    })]
}
  , AStyled = styled.a`
    display: block;
    text-decoration: unset;
`
  , Link = xt => createComponent(AStyled, mergeProps$1({
    get href() {
        return xt.href
    },
    get target() {
        return xt.blank ? "_blank" : "_self"
    },
    get class() {
        return xt.class
    }
}, () => xt.blank ? {
    rel: "noreferrer noopener"
} : {}, {
    get children() {
        return xt.children
    }
}))
  , TonConnectUiContext = createContext()
  , _tmpl$$7 = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7.76228 2.09998H10.2378C11.0458 2.09997 11.7067 2.09996 12.2438 2.14384C12.7997 2.18926 13.3017 2.28614 13.7706 2.52505C14.5045 2.89896 15.1011 3.49558 15.475 4.22941C15.7139 4.6983 15.8108 5.20038 15.8562 5.75629C15.9001 6.29337 15.9001 6.95422 15.9001 7.76227V8.1H16.2377C17.0457 8.09999 17.7066 8.09998 18.2437 8.14386C18.7996 8.18928 19.3017 8.28616 19.7705 8.52507C20.5044 8.89898 21.101 9.4956 21.4749 10.2294C21.7138 10.6983 21.8107 11.2004 21.8561 11.7563C21.9 12.2934 21.9 12.9542 21.9 13.7623V16.2377C21.9 17.0458 21.9 17.7066 21.8561 18.2437C21.8107 18.7996 21.7138 19.3017 21.4749 19.7706C21.101 20.5044 20.5044 21.101 19.7705 21.4749C19.3017 21.7138 18.7996 21.8107 18.2437 21.8561C17.7066 21.9 17.0458 21.9 16.2378 21.9H13.7623C12.9543 21.9 12.2934 21.9 11.7563 21.8561C11.2004 21.8107 10.6983 21.7138 10.2294 21.4749C9.49561 21.101 8.89898 20.5044 8.52508 19.7706C8.28616 19.3017 8.18928 18.7996 8.14386 18.2437C8.09998 17.7066 8.09999 17.0458 8.1 16.2377V15.9H7.76227C6.95426 15.9 6.29335 15.9 5.75629 15.8561C5.20038 15.8107 4.6983 15.7138 4.22941 15.4749C3.49558 15.101 2.89896 14.5044 2.52505 13.7705C2.28614 13.3017 2.18926 12.7996 2.14384 12.2437C2.09996 11.7066 2.09997 11.0458 2.09998 10.2377V7.76228C2.09997 6.95424 2.09996 6.29336 2.14384 5.75629C2.18926 5.20038 2.28614 4.6983 2.52505 4.22941C2.89896 3.49558 3.49558 2.89896 4.22941 2.52505C4.6983 2.28614 5.20038 2.18926 5.75629 2.14384C6.29336 2.09996 6.95425 2.09997 7.76228 2.09998ZM8.1 14.1V13.7623C8.09999 12.9542 8.09998 12.2934 8.14386 11.7563C8.18928 11.2004 8.28616 10.6983 8.52508 10.2294C8.89898 9.4956 9.49561 8.89898 10.2294 8.52507C10.6983 8.28616 11.2004 8.18928 11.7563 8.14386C12.2934 8.09998 12.9542 8.09999 13.7623 8.1H14.1001V7.79998C14.1001 6.94505 14.0994 6.35798 14.0622 5.90287C14.0259 5.45827 13.9593 5.21944 13.8712 5.0466C13.6699 4.65146 13.3486 4.3302 12.9535 4.12886C12.7806 4.04079 12.5418 3.97419 12.0972 3.93786C11.6421 3.90068 11.055 3.89998 10.2001 3.89998H7.79998C6.94505 3.89998 6.35798 3.90068 5.90287 3.93786C5.45827 3.97419 5.21944 4.04079 5.0466 4.12886C4.65146 4.3302 4.3302 4.65146 4.12886 5.0466C4.04079 5.21944 3.97419 5.45827 3.93786 5.90287C3.90068 6.35798 3.89998 6.94505 3.89998 7.79998V10.2C3.89998 11.0549 3.90068 11.642 3.93786 12.0971C3.97419 12.5417 4.04079 12.7805 4.12886 12.9534C4.3302 13.3485 4.65146 13.6698 5.0466 13.8711C5.21944 13.9592 5.45827 14.0258 5.90287 14.0621C6.35798 14.0993 6.94505 14.1 7.79998 14.1H8.1ZM11.0466 10.1289C11.2195 10.0408 11.4583 9.97421 11.9029 9.93788C12.358 9.9007 12.9451 9.9 13.8 9.9H16.2C17.0549 9.9 17.642 9.9007 18.0971 9.93788C18.5417 9.97421 18.7805 10.0408 18.9534 10.1289C19.3485 10.3302 19.6698 10.6515 19.8711 11.0466C19.9592 11.2195 20.0258 11.4583 20.0621 11.9029C20.0993 12.358 20.1 12.9451 20.1 13.8V16.2C20.1 17.0549 20.0993 17.642 20.0621 18.0971C20.0258 18.5417 19.9592 18.7805 19.8711 18.9534C19.6698 19.3485 19.3485 19.6698 18.9534 19.8711C18.7805 19.9592 18.5417 20.0258 18.0971 20.0621C17.642 20.0993 17.0549 20.1 16.2 20.1H13.8C12.9451 20.1 12.358 20.0993 11.9029 20.0621C11.4583 20.0258 11.2195 19.9592 11.0466 19.8711C10.6515 19.6698 10.3302 19.3485 10.1289 18.9534C10.0408 18.7805 9.97421 18.5417 9.93788 18.0971C9.9007 17.642 9.9 17.0549 9.9 16.2V13.8C9.9 12.9451 9.9007 12.358 9.93788 11.9029C9.97421 11.4583 10.0408 11.2195 10.1289 11.0466C10.3302 10.6515 10.6515 10.3302 11.0466 10.1289Z"></path></svg>')
  , CopyIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.icon.primary;
    return ( () => {
        const cs = _tmpl$$7.cloneNode(!0)
          , Cs = cs.firstChild;
        return createRenderEffect(Ls => {
            const Vs = xt.class
              , Ws = as();
            return Vs !== Ls._v$ && setAttribute(cs, "class", Ls._v$ = Vs),
            Ws !== Ls._v$2 && setAttribute(Cs, "fill", Ls._v$2 = Ws),
            Ls
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        cs
    }
    )()
}
  , _tmpl$$6 = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.7624 3.10001C7.95435 3.1 7.29349 3.09999 6.75642 3.14387C6.2005 3.18929 5.69842 3.28617 5.22954 3.52508C4.4957 3.89899 3.89908 4.49561 3.52517 5.22944C3.28626 5.69833 3.18938 6.20041 3.14396 6.75632C3.10008 7.2934 3.10009 7.95424 3.1001 8.76229V15.2377C3.10009 16.0458 3.10008 16.7066 3.14396 17.2437C3.18938 17.7996 3.28626 18.3017 3.52517 18.7706C3.89908 19.5044 4.4957 20.101 5.22954 20.4749C5.69842 20.7138 6.2005 20.8107 6.75642 20.8561C7.29349 20.9 7.95434 20.9 8.76239 20.9H12.0001C12.4972 20.9 12.9001 20.4971 12.9001 20C12.9001 19.503 12.4972 19.1 12.0001 19.1H8.8001C7.94517 19.1 7.3581 19.0993 6.90299 19.0621C6.45839 19.0258 6.21956 18.9592 6.04672 18.8711C5.65158 18.6698 5.33032 18.3485 5.12898 17.9534C5.04092 17.7805 4.97431 17.5417 4.93798 17.0971C4.9008 16.642 4.9001 16.0549 4.9001 15.2V8.80001C4.9001 7.94508 4.9008 7.35801 4.93798 6.9029C4.97431 6.4583 5.04092 6.21947 5.12898 6.04663C5.33032 5.65149 5.65158 5.33023 6.04672 5.12889C6.21956 5.04082 6.45839 4.97422 6.90299 4.93789C7.3581 4.90071 7.94517 4.90001 8.8001 4.90001H12.0001C12.4972 4.90001 12.9001 4.49706 12.9001 4.00001C12.9001 3.50295 12.4972 3.10001 12.0001 3.10001H8.7624Z"></path><path d="M17.6364 7.3636C17.2849 7.01212 16.7151 7.01212 16.3636 7.3636C16.0121 7.71507 16.0121 8.28492 16.3636 8.63639L18.8272 11.1H9.00001C8.50295 11.1 8.10001 11.5029 8.10001 12C8.10001 12.497 8.50295 12.9 9.00001 12.9H18.8272L16.3636 15.3636C16.0121 15.7151 16.0121 16.2849 16.3636 16.6364C16.7151 16.9879 17.2849 16.9879 17.6364 16.6364L21.6364 12.6364C21.9879 12.2849 21.9879 11.7151 21.6364 11.3636L17.6364 7.3636Z"></path></svg>')
  , DisconnectIcon = xt => {
    const Cn = useTheme()
      , as = () => xt.fill || Cn.colors.icon.primary;
    return ( () => {
        const cs = _tmpl$$6.cloneNode(!0)
          , Cs = cs.firstChild
          , Ls = Cs.nextSibling;
        return createRenderEffect(Vs => {
            const Ws = as()
              , Xs = as();
            return Ws !== Vs._v$ && setAttribute(Cs, "fill", Vs._v$ = Ws),
            Xs !== Vs._v$2 && setAttribute(Ls, "fill", Vs._v$2 = Xs),
            Vs
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        cs
    }
    )()
}
  , hoverBorders$1 = {
    m: "8px",
    s: "4px",
    none: "0"
}
  , dropdownBorders = {
    m: "16px",
    s: "8px",
    none: "0"
}
  , AccountButtonDropdownStyled = styled.div`
    width: 256px;
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);
    border-radius: ${xt => dropdownBorders[xt.theme.borderRadius]};

    background-color: ${xt => xt.theme.colors.background.primary}
           
    color: ${xt => xt.theme.colors.text.primary}
`
  , UlStyled$1 = styled.ul`
    background-color: ${xt => xt.theme.colors.background.primary};
    padding: 8px;
`
  , MenuButtonStyled = styled.button`
    display: flex;
    align-items: center;
    gap: 8px;
    height: 40px;
    padding-left: 8px;
    width: 100%;

    background-color: ${xt => xt.theme.colors.background.primary};
    border: none;
    border-radius: ${xt => hoverBorders$1[xt.theme.borderRadius]};
    cursor: pointer;

    transition: background-color, transform 0.1s ease-in-out;

    &:hover {
        background-color: ${xt => xt.theme.colors.background.secondary};
    }

    &:active {
        transform: scale(0.96);
    }
`
  , _tmpl$$5 = template$1("<li></li>")
  , MenuItemText = xt => createComponent(Text, {
    get translationKey() {
        return xt.translationKey
    },
    fontSize: "15px",
    fontWeight: "590",
    get children() {
        return xt.children
    }
})
  , AccountButtonDropdown = xt => {
    const Cn = useContext(TonConnectUiContext)
      , [as,cs] = createSignal(!1)
      , Cs = () => __async(void 0, null, function*() {
        const Vs = toUserFriendlyAddress(Cn.account.address, Cn.account.chain === CHAIN.TESTNET);
        yield copyToClipboard(Vs),
        cs(!0),
        setTimeout( () => cs(!1), 1e3)
    })
      , Ls = () => {
        Cn.disconnect(),
        xt.onClose()
    }
    ;
    return createComponent(AccountButtonDropdownStyled, {
        ref(Vs) {
            const Ws = xt.ref;
            typeof Ws == "function" ? Ws(Vs) : xt.ref = Vs
        },
        get class() {
            return xt.class
        },
        "data-tc-dropdown": "true",
        get children() {
            return createComponent(UlStyled$1, {
                get children() {
                    return [( () => {
                        const Vs = _tmpl$$5.cloneNode(!0);
                        return insert(Vs, createComponent(MenuButtonStyled, {
                            onClick: () => Cs(),
                            get children() {
                                return [createComponent(CopyIcon, {}), createComponent(Show, {
                                    get when() {
                                        return !as()
                                    },
                                    get children() {
                                        return createComponent(MenuItemText, {
                                            translationKey: "button.dropdown.copy",
                                            children: "Copy address"
                                        })
                                    }
                                }), createComponent(Show, {
                                    get when() {
                                        return as()
                                    },
                                    get children() {
                                        return createComponent(MenuItemText, {
                                            translationKey: "button.dropdown.copied",
                                            children: "Address copied!"
                                        })
                                    }
                                })]
                            }
                        })),
                        Vs
                    }
                    )(), ( () => {
                        const Vs = _tmpl$$5.cloneNode(!0);
                        return insert(Vs, createComponent(MenuButtonStyled, {
                            onClick: () => Ls(),
                            get children() {
                                return [createComponent(DisconnectIcon, {}), createComponent(MenuItemText, {
                                    translationKey: "button.dropdown.disconnect",
                                    children: "Disconnect"
                                })]
                            }
                        })),
                        Vs
                    }
                    )()]
                }
            })
        }
    })
}
  , borders$2 = {
    m: "16px",
    s: "8px",
    none: "0"
}
  , NotificationStyled = styled.div`
    width: 256px;
    padding: 12px 16px;
    display: flex;
    gap: 9px;

    background-color: ${xt => xt.theme.colors.background.primary};
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);
    border-radius: ${xt => borders$2[xt.theme.borderRadius]};
`
  , NotificationContentStyled = styled.div`
    width: 192px;

    > h3 {
        font-size: 15px;
    }
`
  , TextStyled$2 = styled(Text)`
    margin-top: 4px;
    color: ${xt => xt.theme.colors.text.secondary};
`
  , Notification = xt => {
    const Cn = useDataAttributes(xt);
    return createComponent(NotificationStyled, mergeProps$1({
        get class() {
            return xt.class
        },
        "data-tc-notification": "true"
    }, Cn, {
        get children() {
            return [createComponent(NotificationContentStyled, {
                get children() {
                    return [createComponent(H3, {
                        get translationKey() {
                            return xt.header.translationKey
                        },
                        get translationValues() {
                            return xt.header.translationValues
                        },
                        get children() {
                            return xt.children
                        }
                    }), createComponent(Show, {
                        get when() {
                            return xt.text
                        },
                        get children() {
                            return createComponent(TextStyled$2, {
                                get translationKey() {
                                    return xt.text.translationKey
                                },
                                get translationValues() {
                                    return xt.text.translationValues
                                }
                            })
                        }
                    })]
                }
            }), createMemo( () => xt.icon)]
        }
    }))
}
  , LoaderIconStyled$2 = styled(LoaderIcon)`
    align-self: center;
`
  , ConfirmOperationNotification = xt => {
    const Cn = useContext(TonConnectUiContext)
      , [as] = useI18n()
      , cs = () => Cn.wallet && "name"in Cn.wallet ? Cn.wallet.name : as("common.yourWallet", {}, "Your wallet");
    return createComponent(Notification, {
        get header() {
            return {
                translationKey: "notifications.confirm.header",
                translationValues: {
                    name: cs()
                }
            }
        },
        get class() {
            return xt.class
        },
        get icon() {
            return createComponent(LoaderIconStyled$2, {})
        },
        "data-tc-notification-confirm": "true",
        children: "Confirm operation in your wallet"
    })
}
  , ErrorIconStyled$2 = styled(ErrorIcon)`
    margin-top: 2px;
`
  , ErrorTransactionNotification = xt => createComponent(Notification, {
    header: {
        translationKey: "notifications.transactionCanceled.header"
    },
    text: {
        translationKey: "notifications.transactionCanceled.text"
    },
    get icon() {
        return createComponent(ErrorIconStyled$2, {
            size: "xs"
        })
    },
    get class() {
        return xt.class
    },
    "data-tc-notification-tx-cancelled": "true",
    children: "Transaction cancelled"
})
  , SuccessIconStyled = styled(SuccessIcon)`
    margin-top: 2px;
`
  , SuccessTransactionNotification = xt => createComponent(Notification, {
    header: {
        translationKey: "notifications.transactionSent.header"
    },
    text: {
        translationKey: "notifications.transactionSent.text"
    },
    get icon() {
        return createComponent(SuccessIconStyled, {})
    },
    get class() {
        return xt.class
    },
    "data-tc-notification-tx-sent": "true",
    children: "Transaction sent"
})
  , NotificationClass = u$9`
    transform: translateY(-8px);
    margin-bottom: 12px;
`
  , defaultConfig = {
    timeout: 4500
}
  , [latestAction,setLatestAction] = createSignal(null);
function useOpenedNotifications(xt) {
    const {timeout: Cn} = __spreadValues$1(__spreadValues$1({}, defaultConfig), xt)
      , [as,cs] = createSignal([])
      , [Cs,Ls] = createSignal([]);
    return createEffect(on(action$2, Vs => {
        var Ws;
        if (!Vs || !Vs.showNotification || latestAction() === Vs || ((Ws = latestAction()) == null ? void 0 : Ws.name) === "confirm-transaction" && Vs.name === "confirm-transaction")
            return;
        setLatestAction(Vs),
        cs(ba => ba.filter(yl => yl.action !== "confirm-transaction"));
        const Xs = {
            action: Vs.name
        };
        cs(ba => [...ba, Xs]);
        const ga = setTimeout( () => {
            cs(ba => ba.filter(yl => yl !== Xs)),
            Ls(ba => ba.filter(yl => yl !== ga))
        }
        , Cn);
        Ls(ba => [...ba, ga])
    }
    )),
    onCleanup( () => {
        Cs().forEach(Vs => clearTimeout(Vs))
    }
    ),
    as
}
const _tmpl$$4 = template$1('<div data-tc-list-notifications="true"></div>')
  , Notifications = xt => {
    const Cn = useOpenedNotifications();
    return ( () => {
        const as = _tmpl$$4.cloneNode(!0);
        return insert(as, createComponent(TransitionGroup, {
            onBeforeEnter: cs => {
                animate(cs, [{
                    opacity: 0,
                    transform: "translateY(0)"
                }, {
                    opacity: 1,
                    transform: "translateY(-8px)"
                }], {
                    duration: 200
                })
            }
            ,
            onExit: (cs, Cs) => {
                animate(cs, [{
                    opacity: 1,
                    transform: "translateY(-8px)"
                }, {
                    opacity: 0,
                    transform: "translateY(-30px)"
                }], {
                    duration: 200
                }).finished.then(Cs)
            }
            ,
            get children() {
                return createComponent(For, {
                    get each() {
                        return Cn()
                    },
                    children: cs => createComponent(Switch, {
                        get children() {
                            return [createComponent(Match, {
                                get when() {
                                    return cs.action === "transaction-sent"
                                },
                                get children() {
                                    return createComponent(SuccessTransactionNotification, {
                                        class: NotificationClass
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return cs.action === "transaction-canceled"
                                },
                                get children() {
                                    return createComponent(ErrorTransactionNotification, {
                                        class: NotificationClass
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return cs.action === "confirm-transaction"
                                },
                                get children() {
                                    return createComponent(ConfirmOperationNotification, {
                                        class: NotificationClass
                                    })
                                }
                            })]
                        }
                    })
                })
            }
        })),
        createRenderEffect( () => className(as, xt.class)),
        as
    }
    )()
}
  , AccountButtonStyled = styled(Button$1)`
    background-color: ${xt => xt.theme.colors.connectButton.background};
    color: ${xt => xt.theme.colors.connectButton.foreground};
    box-shadow: ${xt => `0 4px 24px ${rgba$1(xt.theme.colors.constant.black, .16)}`};
    padding: 8px 16px 8px 12px;

    display: flex;
    align-items: center;
    gap: 4px;
    height: 40px;
`
  , DropdownButtonStyled = styled(AccountButtonStyled)`
    padding: 12px 16px;
    min-width: 148px;
    justify-content: center;
    background-color: ${xt => xt.theme.colors.background.primary};
`
  , LoaderButtonStyled$1 = styled(Button$1)`
    min-width: 148px;
    height: 40px;

    background-color: ${xt => xt.theme.colors.background.primary};
    color: ${xt => xt.theme.colors.connectButton.foreground};
    box-shadow: ${xt => `0 4px 24px ${rgba$1(xt.theme.colors.constant.black, .16)}`};

    display: flex;
    align-items: center;
    justify-content: center;
`
  , LoaderIconStyled$1 = styled(LoaderIcon)`
    height: 18px;
    width: 18px;
`
  , DropdownContainerStyled = styled.div`
    width: fit-content;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
`
  , DropdownStyled = styled(AccountButtonDropdown)`
    box-sizing: border-box;
    overflow: hidden;
    margin-top: 12px;
`
  , NotificationsStyled = styled(Notifications)`
    > div:first-child {
        margin-top: 20px;
    }
`;
function getSide$1(xt) {
    return xt.split("-")[0]
}
function getAlignment$1(xt) {
    return xt.split("-")[1]
}
function getMainAxisFromPlacement(xt) {
    return ["top", "bottom"].includes(getSide$1(xt)) ? "x" : "y"
}
function getLengthFromAxis(xt) {
    return xt === "y" ? "height" : "width"
}
function computeCoordsFromPlacement$1(xt, Cn, as) {
    let {reference: cs, floating: Cs} = xt;
    const Ls = cs.x + cs.width / 2 - Cs.width / 2
      , Vs = cs.y + cs.height / 2 - Cs.height / 2
      , Ws = getMainAxisFromPlacement(Cn)
      , Xs = getLengthFromAxis(Ws)
      , ga = cs[Xs] / 2 - Cs[Xs] / 2
      , ba = getSide$1(Cn)
      , yl = Ws === "x";
    let xl;
    switch (ba) {
    case "top":
        xl = {
            x: Ls,
            y: cs.y - Cs.height
        };
        break;
    case "bottom":
        xl = {
            x: Ls,
            y: cs.y + cs.height
        };
        break;
    case "right":
        xl = {
            x: cs.x + cs.width,
            y: Vs
        };
        break;
    case "left":
        xl = {
            x: cs.x - Cs.width,
            y: Vs
        };
        break;
    default:
        xl = {
            x: cs.x,
            y: cs.y
        }
    }
    switch (getAlignment$1(Cn)) {
    case "start":
        xl[Ws] -= ga * (as && yl ? -1 : 1);
        break;
    case "end":
        xl[Ws] += ga * (as && yl ? -1 : 1);
        break
    }
    return xl
}
const computePosition$1$1 = (xt, Cn, as) => __async(void 0, null, function*() {
    const {placement: cs="bottom", strategy: Cs="absolute", middleware: Ls=[], platform: Vs} = as
      , Ws = Ls.filter(Boolean)
      , Xs = yield Vs.isRTL == null ? void 0 : Vs.isRTL(Cn);
    if ({}.NODE_ENV !== "production") {
        if (Vs == null && console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" ")),
        Ws.filter(El => {
            let {name: Cl} = El;
            return Cl === "autoPlacement" || Cl === "flip"
        }
        ).length > 1)
            throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement` middleware", "detected. This will lead to an infinite loop. Ensure only one of", "either has been passed to the `middleware` array."].join(" "));
        (!xt || !Cn) && console.error(["Floating UI: The reference and/or floating element was not defined", "when `computePosition()` was called. Ensure that both elements have", "been created and can be measured."].join(" "))
    }
    let ga = yield Vs.getElementRects({
        reference: xt,
        floating: Cn,
        strategy: Cs
    })
      , {x: ba, y: yl} = computeCoordsFromPlacement$1(ga, cs, Xs)
      , xl = cs
      , wl = {}
      , _l = 0;
    for (let El = 0; El < Ws.length; El++) {
        const {name: Cl, fn: $l} = Ws[El]
          , {x: Sl, y: Tl, data: Rl, reset: Il} = yield $l({
            x: ba,
            y: yl,
            initialPlacement: cs,
            placement: xl,
            strategy: Cs,
            middlewareData: wl,
            rects: ga,
            platform: Vs,
            elements: {
                reference: xt,
                floating: Cn
            }
        });
        if (ba = Sl ?? ba,
        yl = Tl ?? yl,
        wl = __spreadProps(__spreadValues$1({}, wl), {
            [Cl]: __spreadValues$1(__spreadValues$1({}, wl[Cl]), Rl)
        }),
        {}.NODE_ENV !== "production" && _l > 50 && console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" ")),
        Il && _l <= 50) {
            _l++,
            typeof Il == "object" && (Il.placement && (xl = Il.placement),
            Il.rects && (ga = Il.rects === !0 ? yield Vs.getElementRects({
                reference: xt,
                floating: Cn,
                strategy: Cs
            }) : Il.rects),
            {x: ba, y: yl} = computeCoordsFromPlacement$1(ga, xl, Xs)),
            El = -1;
            continue
        }
    }
    return {
        x: ba,
        y: yl,
        placement: xl,
        strategy: Cs,
        middlewareData: wl
    }
});
function rectToClientRect$1(xt) {
    return __spreadProps(__spreadValues$1({}, xt), {
        top: xt.y,
        left: xt.x,
        right: xt.x + xt.width,
        bottom: xt.y + xt.height
    })
}
function getWindow$2(xt) {
    var Cn;
    return ((Cn = xt.ownerDocument) == null ? void 0 : Cn.defaultView) || window
}
function getComputedStyle$1$1(xt) {
    return getWindow$2(xt).getComputedStyle(xt)
}
function getNodeName$1(xt) {
    return isNode$1(xt) ? (xt.nodeName || "").toLowerCase() : ""
}
let uaString;
function getUAString() {
    if (uaString)
        return uaString;
    const xt = navigator.userAgentData;
    return xt && Array.isArray(xt.brands) ? (uaString = xt.brands.map(Cn => Cn.brand + "/" + Cn.version).join(" "),
    uaString) : navigator.userAgent
}
function isHTMLElement$2(xt) {
    return xt instanceof getWindow$2(xt).HTMLElement
}
function isElement$1(xt) {
    return xt instanceof getWindow$2(xt).Element
}
function isNode$1(xt) {
    return xt instanceof getWindow$2(xt).Node
}
function isShadowRoot$1(xt) {
    if (typeof ShadowRoot > "u")
        return !1;
    const Cn = getWindow$2(xt).ShadowRoot;
    return xt instanceof Cn || xt instanceof ShadowRoot
}
function isOverflowElement$1(xt) {
    const {overflow: Cn, overflowX: as, overflowY: cs, display: Cs} = getComputedStyle$1$1(xt);
    return /auto|scroll|overlay|hidden/.test(Cn + cs + as) && !["inline", "contents"].includes(Cs)
}
function isTableElement$1(xt) {
    return ["table", "td", "th"].includes(getNodeName$1(xt))
}
function isContainingBlock$1(xt) {
    const Cn = /firefox/i.test(getUAString())
      , as = getComputedStyle$1$1(xt)
      , cs = as.backdropFilter || as.WebkitBackdropFilter;
    return as.transform !== "none" || as.perspective !== "none" || (cs ? cs !== "none" : !1) || Cn && as.willChange === "filter" || Cn && (as.filter ? as.filter !== "none" : !1) || ["transform", "perspective"].some(Cs => as.willChange.includes(Cs)) || ["paint", "layout", "strict", "content"].some(Cs => {
        const Ls = as.contain;
        return Ls != null ? Ls.includes(Cs) : !1
    }
    )
}
function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString())
}
function isLastTraversableNode$1(xt) {
    return ["html", "body", "#document"].includes(getNodeName$1(xt))
}
const min$1 = Math.min
  , max$1 = Math.max
  , round$2 = Math.round
  , FALLBACK_SCALE = {
    x: 1,
    y: 1
};
function getScale$1(xt) {
    const Cn = !isElement$1(xt) && xt.contextElement ? xt.contextElement : isElement$1(xt) ? xt : null;
    if (!Cn)
        return FALLBACK_SCALE;
    const as = Cn.getBoundingClientRect()
      , cs = getComputedStyle$1$1(Cn);
    if (cs.boxSizing !== "border-box")
        return isHTMLElement$2(Cn) ? {
            x: Cn.offsetWidth > 0 && round$2(as.width) / Cn.offsetWidth || 1,
            y: Cn.offsetHeight > 0 && round$2(as.height) / Cn.offsetHeight || 1
        } : FALLBACK_SCALE;
    let Cs = as.width / parseFloat(cs.width)
      , Ls = as.height / parseFloat(cs.height);
    return (!Cs || !Number.isFinite(Cs)) && (Cs = 1),
    (!Ls || !Number.isFinite(Ls)) && (Ls = 1),
    {
        x: Cs,
        y: Ls
    }
}
function getBoundingClientRect$1(xt, Cn, as, cs) {
    var Cs, Ls, Vs, Ws;
    Cn === void 0 && (Cn = !1),
    as === void 0 && (as = !1);
    const Xs = xt.getBoundingClientRect();
    let ga = FALLBACK_SCALE;
    Cn && (cs ? isElement$1(cs) && (ga = getScale$1(cs)) : ga = getScale$1(xt));
    const ba = isElement$1(xt) ? getWindow$2(xt) : window
      , yl = !isLayoutViewport() && as
      , xl = (Xs.left + (yl && (Cs = (Ls = ba.visualViewport) == null ? void 0 : Ls.offsetLeft) != null ? Cs : 0)) / ga.x
      , wl = (Xs.top + (yl && (Vs = (Ws = ba.visualViewport) == null ? void 0 : Ws.offsetTop) != null ? Vs : 0)) / ga.y
      , _l = Xs.width / ga.x
      , El = Xs.height / ga.y;
    return {
        width: _l,
        height: El,
        top: wl,
        right: xl + _l,
        bottom: wl + El,
        left: xl,
        x: xl,
        y: wl
    }
}
function getDocumentElement$1(xt) {
    return ((isNode$1(xt) ? xt.ownerDocument : xt.document) || window.document).documentElement
}
function getNodeScroll$1(xt) {
    return isElement$1(xt) ? {
        scrollLeft: xt.scrollLeft,
        scrollTop: xt.scrollTop
    } : {
        scrollLeft: xt.pageXOffset,
        scrollTop: xt.pageYOffset
    }
}
function getWindowScrollBarX$1(xt) {
    return getBoundingClientRect$1(getDocumentElement$1(xt)).left + getNodeScroll$1(xt).scrollLeft
}
function getRectRelativeToOffsetParent$1(xt, Cn, as) {
    const cs = isHTMLElement$2(Cn)
      , Cs = getDocumentElement$1(Cn)
      , Ls = getBoundingClientRect$1(xt, !0, as === "fixed", Cn);
    let Vs = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const Ws = {
        x: 0,
        y: 0
    };
    if (cs || !cs && as !== "fixed")
        if ((getNodeName$1(Cn) !== "body" || isOverflowElement$1(Cs)) && (Vs = getNodeScroll$1(Cn)),
        isHTMLElement$2(Cn)) {
            const Xs = getBoundingClientRect$1(Cn, !0);
            Ws.x = Xs.x + Cn.clientLeft,
            Ws.y = Xs.y + Cn.clientTop
        } else
            Cs && (Ws.x = getWindowScrollBarX$1(Cs));
    return {
        x: Ls.left + Vs.scrollLeft - Ws.x,
        y: Ls.top + Vs.scrollTop - Ws.y,
        width: Ls.width,
        height: Ls.height
    }
}
function getParentNode$1(xt) {
    if (getNodeName$1(xt) === "html")
        return xt;
    const Cn = xt.assignedSlot || xt.parentNode || (isShadowRoot$1(xt) ? xt.host : null) || getDocumentElement$1(xt);
    return isShadowRoot$1(Cn) ? Cn.host : Cn
}
function getTrueOffsetParent$1(xt) {
    return !isHTMLElement$2(xt) || getComputedStyle$1$1(xt).position === "fixed" ? null : xt.offsetParent
}
function getContainingBlock$1(xt) {
    let Cn = getParentNode$1(xt);
    for (; isHTMLElement$2(Cn) && !isLastTraversableNode$1(Cn); ) {
        if (isContainingBlock$1(Cn))
            return Cn;
        Cn = getParentNode$1(Cn)
    }
    return null
}
function getOffsetParent$1(xt) {
    const Cn = getWindow$2(xt);
    let as = getTrueOffsetParent$1(xt);
    for (; as && isTableElement$1(as) && getComputedStyle$1$1(as).position === "static"; )
        as = getTrueOffsetParent$1(as);
    return as && (getNodeName$1(as) === "html" || getNodeName$1(as) === "body" && getComputedStyle$1$1(as).position === "static" && !isContainingBlock$1(as)) ? Cn : as || getContainingBlock$1(xt) || Cn
}
function getDimensions$1(xt) {
    if (isHTMLElement$2(xt))
        return {
            width: xt.offsetWidth,
            height: xt.offsetHeight
        };
    const Cn = getBoundingClientRect$1(xt);
    return {
        width: Cn.width,
        height: Cn.height
    }
}
function convertOffsetParentRelativeRectToViewportRelativeRect$1(xt) {
    let {rect: Cn, offsetParent: as, strategy: cs} = xt;
    const Cs = isHTMLElement$2(as)
      , Ls = getDocumentElement$1(as);
    if (as === Ls)
        return Cn;
    let Vs = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , Ws = {
        x: 1,
        y: 1
    };
    const Xs = {
        x: 0,
        y: 0
    };
    if ((Cs || !Cs && cs !== "fixed") && ((getNodeName$1(as) !== "body" || isOverflowElement$1(Ls)) && (Vs = getNodeScroll$1(as)),
    isHTMLElement$2(as))) {
        const ga = getBoundingClientRect$1(as);
        Ws = getScale$1(as),
        Xs.x = ga.x + as.clientLeft,
        Xs.y = ga.y + as.clientTop
    }
    return {
        width: Cn.width * Ws.x,
        height: Cn.height * Ws.y,
        x: Cn.x * Ws.x - Vs.scrollLeft * Ws.x + Xs.x,
        y: Cn.y * Ws.y - Vs.scrollTop * Ws.y + Xs.y
    }
}
function getViewportRect$1(xt, Cn) {
    const as = getWindow$2(xt)
      , cs = getDocumentElement$1(xt)
      , Cs = as.visualViewport;
    let Ls = cs.clientWidth
      , Vs = cs.clientHeight
      , Ws = 0
      , Xs = 0;
    if (Cs) {
        Ls = Cs.width,
        Vs = Cs.height;
        const ga = isLayoutViewport();
        (ga || !ga && Cn === "fixed") && (Ws = Cs.offsetLeft,
        Xs = Cs.offsetTop)
    }
    return {
        width: Ls,
        height: Vs,
        x: Ws,
        y: Xs
    }
}
function getDocumentRect$1(xt) {
    var Cn;
    const as = getDocumentElement$1(xt)
      , cs = getNodeScroll$1(xt)
      , Cs = (Cn = xt.ownerDocument) == null ? void 0 : Cn.body
      , Ls = max$1(as.scrollWidth, as.clientWidth, Cs ? Cs.scrollWidth : 0, Cs ? Cs.clientWidth : 0)
      , Vs = max$1(as.scrollHeight, as.clientHeight, Cs ? Cs.scrollHeight : 0, Cs ? Cs.clientHeight : 0);
    let Ws = -cs.scrollLeft + getWindowScrollBarX$1(xt);
    const Xs = -cs.scrollTop;
    return getComputedStyle$1$1(Cs || as).direction === "rtl" && (Ws += max$1(as.clientWidth, Cs ? Cs.clientWidth : 0) - Ls),
    {
        width: Ls,
        height: Vs,
        x: Ws,
        y: Xs
    }
}
function getNearestOverflowAncestor$1(xt) {
    const Cn = getParentNode$1(xt);
    return isLastTraversableNode$1(Cn) ? xt.ownerDocument.body : isHTMLElement$2(Cn) && isOverflowElement$1(Cn) ? Cn : getNearestOverflowAncestor$1(Cn)
}
function getOverflowAncestors$1(xt, Cn) {
    var as;
    Cn === void 0 && (Cn = []);
    const cs = getNearestOverflowAncestor$1(xt)
      , Cs = cs === ((as = xt.ownerDocument) == null ? void 0 : as.body)
      , Ls = getWindow$2(cs);
    return Cs ? Cn.concat(Ls, Ls.visualViewport || [], isOverflowElement$1(cs) ? cs : []) : Cn.concat(cs, getOverflowAncestors$1(cs))
}
function getInnerBoundingClientRect$1(xt, Cn) {
    const as = getBoundingClientRect$1(xt, !0, Cn === "fixed")
      , cs = as.top + xt.clientTop
      , Cs = as.left + xt.clientLeft
      , Ls = isHTMLElement$2(xt) ? getScale$1(xt) : {
        x: 1,
        y: 1
    }
      , Vs = xt.clientWidth * Ls.x
      , Ws = xt.clientHeight * Ls.y
      , Xs = Cs * Ls.x
      , ga = cs * Ls.y;
    return {
        top: ga,
        left: Xs,
        right: Xs + Vs,
        bottom: ga + Ws,
        x: Xs,
        y: ga,
        width: Vs,
        height: Ws
    }
}
function getClientRectFromClippingAncestor$1(xt, Cn, as) {
    return Cn === "viewport" ? rectToClientRect$1(getViewportRect$1(xt, as)) : isElement$1(Cn) ? getInnerBoundingClientRect$1(Cn, as) : rectToClientRect$1(getDocumentRect$1(getDocumentElement$1(xt)))
}
function getClippingElementAncestors$1(xt, Cn) {
    const as = Cn.get(xt);
    if (as)
        return as;
    let cs = getOverflowAncestors$1(xt).filter(Ws => isElement$1(Ws) && getNodeName$1(Ws) !== "body")
      , Cs = null;
    const Ls = getComputedStyle$1$1(xt).position === "fixed";
    let Vs = Ls ? getParentNode$1(xt) : xt;
    for (; isElement$1(Vs) && !isLastTraversableNode$1(Vs); ) {
        const Ws = getComputedStyle$1$1(Vs)
          , Xs = isContainingBlock$1(Vs);
        (Ls ? !Xs && !Cs : !Xs && Ws.position === "static" && !!Cs && ["absolute", "fixed"].includes(Cs.position)) ? cs = cs.filter(ba => ba !== Vs) : Cs = Ws,
        Vs = getParentNode$1(Vs)
    }
    return Cn.set(xt, cs),
    cs
}
function getClippingRect$1(xt) {
    let {element: Cn, boundary: as, rootBoundary: cs, strategy: Cs} = xt;
    const Vs = [...as === "clippingAncestors" ? getClippingElementAncestors$1(Cn, this._c) : [].concat(as), cs]
      , Ws = Vs[0]
      , Xs = Vs.reduce( (ga, ba) => {
        const yl = getClientRectFromClippingAncestor$1(Cn, ba, Cs);
        return ga.top = max$1(yl.top, ga.top),
        ga.right = min$1(yl.right, ga.right),
        ga.bottom = min$1(yl.bottom, ga.bottom),
        ga.left = max$1(yl.left, ga.left),
        ga
    }
    , getClientRectFromClippingAncestor$1(Cn, Ws, Cs));
    return {
        width: Xs.right - Xs.left,
        height: Xs.bottom - Xs.top,
        x: Xs.left,
        y: Xs.top
    }
}
const platform$1 = {
    getClippingRect: getClippingRect$1,
    convertOffsetParentRelativeRectToViewportRelativeRect: convertOffsetParentRelativeRectToViewportRelativeRect$1,
    isElement: isElement$1,
    getDimensions: getDimensions$1,
    getOffsetParent: getOffsetParent$1,
    getDocumentElement: getDocumentElement$1,
    getScale: getScale$1,
    getElementRects(xt) {
        return __async(this, null, function*() {
            let {reference: Cn, floating: as, strategy: cs} = xt;
            const Cs = this.getOffsetParent || getOffsetParent$1
              , Ls = this.getDimensions;
            return {
                reference: getRectRelativeToOffsetParent$1(Cn, yield Cs(as), cs),
                floating: __spreadValues$1({
                    x: 0,
                    y: 0
                }, yield Ls(as))
            }
        })
    },
    getClientRects: xt => Array.from(xt.getClientRects()),
    isRTL: xt => getComputedStyle$1$1(xt).direction === "rtl"
};
function autoUpdate$1(xt, Cn, as, cs) {
    cs === void 0 && (cs = {});
    const {ancestorScroll: Cs=!0, ancestorResize: Ls=!0, elementResize: Vs=!0, animationFrame: Ws=!1} = cs
      , Xs = Cs && !Ws
      , ga = Xs || Ls ? [...isElement$1(xt) ? getOverflowAncestors$1(xt) : xt.contextElement ? getOverflowAncestors$1(xt.contextElement) : [], ...getOverflowAncestors$1(Cn)] : [];
    ga.forEach(_l => {
        Xs && _l.addEventListener("scroll", as, {
            passive: !0
        }),
        Ls && _l.addEventListener("resize", as)
    }
    );
    let ba = null;
    if (Vs) {
        let _l = !0;
        ba = new ResizeObserver( () => {
            _l || as(),
            _l = !1
        }
        ),
        isElement$1(xt) && !Ws && ba.observe(xt),
        !isElement$1(xt) && xt.contextElement && !Ws && ba.observe(xt.contextElement),
        ba.observe(Cn)
    }
    let yl, xl = Ws ? getBoundingClientRect$1(xt) : null;
    Ws && wl();
    function wl() {
        const _l = getBoundingClientRect$1(xt);
        xl && (_l.x !== xl.x || _l.y !== xl.y || _l.width !== xl.width || _l.height !== xl.height) && as(),
        xl = _l,
        yl = requestAnimationFrame(wl)
    }
    return as(),
    () => {
        var _l;
        ga.forEach(El => {
            Xs && El.removeEventListener("scroll", as),
            Ls && El.removeEventListener("resize", as)
        }
        ),
        (_l = ba) == null || _l.disconnect(),
        ba = null,
        Ws && cancelAnimationFrame(yl)
    }
}
const computePosition$2 = (xt, Cn, as) => {
    const cs = new Map
      , Cs = __spreadValues$1({
        platform: platform$1
    }, as)
      , Ls = __spreadProps(__spreadValues$1({}, Cs.platform), {
        _c: cs
    });
    return computePosition$1$1(xt, Cn, __spreadProps(__spreadValues$1({}, Cs), {
        platform: Ls
    }))
}
;
function P$6(xt, Cn, as) {
    let cs = () => {
        var yl;
        return (yl = as == null ? void 0 : as.placement) != null ? yl : "bottom"
    }
      , Cs = () => {
        var yl;
        return (yl = as == null ? void 0 : as.strategy) != null ? yl : "absolute"
    }
      , [Ls,Vs] = createSignal({
        x: null,
        y: null,
        placement: cs(),
        strategy: Cs(),
        middlewareData: {}
    })
      , [Ws,Xs] = createSignal();
    createEffect( () => {
        let yl = Ws();
        if (yl)
            throw yl.value
    }
    );
    let ga = createMemo( () => (xt(),
    Cn(),
    {}));
    function ba() {
        let yl = xt()
          , xl = Cn();
        if (yl && xl) {
            let wl = ga();
            computePosition$2(yl, xl, {
                middleware: as == null ? void 0 : as.middleware,
                placement: cs(),
                strategy: Cs()
            }).then(_l => {
                wl === ga() && Vs(_l)
            }
            , _l => {
                Xs(_l)
            }
            )
        }
    }
    return createEffect( () => {
        let yl = xt()
          , xl = Cn();
        if (cs(),
        Cs(),
        yl && xl)
            if (as != null && as.whileElementsMounted) {
                let wl = as.whileElementsMounted(yl, xl, ba);
                wl && onCleanup(wl)
            } else
                ba()
    }
    ),
    {
        get x() {
            return Ls().x
        },
        get y() {
            return Ls().y
        },
        get placement() {
            return Ls().placement
        },
        get strategy() {
            return Ls().strategy
        },
        get middlewareData() {
            return Ls().middlewareData
        },
        update: ba
    }
}
const _tmpl$$3 = template$1('<tc-root data-tc-dropdown-container="true"></tc-root>')
  , AccountButton = () => {
    const xt = useTheme()
      , Cn = useContext(ConnectorContext)
      , as = useContext(TonConnectUiContext)
      , [cs,Cs] = createSignal(!1)
      , [Ls,Vs] = createSignal(Cn.account)
      , [Ws,Xs] = createSignal(!Cn.account);
    let ga;
    const [ba,yl] = createSignal()
      , [xl,wl] = createSignal()
      , _l = P$6(xl, ba, {
        whileElementsMounted: autoUpdate$1,
        placement: "bottom-end"
    })
      , El = () => {
        const Sl = Ls();
        if (Sl) {
            const Tl = toUserFriendlyAddress(Sl.address, Sl.chain === CHAIN.TESTNET);
            return Tl.slice(0, 4) + "" + Tl.slice(-4)
        }
        return ""
    }
    ;
    as.connectionRestored.then( () => Xs(!1));
    const Cl = Cn.onStatusChange(Sl => {
        if (!Sl) {
            Cs(!1),
            Vs(null),
            Xs(!1);
            return
        }
        Vs(Sl.account),
        Xs(!1)
    }
    )
      , $l = Sl => {
        if (!Ls() || !cs())
            return;
        const Tl = xl().contains(Sl.target)
          , Rl = ga.contains(Sl.target);
        !Tl && !Rl && Cs(!1)
    }
    ;
    return onMount( () => {
        document.body.addEventListener("click", $l)
    }
    ),
    onCleanup( () => {
        document.body.removeEventListener("click", $l),
        Cl()
    }
    ),
    createComponent(Dynamic, {
        component: globalStylesTag,
        get children() {
            return [createComponent(Show, {
                get when() {
                    return Ws()
                },
                get children() {
                    return createComponent(LoaderButtonStyled$1, {
                        disabled: !0,
                        "data-tc-connect-button-loading": "true",
                        get children() {
                            return createComponent(LoaderIconStyled$1, {})
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return !Ws()
                },
                get children() {
                    return [createComponent(Show, {
                        get when() {
                            return !Ls()
                        },
                        get children() {
                            return createComponent(AccountButtonStyled, {
                                onClick: () => as.openModal(),
                                "data-tc-connect-button": "true",
                                scale: "s",
                                get children() {
                                    return [createComponent(TonIcon$1, {
                                        get fill() {
                                            return xt.colors.connectButton.foreground
                                        }
                                    }), createComponent(Text, {
                                        translationKey: "button.connectWallet",
                                        fontSize: "15px",
                                        lineHeight: "18px",
                                        fontWeight: "590",
                                        get color() {
                                            return xt.colors.connectButton.foreground
                                        },
                                        children: "Connect wallet"
                                    })]
                                }
                            })
                        }
                    }), createComponent(Show, {
                        get when() {
                            return Ls()
                        },
                        get children() {
                            return createComponent(DropdownContainerStyled, {
                                get children() {
                                    return [createComponent(DropdownButtonStyled, {
                                        onClick: () => Cs(Sl => !Sl),
                                        ref: wl,
                                        "data-tc-dropdown-button": "true",
                                        scale: "s",
                                        get children() {
                                            return [createComponent(Text, {
                                                fontSize: "15px",
                                                fontWeight: "590",
                                                lineHeight: "18px",
                                                get children() {
                                                    return El()
                                                }
                                            }), createComponent(ArrowIcon, {
                                                direction: "bottom"
                                            })]
                                        }
                                    }), createComponent(Portal, {
                                        get children() {
                                            const Sl = untrack( () => document.importNode(_tmpl$$3, !0));
                                            return use(yl, Sl),
                                            Sl.style.setProperty("z-index", "999"),
                                            Sl._$owner = getOwner(),
                                            insert(Sl, createComponent(Transition, {
                                                onBeforeEnter: Tl => {
                                                    animate(Tl, [{
                                                        opacity: 0,
                                                        transform: "translateY(-8px)"
                                                    }, {
                                                        opacity: 1,
                                                        transform: "translateY(0)"
                                                    }], {
                                                        duration: 150
                                                    })
                                                }
                                                ,
                                                onExit: (Tl, Rl) => {
                                                    animate(Tl, [{
                                                        opacity: 1,
                                                        transform: "translateY(0)"
                                                    }, {
                                                        opacity: 0,
                                                        transform: "translateY(-8px)"
                                                    }], {
                                                        duration: 150
                                                    }).finished.then(Rl)
                                                }
                                                ,
                                                get children() {
                                                    return createComponent(Show, {
                                                        get when() {
                                                            return cs()
                                                        },
                                                        get children() {
                                                            return createComponent(DropdownStyled, {
                                                                get hidden() {
                                                                    return !cs()
                                                                },
                                                                onClose: () => Cs(!1),
                                                                ref(Tl) {
                                                                    const Rl = ga;
                                                                    typeof Rl == "function" ? Rl(Tl) : ga = Tl
                                                                }
                                                            })
                                                        }
                                                    })
                                                }
                                            }), null),
                                            insert(Sl, createComponent(NotificationsStyled, {}), null),
                                            createRenderEffect(Tl => {
                                                var Rl, Il;
                                                const Ml = _l.strategy
                                                  , Nl = `${(Rl = _l.y) != null ? Rl : 0}px`
                                                  , Ll = `${(Il = _l.x) != null ? Il : 0}px`;
                                                return Ml !== Tl._v$ && Sl.style.setProperty("position", Tl._v$ = Ml),
                                                Nl !== Tl._v$2 && Sl.style.setProperty("top", Tl._v$2 = Nl),
                                                Ll !== Tl._v$3 && Sl.style.setProperty("left", Tl._v$3 = Ll),
                                                Tl
                                            }
                                            , {
                                                _v$: void 0,
                                                _v$2: void 0,
                                                _v$3: void 0
                                            }),
                                            Sl
                                        }
                                    })]
                                }
                            })
                        }
                    })]
                }
            })]
        }
    })
}
  , StyledModal = styled(Modal)`
    padding-left: 24px;
    padding-right: 24px;
    padding-top: 18px;
    padding-bottom: 0;

    ${media("mobile")} {
        padding-left: 0;
        padding-right: 0;

        min-height: 364px;
    }
`
  , H1Styled$8 = styled(H1)`
    margin-top: 12px;

    ${media("mobile")} {
        padding: 0 10px;
    }
`
  , LoaderContainerStyled = styled.div`
    margin: 30px 0;
    width: 100%;
    display: flex;
    justify-content: center;

    ${media("mobile")} {
        height: 160px;
        align-items: center;
    }
`;
styled(Text)`
    min-width: 84px;
    text-align: center;
    font-weight: 590;
`;
styled(TabBar)`
    margin: 0 auto 22px;
`;
const [appState,setAppState] = createStore$1({
    buttonRootId: null,
    language: "en",
    returnStrategy: "back",
    twaReturnUrl: void 0,
    walletsListConfiguration: {},
    enableAndroidBackHandler: !0
});
function uniq(xt) {
    return [...new Set(xt)]
}
function mergeConcat(xt, Cn, as) {
    return Cn.map(cs => {
        const Cs = as.find(Ls => Ls[xt] === cs[xt]);
        return as = as.filter(Ls => Ls[xt] !== cs[xt]),
        Cs === void 0 ? cs : Cs
    }
    ).concat(as)
}
function uiWalletToWalletInfo(xt) {
    return "jsBridgeKey"in xt ? __spreadProps(__spreadValues$1({}, xt), {
        injected: TonConnect.isWalletInjected(xt.jsBridgeKey),
        embedded: TonConnect.isInsideWalletBrowser(xt.jsBridgeKey)
    }) : xt
}
function applyWalletsListConfiguration(xt, Cn) {
    var as;
    return Cn && (as = Cn.includeWallets) != null && as.length && (xt = mergeConcat("name", xt, Cn.includeWallets.map(uiWalletToWalletInfo))),
    xt
}
function supportsDesktop(xt) {
    return xt.platforms.some(Cn => ["macos", "linux", "windows"].includes(Cn))
}
function supportsMobile(xt) {
    return xt.platforms.some(Cn => ["ios", "android"].includes(Cn))
}
function supportsExtension(xt) {
    return xt.platforms.some(Cn => ["chrome", "firefox", "safari"].includes(Cn))
}
function eqWalletName(xt, Cn) {
    return Cn ? xt.name.toLowerCase() === Cn.toLowerCase() || xt.appName.toLowerCase() === Cn.toLowerCase() : !1
}
const DesktopSelectWalletModalStyled = styled.div`
    display: flex;
    flex-direction: column;
    align-items: center;
`
  , H1Styled$7 = styled(H1)`
    margin-bottom: 18px;
`;
styled.div`
    height: 1px;
    margin: 0 -24px;
    width: calc(100% + 48px);
    opacity: 0.12;
    background: ${xt => xt.isShown ? xt.theme.colors.icon.secondary : "transparent"};
    transition: background 0.15s ease-in-out;

    ${media("mobile")} {
        width: 100%;
    }
`;
const WalletsUl = styled.ul`
    display: grid;
    grid-template-columns: repeat(auto-fit, 92px);
    grid-template-rows: auto;
    align-content: flex-start;
    justify-content: center;
    row-gap: 8px;
    width: 100%;
    padding: 0 0 16px;
    align-self: flex-start;
    max-width: 400px;
    margin: 0 auto;

    > li {
        display: block;
        height: fit-content;
    }

    ${media("mobile")} {
        grid-template-columns: repeat(auto-fit, 82px);
    }
`;
styled(Button$1)`
    display: block;
    margin: 0 auto 1px;
    font-size: 15px;
`;
const StyledIconButton$3 = styled(IconButton)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , WalletLabeledItemStyled = styled(WalletLabeledItem)`
    height: 100%;
`
  , _tmpl$$2 = template$1("<li></li>")
  , AllWalletsListModal = xt => {
    const Cn = () => isMobile$1() ? void 0 : 510
      , as = () => isMobile$1() ? xt.walletsList.filter(supportsMobile) : xt.walletsList;
    return createComponent(DesktopSelectWalletModalStyled, {
        "data-tc-wallets-modal-list": "true",
        get children() {
            return [createComponent(StyledIconButton$3, {
                icon: "arrow",
                onClick: () => xt.onBack()
            }), createComponent(H1Styled$7, {
                translationKey: "walletModal.wallets",
                children: "Wallets"
            }), createComponent(ScrollContainer, {
                get maxHeight() {
                    return Cn()
                },
                get children() {
                    return createComponent(WalletsUl, {
                        get children() {
                            return createComponent(For, {
                                get each() {
                                    return as()
                                },
                                children: cs => ( () => {
                                    const Cs = _tmpl$$2.cloneNode(!0);
                                    return insert(Cs, createComponent(WalletLabeledItemStyled, {
                                        wallet: cs,
                                        onClick: () => xt.onSelect(cs)
                                    })),
                                    Cs
                                }
                                )()
                            })
                        }
                    })
                }
            })]
        }
    })
}
  , tgButtonBorders = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , tgIconBorders = {
    m: "6px",
    s: "6px",
    none: "0"
}
  , DesktopConnectionModalStyled = styled.div`
    display: flex;
    flex-direction: column;
`
  , BodyStyled$1 = styled.div`
    flex: 1;
    margin-top: ${xt => xt.qr ? "0" : "18px"};
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 232px;
`
  , QRCodeStyled$1 = styled(QRCode)`
    margin-bottom: 24px;
`
  , H1Styled$6 = styled(H1)`
    max-width: 288px;
    margin: 0 auto 2px;
`
  , H2Styled$4 = styled(H2)`
    max-width: 288px;
    text-align: center;
    margin: 0 auto 20px;
`
  , StyledIconButton$2 = styled(IconButton)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , ButtonsContainerStyled$1 = styled.div`
    display: flex;
    justify-content: center;
    gap: 8px;
    padding-bottom: 16px;
`
  , BottomButtonsContainerStyled = styled(ButtonsContainerStyled$1)`
    padding-bottom: 0;
`
  , FooterButton$1 = styled(Button$1)`
    margin-bottom: 24px;
`
  , LoaderStyled$1 = styled(LoaderIcon)`
    margin-bottom: 18px;
    margin-top: 2px;
`
  , ErrorIconStyled$1 = styled(ErrorIcon)`
    margin-bottom: 16px;
`
  , BodyTextStyled$1 = styled(H2)`
    color: ${xt => xt.theme.colors.text.secondary};
    text-align: center;
    margin-bottom: 20px;
`
  , TgButtonStyled = styled(Button$1)`
    margin-top: -8px;
    margin-bottom: 24px;
    width: 100%;
    padding: 12px 12px 12px 20px;
    border-radius: ${xt => tgButtonBorders[xt.theme.borderRadius]};
    font-size: 16px;
    line-height: 20px;
`
  , TgImageStyled = styled(Image$1)`
    width: 32px;
    height: 32px;
    border-radius: ${xt => tgIconBorders[xt.theme.borderRadius]};
`
  , Translation = xt => {
    const [Cn] = useI18n();
    return createMemo( () => {
        var as;
        return Cn(xt.translationKey, xt.translationValues, (as = xt.children) == null ? void 0 : as.toString())
    }
    )
}
;
function addReturnStrategy(xt, Cn) {
    let as;
    typeof Cn == "string" ? as = Cn : as = isInTMA() ? Cn.twaReturnUrl || Cn.returnStrategy : "none";
    const cs = addQueryParameter(xt, "ret", as);
    if (!isTelegramUrl(xt))
        return cs;
    const Cs = cs.slice(cs.lastIndexOf("&") + 1);
    return cs.slice(0, cs.lastIndexOf("&")) + "-" + encodeTelegramUrlParameters(Cs)
}
function redirectToTelegram(xt, Cn) {
    Cn = __spreadValues$1({}, Cn);
    const as = convertToTGDirectLink(xt)
      , cs = new URL(as);
    if (cs.searchParams.has("startapp") || cs.searchParams.append("startapp", "tonconnect"),
    isInTelegramBrowser()) {
        Cn.returnStrategy = "back";
        const Cs = addReturnStrategy(cs.toString(), Cn.returnStrategy);
        openLinkBlank(Cs)
    } else if (isInTMA())
        if (isTmaPlatform("ios", "android", "macos", "tdesktop", "web")) {
            Cn.returnStrategy = "back";
            const Cs = addReturnStrategy(cs.toString(), Cn.returnStrategy);
            sendOpenTelegramLink(Cs)
        } else
            isTmaPlatform("weba") ? sendOpenTelegramLink(addReturnStrategy(cs.toString(), Cn)) : openLinkBlank(addReturnStrategy(cs.toString(), Cn));
    else if (isOS("ios")) {
        Cn.returnStrategy === "back" && (isBrowser$2("safari") ? Cn.returnStrategy = "back" : isBrowser$2("chrome") ? Cn.returnStrategy = "googlechrome://" : isBrowser$2("firefox") ? Cn.returnStrategy = "firefox://" : isBrowser$2("opera") ? Cn.returnStrategy = "opera-http://" : Cn.returnStrategy = location.href);
        const Cs = isBrowser$2("chrome")
          , Ls = isBrowser$2("firefox");
        if ((Cs || Ls) && !Cn.forceRedirect) {
            const Ws = addReturnStrategy(cs.toString(), Cn.returnStrategy)
              , Xs = convertToTGDeepLink(Ws);
            openDeeplinkWithFallback(Xs, () => openLinkBlank(Ws))
        } else {
            const Ws = addReturnStrategy(cs.toString(), Cn.returnStrategy);
            openLinkBlank(Ws)
        }
    } else if (isOS("android")) {
        Cn.returnStrategy = "back";
        const Cs = isBrowser$2("chrome")
          , Ls = isBrowser$2("firefox");
        if ((Cs || Ls) && !Cn.forceRedirect) {
            const Ws = addReturnStrategy(cs.toString(), Cn.returnStrategy)
              , Xs = convertToTGDeepLink(Ws);
            openDeeplinkWithFallback(Xs, () => openLinkBlank(Ws))
        } else {
            const Ws = addReturnStrategy(cs.toString(), Cn.returnStrategy);
            openLinkBlank(Ws)
        }
    } else if (isOS("ipad")) {
        Cn.returnStrategy === "back" && (isBrowser$2("safari") ? Cn.returnStrategy = "back" : isBrowser$2("chrome") ? Cn.returnStrategy = "googlechrome://" : isBrowser$2("firefox") ? Cn.returnStrategy = "firefox://" : isBrowser$2("opera") ? Cn.returnStrategy = "opera-http://" : Cn.returnStrategy = location.href);
        const Cs = isBrowser$2("chrome")
          , Ls = isBrowser$2("firefox")
          , Vs = (Cs || Ls) && !Cn.forceRedirect
          , Ws = addReturnStrategy(cs.toString(), Cn.returnStrategy);
        if (Vs) {
            const Xs = convertToTGDeepLink(Ws);
            openDeeplinkWithFallback(Xs, () => openLinkBlank(Ws))
        } else
            openLinkBlank(Ws)
    } else if (isOS("macos", "windows", "linux")) {
        Cn.returnStrategy = "back",
        Cn.twaReturnUrl = void 0;
        const Cs = addReturnStrategy(cs.toString(), Cn.returnStrategy);
        if (Cn.forceRedirect)
            openLinkBlank(Cs);
        else {
            const Ls = convertToTGDeepLink(Cs);
            openDeeplinkWithFallback(Ls, () => openLinkBlank(Cs))
        }
    } else
        openLinkBlank(addReturnStrategy(cs.toString(), Cn))
}
function redirectToWallet(xt, Cn, as, cs) {
    if (as = __spreadValues$1({}, as),
    isInTelegramBrowser())
        if (isOS("ios", "android"))
            as.returnStrategy === "back" && (as.returnStrategy = "tg://resolve"),
            cs("universal-link"),
            openLink(addReturnStrategy(xt, as.returnStrategy), "_self");
        else {
            cs("universal-link");
            const Cs = addReturnStrategy(xt, as.returnStrategy);
            openLinkBlank(Cs)
        }
    else if (isInTMA())
        if (isTmaPlatform("ios", "android")) {
            as.returnStrategy === "back" && (as.returnStrategy = "tg://resolve"),
            cs("universal-link");
            const Cs = addReturnStrategy(xt, as.returnStrategy);
            sendOpenTelegramLink(Cs, () => {
                cs("universal-link"),
                openLinkBlank(Cs)
            }
            )
        } else if (isTmaPlatform("macos", "tdesktop")) {
            as.returnStrategy === "back" && (as.returnStrategy = "tg://resolve");
            const Cs = addReturnStrategy(xt, as.returnStrategy);
            !!Cn && !as.forceRedirect ? (cs("custom-deeplink"),
            openDeeplinkWithFallback(toDeeplink(Cs, Cn), () => {
                cs("universal-link"),
                openLinkBlank(Cs)
            }
            )) : (cs("universal-link"),
            openLinkBlank(Cs))
        } else if (isTmaPlatform("weba")) {
            as.returnStrategy === "back" && (isBrowser$2("safari") ? as.returnStrategy = location.href : isBrowser$2("chrome") ? as.returnStrategy = "googlechrome://" : isBrowser$2("firefox") ? as.returnStrategy = "firefox://" : isBrowser$2("opera") ? as.returnStrategy = "opera-http://" : as.returnStrategy = location.href);
            const Cs = addReturnStrategy(xt, as.returnStrategy);
            !!Cn && !as.forceRedirect ? (cs("custom-deeplink"),
            openDeeplinkWithFallback(toDeeplink(Cs, Cn), () => {
                cs("universal-link"),
                openLinkBlank(Cs)
            }
            )) : (cs("universal-link"),
            openLinkBlank(Cs))
        } else if (isTmaPlatform("web")) {
            as.returnStrategy === "back" && (isBrowser$2("safari") ? as.returnStrategy = location.href : isBrowser$2("chrome") ? as.returnStrategy = "googlechrome://" : isBrowser$2("firefox") ? as.returnStrategy = "firefox://" : isBrowser$2("opera") ? as.returnStrategy = "opera-http://" : as.returnStrategy = location.href);
            const Cs = addReturnStrategy(xt, as.returnStrategy);
            !!Cn && !as.forceRedirect ? (cs("custom-deeplink"),
            openDeeplinkWithFallback(toDeeplink(Cs, Cn), () => {
                cs("universal-link"),
                openLinkBlank(Cs)
            }
            )) : (cs("universal-link"),
            openLinkBlank(Cs))
        } else {
            cs("universal-link");
            const Cs = addReturnStrategy(xt, as.returnStrategy);
            openLinkBlank(Cs)
        }
    else if (isOS("ios"))
        as.returnStrategy === "back" && (isBrowser$2("safari") ? as.returnStrategy = "none" : isBrowser$2("chrome") ? as.returnStrategy = "googlechrome://" : isBrowser$2("firefox") ? as.returnStrategy = "firefox://" : isBrowser$2("opera") ? as.returnStrategy = "opera-http://" : as.returnStrategy = location.href),
        isBrowser$2("chrome") ? (cs("universal-link"),
        openLink(addReturnStrategy(xt, as.returnStrategy), "_self")) : (cs("universal-link"),
        openLinkBlank(addReturnStrategy(xt, as.returnStrategy)));
    else if (isOS("android"))
        as.returnStrategy === "back" && (isBrowser$2("chrome") ? as.returnStrategy = "googlechrome://" : isBrowser$2("firefox") ? as.returnStrategy = "firefox://" : isBrowser$2("opera") ? as.returnStrategy = "opera-http://" : as.returnStrategy = location.href),
        cs("universal-link"),
        openLinkBlank(addReturnStrategy(xt, as.returnStrategy));
    else if (isOS("ipad"))
        as.returnStrategy === "back" && (isBrowser$2("safari") ? as.returnStrategy = "none" : isBrowser$2("chrome") ? as.returnStrategy = "googlechrome://" : isBrowser$2("firefox") ? as.returnStrategy = "firefox://" : isBrowser$2("opera") ? as.returnStrategy = "opera-http://" : as.returnStrategy = location.href),
        isBrowser$2("chrome") ? (cs("universal-link"),
        openLink(addReturnStrategy(xt, as.returnStrategy), "_self")) : (cs("universal-link"),
        openLinkBlank(addReturnStrategy(xt, as.returnStrategy)));
    else if (isOS("macos", "windows", "linux")) {
        as.returnStrategy === "back" && (isBrowser$2("safari") ? as.returnStrategy = "none" : isBrowser$2("chrome") ? as.returnStrategy = "googlechrome://" : isBrowser$2("firefox") ? as.returnStrategy = "firefox://" : isBrowser$2("opera") ? as.returnStrategy = "opera-http://" : as.returnStrategy = "none");
        const Cs = addReturnStrategy(xt, as.returnStrategy);
        !!Cn && !as.forceRedirect ? (cs("custom-deeplink"),
        openDeeplinkWithFallback(toDeeplink(Cs, Cn), () => {
            cs("universal-link"),
            openLinkBlank(Cs)
        }
        )) : (cs("universal-link"),
        openLinkBlank(Cs))
    } else
        cs("universal-link"),
        openLinkBlank(addReturnStrategy(xt, as.returnStrategy))
}
function addQueryParameter(xt, Cn, as) {
    const cs = new URL(xt);
    return cs.searchParams.append(Cn, as),
    cs.toString()
}
function convertToTGDirectLink(xt) {
    const Cn = new URL(xt);
    return Cn.searchParams.has("attach") && (Cn.searchParams.delete("attach"),
    Cn.pathname += "/start"),
    Cn.toString()
}
function convertToTGDeepLink(xt) {
    const Cn = new URL(xt)
      , [,as,cs] = Cn.pathname.split("/")
      , Cs = Cn.searchParams.get("startapp");
    return `tg://resolve?domain=${as}&appname=${cs}&startapp=${Cs}`
}
const DesktopConnectionModal = xt => {
    const [Cn,as] = createSignal("mobile")
      , [cs,Cs] = createSignal(!1)
      , [Ls,Vs] = createSignal()
      , [Ws,Xs] = createSignal(!0)
      , ga = useContext(ConnectorContext)
      , ba = ga.onStatusChange( () => {}
    , () => {
        xt.wallet.appName !== AT_WALLET_APP_NAME && Cs(!0)
    }
    );
    onCleanup(ba);
    const yl = () => {
        try {
            const Cl = ga.connect({
                universalLink: xt.wallet.universalLink,
                bridgeUrl: xt.wallet.bridgeUrl
            }, xt.additionalRequest);
            Vs(Cl)
        } catch {}
    }
    ;
    createEffect( () => {
        untrack(Cn) !== "extension" && (supportsMobile(xt.wallet) || supportsDesktop(xt.wallet)) && yl()
    }
    );
    const xl = () => {
        Cs(!1),
        Cn() === "extension" && yl(),
        as("mobile"),
        setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, xt.wallet), {
            openMethod: "qrcode"
        }))
    }
      , wl = () => {
        if (Cs(!1),
        Cn() === "extension" && yl(),
        as("desktop"),
        isTelegramUrl(Ls()))
            _l();
        else {
            const Cl = !Ws();
            Xs(!1),
            redirectToWallet(Ls(), xt.wallet.deepLink, {
                returnStrategy: appState.returnStrategy,
                forceRedirect: Cl
            }, $l => {
                setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, xt.wallet), {
                    openMethod: $l
                }))
            }
            )
        }
    }
      , _l = () => {
        const Cl = !Ws();
        Xs(!1),
        setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, xt.wallet), {
            openMethod: "universal-link"
        })),
        redirectToTelegram(Ls(), {
            returnStrategy: appState.returnStrategy,
            twaReturnUrl: appState.twaReturnUrl,
            forceRedirect: Cl
        })
    }
      , El = () => {
        Cs(!1),
        as("extension"),
        isWalletInfoCurrentlyInjected(xt.wallet) && (setLastSelectedWalletInfo(xt.wallet),
        ga.connect({
            jsBridgeKey: xt.wallet.jsBridgeKey
        }, xt.additionalRequest))
    }
    ;
    return supportsMobile(xt.wallet) ? xl() : supportsExtension(xt.wallet) ? El() : wl(),
    createComponent(DesktopConnectionModalStyled, {
        "data-tc-wallets-modal-connection-desktop": "true",
        get children() {
            return [createComponent(Show, {
                get when() {
                    return !xt.backDisabled
                },
                get children() {
                    return createComponent(StyledIconButton$2, {
                        icon: "arrow",
                        onClick: () => xt.onBackClick()
                    })
                }
            }), createComponent(H1Styled$6, {
                get children() {
                    return xt.wallet.name
                }
            }), createComponent(Show, {
                get when() {
                    return Cn() === "mobile"
                },
                get children() {
                    return createComponent(H2Styled$4, {
                        translationKey: "walletModal.desktopConnectionModal.scanQR",
                        get translationValues() {
                            return {
                                name: xt.wallet.name
                            }
                        },
                        get children() {
                            return ["Scan the QR code below with your phones or ", createMemo( () => xt.wallet.name), "s camera"]
                        }
                    })
                }
            }), createComponent(BodyStyled$1, {
                get qr() {
                    return Cn() === "mobile"
                },
                get children() {
                    return createComponent(Switch, {
                        get children() {
                            return [createComponent(Match, {
                                get when() {
                                    return Cn() === "mobile"
                                },
                                get children() {
                                    return createComponent(QRCodeStyled$1, {
                                        disableCopy: !1,
                                        get sourceUrl() {
                                            return addReturnStrategy(Ls(), "none")
                                        },
                                        get imageUrl() {
                                            return xt.wallet.imageUrl
                                        }
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return cs()
                                },
                                get children() {
                                    return [createComponent(ErrorIconStyled$1, {
                                        size: "s"
                                    }), createComponent(BodyTextStyled$1, {
                                        translationKey: "walletModal.desktopConnectionModal.connectionDeclined",
                                        children: "Connection declined"
                                    }), createComponent(ButtonsContainerStyled$1, {
                                        get children() {
                                            return createComponent(Button$1, {
                                                get leftIcon() {
                                                    return createComponent(RetryIcon, {})
                                                },
                                                get onClick() {
                                                    return Cn() === "extension" ? El : wl
                                                },
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "common.retry",
                                                        children: "Retry"
                                                    })
                                                }
                                            })
                                        }
                                    })]
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return Cn() === "extension"
                                },
                                get children() {
                                    return [createComponent(Show, {
                                        get when() {
                                            return isWalletInfoCurrentlyInjected(xt.wallet)
                                        },
                                        get children() {
                                            return [createComponent(LoaderStyled$1, {
                                                size: "s"
                                            }), createComponent(BodyTextStyled$1, {
                                                translationKey: "walletModal.desktopConnectionModal.continueInExtension",
                                                get translationValues() {
                                                    return {
                                                        name: xt.wallet.name
                                                    }
                                                },
                                                get children() {
                                                    return ["Continue in ", createMemo( () => xt.wallet.name), " browser extension"]
                                                }
                                            }), createComponent(ButtonsContainerStyled$1, {
                                                get children() {
                                                    return createComponent(Button$1, {
                                                        get leftIcon() {
                                                            return createComponent(RetryIcon, {})
                                                        },
                                                        onClick: El,
                                                        get children() {
                                                            return createComponent(Translation, {
                                                                translationKey: "common.retry",
                                                                children: "Retry"
                                                            })
                                                        }
                                                    })
                                                }
                                            })]
                                        }
                                    }), createComponent(Show, {
                                        get when() {
                                            return !isWalletInfoCurrentlyInjected(xt.wallet)
                                        },
                                        get children() {
                                            return [createComponent(BodyTextStyled$1, {
                                                translationKey: "walletModal.desktopConnectionModal.dontHaveExtension",
                                                get translationValues() {
                                                    return {
                                                        name: xt.wallet.name
                                                    }
                                                },
                                                get children() {
                                                    return ["Seems you don't have installed ", createMemo( () => xt.wallet.name), " browser extension"]
                                                }
                                            }), createComponent(ButtonsContainerStyled$1, {
                                                get children() {
                                                    return createComponent(Link, {
                                                        get href() {
                                                            return xt.wallet.aboutUrl
                                                        },
                                                        blank: !0,
                                                        get children() {
                                                            return createComponent(Button$1, {
                                                                get rightIcon() {
                                                                    return createComponent(LinkIcon, {})
                                                                },
                                                                onClick: El,
                                                                get children() {
                                                                    return createComponent(Translation, {
                                                                        translationKey: "walletModal.desktopConnectionModal.getWallet",
                                                                        get translationValues() {
                                                                            return {
                                                                                name: xt.wallet.name
                                                                            }
                                                                        },
                                                                        get children() {
                                                                            return ["Get ", createMemo( () => xt.wallet.name)]
                                                                        }
                                                                    })
                                                                }
                                                            })
                                                        }
                                                    })
                                                }
                                            })]
                                        }
                                    })]
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return Cn() === "desktop"
                                },
                                get children() {
                                    return [createComponent(LoaderIcon, {
                                        size: "m"
                                    }), createComponent(BodyTextStyled$1, {
                                        translationKey: "walletModal.desktopConnectionModal.continueOnDesktop",
                                        get translationValues() {
                                            return {
                                                name: xt.wallet.name
                                            }
                                        },
                                        get children() {
                                            return ["Continue in ", createMemo( () => xt.wallet.name), " on desktop"]
                                        }
                                    }), createComponent(ButtonsContainerStyled$1, {
                                        get children() {
                                            return [createComponent(Button$1, {
                                                get leftIcon() {
                                                    return createComponent(RetryIcon, {})
                                                },
                                                onClick: wl,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "common.retry",
                                                        children: "Retry"
                                                    })
                                                }
                                            }), createComponent(Link, {
                                                get href() {
                                                    return xt.wallet.aboutUrl
                                                },
                                                blank: !0,
                                                get children() {
                                                    return createComponent(Button$1, {
                                                        get rightIcon() {
                                                            return createComponent(LinkIcon, {})
                                                        },
                                                        get children() {
                                                            return createComponent(Translation, {
                                                                translationKey: "walletModal.desktopConnectionModal.getWallet",
                                                                get translationValues() {
                                                                    return {
                                                                        name: xt.wallet.name
                                                                    }
                                                                },
                                                                get children() {
                                                                    return ["Get ", createMemo( () => xt.wallet.name)]
                                                                }
                                                            })
                                                        }
                                                    })
                                                }
                                            })]
                                        }
                                    })]
                                }
                            })]
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return xt.wallet.appName === AT_WALLET_APP_NAME
                },
                get children() {
                    return createComponent(TgButtonStyled, {
                        get rightIcon() {
                            return createComponent(TgImageStyled, {
                                get src() {
                                    return IMG.TG
                                }
                            })
                        },
                        scale: "s",
                        onClick: _l,
                        get children() {
                            return createComponent(Translation, {
                                translationKey: "walletModal.desktopConnectionModal.openWalletOnTelegram",
                                children: "Open Wallet in Telegram on desktop"
                            })
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return xt.wallet.appName !== AT_WALLET_APP_NAME
                },
                get children() {
                    return createComponent(BottomButtonsContainerStyled, {
                        get children() {
                            return [createComponent(Show, {
                                get when() {
                                    return createMemo( () => Cn() !== "mobile")() && supportsMobile(xt.wallet)
                                },
                                get children() {
                                    return createComponent(FooterButton$1, {
                                        appearance: "secondary",
                                        get leftIcon() {
                                            return createComponent(MobileIcon, {})
                                        },
                                        onClick: xl,
                                        get children() {
                                            return createComponent(Translation, {
                                                translationKey: "common.mobile",
                                                children: "Mobile"
                                            })
                                        }
                                    })
                                }
                            }), createComponent(Show, {
                                get when() {
                                    return createMemo( () => Cn() !== "extension")() && supportsExtension(xt.wallet)
                                },
                                get children() {
                                    return createComponent(FooterButton$1, {
                                        appearance: "secondary",
                                        get leftIcon() {
                                            return createComponent(BrowserIcon, {})
                                        },
                                        onClick: El,
                                        get children() {
                                            return createComponent(Translation, {
                                                translationKey: "common.browserExtension",
                                                children: "Browser Extension"
                                            })
                                        }
                                    })
                                }
                            }), createComponent(Show, {
                                get when() {
                                    return createMemo( () => Cn() !== "desktop")() && supportsDesktop(xt.wallet)
                                },
                                get children() {
                                    return createComponent(FooterButton$1, {
                                        appearance: "secondary",
                                        get leftIcon() {
                                            return createComponent(DesktopIcon, {})
                                        },
                                        onClick: wl,
                                        get children() {
                                            return createComponent(Translation, {
                                                translationKey: "common.desktop",
                                                children: "Desktop"
                                            })
                                        }
                                    })
                                }
                            })]
                        }
                    })
                }
            })]
        }
    })
}
  , InfoModalStyled = styled.div``
  , StyledIconButton$1 = styled(IconButton)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , H1Styled$5 = styled(H1)`
    margin-bottom: 18px;
`
  , InfoBlock = styled.div`
    padding: 16px 0;
    display: flex;
    flex-direction: column;
    align-items: center;
`
  , InfoBlockIconClass = u$9`
    margin-bottom: 12px;
`
  , H3Styled = styled(H3)`
    text-align: center;
    margin-bottom: 4px;
`
  , TextStyled$1 = styled(Text)`
    text-align: center;
    max-width: 352px;
    color: ${xt => xt.theme.colors.text.secondary};
`
  , ButtonsBlock = styled.div`
    padding: 16px 24px 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
`
  , LINKS = {
    GET_A_WALLET: "https://ton.org/wallets?filters[wallet_features][slug][$in]=dapp-auth&pagination[limit]=-1"
}
  , InfoModal = xt => createComponent(InfoModalStyled, {
    "data-tc-wallets-modal-info": "true",
    get children() {
        return [createComponent(StyledIconButton$1, {
            icon: "arrow",
            onClick: () => xt.onBackClick()
        }), createComponent(H1Styled$5, {
            translationKey: "walletModal.infoModal.whatIsAWallet",
            children: "What is a wallet"
        }), createComponent(ScrollContainer, {
            get children() {
                return [createComponent(InfoBlock, {
                    get children() {
                        return [createComponent(SecurityIcon, {
                            class: InfoBlockIconClass
                        }), createComponent(H3Styled, {
                            translationKey: "walletModal.infoModal.secureDigitalAssets",
                            children: "Secure digital assets storage"
                        }), createComponent(TextStyled$1, {
                            translationKey: "walletModal.infoModal.walletProtects",
                            children: "A wallet protects and manages your digital assets including TON, tokens and collectables."
                        })]
                    }
                }), createComponent(InfoBlock, {
                    get children() {
                        return [createComponent(PersonalityIcon, {
                            class: InfoBlockIconClass
                        }), createComponent(H3Styled, {
                            translationKey: "walletModal.infoModal.controlIdentity",
                            children: "Control your Web3 identity"
                        }), createComponent(TextStyled$1, {
                            translationKey: "walletModal.infoModal.manageIdentity",
                            children: "Manage your digital identity and access decentralized applications with ease. Maintain control over your data and engage securely in the blockchain ecosystem."
                        })]
                    }
                }), createComponent(InfoBlock, {
                    get children() {
                        return [createComponent(SwapIcon, {
                            class: InfoBlockIconClass
                        }), createComponent(H3Styled, {
                            translationKey: "walletModal.infoModal.effortlessCryptoTransactions",
                            children: "Effortless crypto transactions"
                        }), createComponent(TextStyled$1, {
                            translationKey: "walletModal.infoModal.easilySend",
                            children: "Easily send, receive, monitor your cryptocurrencies. Streamline your operations with decentralized applications."
                        })]
                    }
                }), createComponent(ButtonsBlock, {
                    get children() {
                        return createComponent(Link, {
                            get href() {
                                return LINKS.GET_A_WALLET
                            },
                            blank: !0,
                            get children() {
                                return createComponent(Button$1, {
                                    get rightIcon() {
                                        return createComponent(WalletIcon, {})
                                    },
                                    get children() {
                                        return createComponent(Translation, {
                                            translationKey: "walletModal.infoModal.getAWallet",
                                            children: "Get a Wallet"
                                        })
                                    }
                                })
                            }
                        })
                    }
                })]
            }
        })]
    }
})
  , MobileConnectionModalStyled = styled.div``
  , BodyStyled = styled.div`
    flex: 1;
    margin-top: 18px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 232px;
`
  , H1Styled$4 = styled(H1)`
    max-width: 262px;
    margin: 0 auto 8px;
`
  , StyledIconButton = styled(IconButton)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , FooterStyled = styled.div`
    padding: 16px;
    display: flex;
    align-items: center;
    gap: 12px;
    border-top: 0.5px solid ${xt => rgba$1(xt.theme.colors.icon.secondary, .2)};
`
  , ImageStyled = styled(Image$1)`
    width: 36px;
    height: 36px;
    border-radius: 10px;
`
  , FooterButton = styled(Link)`
    margin-left: auto;
`
  , LoaderStyled = styled(LoaderIcon)`
    margin-bottom: 18px;
    margin-top: 2px;
`
  , ErrorIconStyled = styled(ErrorIcon)`
    margin-bottom: 16px;
`
  , BodyTextStyled = styled(H2)`
    color: ${xt => xt.theme.colors.text.secondary};
    text-align: center;
    margin-bottom: 20px;
`
  , ButtonsContainerStyled = styled.div`
    display: flex;
    justify-content: center;
    gap: 8px;
    padding-bottom: 16px;
`
  , H1Styled$3 = styled(H1)`
    margin-bottom: 2px;
    padding: 0 64px;
`
  , H2Styled$3 = styled(H2)`
    margin-bottom: 20px;
    padding: 0 64px;
    min-height: 44px;
`
  , QrCodeWrapper$1 = styled.div`
    padding: 0 24px 24px;
`
  , MobileConnectionQR = xt => [createComponent(H1Styled$3, {
    get children() {
        return xt.walletInfo.name
    }
}), createComponent(H2Styled$3, {
    translationKey: "walletModal.mobileConnectionModal.scanQR",
    get translationValues() {
        return {
            name: xt.walletInfo.name
        }
    },
    get children() {
        return ["Scan the QR code below with your phones or ", createMemo( () => xt.walletInfo.name), "s camera"]
    }
}), createComponent(QrCodeWrapper$1, {
    get children() {
        return createComponent(QRCode, {
            get imageUrl() {
                return xt.walletInfo.imageUrl
            },
            get sourceUrl() {
                return addReturnStrategy(xt.universalLink, "none")
            },
            disableCopy: !0
        })
    }
})]
  , MobileConnectionModal = xt => {
    const Cn = useTheme()
      , [as,cs] = createSignal(!0)
      , [Cs,Ls] = createSignal(!1)
      , [Vs,Ws] = createSignal(!1)
      , Xs = useContext(ConnectorContext)
      , ga = Xs.onStatusChange( () => {}
    , () => {
        Ws(!0)
    }
    )
      , ba = createMemo( () => Xs.connect({
        universalLink: xt.wallet.universalLink,
        bridgeUrl: xt.wallet.bridgeUrl
    }, xt.additionalRequest))
      , yl = () => {
        setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, xt.wallet), {
            openMethod: "universal-link"
        })),
        redirectToTelegram(ba(), {
            returnStrategy: appState.returnStrategy,
            twaReturnUrl: appState.twaReturnUrl,
            forceRedirect: !0
        })
    }
      , xl = () => {
        const Cl = ba();
        if (isTelegramUrl(Cl))
            return yl();
        Ws(!1);
        const $l = !as();
        cs(!1),
        redirectToWallet(ba(), xt.wallet.deepLink, {
            returnStrategy: appState.returnStrategy,
            forceRedirect: $l
        }, Sl => {
            setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, xt.wallet), {
                openMethod: Sl
            }))
        }
        )
    }
      , wl = () => {
        Ws(!1),
        Ls(!0),
        setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, xt.wallet), {
            openMethod: "qrcode"
        }))
    }
      , _l = () => {
        Ls(!1),
        setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, xt.wallet), {
            openMethod: "universal-link"
        }))
    }
      , El = () => {
        Cs() ? _l() : xt.onBackClick()
    }
    ;
    return onCleanup(ga),
    xl(),
    createComponent(MobileConnectionModalStyled, {
        "data-tc-wallets-modal-connection-mobile": "true",
        get children() {
            return [createComponent(Show, {
                get when() {
                    return !xt.backDisabled || Cs()
                },
                get children() {
                    return createComponent(StyledIconButton, {
                        icon: "arrow",
                        onClick: El
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return Cs()
                },
                get children() {
                    return createComponent(MobileConnectionQR, {
                        get universalLink() {
                            return ba()
                        },
                        get walletInfo() {
                            return xt.wallet
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return !Cs()
                },
                get children() {
                    return [createComponent(H1Styled$4, {
                        get children() {
                            return xt.wallet.name
                        }
                    }), createComponent(BodyStyled, {
                        get children() {
                            return [createComponent(Show, {
                                get when() {
                                    return Vs()
                                },
                                get children() {
                                    return [createComponent(ErrorIconStyled, {
                                        size: "s"
                                    }), createComponent(BodyTextStyled, {
                                        translationKey: "walletModal.mobileConnectionModal.connectionDeclined",
                                        children: "Connection declined"
                                    }), createComponent(ButtonsContainerStyled, {
                                        get children() {
                                            return [createComponent(Button$1, {
                                                get leftIcon() {
                                                    return createComponent(RetryIcon, {})
                                                },
                                                onClick: xl,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "common.retry",
                                                        children: "Retry"
                                                    })
                                                }
                                            }), createComponent(Button$1, {
                                                get leftIcon() {
                                                    return createComponent(QRIcon, {
                                                        get fill() {
                                                            return Cn.colors.accent
                                                        }
                                                    })
                                                },
                                                onClick: wl,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "walletModal.mobileConnectionModal.showQR",
                                                        children: "Show QR Code"
                                                    })
                                                }
                                            })]
                                        }
                                    })]
                                }
                            }), createComponent(Show, {
                                get when() {
                                    return !Vs()
                                },
                                get children() {
                                    return [createComponent(LoaderStyled, {
                                        size: "s"
                                    }), createComponent(BodyTextStyled, {
                                        translationKey: "walletModal.mobileConnectionModal.continueIn",
                                        get translationValues() {
                                            return {
                                                name: xt.wallet.name
                                            }
                                        },
                                        get children() {
                                            return ["Continue in ", createMemo( () => xt.wallet.name), ""]
                                        }
                                    }), createComponent(ButtonsContainerStyled, {
                                        get children() {
                                            return [createComponent(Button$1, {
                                                get leftIcon() {
                                                    return createComponent(RetryIcon, {})
                                                },
                                                onClick: xl,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "common.retry",
                                                        children: "Retry"
                                                    })
                                                }
                                            }), createComponent(Button$1, {
                                                get leftIcon() {
                                                    return createComponent(QRIcon, {
                                                        get fill() {
                                                            return Cn.colors.accent
                                                        }
                                                    })
                                                },
                                                onClick: wl,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "walletModal.mobileConnectionModal.showQR",
                                                        children: "Show QR Code"
                                                    })
                                                }
                                            })]
                                        }
                                    })]
                                }
                            })]
                        }
                    }), createComponent(FooterStyled, {
                        get children() {
                            return [createComponent(ImageStyled, {
                                get src() {
                                    return xt.wallet.imageUrl
                                }
                            }), createComponent(H3, {
                                get children() {
                                    return xt.wallet.name
                                }
                            }), createComponent(FooterButton, {
                                get href() {
                                    return xt.wallet.aboutUrl
                                },
                                blank: !0,
                                get children() {
                                    return createComponent(Button$1, {
                                        get children() {
                                            return createComponent(Translation, {
                                                translationKey: "common.get",
                                                children: "GET"
                                            })
                                        }
                                    })
                                }
                            })]
                        }
                    })]
                }
            })]
        }
    })
}
  , borders$1 = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , tgBorders = {
    m: "6px",
    s: "6px",
    none: "0"
}
  , UlStyled = styled.ul`
    display: flex;
    justify-content: space-between;
    margin: 0 auto;
    width: fit-content;
    max-width: 100%;
    min-width: 100%;
    height: fit-content;
    overflow-x: auto;
    overflow-y: hidden;
    padding: 0 13px 24px;

    &&::-webkit-scrollbar {
        display: none;
    }

    -ms-overflow-style: none;
    scrollbar-width: none;

    > li {
        height: fit-content;
    }
`
  , OtherOptionButton = styled.li`
    width: 82px;
    min-width: 82px;
    height: 124px;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 8px 4px;

    text-align: center;
    cursor: pointer;

    transition: transform 0.1s ease-in-out;

    ${mediaNotTouch} {
        &:hover {
            transform: scale(1.04);
        }
    }

    &:active {
        transform: scale(0.96);
    }

    ${mediaTouch} {
        &:active {
            transform: scale(0.92);
        }
    }
`
  , Divider$1 = styled.div`
    width: 1px;
    margin: 0 10px;
    height: 24px;
    position: relative;
    top: 26px;

    background-color: ${xt => xt.theme.colors.icon.secondary};
    opacity: 0.2;
`
  , IconContainer = styled.div`
    width: 60px;
    height: 60px;
    border-radius: ${xt => borders$1[xt.theme.borderRadius]};
    display: flex;
    align-items: center;
    justify-content: center;

    background-color: ${xt => xt.theme.colors.background.tint};
    margin-bottom: 8px;
`
  , H1Styled$2 = styled(H1)`
    margin-top: 38px;
    margin-bottom: 4px;
    padding: 0 24px;
`
  , H2Styled$2 = styled(H2)`
    margin-bottom: 24px;
    padding: 0 24px;
    min-height: 44px;
    max-width: ${xt => xt.maxWidth}px;
    margin-left: ${xt => xt.maxWidth ? "auto" : "0px"};
    margin-right: ${xt => xt.maxWidth ? "auto" : "0px"};
`;
styled(Button$1)`
    display: block;
    margin: 0 auto;
`;
const TelegramButtonStyled = styled(Button$1)`
    margin: 0 24px 24px;
    width: calc(100% - 48px);
    border-radius: ${xt => borders$1[xt.theme.borderRadius]};
    padding: 14px 16px 14px 14px;
    background-color: ${xt => xt.theme.colors.telegramButton};

    color: ${xt => xt.theme.colors.constant.white};
    font-weight: 510;
    font-size: 16px;
    line-height: 20px;
`
  , TGImageStyled = styled(Image$1)`
    background-color: transparent;
    border-radius: ${xt => tgBorders[xt.theme.borderRadius]};
    width: 24px;
    height: 24px;
`
  , StyledLeftActionButton = styled(IconButton)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , H1Styled$1 = styled(H1)`
    margin-bottom: 2px;
    padding: 0 64px;
`
  , H2Styled$1 = styled(H2)`
    margin-bottom: 20px;
    padding: 0 64px;
`
  , QrCodeWrapper = styled.div`
    padding: 0 24px 24px;
`
  , MobileUniversalQR = xt => [createComponent(H1Styled$1, {
    translationKey: "walletModal.mobileUniversalModal.connectYourWallet",
    children: "Connect your wallet"
}), createComponent(H2Styled$1, {
    translationKey: "walletModal.mobileUniversalModal.scan",
    children: "Scan with your mobile wallet"
}), createComponent(QrCodeWrapper, {
    get children() {
        return createComponent(QRCode, {
            get imageUrl() {
                return IMG.TON
            },
            get sourceUrl() {
                return addReturnStrategy(xt.universalLink, "none")
            },
            disableCopy: !0
        })
    }
})];
function getUniqueBridges(xt) {
    const Cn = new Set(xt.filter(isWalletInfoRemote).map(as => as.bridgeUrl));
    return Array.from(Cn).map(as => ({
        bridgeUrl: as
    }))
}
function bridgesIsEqual(xt, Cn) {
    const as = new Set(xt == null ? void 0 : xt.map(Cs => Cs.bridgeUrl))
      , cs = new Set(Cn == null ? void 0 : Cn.map(Cs => Cs.bridgeUrl));
    return as.size === cs.size && [...as].every(Cs => cs.has(Cs))
}
const _tmpl$$1 = template$1("<li></li>")
  , _tmpl$2 = template$1('<div data-tc-wallets-modal-universal-mobile="true"></div>')
  , MobileUniversalModal = xt => {
    const [Cn,as] = createSignal(!1)
      , [cs,Cs] = createSignal(!0)
      , [Ls,Vs] = createSignal(null)
      , Ws = appState.connector
      , Xs = () => xt.walletsList.filter(Tl => supportsMobile(Tl) && Tl.appName !== AT_WALLET_APP_NAME)
      , ga = () => Xs().length > 7
      , ba = createMemo( () => getUniqueBridges(xt.walletsList), null, {
        equals: bridgesIsEqual
    })
      , yl = () => (Ls() || Vs(Ws.connect(ba(), xt.additionalRequest)),
    Ls());
    setLastSelectedWalletInfo({
        openMethod: "universal-link"
    });
    const [xl,wl] = createSignal(void 0)
      , _l = () => __async(void 0, null, function*() {
        xl() !== void 0 && clearTimeout(xl()),
        yield copyToClipboard(yl());
        const Tl = setTimeout( () => wl(void 0), 1500);
        wl(Tl)
    })
      , El = () => {
        const Tl = !cs();
        Cs(!1),
        redirectToWallet(yl(), void 0, {
            returnStrategy: appState.returnStrategy,
            forceRedirect: Tl
        }, Rl => {
            setLastSelectedWalletInfo({
                openMethod: Rl
            })
        }
        )
    }
      , Cl = () => {
        Vs(null);
        const Tl = xt.walletsList.find(Ml => Ml.appName === AT_WALLET_APP_NAME);
        if (!Tl || !isWalletInfoRemote(Tl))
            throw new TonConnectUIError("@wallet bot not found in the wallets list");
        const Rl = Ws.connect({
            bridgeUrl: Tl.bridgeUrl,
            universalLink: Tl.universalLink
        }, xt.additionalRequest)
          , Il = !cs();
        Cs(!1),
        redirectToTelegram(Rl, {
            returnStrategy: appState.returnStrategy,
            twaReturnUrl: appState.twaReturnUrl,
            forceRedirect: Il
        })
    }
      , $l = () => {
        as(!0),
        setLastSelectedWalletInfo({
            openMethod: "qrcode"
        })
    }
      , Sl = () => {
        as(!1),
        setLastSelectedWalletInfo({
            openMethod: "universal-link"
        })
    }
    ;
    return ( () => {
        const Tl = _tmpl$2.cloneNode(!0);
        return insert(Tl, createComponent(Show, {
            get when() {
                return Cn()
            },
            get children() {
                return [createComponent(StyledLeftActionButton, {
                    icon: "arrow",
                    onClick: Sl
                }), createComponent(MobileUniversalQR, {
                    get universalLink() {
                        return yl()
                    }
                })]
            }
        }), null),
        insert(Tl, createComponent(Show, {
            get when() {
                return !Cn()
            },
            get children() {
                return [createComponent(StyledLeftActionButton, {
                    get icon() {
                        return createComponent(QRIcon, {})
                    },
                    onClick: $l
                }), createComponent(H1Styled$2, {
                    translationKey: "walletModal.mobileUniversalModal.connectYourWallet",
                    children: "Connect your wallet"
                }), createComponent(H2Styled$2, {
                    translationKey: "walletModal.mobileUniversalModal.openWalletOnTelegramOrSelect",
                    maxWidth: 342,
                    children: "Open Wallet in Telegram or select your wallet to connect"
                }), createComponent(TelegramButtonStyled, {
                    get leftIcon() {
                        return createComponent(AtWalletIcon, {})
                    },
                    get rightIcon() {
                        return createComponent(TGImageStyled, {
                            get src() {
                                return IMG.TG
                            }
                        })
                    },
                    onClick: Cl,
                    scale: "s",
                    get children() {
                        return createComponent(Translation, {
                            translationKey: "walletModal.mobileUniversalModal.openWalletOnTelegram",
                            children: "Open Wallet in Telegram"
                        })
                    }
                }), createComponent(UlStyled, {
                    get children() {
                        return [createComponent(For, {
                            get each() {
                                return createMemo( () => !!ga())() ? Xs().slice(0, 4) : Xs()
                            },
                            children: Rl => ( () => {
                                const Il = _tmpl$$1.cloneNode(!0);
                                return insert(Il, createComponent(WalletItem, {
                                    get icon() {
                                        return Rl.imageUrl
                                    },
                                    get name() {
                                        return Rl.name
                                    },
                                    onClick: () => xt.onSelect(Rl)
                                })),
                                Il
                            }
                            )()
                        }), createComponent(Show, {
                            get when() {
                                return ga()
                            },
                            get children() {
                                const Rl = _tmpl$$1.cloneNode(!0);
                                return insert(Rl, createComponent(FourWalletsItem, {
                                    labelLine1: "View all",
                                    labelLine2: "wallets",
                                    get images() {
                                        return Xs().slice(3, 7).map(Il => Il.imageUrl)
                                    },
                                    onClick: () => xt.onSelectAllWallets()
                                })),
                                Rl
                            }
                        }), createComponent(Divider$1, {
                            children: ""
                        }), createComponent(OtherOptionButton, {
                            onClick: El,
                            get children() {
                                return [createComponent(IconContainer, {
                                    get children() {
                                        return createComponent(LongArrowIcon, {})
                                    }
                                }), createComponent(Text, {
                                    fontWeight: 590,
                                    translationKey: "walletModal.mobileUniversalModal.openLink",
                                    children: "Open Link"
                                })]
                            }
                        }), createComponent(OtherOptionButton, {
                            onClick: _l,
                            get children() {
                                return [createComponent(IconContainer, {
                                    get children() {
                                        return createMemo( () => xl() !== void 0)() ? createComponent(DoneIcon, {}) : createComponent(CopyLightIcon, {})
                                    }
                                }), createComponent(Text, {
                                    fontWeight: 590,
                                    get translationKey() {
                                        return xl() !== void 0 ? "common.copied" : "common.copyLink"
                                    },
                                    get children() {
                                        return xl() !== void 0 ? "Copied" : "Copy Link"
                                    }
                                })]
                            }
                        })]
                    }
                })]
            }
        }), null),
        Tl
    }
    )()
}
  , borders$6 = {
    m: "16px",
    s: "8px",
    none: "0"
}
  , hoverBorders = {
    m: "8px",
    s: "4px",
    none: "0"
}
  , DesktopUniversalModalStyled = styled.div`
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-bottom: 16px;
`
  , H2Styled = styled(H2)`
    max-width: 320px;
    margin-top: 2px;
    margin-bottom: 20px;
`
  , H2AvailableWalletsStyled = styled(H2)`
    margin-bottom: 16px;
`
  , QRCodeStyled = styled(QRCode)`
    margin-bottom: 24px;
`
  , WalletsContainerStyled = styled.ul`
    display: flex;
`;
styled.div`
    display: flex;
    gap: 16px;
    width: 100%;
`;
styled(Button$1)`
    position: relative;
    font-size: 16px;
    line-height: 20px;
    width: 100%;
    padding: 0 16px;
    height: 56px;
    border-radius: ${xt => borders$6[xt.theme.borderRadius]};

    &:hover {
        ${xt => xt.disableEventsAnimation ? "transform: unset;" : ""}
    }

    &:active {
        ${xt => xt.disableEventsAnimation ? "transform: unset;" : ""}
    }
`;
styled.ul`
    position: absolute;
    bottom: 100%;
    left: 0;
    margin: 0;
    padding: 8px;
    width: 188px;
    transform: translateY(-16px);

    background-color: ${xt => xt.theme.colors.background.primary};
    border-radius: ${xt => borders$6[xt.theme.borderRadius]};
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);
`;
styled.li`
    padding: 8px;

    display: flex;
    align-items: center;
    gap: 8px;

    cursor: pointer;
    border-radius: ${xt => hoverBorders[xt.theme.borderRadius]};

    transition: background-color, transform 0.1s ease-in-out;

    &:hover {
        background-color: ${xt => xt.theme.colors.background.secondary};
    }

    &:active {
        transform: scale(0.96);
    }
`;
styled(Image$1)`
    width: 24px;
    height: 24px;

    border-radius: 6px;
`;
styled.div`
    margin-top: 23px;
    margin-bottom: 1px;
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
`;
styled(Text)`
    color: ${xt => xt.theme.colors.text.secondary};
    font-size: 16px;
`;
const _tmpl$ = template$1("<li></li>")
  , DesktopUniversalModal = xt => {
    const [Cn,as] = createSignal(!1)
      , cs = appState.connector
      , Cs = createMemo( () => getUniqueBridges(xt.walletsList), null, {
        equals: bridgesIsEqual
    });
    setLastSelectedWalletInfo({
        openMethod: "qrcode"
    });
    const Ls = createMemo( () => cs.connect(Cs(), xt.additionalRequest));
    return createComponent(DesktopUniversalModalStyled, {
        onClick: () => as(!1),
        "data-tc-wallets-modal-universal-desktop": "true",
        get children() {
            return [createComponent(H1, {
                translationKey: "walletModal.desktopUniversalModal.connectYourWallet",
                children: "Connect your wallet"
            }), createComponent(H2Styled, {
                translationKey: "walletModal.desktopUniversalModal.scan",
                children: "Scan with your mobile wallet"
            }), createComponent(QRCodeStyled, {
                get sourceUrl() {
                    return addReturnStrategy(Ls(), "none")
                },
                get disableCopy() {
                    return Cn()
                },
                get imageUrl() {
                    return IMG.TON
                }
            }), createComponent(H2AvailableWalletsStyled, {
                translationKey: "walletModal.desktopUniversalModal.availableWallets",
                children: "Available wallets"
            }), createComponent(WalletsContainerStyled, {
                get children() {
                    return [createComponent(For, {
                        get each() {
                            return xt.walletsList.slice(0, 3)
                        },
                        children: Vs => ( () => {
                            const Ws = _tmpl$.cloneNode(!0);
                            return insert(Ws, createComponent(WalletLabeledItem, {
                                wallet: Vs,
                                onClick: () => xt.onSelect(Vs)
                            })),
                            Ws
                        }
                        )()
                    }), createComponent(FourWalletsItem, {
                        labelLine1: "View all",
                        labelLine2: "wallets",
                        get images() {
                            return xt.walletsList.slice(3, 7).map(Vs => Vs.imageUrl)
                        },
                        onClick: () => xt.onSelectAllWallets()
                    })]
                }
            })]
        }
    })
}
  , WalletsModal = () => {
    const {locale: xt} = useI18n()[1];
    createEffect( () => xt(appState.language)),
    createEffect( () => {
        getWalletsModalIsOpened() ? updateIsMobile() : (Ls(null),
        Ws("universal"),
        ga(!1))
    }
    );
    const Cn = useContext(ConnectorContext)
      , as = useContext(TonConnectUiContext)
      , [cs] = createResource( () => as.getWallets())
      , [Cs,Ls] = createSignal(null)
      , [Vs,Ws] = createSignal("universal")
      , [Xs,ga] = createSignal(!1)
      , ba = createMemo( () => {
        if (cs.state !== "ready")
            return null;
        let Sl = applyWalletsListConfiguration(cs(), appState.walletsListConfiguration);
        const Tl = Sl.filter(isWalletInfoCurrentlyInjected)
          , Rl = Sl.filter(Fl => !isWalletInfoCurrentlyInjected(Fl));
        Sl = (Tl || []).concat(Rl);
        const Il = appState.preferredWalletAppName
          , Ml = Sl.find(Fl => eqWalletName(Fl, Il))
          , Nl = Sl.filter(Fl => eqWalletName(Fl, Il)).length >= 2;
        Il && Ml && !Nl && (Sl = [__spreadProps(__spreadValues$1({}, Ml), {
            isPreferred: !0
        })].concat(Sl.filter(Fl => !eqWalletName(Fl, Il))));
        const Ll = Sl.find(Fl => eqWalletName(Fl, AT_WALLET_APP_NAME));
        return Ll && (Sl = [Ll].concat(Sl.filter(Fl => !eqWalletName(Fl, AT_WALLET_APP_NAME)))),
        Sl
    }
    )
      , yl = () => {
        var Sl;
        return ((Sl = appState.connectRequestParameters) == null ? void 0 : Sl.state) === "loading"
    }
      , xl = createMemo( () => {
        var Sl;
        if (!yl())
            return (Sl = appState.connectRequestParameters) == null ? void 0 : Sl.value
    }
    )
      , wl = Sl => {
        as.closeModal(Sl)
    }
      , _l = Cn.onStatusChange(Sl => {
        Sl && wl("wallet-selected")
    }
    )
      , El = () => {
        Ws("all-wallets")
    }
      , Cl = () => {
        Ws("universal")
    }
      , $l = () => {
        Ls(null)
    }
    ;
    return onCleanup( () => {
        Ls(null),
        ga(!1)
    }
    ),
    onCleanup(_l),
    createComponent(StyledModal, {
        get opened() {
            return getWalletsModalIsOpened()
        },
        get enableAndroidBackHandler() {
            return appState.enableAndroidBackHandler
        },
        onClose: () => wl("action-cancelled"),
        onClickQuestion: () => ga(Sl => !Sl),
        "data-tc-wallets-modal-container": "true",
        get children() {
            return [createComponent(Show, {
                get when() {
                    return Xs()
                },
                get children() {
                    return createComponent(InfoModal, {
                        onBackClick: () => ga(!1)
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return !Xs()
                },
                get children() {
                    return [createComponent(Show, {
                        get when() {
                            return yl() || !ba()
                        },
                        get children() {
                            return [createComponent(H1Styled$8, {
                                translationKey: "walletModal.loading",
                                children: "Wallets list is loading"
                            }), createComponent(LoaderContainerStyled, {
                                get children() {
                                    return createComponent(LoaderIcon, {
                                        size: "m"
                                    })
                                }
                            })]
                        }
                    }), createComponent(Show, {
                        get when() {
                            return createMemo( () => !yl())() && ba()
                        },
                        get children() {
                            return createComponent(Switch, {
                                get children() {
                                    return [createComponent(Match, {
                                        get when() {
                                            return Cs()
                                        },
                                        get children() {
                                            return createComponent(Dynamic, {
                                                get component() {
                                                    return isMobile$1() ? MobileConnectionModal : DesktopConnectionModal
                                                },
                                                get wallet() {
                                                    return Cs()
                                                },
                                                get additionalRequest() {
                                                    return xl()
                                                },
                                                onBackClick: $l
                                            })
                                        }
                                    }), createComponent(Match, {
                                        get when() {
                                            return Vs() === "universal"
                                        },
                                        get children() {
                                            return createComponent(Dynamic, {
                                                get component() {
                                                    return isMobile$1() ? MobileUniversalModal : DesktopUniversalModal
                                                },
                                                onSelect: Ls,
                                                get walletsList() {
                                                    return ba()
                                                },
                                                get additionalRequest() {
                                                    return xl()
                                                },
                                                onSelectAllWallets: El
                                            })
                                        }
                                    }), createComponent(Match, {
                                        get when() {
                                            return Vs() === "all-wallets"
                                        },
                                        get children() {
                                            return createComponent(AllWalletsListModal, {
                                                get walletsList() {
                                                    return ba()
                                                },
                                                onBack: Cl,
                                                onSelect: Ls
                                            })
                                        }
                                    })]
                                }
                            })
                        }
                    })]
                }
            })]
        }
    })
}
  , ActionModalStyled = styled.div`
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-bottom: 8px;
`
  , H1Styled = styled(H1)`
    margin-top: 16px;
`
  , TextStyled = styled(Text)`
    font-weight: 510;
    font-size: 16px;
    line-height: 20px;
    text-align: center;
    max-width: 250px;

    color: ${xt => xt.theme.colors.text.secondary};
`
  , LoaderButtonStyled = styled(Button$1)`
    min-width: 112px;
    margin-top: 32px;
`
  , LoaderIconStyled = styled(LoaderIcon)`
    height: 16px;
    width: 16px;
`
  , ButtonStyled = styled(Button$1)`
    margin-top: 32px;
`
  , ActionModal = xt => {
    const Cn = useDataAttributes(xt)
      , as = useContext(TonConnectUiContext)
      , [cs,Cs] = createSignal(!0)
      , [Ls,Vs] = createSignal(!1);
    createEffect( () => {
        const ba = action$2();
        Vs(!!ba && "sent"in ba && ba.sent)
    }
    );
    let Ws;
    as != null && as.wallet && "universalLink"in as.wallet && (as.wallet.openMethod === "universal-link" || isTelegramUrl(as.wallet.universalLink) && isInTMA()) && (Ws = as.wallet.universalLink);
    let Xs;
    as != null && as.wallet && "deepLink"in as.wallet && (as.wallet.openMethod === "custom-deeplink" || isTelegramUrl(as.wallet.deepLink) && isInTMA()) && (Xs = as.wallet.deepLink);
    const ga = () => {
        const ba = action$2()
          , yl = "returnStrategy"in ba ? ba.returnStrategy : appState.returnStrategy
          , xl = !cs();
        Cs(!1),
        isTelegramUrl(Ws) ? redirectToTelegram(Ws, {
            returnStrategy: yl,
            twaReturnUrl: "twaReturnUrl"in ba ? ba.twaReturnUrl : appState.twaReturnUrl,
            forceRedirect: xl
        }) : redirectToWallet(Ws, Xs, {
            returnStrategy: yl,
            forceRedirect: xl
        }, () => {}
        )
    }
    ;
    return createComponent(ActionModalStyled, mergeProps$1(Cn, {
        get children() {
            return [createMemo( () => xt.icon), createComponent(H1Styled, {
                get translationKey() {
                    return xt.headerTranslationKey
                },
                get translationValues() {
                    return xt.headerTranslationValues
                }
            }), createComponent(TextStyled, {
                get translationKey() {
                    return xt.textTranslationKey
                },
                get translationValues() {
                    return xt.textTranslationValues
                }
            }), createComponent(Show, {
                get when() {
                    return !Ls() && (xt.showButton === "open-wallet" && Ws || xt.showButton !== "open-wallet")
                },
                get children() {
                    return createComponent(LoaderButtonStyled, {
                        disabled: !0,
                        "data-tc-connect-button-loading": "true",
                        get children() {
                            return createComponent(LoaderIconStyled, {})
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return Ls()
                },
                get children() {
                    return [createComponent(Show, {
                        get when() {
                            return xt.showButton !== "open-wallet"
                        },
                        get children() {
                            return createComponent(ButtonStyled, {
                                onClick: () => xt.onClose(),
                                get children() {
                                    return createComponent(Translation, {
                                        translationKey: "common.close",
                                        children: "Close"
                                    })
                                }
                            })
                        }
                    }), createComponent(Show, {
                        get when() {
                            return xt.showButton === "open-wallet" && Ws
                        },
                        get children() {
                            return createComponent(ButtonStyled, {
                                onClick: ga,
                                get children() {
                                    return createComponent(Translation, {
                                        translationKey: "common.openWallet",
                                        children: "Open wallet"
                                    })
                                }
                            })
                        }
                    })]
                }
            })]
        }
    }))
}
  , ConfirmTransactionModal = xt => {
    const Cn = useContext(TonConnectUiContext)
      , [as] = useI18n()
      , cs = () => Cn.wallet && "name"in Cn.wallet ? Cn.wallet.name : as("common.yourWallet", {}, "Your wallet");
    return createComponent(ActionModal, {
        headerTranslationKey: "actionModal.confirmTransaction.header",
        get headerTranslationValues() {
            return {
                name: cs()
            }
        },
        textTranslationKey: "actionModal.confirmTransaction.text",
        get icon() {
            return createComponent(LoaderIcon, {
                size: "m"
            })
        },
        onClose: () => xt.onClose(),
        showButton: "open-wallet",
        "data-tc-confirm-modal": "true"
    })
}
  , TransactionCanceledModal = xt => createComponent(ActionModal, {
    headerTranslationKey: "actionModal.transactionCanceled.header",
    textTranslationKey: "actionModal.transactionCanceled.text",
    get icon() {
        return createComponent(ErrorIcon, {
            size: "m"
        })
    },
    onClose: () => xt.onClose(),
    "data-tc-transaction-canceled-modal": "true"
})
  , TransactionSentModal = xt => createComponent(ActionModal, {
    headerTranslationKey: "actionModal.transactionSent.header",
    textTranslationKey: "actionModal.transactionSent.text",
    get icon() {
        return createComponent(SuccessIcon, {
            size: "m"
        })
    },
    onClose: () => xt.onClose(),
    "data-tc-transaction-sent-modal": "true"
})
  , ActionsModal = () => createComponent(Modal, {
    get opened() {
        var xt;
        return createMemo( () => action$2() !== null)() && ((xt = action$2()) == null ? void 0 : xt.openModal) === !0
    },
    get enableAndroidBackHandler() {
        return appState.enableAndroidBackHandler
    },
    onClose: () => setAction(null),
    "data-tc-actions-modal-container": "true",
    get children() {
        return createComponent(Switch, {
            get children() {
                return [createComponent(Match, {
                    get when() {
                        return action$2().name === "transaction-sent"
                    },
                    get children() {
                        return createComponent(TransactionSentModal, {
                            onClose: () => setAction(null)
                        })
                    }
                }), createComponent(Match, {
                    get when() {
                        return action$2().name === "transaction-canceled"
                    },
                    get children() {
                        return createComponent(TransactionCanceledModal, {
                            onClose: () => setAction(null)
                        })
                    }
                }), createComponent(Match, {
                    get when() {
                        return action$2().name === "confirm-transaction"
                    },
                    get children() {
                        return createComponent(ConfirmTransactionModal, {
                            onClose: () => setAction(null)
                        })
                    }
                })]
            }
        })
    }
})
  , SingleWalletModal = () => {
    const {locale: xt} = useI18n()[1];
    createEffect( () => xt(appState.language)),
    createEffect( () => {
        getSingleWalletModalIsOpened() && updateIsMobile()
    }
    );
    const Cn = useContext(ConnectorContext)
      , as = useContext(TonConnectUiContext)
      , [cs,Cs] = createSignal(!1)
      , Ls = () => {
        var ga;
        return ((ga = appState.connectRequestParameters) == null ? void 0 : ga.state) === "loading"
    }
      , Vs = createMemo( () => {
        var ga;
        if (!Ls())
            return (ga = appState.connectRequestParameters) == null ? void 0 : ga.value
    }
    )
      , Ws = ga => {
        as.closeSingleWalletModal(ga)
    }
      , Xs = Cn.onStatusChange(ga => {
        ga && Ws("wallet-selected")
    }
    );
    return onCleanup(Xs),
    onCleanup( () => {
        Cs(!1)
    }
    ),
    createComponent(StyledModal, {
        get opened() {
            return getSingleWalletModalIsOpened()
        },
        get enableAndroidBackHandler() {
            return appState.enableAndroidBackHandler
        },
        onClose: () => Ws("action-cancelled"),
        onClickQuestion: () => Cs(ga => !ga),
        "data-tc-wallets-modal-container": "true",
        get children() {
            return [createComponent(Show, {
                get when() {
                    return cs()
                },
                get children() {
                    return createComponent(InfoModal, {
                        onBackClick: () => Cs(!1)
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return !cs()
                },
                get children() {
                    return [createComponent(Show, {
                        get when() {
                            return Ls()
                        },
                        get children() {
                            return [createComponent(H1Styled$8, {
                                translationKey: "walletModal.loading",
                                children: "Wallets list is loading"
                            }), createComponent(LoaderContainerStyled, {
                                get children() {
                                    return createComponent(LoaderIcon, {
                                        size: "m"
                                    })
                                }
                            })]
                        }
                    }), createComponent(Show, {
                        get when() {
                            return !Ls()
                        },
                        get children() {
                            return createComponent(Dynamic, {
                                get component() {
                                    return isMobile$1() ? MobileConnectionModal : DesktopConnectionModal
                                },
                                get wallet() {
                                    return getSingleWalletModalWalletInfo()
                                },
                                get additionalRequest() {
                                    return Vs()
                                },
                                onBackClick: () => {}
                                ,
                                backDisabled: !0
                            })
                        }
                    })]
                }
            })]
        }
    })
}
  , App$1 = xt => {
    const Cn = createI18nContext(i18nDictionary, appState.language);
    return defineStylesRoot(),
    fixMobileSafariActiveTransition(),
    createComponent(I18nContext.Provider, {
        value: Cn,
        get children() {
            return createComponent(TonConnectUiContext.Provider, {
                get value() {
                    return xt.tonConnectUI
                },
                get children() {
                    return createComponent(ConnectorContext.Provider, {
                        get value() {
                            return appState.connector
                        },
                        get children() {
                            return [createComponent(GlobalStyles, {}), createComponent(ThemeProvider, {
                                theme: themeState,
                                get children() {
                                    return [createComponent(Show, {
                                        get when() {
                                            return appState.buttonRootId
                                        },
                                        get children() {
                                            return createComponent(Portal, {
                                                get mount() {
                                                    return document.getElementById(appState.buttonRootId)
                                                },
                                                get children() {
                                                    return createComponent(AccountButton, {})
                                                }
                                            })
                                        }
                                    }), createComponent(Dynamic, {
                                        component: globalStylesTag,
                                        get children() {
                                            return [createComponent(WalletsModal, {}), createComponent(SingleWalletModal, {}), createComponent(ActionsModal, {})]
                                        }
                                    })]
                                }
                            })]
                        }
                    })
                }
            })
        }
    })
}
  , widgetController = {
    openWalletsModal: () => void setTimeout( () => setWalletsModalState({
        status: "opened",
        closeReason: null
    })),
    closeWalletsModal: xt => void setTimeout( () => setWalletsModalState({
        status: "closed",
        closeReason: xt
    })),
    openSingleWalletModal: xt => {
        setTimeout( () => setSingleWalletModalState({
            status: "opened",
            closeReason: null,
            walletInfo: xt
        }))
    }
    ,
    closeSingleWalletModal: xt => void setTimeout( () => setSingleWalletModalState({
        status: "closed",
        closeReason: xt
    })),
    setAction: xt => void setTimeout( () => setAction(xt)),
    clearAction: () => void setTimeout( () => setAction(null)),
    getSelectedWalletInfo: () => lastSelectedWalletInfo(),
    removeSelectedWalletInfo: () => setLastSelectedWalletInfo(null),
    renderApp: (xt, Cn) => render( () => createComponent(App$1, {
        tonConnectUI: Cn
    }), document.getElementById(xt))
};
class WalletsModalManager {
    constructor(Cn) {
        __publicField(this, "connector"),
        __publicField(this, "setConnectRequestParametersCallback"),
        __publicField(this, "consumers", []),
        __publicField(this, "tracker"),
        __publicField(this, "state", walletsModalState()),
        this.connector = Cn.connector,
        this.tracker = Cn.tracker,
        this.setConnectRequestParametersCallback = Cn.setConnectRequestParametersCallback,
        createEffect( () => {
            const as = walletsModalState();
            this.state = as,
            this.consumers.forEach(cs => cs(as))
        }
        )
    }
    open() {
        return __async(this, null, function*() {
            this.tracker.trackConnectionStarted();
            const as = (yield this.connector.getWallets()).find(isWalletInfoCurrentlyEmbedded);
            return as ? this.connectEmbeddedWallet(as) : this.openWalletsModal()
        })
    }
    close(Cn="action-cancelled") {
        Cn === "action-cancelled" && this.tracker.trackConnectionError("Connection was cancelled"),
        widgetController.closeWalletsModal(Cn)
    }
    onStateChange(Cn) {
        return this.consumers.push(Cn),
        () => {
            this.consumers = this.consumers.filter(as => as !== Cn)
        }
    }
    connectEmbeddedWallet(Cn) {
        const as = Cs => {
            setLastSelectedWalletInfo(Cn),
            this.connector.connect({
                jsBridgeKey: Cn.jsBridgeKey
            }, Cs)
        }
          , cs = appState.connectRequestParameters;
        (cs == null ? void 0 : cs.state) === "loading" ? this.setConnectRequestParametersCallback(as) : as(cs == null ? void 0 : cs.value)
    }
    openWalletsModal() {
        return __async(this, null, function*() {
            return isInTMA() && sendExpand(),
            widgetController.openWalletsModal(),
            new Promise(Cn => {
                const as = this.onStateChange(cs => {
                    const {status: Cs} = cs;
                    Cs === "opened" && (as(),
                    Cn())
                }
                )
            }
            )
        })
    }
}
class TransactionModalManager {
    constructor(Cn) {
        __publicField(this, "connector"),
        __publicField(this, "consumers", []),
        this.connector = Cn.connector,
        createEffect( () => {
            const as = action$2();
            this.consumers.forEach(cs => cs(as))
        }
        )
    }
    onStateChange(Cn) {
        return this.consumers.push(Cn),
        () => {
            this.consumers = this.consumers.filter(as => as !== Cn)
        }
    }
}
class SingleWalletModalManager {
    constructor(Cn) {
        __publicField(this, "connector"),
        __publicField(this, "setConnectRequestParametersCallback"),
        __publicField(this, "consumers", []),
        __publicField(this, "tracker"),
        __publicField(this, "state", singleWalletModalState()),
        this.connector = Cn.connector,
        this.tracker = Cn.tracker,
        this.setConnectRequestParametersCallback = Cn.setConnectRequestParametersCallback,
        createEffect( () => {
            const as = singleWalletModalState();
            this.state = as,
            this.consumers.forEach(cs => cs(as))
        }
        )
    }
    open(Cn) {
        return __async(this, null, function*() {
            this.tracker.trackConnectionStarted();
            const as = yield this.connector.getWallets()
              , cs = applyWalletsListConfiguration(as, appState.walletsListConfiguration)
              , Cs = cs.find(isWalletInfoCurrentlyEmbedded);
            if (!!Cs)
                return this.connectEmbeddedWallet(Cs);
            const Ws = cs.filter(isWalletInfoRemote).find(ba => eqWalletName(ba, Cn));
            if (!!Ws)
                return this.openSingleWalletModal(Ws);
            const ga = `Trying to open modal window with unknown wallet "${Cn}".`;
            throw this.tracker.trackConnectionError(ga),
            new TonConnectUIError(ga)
        })
    }
    close(Cn="action-cancelled") {
        Cn === "action-cancelled" && this.tracker.trackConnectionError("Connection was cancelled"),
        widgetController.closeSingleWalletModal("action-cancelled")
    }
    onStateChange(Cn) {
        return this.consumers.push(Cn),
        () => {
            this.consumers = this.consumers.filter(as => as !== Cn)
        }
    }
    connectEmbeddedWallet(Cn) {
        const as = Cs => {
            setLastSelectedWalletInfo(Cn),
            this.connector.connect({
                jsBridgeKey: Cn.jsBridgeKey
            }, Cs)
        }
          , cs = appState.connectRequestParameters;
        (cs == null ? void 0 : cs.state) === "loading" ? this.setConnectRequestParametersCallback(as) : as(cs == null ? void 0 : cs.value)
    }
    openSingleWalletModal(Cn) {
        return __async(this, null, function*() {
            return isInTMA() && sendExpand(),
            widgetController.openSingleWalletModal(Cn),
            new Promise(as => {
                const cs = this.onStateChange(Cs => {
                    const {status: Ls} = Cs;
                    Ls === "opened" && (cs(),
                    as())
                }
                )
            }
            )
        })
    }
}
class TonConnectUITracker {
    constructor(Cn) {
        __publicField(this, "eventPrefix", "ton-connect-ui-"),
        __publicField(this, "tonConnectUiVersion"),
        __publicField(this, "tonConnectSdkVersion", null),
        __publicField(this, "eventDispatcher");
        var as;
        this.eventDispatcher = (as = Cn == null ? void 0 : Cn.eventDispatcher) != null ? as : new BrowserEventDispatcher,
        this.tonConnectUiVersion = Cn.tonConnectUiVersion,
        this.init().catch()
    }
    get version() {
        return createVersionInfo({
            ton_connect_sdk_lib: this.tonConnectSdkVersion,
            ton_connect_ui_lib: this.tonConnectUiVersion
        })
    }
    init() {
        return __async(this, null, function*() {
            try {
                yield this.setRequestVersionHandler(),
                this.tonConnectSdkVersion = yield this.requestTonConnectSdkVersion()
            } catch {}
        })
    }
    setRequestVersionHandler() {
        return __async(this, null, function*() {
            yield this.eventDispatcher.addEventListener("ton-connect-ui-request-version", () => __async(this, null, function*() {
                yield this.eventDispatcher.dispatchEvent("ton-connect-ui-response-version", createResponseVersionEvent(this.tonConnectUiVersion))
            }))
        })
    }
    requestTonConnectSdkVersion() {
        return __async(this, null, function*() {
            return new Promise( (Cn, as) => __async(this, null, function*() {
                try {
                    yield this.eventDispatcher.addEventListener("ton-connect-response-version", cs => {
                        Cn(cs.detail.version)
                    }
                    , {
                        once: !0
                    }),
                    yield this.eventDispatcher.dispatchEvent("ton-connect-request-version", createRequestVersionEvent())
                } catch (cs) {
                    as(cs)
                }
            }))
        })
    }
    dispatchUserActionEvent(Cn) {
        var as;
        try {
            (as = this.eventDispatcher) == null || as.dispatchEvent(`${this.eventPrefix}${Cn.type}`, Cn).catch()
        } catch {}
    }
    trackConnectionStarted(...Cn) {
        try {
            const as = createConnectionStartedEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
    trackConnectionCompleted(...Cn) {
        try {
            const as = createConnectionCompletedEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
    trackConnectionError(...Cn) {
        try {
            const as = createConnectionErrorEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
    trackConnectionRestoringStarted(...Cn) {
        try {
            const as = createConnectionRestoringStartedEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
    trackConnectionRestoringCompleted(...Cn) {
        try {
            const as = createConnectionRestoringCompletedEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
    trackConnectionRestoringError(...Cn) {
        try {
            const as = createConnectionRestoringErrorEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
    trackDisconnection(...Cn) {
        try {
            const as = createDisconnectionEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
    trackTransactionSentForSignature(...Cn) {
        try {
            const as = createTransactionSentForSignatureEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
    trackTransactionSigned(...Cn) {
        try {
            const as = createTransactionSignedEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
    trackTransactionSigningFailed(...Cn) {
        try {
            const as = createTransactionSigningFailedEvent(this.version, ...Cn);
            this.dispatchUserActionEvent(as)
        } catch {}
    }
}
const tonConnectUiVersion = "2.0.9";
class TonConnectUI {
    constructor(Cn) {
        if (__publicField(this, "walletInfoStorage", new WalletInfoStorage),
        __publicField(this, "preferredWalletStorage", new PreferredWalletStorage),
        __publicField(this, "tracker"),
        __publicField(this, "walletInfo", null),
        __publicField(this, "systemThemeChangeUnsubscribe", null),
        __publicField(this, "actionsConfiguration"),
        __publicField(this, "walletsList"),
        __publicField(this, "connectRequestParametersCallback"),
        __publicField(this, "connector"),
        __publicField(this, "modal"),
        __publicField(this, "singleWalletModal"),
        __publicField(this, "transactionModal"),
        __publicField(this, "connectionRestored", Promise.resolve(!1)),
        Cn && "connector"in Cn && Cn.connector)
            this.connector = Cn.connector;
        else if (Cn && "manifestUrl"in Cn && Cn.manifestUrl)
            this.connector = new TonConnect({
                manifestUrl: Cn.manifestUrl,
                eventDispatcher: Cn == null ? void 0 : Cn.eventDispatcher
            });
        else
            throw new TonConnectUIError("You have to specify a `manifestUrl` or a `connector` in the options.");
        this.tracker = new TonConnectUITracker({
            eventDispatcher: Cn == null ? void 0 : Cn.eventDispatcher,
            tonConnectUiVersion
        }),
        this.modal = new WalletsModalManager({
            connector: this.connector,
            tracker: this.tracker,
            setConnectRequestParametersCallback: Cs => {
                this.connectRequestParametersCallback = Cs
            }
        }),
        this.singleWalletModal = new SingleWalletModalManager({
            connector: this.connector,
            tracker: this.tracker,
            setConnectRequestParametersCallback: Cs => {
                this.connectRequestParametersCallback = Cs
            }
        }),
        this.transactionModal = new TransactionModalManager({
            connector: this.connector
        }),
        this.walletsList = this.getWallets(),
        this.walletsList.then(Cs => preloadImages(uniq(Cs.map(Ls => Ls.imageUrl))));
        const as = this.normalizeWidgetRoot(Cn == null ? void 0 : Cn.widgetRootId);
        this.subscribeToWalletChange(),
        (Cn == null ? void 0 : Cn.restoreConnection) !== !1 && (this.connectionRestored = createMacrotaskAsync( () => __async(this, null, function*() {
            return this.tracker.trackConnectionRestoringStarted(),
            yield this.connector.restoreConnection(),
            this.connector.connected ? this.tracker.trackConnectionRestoringCompleted(this.wallet) : (this.tracker.trackConnectionRestoringError("Connection was not restored"),
            this.walletInfoStorage.removeWalletInfo()),
            this.connector.connected
        }))),
        this.uiOptions = mergeOptions(Cn, {
            uiPreferences: {
                theme: "SYSTEM"
            }
        });
        const cs = this.preferredWalletStorage.getPreferredWalletAppName();
        setAppState({
            connector: this.connector,
            preferredWalletAppName: cs
        }),
        widgetController.renderApp(as, this)
    }
    static getWallets() {
        return TonConnect.getWallets()
    }
    get connected() {
        return this.connector.connected
    }
    get account() {
        return this.connector.account
    }
    get wallet() {
        return this.connector.wallet ? __spreadValues$1(__spreadValues$1({}, this.connector.wallet), this.walletInfo) : null
    }
    set uiOptions(Cn) {
        var as, cs, Cs, Ls, Vs;
        this.checkButtonRootExist(Cn.buttonRootId),
        this.actionsConfiguration = Cn.actionsConfiguration,
        (as = Cn.uiPreferences) != null && as.theme ? ((cs = Cn.uiPreferences) == null ? void 0 : cs.theme) !== "SYSTEM" ? ((Cs = this.systemThemeChangeUnsubscribe) == null || Cs.call(this),
        setTheme(Cn.uiPreferences.theme, Cn.uiPreferences.colorsSet)) : (setTheme(getSystemTheme(), Cn.uiPreferences.colorsSet),
        this.systemThemeChangeUnsubscribe || (this.systemThemeChangeUnsubscribe = subscribeToThemeChange(setTheme))) : (Ls = Cn.uiPreferences) != null && Ls.colorsSet && setColors(Cn.uiPreferences.colorsSet),
        (Vs = Cn.uiPreferences) != null && Vs.borderRadius && setBorderRadius(Cn.uiPreferences.borderRadius),
        setAppState(Ws => {
            var Xs, ga;
            const ba = mergeOptions(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1({}, Cn.language && {
                language: Cn.language
            }), !!((Xs = Cn.actionsConfiguration) != null && Xs.returnStrategy) && {
                returnStrategy: Cn.actionsConfiguration.returnStrategy
            }), !!((ga = Cn.actionsConfiguration) != null && ga.twaReturnUrl) && {
                twaReturnUrl: Cn.actionsConfiguration.twaReturnUrl
            }), !!Cn.walletsListConfiguration && {
                walletsListConfiguration: Cn.walletsListConfiguration
            }), unwrap(Ws));
            return Cn.buttonRootId !== void 0 && (ba.buttonRootId = Cn.buttonRootId),
            Cn.enableAndroidBackHandler !== void 0 && (ba.enableAndroidBackHandler = Cn.enableAndroidBackHandler),
            ba
        }
        )
    }
    setConnectRequestParameters(Cn) {
        var as;
        setAppState({
            connectRequestParameters: Cn
        }),
        ((Cn == null ? void 0 : Cn.state) === "ready" || !Cn) && ((as = this.connectRequestParametersCallback) == null || as.call(this, Cn == null ? void 0 : Cn.value))
    }
    getWallets() {
        return __async(this, null, function*() {
            return this.connector.getWallets()
        })
    }
    onStatusChange(Cn, as) {
        return this.connector.onStatusChange(cs => __async(this, null, function*() {
            if (cs) {
                const Cs = yield this.getSelectedWalletInfo(cs);
                Cn(__spreadValues$1(__spreadValues$1({}, cs), Cs || this.walletInfoStorage.getWalletInfo()))
            } else
                Cn(cs)
        }), as)
    }
    openModal() {
        return __async(this, null, function*() {
            return this.modal.open()
        })
    }
    closeModal(Cn) {
        this.modal.close(Cn)
    }
    onModalStateChange(Cn) {
        return this.modal.onStateChange(Cn)
    }
    get modalState() {
        return this.modal.state
    }
    openSingleWalletModal(Cn) {
        return __async(this, null, function*() {
            return this.singleWalletModal.open(Cn)
        })
    }
    closeSingleWalletModal(Cn) {
        this.singleWalletModal.close(Cn)
    }
    onSingleWalletModalStateChange(Cn) {
        return this.singleWalletModal.onStateChange(Cn)
    }
    get singleWalletModalState() {
        return this.singleWalletModal.state
    }
    connectWallet() {
        return __async(this, null, function*() {
            const as = (yield this.getWallets()).find(isWalletInfoCurrentlyEmbedded);
            return as ? yield this.connectEmbeddedWallet(as) : yield this.connectExternalWallet()
        })
    }
    disconnect() {
        return this.tracker.trackDisconnection(this.wallet, "dapp"),
        widgetController.clearAction(),
        widgetController.removeSelectedWalletInfo(),
        this.walletInfoStorage.removeWalletInfo(),
        this.connector.disconnect()
    }
    sendTransaction(Cn, as) {
        return __async(this, null, function*() {
            if (this.tracker.trackTransactionSentForSignature(this.wallet, Cn),
            !this.connected)
                throw this.tracker.trackTransactionSigningFailed(this.wallet, Cn, "Wallet was not connected"),
                new TonConnectUIError("Connect wallet to send a transaction.");
            isInTMA() && sendExpand();
            const {notifications: cs, modals: Cs, returnStrategy: Ls, twaReturnUrl: Vs, skipRedirectToWallet: Ws} = this.getModalsAndNotificationsConfiguration(as);
            widgetController.setAction({
                name: "confirm-transaction",
                showNotification: cs.includes("before"),
                openModal: Cs.includes("before"),
                sent: !1
            });
            const Xs = () => {
                ga.signal.aborted || (widgetController.setAction({
                    name: "confirm-transaction",
                    showNotification: cs.includes("before"),
                    openModal: Cs.includes("before"),
                    sent: !0
                }),
                this.walletInfo && "universalLink"in this.walletInfo && (this.walletInfo.openMethod === "universal-link" || this.walletInfo.openMethod === "custom-deeplink") && (isTelegramUrl(this.walletInfo.universalLink) ? redirectToTelegram(this.walletInfo.universalLink, {
                    returnStrategy: Ls,
                    twaReturnUrl: Vs || appState.twaReturnUrl,
                    forceRedirect: !1
                }) : redirectToWallet(this.walletInfo.universalLink, this.walletInfo.deepLink, {
                    returnStrategy: Ls,
                    forceRedirect: !1
                }, () => {}
                )))
            }
              , ga = new AbortController
              , ba = this.onTransactionModalStateChange(yl => {
                yl != null && yl.openModal || (ba(),
                yl || ga.abort())
            }
            );
            try {
                const yl = yield this.waitForSendTransaction({
                    transaction: Cn,
                    signal: ga.signal
                }, Xs);
                return this.tracker.trackTransactionSigned(this.wallet, Cn, yl),
                widgetController.setAction({
                    name: "transaction-sent",
                    showNotification: cs.includes("success"),
                    openModal: Cs.includes("success")
                }),
                yl
            } catch (yl) {
                throw widgetController.setAction({
                    name: "transaction-canceled",
                    showNotification: cs.includes("error"),
                    openModal: Cs.includes("error")
                }),
                yl instanceof TonConnectError ? yl : (console.error(yl),
                new TonConnectUIError("Unhandled error:" + yl))
            } finally {
                ba()
            }
        })
    }
    connectEmbeddedWallet(Cn) {
        return __async(this, null, function*() {
            const as = Cs => {
                setLastSelectedWalletInfo(Cn),
                this.connector.connect({
                    jsBridgeKey: Cn.jsBridgeKey
                }, Cs)
            }
              , cs = appState.connectRequestParameters;
            return (cs == null ? void 0 : cs.state) === "loading" ? this.connectRequestParametersCallback = as : as(cs == null ? void 0 : cs.value),
            yield this.waitForWalletConnection({
                ignoreErrors: !1
            })
        })
    }
    connectExternalWallet() {
        return __async(this, null, function*() {
            const Cn = new AbortController;
            widgetController.openWalletsModal();
            const as = this.onModalStateChange(cs => {
                const {status: Cs, closeReason: Ls} = cs;
                Cs !== "opened" && (as(),
                Ls === "action-cancelled" && Cn.abort())
            }
            );
            return yield this.waitForWalletConnection({
                ignoreErrors: !0,
                signal: Cn.signal
            })
        })
    }
    waitForWalletConnection(Cn) {
        return __async(this, null, function*() {
            return new Promise( (as, cs) => {
                this.tracker.trackConnectionStarted();
                const {ignoreErrors: Cs=!1, signal: Ls=null} = Cn;
                if (Ls && Ls.aborted)
                    return this.tracker.trackConnectionError("Connection was cancelled"),
                    cs(new TonConnectUIError("Wallet was not connected"));
                const Vs = ga => __async(this, null, function*() {
                    if (ga)
                        this.tracker.trackConnectionCompleted(ga),
                        Xs(),
                        as(ga);
                    else {
                        if (this.tracker.trackConnectionError("Connection was cancelled"),
                        Cs)
                            return;
                        Xs(),
                        cs(new TonConnectUIError("Wallet was not connected"))
                    }
                })
                  , Ws = ga => {
                    this.tracker.trackConnectionError(ga.message),
                    !Cs && (Xs(),
                    cs(ga))
                }
                  , Xs = this.onStatusChange(ga => Vs(ga), ga => Ws(ga));
                Ls && Ls.addEventListener("abort", () => {
                    Xs(),
                    cs(new TonConnectUIError("Wallet was not connected"))
                }
                , {
                    once: !0
                })
            }
            )
        })
    }
    waitForSendTransaction(Cn, as) {
        return __async(this, null, function*() {
            return new Promise( (cs, Cs) => {
                const {transaction: Ls, signal: Vs} = Cn;
                if (Vs.aborted)
                    return this.tracker.trackTransactionSigningFailed(this.wallet, Ls, "Transaction was cancelled"),
                    Cs(new TonConnectUIError("Transaction was not sent"));
                const Ws = ba => __async(this, null, function*() {
                    cs(ba)
                })
                  , Xs = ba => {
                    Cs(ba)
                }
                  , ga = () => {
                    this.tracker.trackTransactionSigningFailed(this.wallet, Ls, "Transaction was cancelled"),
                    Cs(new TonConnectUIError("Transaction was not sent"))
                }
                ;
                Vs.addEventListener("abort", ga, {
                    once: !0
                }),
                this.connector.sendTransaction(Ls, {
                    onRequestSent: as,
                    signal: Vs
                }).then(ba => (Vs.removeEventListener("abort", ga),
                Ws(ba))).catch(ba => (Vs.removeEventListener("abort", ga),
                Xs(ba)))
            }
            )
        })
    }
    onTransactionModalStateChange(Cn) {
        return this.transactionModal.onStateChange(Cn)
    }
    subscribeToWalletChange() {
        this.connector.onStatusChange(Cn => __async(this, null, function*() {
            var as;
            Cn ? (yield this.updateWalletInfo(Cn),
            this.setPreferredWalletAppName(((as = this.walletInfo) == null ? void 0 : as.appName) || Cn.device.appName)) : this.walletInfoStorage.removeWalletInfo()
        }))
    }
    setPreferredWalletAppName(Cn) {
        this.preferredWalletStorage.setPreferredWalletAppName(Cn),
        setAppState({
            preferredWalletAppName: Cn
        })
    }
    getSelectedWalletInfo(Cn) {
        return __async(this, null, function*() {
            let as = widgetController.getSelectedWalletInfo();
            if (!as)
                return null;
            let cs;
            if ("name"in as)
                cs = as;
            else {
                const Ls = applyWalletsListConfiguration(yield this.walletsList, appState.walletsListConfiguration).find(Vs => eqWalletName(Vs, Cn.device.appName));
                if (!Ls)
                    throw new TonConnectUIError(`Cannot find WalletInfo for the '${Cn.device.appName}' wallet`);
                cs = __spreadValues$1(__spreadValues$1({}, Ls), as)
            }
            return cs
        })
    }
    updateWalletInfo(Cn) {
        return __async(this, null, function*() {
            const as = yield this.getSelectedWalletInfo(Cn);
            if (as) {
                this.walletInfo = as,
                this.walletInfoStorage.setWalletInfo(as);
                return
            }
            const cs = this.walletInfoStorage.getWalletInfo();
            if (cs) {
                this.walletInfo = cs;
                return
            }
            this.walletInfo = (yield this.walletsList).find(Cs => eqWalletName(Cs, Cn.device.appName)) || null
        })
    }
    normalizeWidgetRoot(Cn) {
        if (!Cn || !document.getElementById(Cn)) {
            Cn = "tc-widget-root";
            const as = document.createElement("div");
            as.id = Cn,
            document.body.appendChild(as)
        }
        return Cn
    }
    checkButtonRootExist(Cn) {
        if (Cn != null && !document.getElementById(Cn))
            throw new TonConnectUIError(`${Cn} element not found in the document.`)
    }
    getModalsAndNotificationsConfiguration(Cn) {
        var as, cs, Cs, Ls, Vs, Ws;
        const Xs = ["before", "success", "error"];
        let ga = Xs;
        (as = this.actionsConfiguration) != null && as.notifications && ((cs = this.actionsConfiguration) == null ? void 0 : cs.notifications) !== "all" && (ga = this.actionsConfiguration.notifications),
        Cn != null && Cn.notifications && (Cn.notifications === "all" ? ga = Xs : ga = Cn.notifications);
        let ba = ["before"];
        (Cs = this.actionsConfiguration) != null && Cs.modals && (this.actionsConfiguration.modals === "all" ? ba = Xs : ba = this.actionsConfiguration.modals),
        Cn != null && Cn.modals && (Cn.modals === "all" ? ba = Xs : ba = Cn.modals);
        const yl = (Cn == null ? void 0 : Cn.returnStrategy) || ((Ls = this.actionsConfiguration) == null ? void 0 : Ls.returnStrategy) || "back"
          , xl = (Cn == null ? void 0 : Cn.twaReturnUrl) || ((Vs = this.actionsConfiguration) == null ? void 0 : Vs.twaReturnUrl);
        let wl = (Cn == null ? void 0 : Cn.skipRedirectToWallet) || ((Ws = this.actionsConfiguration) == null ? void 0 : Ws.skipRedirectToWallet) || "ios";
        return isInTMA() && (wl = "never"),
        {
            notifications: ga,
            modals: ba,
            returnStrategy: yl,
            twaReturnUrl: xl,
            skipRedirectToWallet: wl
        }
    }
}
var __defProp = Object.defineProperty
  , __getOwnPropSymbols = Object.getOwnPropertySymbols
  , __hasOwnProp = Object.prototype.hasOwnProperty
  , __propIsEnum = Object.prototype.propertyIsEnumerable
  , __defNormalProp = (xt, Cn, as) => Cn in xt ? __defProp(xt, Cn, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: as
}) : xt[Cn] = as
  , __spreadValues = (xt, Cn) => {
    for (var as in Cn || (Cn = {}))
        __hasOwnProp.call(Cn, as) && __defNormalProp(xt, as, Cn[as]);
    if (__getOwnPropSymbols)
        for (var as of __getOwnPropSymbols(Cn))
            __propIsEnum.call(Cn, as) && __defNormalProp(xt, as, Cn[as]);
    return xt
}
  , __objRest = (xt, Cn) => {
    var as = {};
    for (var cs in xt)
        __hasOwnProp.call(xt, cs) && Cn.indexOf(cs) < 0 && (as[cs] = xt[cs]);
    if (xt != null && __getOwnPropSymbols)
        for (var cs of __getOwnPropSymbols(xt))
            Cn.indexOf(cs) < 0 && __propIsEnum.call(xt, cs) && (as[cs] = xt[cs]);
    return as
}
  , jsxRuntime = {
    exports: {}
}
  , reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
    if (hasRequiredReactJsxRuntime_production_min)
        return reactJsxRuntime_production_min;
    hasRequiredReactJsxRuntime_production_min = 1;
    var xt = React__default
      , Cn = Symbol.for("react.element")
      , as = Symbol.for("react.fragment")
      , cs = Object.prototype.hasOwnProperty
      , Cs = xt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
      , Ls = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
    function Vs(Ws, Xs, ga) {
        var ba, yl = {}, xl = null, wl = null;
        ga !== void 0 && (xl = "" + ga),
        Xs.key !== void 0 && (xl = "" + Xs.key),
        Xs.ref !== void 0 && (wl = Xs.ref);
        for (ba in Xs)
            cs.call(Xs, ba) && !Ls.hasOwnProperty(ba) && (yl[ba] = Xs[ba]);
        if (Ws && Ws.defaultProps)
            for (ba in Xs = Ws.defaultProps,
            Xs)
                yl[ba] === void 0 && (yl[ba] = Xs[ba]);
        return {
            $$typeof: Cn,
            type: Ws,
            key: xl,
            ref: wl,
            props: yl,
            _owner: Cs.current
        }
    }
    return reactJsxRuntime_production_min.Fragment = as,
    reactJsxRuntime_production_min.jsx = Vs,
    reactJsxRuntime_production_min.jsxs = Vs,
    reactJsxRuntime_production_min
}
(function(xt) {
    xt.exports = requireReactJsxRuntime_production_min()
}
)(jsxRuntime);
const jsx = jsxRuntime.exports.jsx;
function isClientSide() {
    return typeof window < "u"
}
function isServerSide() {
    return !isClientSide()
}
const TonConnectUIContext = reactExports.createContext(null);
let tonConnectUI = null;
const TonConnectUIProvider = xt => {
    var Cn = xt
      , {children: as} = Cn
      , cs = __objRest(Cn, ["children"]);
    return isClientSide() && !tonConnectUI && (tonConnectUI = new TonConnectUI(cs)),
    jsx(TonConnectUIContext.Provider, {
        value: tonConnectUI,
        children: as
    })
}
  , TonConnectUIProvider$1 = reactExports.memo(TonConnectUIProvider);
class TonConnectUIReactError extends TonConnectUIError {
    constructor(...Cn) {
        super(...Cn),
        Object.setPrototypeOf(this, TonConnectUIReactError.prototype)
    }
}
class TonConnectProviderNotSetError extends TonConnectUIReactError {
    constructor(...Cn) {
        super(...Cn),
        Object.setPrototypeOf(this, TonConnectProviderNotSetError.prototype)
    }
}
function checkProvider(xt) {
    if (!xt)
        throw new TonConnectProviderNotSetError("You should add <TonConnectUIProvider> on the top of the app to use TonConnect");
    return !0
}
function useTonConnectUI() {
    const xt = reactExports.useContext(TonConnectUIContext)
      , Cn = reactExports.useCallback(as => {
        xt && (xt.uiOptions = as)
    }
    , [xt]);
    return isServerSide() ? [null, () => {}
    ] : (checkProvider(xt),
    [xt, Cn])
}
const buttonRootId = "ton-connect-button"
  , TonConnectButton = ({className: xt, style: Cn}) => {
    const [as,cs] = useTonConnectUI();
    return reactExports.useEffect( () => (cs({
        buttonRootId
    }),
    () => cs({
        buttonRootId: null
    })), [cs]),
    jsx("div", {
        id: buttonRootId,
        className: xt,
        style: __spreadValues({
            width: "fit-content"
        }, Cn)
    })
}
;
reactExports.memo(TonConnectButton);
function useTonWallet() {
    const [xt] = useTonConnectUI()
      , [Cn,as] = reactExports.useState((xt == null ? void 0 : xt.wallet) || null);
    return reactExports.useEffect( () => {
        if (xt)
            return as(xt.wallet),
            xt.onStatusChange(cs => {
                as(cs)
            }
            )
    }
    , [xt]),
    Cn
}
function useTonAddress(xt=!0) {
    const Cn = useTonWallet();
    return reactExports.useMemo( () => Cn ? xt ? toUserFriendlyAddress(Cn.account.address, Cn.account.chain === CHAIN.TESTNET) : Cn.account.address : "", [Cn, xt, Cn == null ? void 0 : Cn.account.address, Cn == null ? void 0 : Cn.account.chain])
}
const isObjectLike = xt => typeof xt == "object" && xt !== null
  , isEqual = (xt, Cn) => {
    if (xt === Cn)
        return !0;
    if (xt == null || Cn == null || !isObjectLike(xt) && !isObjectLike(Cn))
        return !1;
    if (isObjectLike(xt) && isObjectLike(Cn)) {
        if (Object.keys(xt).length !== Object.keys(Cn).length)
            return !1;
        for (const as in xt)
            if (Object.prototype.hasOwnProperty.call(xt, as) && Object.prototype.hasOwnProperty.call(Cn, as)) {
                if (!isEqual(xt[as], Cn[as]))
                    return !1
            } else
                return !1;
        return !0
    }
    return !1
}
  , useObjectMemo = xt => {
    const Cn = reactExports.useRef(xt);
    return isEqual(Cn.current, xt) || (Cn.current = xt),
    Cn.current
}
;
function _define_property(xt, Cn, as) {
    return Cn in xt ? Object.defineProperty(xt, Cn, {
        value: as,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : xt[Cn] = as,
    xt
}
function _object_spread(xt) {
    for (var Cn = 1; Cn < arguments.length; Cn++) {
        var as = arguments[Cn] != null ? arguments[Cn] : {}
          , cs = Object.keys(as);
        typeof Object.getOwnPropertySymbols == "function" && (cs = cs.concat(Object.getOwnPropertySymbols(as).filter(function(Cs) {
            return Object.getOwnPropertyDescriptor(as, Cs).enumerable
        }))),
        cs.forEach(function(Cs) {
            _define_property(xt, Cs, as[Cs])
        })
    }
    return xt
}
function ownKeys$2(xt, Cn) {
    var as = Object.keys(xt);
    if (Object.getOwnPropertySymbols) {
        var cs = Object.getOwnPropertySymbols(xt);
        as.push.apply(as, cs)
    }
    return as
}
function _object_spread_props(xt, Cn) {
    return Cn = Cn ?? {},
    Object.getOwnPropertyDescriptors ? Object.defineProperties(xt, Object.getOwnPropertyDescriptors(Cn)) : ownKeys$2(Object(Cn)).forEach(function(as) {
        Object.defineProperty(xt, as, Object.getOwnPropertyDescriptor(Cn, as))
    }),
    xt
}
function _object_without_properties_loose(xt, Cn) {
    if (xt == null)
        return {};
    var as = {}, cs = Object.keys(xt), Cs, Ls;
    for (Ls = 0; Ls < cs.length; Ls++)
        Cs = cs[Ls],
        !(Cn.indexOf(Cs) >= 0) && (as[Cs] = xt[Cs]);
    return as
}
function _object_without_properties(xt, Cn) {
    if (xt == null)
        return {};
    var as = _object_without_properties_loose(xt, Cn), cs, Cs;
    if (Object.getOwnPropertySymbols) {
        var Ls = Object.getOwnPropertySymbols(xt);
        for (Cs = 0; Cs < Ls.length; Cs++)
            cs = Ls[Cs],
            !(Cn.indexOf(cs) >= 0) && Object.prototype.propertyIsEnumerable.call(xt, cs) && (as[cs] = xt[cs])
    }
    return as
}
function classNames(...xt) {
    const Cn = [];
    return xt.forEach(as => {
        if (as)
            switch (typeof as) {
            case "string":
                Cn.push(as);
                break;
            case "object":
                Object.keys(as).forEach(cs => {
                    as[cs] && Cn.push(cs)
                }
                );
                break;
            default:
                Cn.push(`${as}`)
            }
    }
    ),
    Cn.join(" ")
}
const AppRootContext = reactExports.createContext({
    isRendered: !1
});
function hasWindow() {
    return typeof window < "u"
}
function getNodeName(xt) {
    return isNode(xt) ? (xt.nodeName || "").toLowerCase() : "#document"
}
function getWindow(xt) {
    var Cn;
    return (xt == null || (Cn = xt.ownerDocument) == null ? void 0 : Cn.defaultView) || window
}
function getDocumentElement(xt) {
    var Cn;
    return (Cn = (isNode(xt) ? xt.ownerDocument : xt.document) || window.document) == null ? void 0 : Cn.documentElement
}
function isNode(xt) {
    return hasWindow() ? xt instanceof Node || xt instanceof getWindow(xt).Node : !1
}
function isElement(xt) {
    return hasWindow() ? xt instanceof Element || xt instanceof getWindow(xt).Element : !1
}
function isHTMLElement$1(xt) {
    return hasWindow() ? xt instanceof HTMLElement || xt instanceof getWindow(xt).HTMLElement : !1
}
function isShadowRoot(xt) {
    return !hasWindow() || typeof ShadowRoot > "u" ? !1 : xt instanceof ShadowRoot || xt instanceof getWindow(xt).ShadowRoot
}
function isOverflowElement(xt) {
    const {overflow: Cn, overflowX: as, overflowY: cs, display: Cs} = getComputedStyle$2(xt);
    return /auto|scroll|overlay|hidden|clip/.test(Cn + cs + as) && !["inline", "contents"].includes(Cs)
}
function isTableElement(xt) {
    return ["table", "td", "th"].includes(getNodeName(xt))
}
function isTopLayer(xt) {
    return [":popover-open", ":modal"].some(Cn => {
        try {
            return xt.matches(Cn)
        } catch {
            return !1
        }
    }
    )
}
function isContainingBlock(xt) {
    const Cn = isWebKit$1()
      , as = isElement(xt) ? getComputedStyle$2(xt) : xt;
    return ["transform", "translate", "scale", "rotate", "perspective"].some(cs => as[cs] ? as[cs] !== "none" : !1) || (as.containerType ? as.containerType !== "normal" : !1) || !Cn && (as.backdropFilter ? as.backdropFilter !== "none" : !1) || !Cn && (as.filter ? as.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some(cs => (as.willChange || "").includes(cs)) || ["paint", "layout", "strict", "content"].some(cs => (as.contain || "").includes(cs))
}
function getContainingBlock(xt) {
    let Cn = getParentNode(xt);
    for (; isHTMLElement$1(Cn) && !isLastTraversableNode(Cn); ) {
        if (isContainingBlock(Cn))
            return Cn;
        if (isTopLayer(Cn))
            return null;
        Cn = getParentNode(Cn)
    }
    return null
}
function isWebKit$1() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
}
function isLastTraversableNode(xt) {
    return ["html", "body", "#document"].includes(getNodeName(xt))
}
function getComputedStyle$2(xt) {
    return getWindow(xt).getComputedStyle(xt)
}
function getNodeScroll(xt) {
    return isElement(xt) ? {
        scrollLeft: xt.scrollLeft,
        scrollTop: xt.scrollTop
    } : {
        scrollLeft: xt.scrollX,
        scrollTop: xt.scrollY
    }
}
function getParentNode(xt) {
    if (getNodeName(xt) === "html")
        return xt;
    const Cn = xt.assignedSlot || xt.parentNode || isShadowRoot(xt) && xt.host || getDocumentElement(xt);
    return isShadowRoot(Cn) ? Cn.host : Cn
}
function getNearestOverflowAncestor(xt) {
    const Cn = getParentNode(xt);
    return isLastTraversableNode(Cn) ? xt.ownerDocument ? xt.ownerDocument.body : xt.body : isHTMLElement$1(Cn) && isOverflowElement(Cn) ? Cn : getNearestOverflowAncestor(Cn)
}
function getOverflowAncestors(xt, Cn, as) {
    var cs;
    Cn === void 0 && (Cn = []),
    as === void 0 && (as = !0);
    const Cs = getNearestOverflowAncestor(xt)
      , Ls = Cs === ((cs = xt.ownerDocument) == null ? void 0 : cs.body)
      , Vs = getWindow(Cs);
    if (Ls) {
        const Ws = getFrameElement(Vs);
        return Cn.concat(Vs, Vs.visualViewport || [], isOverflowElement(Cs) ? Cs : [], Ws && as ? getOverflowAncestors(Ws) : [])
    }
    return Cn.concat(Cs, getOverflowAncestors(Cs, [], as))
}
function getFrameElement(xt) {
    return xt.parent && Object.getPrototypeOf(xt.parent) ? xt.frameElement : null
}
const canUseDOM = !!(typeof window < "u" && window.document && window.document.createElement)
  , setRef = (xt, Cn) => {
    Cn && (typeof Cn == "function" ? Cn(xt) : Cn.current = xt)
}
  , multipleRef = (...xt) => {
    let Cn = null;
    return {
        get current() {
            return Cn
        },
        set current(as) {
            Cn = as,
            xt.forEach(cs => cs && setRef(as, cs))
        }
    }
}
  , min = Math.min
  , max = Math.max
  , round$1 = Math.round
  , floor$2 = Math.floor
  , createCoords = xt => ({
    x: xt,
    y: xt
})
  , oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
}
  , oppositeAlignmentMap = {
    start: "end",
    end: "start"
};
function clamp$2(xt, Cn, as) {
    return max(xt, min(Cn, as))
}
function evaluate(xt, Cn) {
    return typeof xt == "function" ? xt(Cn) : xt
}
function getSide(xt) {
    return xt.split("-")[0]
}
function getAlignment(xt) {
    return xt.split("-")[1]
}
function getOppositeAxis(xt) {
    return xt === "x" ? "y" : "x"
}
function getAxisLength(xt) {
    return xt === "y" ? "height" : "width"
}
function getSideAxis(xt) {
    return ["top", "bottom"].includes(getSide(xt)) ? "y" : "x"
}
function getAlignmentAxis(xt) {
    return getOppositeAxis(getSideAxis(xt))
}
function getAlignmentSides(xt, Cn, as) {
    as === void 0 && (as = !1);
    const cs = getAlignment(xt)
      , Cs = getAlignmentAxis(xt)
      , Ls = getAxisLength(Cs);
    let Vs = Cs === "x" ? cs === (as ? "end" : "start") ? "right" : "left" : cs === "start" ? "bottom" : "top";
    return Cn.reference[Ls] > Cn.floating[Ls] && (Vs = getOppositePlacement(Vs)),
    [Vs, getOppositePlacement(Vs)]
}
function getExpandedPlacements(xt) {
    const Cn = getOppositePlacement(xt);
    return [getOppositeAlignmentPlacement(xt), Cn, getOppositeAlignmentPlacement(Cn)]
}
function getOppositeAlignmentPlacement(xt) {
    return xt.replace(/start|end/g, Cn => oppositeAlignmentMap[Cn])
}
function getSideList(xt, Cn, as) {
    const cs = ["left", "right"]
      , Cs = ["right", "left"]
      , Ls = ["top", "bottom"]
      , Vs = ["bottom", "top"];
    switch (xt) {
    case "top":
    case "bottom":
        return as ? Cn ? Cs : cs : Cn ? cs : Cs;
    case "left":
    case "right":
        return Cn ? Ls : Vs;
    default:
        return []
    }
}
function getOppositeAxisPlacements(xt, Cn, as, cs) {
    const Cs = getAlignment(xt);
    let Ls = getSideList(getSide(xt), as === "start", cs);
    return Cs && (Ls = Ls.map(Vs => Vs + "-" + Cs),
    Cn && (Ls = Ls.concat(Ls.map(getOppositeAlignmentPlacement)))),
    Ls
}
function getOppositePlacement(xt) {
    return xt.replace(/left|right|bottom|top/g, Cn => oppositeSideMap[Cn])
}
function expandPaddingObject(xt) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...xt
    }
}
function getPaddingObject(xt) {
    return typeof xt != "number" ? expandPaddingObject(xt) : {
        top: xt,
        right: xt,
        bottom: xt,
        left: xt
    }
}
function rectToClientRect(xt) {
    const {x: Cn, y: as, width: cs, height: Cs} = xt;
    return {
        width: cs,
        height: Cs,
        top: as,
        left: Cn,
        right: Cn + cs,
        bottom: as + Cs,
        x: Cn,
        y: as
    }
}
function computeCoordsFromPlacement(xt, Cn, as) {
    let {reference: cs, floating: Cs} = xt;
    const Ls = getSideAxis(Cn)
      , Vs = getAlignmentAxis(Cn)
      , Ws = getAxisLength(Vs)
      , Xs = getSide(Cn)
      , ga = Ls === "y"
      , ba = cs.x + cs.width / 2 - Cs.width / 2
      , yl = cs.y + cs.height / 2 - Cs.height / 2
      , xl = cs[Ws] / 2 - Cs[Ws] / 2;
    let wl;
    switch (Xs) {
    case "top":
        wl = {
            x: ba,
            y: cs.y - Cs.height
        };
        break;
    case "bottom":
        wl = {
            x: ba,
            y: cs.y + cs.height
        };
        break;
    case "right":
        wl = {
            x: cs.x + cs.width,
            y: yl
        };
        break;
    case "left":
        wl = {
            x: cs.x - Cs.width,
            y: yl
        };
        break;
    default:
        wl = {
            x: cs.x,
            y: cs.y
        }
    }
    switch (getAlignment(Cn)) {
    case "start":
        wl[Vs] -= xl * (as && ga ? -1 : 1);
        break;
    case "end":
        wl[Vs] += xl * (as && ga ? -1 : 1);
        break
    }
    return wl
}
const computePosition$1 = async (xt, Cn, as) => {
    const {placement: cs="bottom", strategy: Cs="absolute", middleware: Ls=[], platform: Vs} = as
      , Ws = Ls.filter(Boolean)
      , Xs = await (Vs.isRTL == null ? void 0 : Vs.isRTL(Cn));
    let ga = await Vs.getElementRects({
        reference: xt,
        floating: Cn,
        strategy: Cs
    })
      , {x: ba, y: yl} = computeCoordsFromPlacement(ga, cs, Xs)
      , xl = cs
      , wl = {}
      , _l = 0;
    for (let El = 0; El < Ws.length; El++) {
        const {name: Cl, fn: $l} = Ws[El]
          , {x: Sl, y: Tl, data: Rl, reset: Il} = await $l({
            x: ba,
            y: yl,
            initialPlacement: cs,
            placement: xl,
            strategy: Cs,
            middlewareData: wl,
            rects: ga,
            platform: Vs,
            elements: {
                reference: xt,
                floating: Cn
            }
        });
        ba = Sl ?? ba,
        yl = Tl ?? yl,
        wl = {
            ...wl,
            [Cl]: {
                ...wl[Cl],
                ...Rl
            }
        },
        Il && _l <= 50 && (_l++,
        typeof Il == "object" && (Il.placement && (xl = Il.placement),
        Il.rects && (ga = Il.rects === !0 ? await Vs.getElementRects({
            reference: xt,
            floating: Cn,
            strategy: Cs
        }) : Il.rects),
        {x: ba, y: yl} = computeCoordsFromPlacement(ga, xl, Xs)),
        El = -1)
    }
    return {
        x: ba,
        y: yl,
        placement: xl,
        strategy: Cs,
        middlewareData: wl
    }
}
;
async function detectOverflow$1(xt, Cn) {
    var as;
    Cn === void 0 && (Cn = {});
    const {x: cs, y: Cs, platform: Ls, rects: Vs, elements: Ws, strategy: Xs} = xt
      , {boundary: ga="clippingAncestors", rootBoundary: ba="viewport", elementContext: yl="floating", altBoundary: xl=!1, padding: wl=0} = evaluate(Cn, xt)
      , _l = getPaddingObject(wl)
      , Cl = Ws[xl ? yl === "floating" ? "reference" : "floating" : yl]
      , $l = rectToClientRect(await Ls.getClippingRect({
        element: (as = await (Ls.isElement == null ? void 0 : Ls.isElement(Cl))) == null || as ? Cl : Cl.contextElement || await (Ls.getDocumentElement == null ? void 0 : Ls.getDocumentElement(Ws.floating)),
        boundary: ga,
        rootBoundary: ba,
        strategy: Xs
    }))
      , Sl = yl === "floating" ? {
        x: cs,
        y: Cs,
        width: Vs.floating.width,
        height: Vs.floating.height
    } : Vs.reference
      , Tl = await (Ls.getOffsetParent == null ? void 0 : Ls.getOffsetParent(Ws.floating))
      , Rl = await (Ls.isElement == null ? void 0 : Ls.isElement(Tl)) ? await (Ls.getScale == null ? void 0 : Ls.getScale(Tl)) || {
        x: 1,
        y: 1
    } : {
        x: 1,
        y: 1
    }
      , Il = rectToClientRect(Ls.convertOffsetParentRelativeRectToViewportRelativeRect ? await Ls.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements: Ws,
        rect: Sl,
        offsetParent: Tl,
        strategy: Xs
    }) : Sl);
    return {
        top: ($l.top - Il.top + _l.top) / Rl.y,
        bottom: (Il.bottom - $l.bottom + _l.bottom) / Rl.y,
        left: ($l.left - Il.left + _l.left) / Rl.x,
        right: (Il.right - $l.right + _l.right) / Rl.x
    }
}
const flip$2 = function(xt) {
    return xt === void 0 && (xt = {}),
    {
        name: "flip",
        options: xt,
        async fn(Cn) {
            var as, cs;
            const {placement: Cs, middlewareData: Ls, rects: Vs, initialPlacement: Ws, platform: Xs, elements: ga} = Cn
              , {mainAxis: ba=!0, crossAxis: yl=!0, fallbackPlacements: xl, fallbackStrategy: wl="bestFit", fallbackAxisSideDirection: _l="none", flipAlignment: El=!0, ...Cl} = evaluate(xt, Cn);
            if ((as = Ls.arrow) != null && as.alignmentOffset)
                return {};
            const $l = getSide(Cs)
              , Sl = getSideAxis(Ws)
              , Tl = getSide(Ws) === Ws
              , Rl = await (Xs.isRTL == null ? void 0 : Xs.isRTL(ga.floating))
              , Il = xl || (Tl || !El ? [getOppositePlacement(Ws)] : getExpandedPlacements(Ws))
              , Ml = _l !== "none";
            !xl && Ml && Il.push(...getOppositeAxisPlacements(Ws, El, _l, Rl));
            const Nl = [Ws, ...Il]
              , Ll = await detectOverflow$1(Cn, Cl)
              , Fl = [];
            let Ul = ((cs = Ls.flip) == null ? void 0 : cs.overflows) || [];
            if (ba && Fl.push(Ll[$l]),
            yl) {
                const Wl = getAlignmentSides(Cs, Vs, Rl);
                Fl.push(Ll[Wl[0]], Ll[Wl[1]])
            }
            if (Ul = [...Ul, {
                placement: Cs,
                overflows: Fl
            }],
            !Fl.every(Wl => Wl <= 0)) {
                var Dl, Zl;
                const Wl = (((Dl = Ls.flip) == null ? void 0 : Dl.index) || 0) + 1
                  , Ql = Nl[Wl];
                if (Ql)
                    return {
                        data: {
                            index: Wl,
                            overflows: Ul
                        },
                        reset: {
                            placement: Ql
                        }
                    };
                let cu = (Zl = Ul.filter(pu => pu.overflows[0] <= 0).sort( (pu, zl) => pu.overflows[1] - zl.overflows[1])[0]) == null ? void 0 : Zl.placement;
                if (!cu)
                    switch (wl) {
                    case "bestFit":
                        {
                            var Gl;
                            const pu = (Gl = Ul.filter(zl => {
                                if (Ml) {
                                    const Yl = getSideAxis(zl.placement);
                                    return Yl === Sl || Yl === "y"
                                }
                                return !0
                            }
                            ).map(zl => [zl.placement, zl.overflows.filter(Yl => Yl > 0).reduce( (Yl, lu) => Yl + lu, 0)]).sort( (zl, Yl) => zl[1] - Yl[1])[0]) == null ? void 0 : Gl[0];
                            pu && (cu = pu);
                            break
                        }
                    case "initialPlacement":
                        cu = Ws;
                        break
                    }
                if (Cs !== cu)
                    return {
                        reset: {
                            placement: cu
                        }
                    }
            }
            return {}
        }
    }
};
async function convertValueToCoords(xt, Cn) {
    const {placement: as, platform: cs, elements: Cs} = xt
      , Ls = await (cs.isRTL == null ? void 0 : cs.isRTL(Cs.floating))
      , Vs = getSide(as)
      , Ws = getAlignment(as)
      , Xs = getSideAxis(as) === "y"
      , ga = ["left", "top"].includes(Vs) ? -1 : 1
      , ba = Ls && Xs ? -1 : 1
      , yl = evaluate(Cn, xt);
    let {mainAxis: xl, crossAxis: wl, alignmentAxis: _l} = typeof yl == "number" ? {
        mainAxis: yl,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: yl.mainAxis || 0,
        crossAxis: yl.crossAxis || 0,
        alignmentAxis: yl.alignmentAxis
    };
    return Ws && typeof _l == "number" && (wl = Ws === "end" ? _l * -1 : _l),
    Xs ? {
        x: wl * ba,
        y: xl * ga
    } : {
        x: xl * ga,
        y: wl * ba
    }
}
const offset$2 = function(xt) {
    return xt === void 0 && (xt = 0),
    {
        name: "offset",
        options: xt,
        async fn(Cn) {
            var as, cs;
            const {x: Cs, y: Ls, placement: Vs, middlewareData: Ws} = Cn
              , Xs = await convertValueToCoords(Cn, xt);
            return Vs === ((as = Ws.offset) == null ? void 0 : as.placement) && (cs = Ws.arrow) != null && cs.alignmentOffset ? {} : {
                x: Cs + Xs.x,
                y: Ls + Xs.y,
                data: {
                    ...Xs,
                    placement: Vs
                }
            }
        }
    }
}
  , shift$2 = function(xt) {
    return xt === void 0 && (xt = {}),
    {
        name: "shift",
        options: xt,
        async fn(Cn) {
            const {x: as, y: cs, placement: Cs} = Cn
              , {mainAxis: Ls=!0, crossAxis: Vs=!1, limiter: Ws={
                fn: Cl => {
                    let {x: $l, y: Sl} = Cl;
                    return {
                        x: $l,
                        y: Sl
                    }
                }
            }, ...Xs} = evaluate(xt, Cn)
              , ga = {
                x: as,
                y: cs
            }
              , ba = await detectOverflow$1(Cn, Xs)
              , yl = getSideAxis(getSide(Cs))
              , xl = getOppositeAxis(yl);
            let wl = ga[xl]
              , _l = ga[yl];
            if (Ls) {
                const Cl = xl === "y" ? "top" : "left"
                  , $l = xl === "y" ? "bottom" : "right"
                  , Sl = wl + ba[Cl]
                  , Tl = wl - ba[$l];
                wl = clamp$2(Sl, wl, Tl)
            }
            if (Vs) {
                const Cl = yl === "y" ? "top" : "left"
                  , $l = yl === "y" ? "bottom" : "right"
                  , Sl = _l + ba[Cl]
                  , Tl = _l - ba[$l];
                _l = clamp$2(Sl, _l, Tl)
            }
            const El = Ws.fn({
                ...Cn,
                [xl]: wl,
                [yl]: _l
            });
            return {
                ...El,
                data: {
                    x: El.x - as,
                    y: El.y - cs,
                    enabled: {
                        [xl]: Ls,
                        [yl]: Vs
                    }
                }
            }
        }
    }
}
  , size$2 = function(xt) {
    return xt === void 0 && (xt = {}),
    {
        name: "size",
        options: xt,
        async fn(Cn) {
            var as, cs;
            const {placement: Cs, rects: Ls, platform: Vs, elements: Ws} = Cn
              , {apply: Xs= () => {}
            , ...ga} = evaluate(xt, Cn)
              , ba = await detectOverflow$1(Cn, ga)
              , yl = getSide(Cs)
              , xl = getAlignment(Cs)
              , wl = getSideAxis(Cs) === "y"
              , {width: _l, height: El} = Ls.floating;
            let Cl, $l;
            yl === "top" || yl === "bottom" ? (Cl = yl,
            $l = xl === (await (Vs.isRTL == null ? void 0 : Vs.isRTL(Ws.floating)) ? "start" : "end") ? "left" : "right") : ($l = yl,
            Cl = xl === "end" ? "top" : "bottom");
            const Sl = El - ba.top - ba.bottom
              , Tl = _l - ba.left - ba.right
              , Rl = min(El - ba[Cl], Sl)
              , Il = min(_l - ba[$l], Tl)
              , Ml = !Cn.middlewareData.shift;
            let Nl = Rl
              , Ll = Il;
            if ((as = Cn.middlewareData.shift) != null && as.enabled.x && (Ll = Tl),
            (cs = Cn.middlewareData.shift) != null && cs.enabled.y && (Nl = Sl),
            Ml && !xl) {
                const Ul = max(ba.left, 0)
                  , Dl = max(ba.right, 0)
                  , Zl = max(ba.top, 0)
                  , Gl = max(ba.bottom, 0);
                wl ? Ll = _l - 2 * (Ul !== 0 || Dl !== 0 ? Ul + Dl : max(ba.left, ba.right)) : Nl = El - 2 * (Zl !== 0 || Gl !== 0 ? Zl + Gl : max(ba.top, ba.bottom))
            }
            await Xs({
                ...Cn,
                availableWidth: Ll,
                availableHeight: Nl
            });
            const Fl = await Vs.getDimensions(Ws.floating);
            return _l !== Fl.width || El !== Fl.height ? {
                reset: {
                    rects: !0
                }
            } : {}
        }
    }
};
function getCssDimensions(xt) {
    const Cn = getComputedStyle$2(xt);
    let as = parseFloat(Cn.width) || 0
      , cs = parseFloat(Cn.height) || 0;
    const Cs = isHTMLElement$1(xt)
      , Ls = Cs ? xt.offsetWidth : as
      , Vs = Cs ? xt.offsetHeight : cs
      , Ws = round$1(as) !== Ls || round$1(cs) !== Vs;
    return Ws && (as = Ls,
    cs = Vs),
    {
        width: as,
        height: cs,
        $: Ws
    }
}
function unwrapElement(xt) {
    return isElement(xt) ? xt : xt.contextElement
}
function getScale(xt) {
    const Cn = unwrapElement(xt);
    if (!isHTMLElement$1(Cn))
        return createCoords(1);
    const as = Cn.getBoundingClientRect()
      , {width: cs, height: Cs, $: Ls} = getCssDimensions(Cn);
    let Vs = (Ls ? round$1(as.width) : as.width) / cs
      , Ws = (Ls ? round$1(as.height) : as.height) / Cs;
    return (!Vs || !Number.isFinite(Vs)) && (Vs = 1),
    (!Ws || !Number.isFinite(Ws)) && (Ws = 1),
    {
        x: Vs,
        y: Ws
    }
}
const noOffsets = createCoords(0);
function getVisualOffsets(xt) {
    const Cn = getWindow(xt);
    return !isWebKit$1() || !Cn.visualViewport ? noOffsets : {
        x: Cn.visualViewport.offsetLeft,
        y: Cn.visualViewport.offsetTop
    }
}
function shouldAddVisualOffsets(xt, Cn, as) {
    return Cn === void 0 && (Cn = !1),
    !as || Cn && as !== getWindow(xt) ? !1 : Cn
}
function getBoundingClientRect(xt, Cn, as, cs) {
    Cn === void 0 && (Cn = !1),
    as === void 0 && (as = !1);
    const Cs = xt.getBoundingClientRect()
      , Ls = unwrapElement(xt);
    let Vs = createCoords(1);
    Cn && (cs ? isElement(cs) && (Vs = getScale(cs)) : Vs = getScale(xt));
    const Ws = shouldAddVisualOffsets(Ls, as, cs) ? getVisualOffsets(Ls) : createCoords(0);
    let Xs = (Cs.left + Ws.x) / Vs.x
      , ga = (Cs.top + Ws.y) / Vs.y
      , ba = Cs.width / Vs.x
      , yl = Cs.height / Vs.y;
    if (Ls) {
        const xl = getWindow(Ls)
          , wl = cs && isElement(cs) ? getWindow(cs) : cs;
        let _l = xl
          , El = getFrameElement(_l);
        for (; El && cs && wl !== _l; ) {
            const Cl = getScale(El)
              , $l = El.getBoundingClientRect()
              , Sl = getComputedStyle$2(El)
              , Tl = $l.left + (El.clientLeft + parseFloat(Sl.paddingLeft)) * Cl.x
              , Rl = $l.top + (El.clientTop + parseFloat(Sl.paddingTop)) * Cl.y;
            Xs *= Cl.x,
            ga *= Cl.y,
            ba *= Cl.x,
            yl *= Cl.y,
            Xs += Tl,
            ga += Rl,
            _l = getWindow(El),
            El = getFrameElement(_l)
        }
    }
    return rectToClientRect({
        width: ba,
        height: yl,
        x: Xs,
        y: ga
    })
}
function getWindowScrollBarX(xt, Cn) {
    const as = getNodeScroll(xt).scrollLeft;
    return Cn ? Cn.left + as : getBoundingClientRect(getDocumentElement(xt)).left + as
}
function getHTMLOffset(xt, Cn, as) {
    as === void 0 && (as = !1);
    const cs = xt.getBoundingClientRect()
      , Cs = cs.left + Cn.scrollLeft - (as ? 0 : getWindowScrollBarX(xt, cs))
      , Ls = cs.top + Cn.scrollTop;
    return {
        x: Cs,
        y: Ls
    }
}
function convertOffsetParentRelativeRectToViewportRelativeRect(xt) {
    let {elements: Cn, rect: as, offsetParent: cs, strategy: Cs} = xt;
    const Ls = Cs === "fixed"
      , Vs = getDocumentElement(cs)
      , Ws = Cn ? isTopLayer(Cn.floating) : !1;
    if (cs === Vs || Ws && Ls)
        return as;
    let Xs = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , ga = createCoords(1);
    const ba = createCoords(0)
      , yl = isHTMLElement$1(cs);
    if ((yl || !yl && !Ls) && ((getNodeName(cs) !== "body" || isOverflowElement(Vs)) && (Xs = getNodeScroll(cs)),
    isHTMLElement$1(cs))) {
        const wl = getBoundingClientRect(cs);
        ga = getScale(cs),
        ba.x = wl.x + cs.clientLeft,
        ba.y = wl.y + cs.clientTop
    }
    const xl = Vs && !yl && !Ls ? getHTMLOffset(Vs, Xs, !0) : createCoords(0);
    return {
        width: as.width * ga.x,
        height: as.height * ga.y,
        x: as.x * ga.x - Xs.scrollLeft * ga.x + ba.x + xl.x,
        y: as.y * ga.y - Xs.scrollTop * ga.y + ba.y + xl.y
    }
}
function getClientRects(xt) {
    return Array.from(xt.getClientRects())
}
function getDocumentRect(xt) {
    const Cn = getDocumentElement(xt)
      , as = getNodeScroll(xt)
      , cs = xt.ownerDocument.body
      , Cs = max(Cn.scrollWidth, Cn.clientWidth, cs.scrollWidth, cs.clientWidth)
      , Ls = max(Cn.scrollHeight, Cn.clientHeight, cs.scrollHeight, cs.clientHeight);
    let Vs = -as.scrollLeft + getWindowScrollBarX(xt);
    const Ws = -as.scrollTop;
    return getComputedStyle$2(cs).direction === "rtl" && (Vs += max(Cn.clientWidth, cs.clientWidth) - Cs),
    {
        width: Cs,
        height: Ls,
        x: Vs,
        y: Ws
    }
}
function getViewportRect(xt, Cn) {
    const as = getWindow(xt)
      , cs = getDocumentElement(xt)
      , Cs = as.visualViewport;
    let Ls = cs.clientWidth
      , Vs = cs.clientHeight
      , Ws = 0
      , Xs = 0;
    if (Cs) {
        Ls = Cs.width,
        Vs = Cs.height;
        const ga = isWebKit$1();
        (!ga || ga && Cn === "fixed") && (Ws = Cs.offsetLeft,
        Xs = Cs.offsetTop)
    }
    return {
        width: Ls,
        height: Vs,
        x: Ws,
        y: Xs
    }
}
function getInnerBoundingClientRect(xt, Cn) {
    const as = getBoundingClientRect(xt, !0, Cn === "fixed")
      , cs = as.top + xt.clientTop
      , Cs = as.left + xt.clientLeft
      , Ls = isHTMLElement$1(xt) ? getScale(xt) : createCoords(1)
      , Vs = xt.clientWidth * Ls.x
      , Ws = xt.clientHeight * Ls.y
      , Xs = Cs * Ls.x
      , ga = cs * Ls.y;
    return {
        width: Vs,
        height: Ws,
        x: Xs,
        y: ga
    }
}
function getClientRectFromClippingAncestor(xt, Cn, as) {
    let cs;
    if (Cn === "viewport")
        cs = getViewportRect(xt, as);
    else if (Cn === "document")
        cs = getDocumentRect(getDocumentElement(xt));
    else if (isElement(Cn))
        cs = getInnerBoundingClientRect(Cn, as);
    else {
        const Cs = getVisualOffsets(xt);
        cs = {
            x: Cn.x - Cs.x,
            y: Cn.y - Cs.y,
            width: Cn.width,
            height: Cn.height
        }
    }
    return rectToClientRect(cs)
}
function hasFixedPositionAncestor(xt, Cn) {
    const as = getParentNode(xt);
    return as === Cn || !isElement(as) || isLastTraversableNode(as) ? !1 : getComputedStyle$2(as).position === "fixed" || hasFixedPositionAncestor(as, Cn)
}
function getClippingElementAncestors(xt, Cn) {
    const as = Cn.get(xt);
    if (as)
        return as;
    let cs = getOverflowAncestors(xt, [], !1).filter(Ws => isElement(Ws) && getNodeName(Ws) !== "body")
      , Cs = null;
    const Ls = getComputedStyle$2(xt).position === "fixed";
    let Vs = Ls ? getParentNode(xt) : xt;
    for (; isElement(Vs) && !isLastTraversableNode(Vs); ) {
        const Ws = getComputedStyle$2(Vs)
          , Xs = isContainingBlock(Vs);
        !Xs && Ws.position === "fixed" && (Cs = null),
        (Ls ? !Xs && !Cs : !Xs && Ws.position === "static" && !!Cs && ["absolute", "fixed"].includes(Cs.position) || isOverflowElement(Vs) && !Xs && hasFixedPositionAncestor(xt, Vs)) ? cs = cs.filter(ba => ba !== Vs) : Cs = Ws,
        Vs = getParentNode(Vs)
    }
    return Cn.set(xt, cs),
    cs
}
function getClippingRect(xt) {
    let {element: Cn, boundary: as, rootBoundary: cs, strategy: Cs} = xt;
    const Vs = [...as === "clippingAncestors" ? isTopLayer(Cn) ? [] : getClippingElementAncestors(Cn, this._c) : [].concat(as), cs]
      , Ws = Vs[0]
      , Xs = Vs.reduce( (ga, ba) => {
        const yl = getClientRectFromClippingAncestor(Cn, ba, Cs);
        return ga.top = max(yl.top, ga.top),
        ga.right = min(yl.right, ga.right),
        ga.bottom = min(yl.bottom, ga.bottom),
        ga.left = max(yl.left, ga.left),
        ga
    }
    , getClientRectFromClippingAncestor(Cn, Ws, Cs));
    return {
        width: Xs.right - Xs.left,
        height: Xs.bottom - Xs.top,
        x: Xs.left,
        y: Xs.top
    }
}
function getDimensions(xt) {
    const {width: Cn, height: as} = getCssDimensions(xt);
    return {
        width: Cn,
        height: as
    }
}
function getRectRelativeToOffsetParent(xt, Cn, as) {
    const cs = isHTMLElement$1(Cn)
      , Cs = getDocumentElement(Cn)
      , Ls = as === "fixed"
      , Vs = getBoundingClientRect(xt, !0, Ls, Cn);
    let Ws = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const Xs = createCoords(0);
    if (cs || !cs && !Ls)
        if ((getNodeName(Cn) !== "body" || isOverflowElement(Cs)) && (Ws = getNodeScroll(Cn)),
        cs) {
            const xl = getBoundingClientRect(Cn, !0, Ls, Cn);
            Xs.x = xl.x + Cn.clientLeft,
            Xs.y = xl.y + Cn.clientTop
        } else
            Cs && (Xs.x = getWindowScrollBarX(Cs));
    const ga = Cs && !cs && !Ls ? getHTMLOffset(Cs, Ws) : createCoords(0)
      , ba = Vs.left + Ws.scrollLeft - Xs.x - ga.x
      , yl = Vs.top + Ws.scrollTop - Xs.y - ga.y;
    return {
        x: ba,
        y: yl,
        width: Vs.width,
        height: Vs.height
    }
}
function isStaticPositioned(xt) {
    return getComputedStyle$2(xt).position === "static"
}
function getTrueOffsetParent(xt, Cn) {
    if (!isHTMLElement$1(xt) || getComputedStyle$2(xt).position === "fixed")
        return null;
    if (Cn)
        return Cn(xt);
    let as = xt.offsetParent;
    return getDocumentElement(xt) === as && (as = as.ownerDocument.body),
    as
}
function getOffsetParent(xt, Cn) {
    const as = getWindow(xt);
    if (isTopLayer(xt))
        return as;
    if (!isHTMLElement$1(xt)) {
        let Cs = getParentNode(xt);
        for (; Cs && !isLastTraversableNode(Cs); ) {
            if (isElement(Cs) && !isStaticPositioned(Cs))
                return Cs;
            Cs = getParentNode(Cs)
        }
        return as
    }
    let cs = getTrueOffsetParent(xt, Cn);
    for (; cs && isTableElement(cs) && isStaticPositioned(cs); )
        cs = getTrueOffsetParent(cs, Cn);
    return cs && isLastTraversableNode(cs) && isStaticPositioned(cs) && !isContainingBlock(cs) ? as : cs || getContainingBlock(xt) || as
}
const getElementRects = async function(xt) {
    const Cn = this.getOffsetParent || getOffsetParent
      , as = this.getDimensions
      , cs = await as(xt.floating);
    return {
        reference: getRectRelativeToOffsetParent(xt.reference, await Cn(xt.floating), xt.strategy),
        floating: {
            x: 0,
            y: 0,
            width: cs.width,
            height: cs.height
        }
    }
};
function isRTL(xt) {
    return getComputedStyle$2(xt).direction === "rtl"
}
const platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement,
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement,
    isRTL
};
function rectsAreEqual(xt, Cn) {
    return xt.x === Cn.x && xt.y === Cn.y && xt.width === Cn.width && xt.height === Cn.height
}
function observeMove(xt, Cn) {
    let as = null, cs;
    const Cs = getDocumentElement(xt);
    function Ls() {
        var Ws;
        clearTimeout(cs),
        (Ws = as) == null || Ws.disconnect(),
        as = null
    }
    function Vs(Ws, Xs) {
        Ws === void 0 && (Ws = !1),
        Xs === void 0 && (Xs = 1),
        Ls();
        const ga = xt.getBoundingClientRect()
          , {left: ba, top: yl, width: xl, height: wl} = ga;
        if (Ws || Cn(),
        !xl || !wl)
            return;
        const _l = floor$2(yl)
          , El = floor$2(Cs.clientWidth - (ba + xl))
          , Cl = floor$2(Cs.clientHeight - (yl + wl))
          , $l = floor$2(ba)
          , Tl = {
            rootMargin: -_l + "px " + -El + "px " + -Cl + "px " + -$l + "px",
            threshold: max(0, min(1, Xs)) || 1
        };
        let Rl = !0;
        function Il(Ml) {
            const Nl = Ml[0].intersectionRatio;
            if (Nl !== Xs) {
                if (!Rl)
                    return Vs();
                Nl ? Vs(!1, Nl) : cs = setTimeout( () => {
                    Vs(!1, 1e-7)
                }
                , 1e3)
            }
            Nl === 1 && !rectsAreEqual(ga, xt.getBoundingClientRect()) && Vs(),
            Rl = !1
        }
        try {
            as = new IntersectionObserver(Il,{
                ...Tl,
                root: Cs.ownerDocument
            })
        } catch {
            as = new IntersectionObserver(Il,Tl)
        }
        as.observe(xt)
    }
    return Vs(!0),
    Ls
}
function autoUpdate(xt, Cn, as, cs) {
    cs === void 0 && (cs = {});
    const {ancestorScroll: Cs=!0, ancestorResize: Ls=!0, elementResize: Vs=typeof ResizeObserver == "function", layoutShift: Ws=typeof IntersectionObserver == "function", animationFrame: Xs=!1} = cs
      , ga = unwrapElement(xt)
      , ba = Cs || Ls ? [...ga ? getOverflowAncestors(ga) : [], ...getOverflowAncestors(Cn)] : [];
    ba.forEach($l => {
        Cs && $l.addEventListener("scroll", as, {
            passive: !0
        }),
        Ls && $l.addEventListener("resize", as)
    }
    );
    const yl = ga && Ws ? observeMove(ga, as) : null;
    let xl = -1
      , wl = null;
    Vs && (wl = new ResizeObserver($l => {
        let[Sl] = $l;
        Sl && Sl.target === ga && wl && (wl.unobserve(Cn),
        cancelAnimationFrame(xl),
        xl = requestAnimationFrame( () => {
            var Tl;
            (Tl = wl) == null || Tl.observe(Cn)
        }
        )),
        as()
    }
    ),
    ga && !Xs && wl.observe(ga),
    wl.observe(Cn));
    let _l, El = Xs ? getBoundingClientRect(xt) : null;
    Xs && Cl();
    function Cl() {
        const $l = getBoundingClientRect(xt);
        El && !rectsAreEqual(El, $l) && as(),
        El = $l,
        _l = requestAnimationFrame(Cl)
    }
    return as(),
    () => {
        var $l;
        ba.forEach(Sl => {
            Cs && Sl.removeEventListener("scroll", as),
            Ls && Sl.removeEventListener("resize", as)
        }
        ),
        yl == null || yl(),
        ($l = wl) == null || $l.disconnect(),
        wl = null,
        Xs && cancelAnimationFrame(_l)
    }
}
const detectOverflow = detectOverflow$1
  , offset$1 = offset$2
  , shift$1 = shift$2
  , flip$1 = flip$2
  , size$1 = size$2
  , computePosition = (xt, Cn, as) => {
    const cs = new Map
      , Cs = {
        platform,
        ...as
    }
      , Ls = {
        ...Cs.platform,
        _c: cs
    };
    return computePosition$1(xt, Cn, {
        ...Cs,
        platform: Ls
    })
}
;
var index$2 = typeof document < "u" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual$2(xt, Cn) {
    if (xt === Cn)
        return !0;
    if (typeof xt != typeof Cn)
        return !1;
    if (typeof xt == "function" && xt.toString() === Cn.toString())
        return !0;
    let as, cs, Cs;
    if (xt && Cn && typeof xt == "object") {
        if (Array.isArray(xt)) {
            if (as = xt.length,
            as !== Cn.length)
                return !1;
            for (cs = as; cs-- !== 0; )
                if (!deepEqual$2(xt[cs], Cn[cs]))
                    return !1;
            return !0
        }
        if (Cs = Object.keys(xt),
        as = Cs.length,
        as !== Object.keys(Cn).length)
            return !1;
        for (cs = as; cs-- !== 0; )
            if (!{}.hasOwnProperty.call(Cn, Cs[cs]))
                return !1;
        for (cs = as; cs-- !== 0; ) {
            const Ls = Cs[cs];
            if (!(Ls === "_owner" && xt.$$typeof) && !deepEqual$2(xt[Ls], Cn[Ls]))
                return !1
        }
        return !0
    }
    return xt !== xt && Cn !== Cn
}
function getDPR(xt) {
    return typeof window > "u" ? 1 : (xt.ownerDocument.defaultView || window).devicePixelRatio || 1
}
function roundByDPR(xt, Cn) {
    const as = getDPR(xt);
    return Math.round(Cn * as) / as
}
function useLatestRef(xt) {
    const Cn = reactExports.useRef(xt);
    return index$2( () => {
        Cn.current = xt
    }
    ),
    Cn
}
function useFloating$1(xt) {
    xt === void 0 && (xt = {});
    const {placement: Cn="bottom", strategy: as="absolute", middleware: cs=[], platform: Cs, elements: {reference: Ls, floating: Vs}={}, transform: Ws=!0, whileElementsMounted: Xs, open: ga} = xt
      , [ba,yl] = reactExports.useState({
        x: 0,
        y: 0,
        strategy: as,
        placement: Cn,
        middlewareData: {},
        isPositioned: !1
    })
      , [xl,wl] = reactExports.useState(cs);
    deepEqual$2(xl, cs) || wl(cs);
    const [_l,El] = reactExports.useState(null)
      , [Cl,$l] = reactExports.useState(null)
      , Sl = reactExports.useCallback(zl => {
        zl !== Ml.current && (Ml.current = zl,
        El(zl))
    }
    , [])
      , Tl = reactExports.useCallback(zl => {
        zl !== Nl.current && (Nl.current = zl,
        $l(zl))
    }
    , [])
      , Rl = Ls || _l
      , Il = Vs || Cl
      , Ml = reactExports.useRef(null)
      , Nl = reactExports.useRef(null)
      , Ll = reactExports.useRef(ba)
      , Fl = Xs != null
      , Ul = useLatestRef(Xs)
      , Dl = useLatestRef(Cs)
      , Zl = useLatestRef(ga)
      , Gl = reactExports.useCallback( () => {
        if (!Ml.current || !Nl.current)
            return;
        const zl = {
            placement: Cn,
            strategy: as,
            middleware: xl
        };
        Dl.current && (zl.platform = Dl.current),
        computePosition(Ml.current, Nl.current, zl).then(Yl => {
            const lu = {
                ...Yl,
                isPositioned: Zl.current !== !1
            };
            Wl.current && !deepEqual$2(Ll.current, lu) && (Ll.current = lu,
            reactDomExports.flushSync( () => {
                yl(lu)
            }
            ))
        }
        )
    }
    , [xl, Cn, as, Dl, Zl]);
    index$2( () => {
        ga === !1 && Ll.current.isPositioned && (Ll.current.isPositioned = !1,
        yl(zl => ({
            ...zl,
            isPositioned: !1
        })))
    }
    , [ga]);
    const Wl = reactExports.useRef(!1);
    index$2( () => (Wl.current = !0,
    () => {
        Wl.current = !1
    }
    ), []),
    index$2( () => {
        if (Rl && (Ml.current = Rl),
        Il && (Nl.current = Il),
        Rl && Il) {
            if (Ul.current)
                return Ul.current(Rl, Il, Gl);
            Gl()
        }
    }
    , [Rl, Il, Gl, Ul, Fl]);
    const Ql = reactExports.useMemo( () => ({
        reference: Ml,
        floating: Nl,
        setReference: Sl,
        setFloating: Tl
    }), [Sl, Tl])
      , cu = reactExports.useMemo( () => ({
        reference: Rl,
        floating: Il
    }), [Rl, Il])
      , pu = reactExports.useMemo( () => {
        const zl = {
            position: as,
            left: 0,
            top: 0
        };
        if (!cu.floating)
            return zl;
        const Yl = roundByDPR(cu.floating, ba.x)
          , lu = roundByDPR(cu.floating, ba.y);
        return Ws ? {
            ...zl,
            transform: "translate(" + Yl + "px, " + lu + "px)",
            ...getDPR(cu.floating) >= 1.5 && {
                willChange: "transform"
            }
        } : {
            position: as,
            left: Yl,
            top: lu
        }
    }
    , [as, Ws, cu.floating, ba.x, ba.y]);
    return reactExports.useMemo( () => ({
        ...ba,
        update: Gl,
        refs: Ql,
        elements: cu,
        floatingStyles: pu
    }), [ba, Gl, Ql, cu, pu])
}
const offset = (xt, Cn) => ({
    ...offset$1(xt),
    options: [xt, Cn]
})
  , shift = (xt, Cn) => ({
    ...shift$1(xt),
    options: [xt, Cn]
})
  , flip = (xt, Cn) => ({
    ...flip$1(xt),
    options: [xt, Cn]
})
  , size = (xt, Cn) => ({
    ...size$1(xt),
    options: [xt, Cn]
});
var __assign = function() {
    return __assign = Object.assign || function(Cn) {
        for (var as, cs = 1, Cs = arguments.length; cs < Cs; cs++) {
            as = arguments[cs];
            for (var Ls in as)
                Object.prototype.hasOwnProperty.call(as, Ls) && (Cn[Ls] = as[Ls])
        }
        return Cn
    }
    ,
    __assign.apply(this, arguments)
};
function __awaiter(xt, Cn, as, cs) {
    function Cs(Ls) {
        return Ls instanceof as ? Ls : new as(function(Vs) {
            Vs(Ls)
        }
        )
    }
    return new (as || (as = Promise))(function(Ls, Vs) {
        function Ws(ba) {
            try {
                ga(cs.next(ba))
            } catch (yl) {
                Vs(yl)
            }
        }
        function Xs(ba) {
            try {
                ga(cs.throw(ba))
            } catch (yl) {
                Vs(yl)
            }
        }
        function ga(ba) {
            ba.done ? Ls(ba.value) : Cs(ba.value).then(Ws, Xs)
        }
        ga((cs = cs.apply(xt, Cn || [])).next())
    }
    )
}
function __generator(xt, Cn) {
    var as = {
        label: 0,
        sent: function() {
            if (Ls[0] & 1)
                throw Ls[1];
            return Ls[1]
        },
        trys: [],
        ops: []
    }, cs, Cs, Ls, Vs = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
    return Vs.next = Ws(0),
    Vs.throw = Ws(1),
    Vs.return = Ws(2),
    typeof Symbol == "function" && (Vs[Symbol.iterator] = function() {
        return this
    }
    ),
    Vs;
    function Ws(ga) {
        return function(ba) {
            return Xs([ga, ba])
        }
    }
    function Xs(ga) {
        if (cs)
            throw new TypeError("Generator is already executing.");
        for (; Vs && (Vs = 0,
        ga[0] && (as = 0)),
        as; )
            try {
                if (cs = 1,
                Cs && (Ls = ga[0] & 2 ? Cs.return : ga[0] ? Cs.throw || ((Ls = Cs.return) && Ls.call(Cs),
                0) : Cs.next) && !(Ls = Ls.call(Cs, ga[1])).done)
                    return Ls;
                switch (Cs = 0,
                Ls && (ga = [ga[0] & 2, Ls.value]),
                ga[0]) {
                case 0:
                case 1:
                    Ls = ga;
                    break;
                case 4:
                    return as.label++,
                    {
                        value: ga[1],
                        done: !1
                    };
                case 5:
                    as.label++,
                    Cs = ga[1],
                    ga = [0];
                    continue;
                case 7:
                    ga = as.ops.pop(),
                    as.trys.pop();
                    continue;
                default:
                    if (Ls = as.trys,
                    !(Ls = Ls.length > 0 && Ls[Ls.length - 1]) && (ga[0] === 6 || ga[0] === 2)) {
                        as = 0;
                        continue
                    }
                    if (ga[0] === 3 && (!Ls || ga[1] > Ls[0] && ga[1] < Ls[3])) {
                        as.label = ga[1];
                        break
                    }
                    if (ga[0] === 6 && as.label < Ls[1]) {
                        as.label = Ls[1],
                        Ls = ga;
                        break
                    }
                    if (Ls && as.label < Ls[2]) {
                        as.label = Ls[2],
                        as.ops.push(ga);
                        break
                    }
                    Ls[2] && as.ops.pop(),
                    as.trys.pop();
                    continue
                }
                ga = Cn.call(xt, as)
            } catch (ba) {
                ga = [6, ba],
                Cs = 0
            } finally {
                cs = Ls = 0
            }
        if (ga[0] & 5)
            throw ga[1];
        return {
            value: ga[0] ? ga[1] : void 0,
            done: !0
        }
    }
}
function __spreadArray(xt, Cn, as) {
    if (as || arguments.length === 2)
        for (var cs = 0, Cs = Cn.length, Ls; cs < Cs; cs++)
            (Ls || !(cs in Cn)) && (Ls || (Ls = Array.prototype.slice.call(Cn, 0, cs)),
            Ls[cs] = Cn[cs]);
    return xt.concat(Ls || Array.prototype.slice.call(Cn))
}
typeof SuppressedError == "function" && SuppressedError;
const getTelegramData = () => {
    var xt;
    if (canUseDOM)
        return (xt = window.Telegram) === null || xt === void 0 ? void 0 : xt.WebApp
}
  , getBrowserAppearanceSubscriber = xt => {
    if (!canUseDOM || !window.matchMedia)
        return () => {}
        ;
    const Cn = window.matchMedia("(prefers-color-scheme: dark)")
      , as = () => {
        xt(Cn.matches ? "dark" : "light")
    }
    ;
    return Cn.addEventListener("change", as),
    () => Cn.removeEventListener("change", as)
}
  , getInitialAppearance = () => canUseDOM && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"
  , useAppearance = xt => {
    const {appearance: Cn} = reactExports.useContext(AppRootContext)
      , [as,cs] = reactExports.useState(xt || Cn || getInitialAppearance())
      , Cs = reactExports.useCallback( () => {
        const Ls = getTelegramData();
        Ls && cs(Ls.colorScheme)
    }
    , []);
    return reactExports.useEffect( () => {
        if (xt !== void 0)
            return cs(xt),
            () => {}
            ;
        const Ls = getTelegramData();
        return Ls ? (Ls.onEvent("themeChanged", Cs),
        () => Ls.offEvent("themeChanged", Cs)) : getBrowserAppearanceSubscriber(cs)
    }
    , [xt]),
    as
}
  , getInitialPlatform = () => {
    const xt = getTelegramData();
    return xt && ["ios", "macos"].includes(xt.platform) ? "ios" : "base"
}
  , usePlatform = xt => {
    if (xt !== void 0)
        return xt;
    const Cn = reactExports.useContext(AppRootContext);
    return Cn.isRendered && Cn.platform !== void 0 ? Cn.platform : getInitialPlatform()
}
  , usePortalContainer = xt => {
    if (xt !== void 0)
        return xt;
    const Cn = reactExports.useContext(AppRootContext);
    return Cn.isRendered && Cn.portalContainer !== void 0 ? Cn.portalContainer : reactExports.useRef(null)
}
  , AppRoot = reactExports.forwardRef( (xt, Cn) => {
    var {platform: as, appearance: cs, portalContainer: Cs, children: Ls, className: Vs} = xt
      , Ws = _object_without_properties(xt, ["platform", "appearance", "portalContainer", "children", "className"]);
    const Xs = useAppearance(cs)
      , ga = usePortalContainer(Cs)
      , ba = usePlatform(as)
      , yl = useObjectMemo({
        platform: ba,
        appearance: Xs,
        portalContainer: ga,
        isRendered: !0
    });
    return jsxRuntimeExports.jsx("div", _object_spread_props(_object_spread({
        ref: multipleRef(Cn, ga),
        className: classNames("tgui-6a12827a138e8827", ba === "ios" && "tgui-56dbb42c1dbd5e2b", Xs === "dark" && "tgui-865b921add8ee075", Vs)
    }, Ws), {
        children: jsxRuntimeExports.jsx(AppRootContext.Provider, {
            value: yl,
            children: Ls
        })
    }))
}
);
/**
 * @remix-run/router v1.17.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
    return _extends$1 = Object.assign ? Object.assign.bind() : function(xt) {
        for (var Cn = 1; Cn < arguments.length; Cn++) {
            var as = arguments[Cn];
            for (var cs in as)
                Object.prototype.hasOwnProperty.call(as, cs) && (xt[cs] = as[cs])
        }
        return xt
    }
    ,
    _extends$1.apply(this, arguments)
}
var Action;
(function(xt) {
    xt.Pop = "POP",
    xt.Push = "PUSH",
    xt.Replace = "REPLACE"
}
)(Action || (Action = {}));
const PopStateEventType = "popstate";
function createHashHistory(xt) {
    xt === void 0 && (xt = {});
    function Cn(Cs, Ls) {
        let {pathname: Vs="/", search: Ws="", hash: Xs=""} = parsePath(Cs.location.hash.substr(1));
        return !Vs.startsWith("/") && !Vs.startsWith(".") && (Vs = "/" + Vs),
        createLocation("", {
            pathname: Vs,
            search: Ws,
            hash: Xs
        }, Ls.state && Ls.state.usr || null, Ls.state && Ls.state.key || "default")
    }
    function as(Cs, Ls) {
        let Vs = Cs.document.querySelector("base")
          , Ws = "";
        if (Vs && Vs.getAttribute("href")) {
            let Xs = Cs.location.href
              , ga = Xs.indexOf("#");
            Ws = ga === -1 ? Xs : Xs.slice(0, ga)
        }
        return Ws + "#" + (typeof Ls == "string" ? Ls : createPath(Ls))
    }
    function cs(Cs, Ls) {
        warning$2(Cs.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(Ls) + ")")
    }
    return getUrlBasedHistory(Cn, as, cs, xt)
}
function invariant$1(xt, Cn) {
    if (xt === !1 || xt === null || typeof xt > "u")
        throw new Error(Cn)
}
function warning$2(xt, Cn) {
    if (!xt) {
        typeof console < "u" && console.warn(Cn);
        try {
            throw new Error(Cn)
        } catch {}
    }
}
function createKey() {
    return Math.random().toString(36).substr(2, 8)
}
function getHistoryState(xt, Cn) {
    return {
        usr: xt.state,
        key: xt.key,
        idx: Cn
    }
}
function createLocation(xt, Cn, as, cs) {
    return as === void 0 && (as = null),
    _extends$1({
        pathname: typeof xt == "string" ? xt : xt.pathname,
        search: "",
        hash: ""
    }, typeof Cn == "string" ? parsePath(Cn) : Cn, {
        state: as,
        key: Cn && Cn.key || cs || createKey()
    })
}
function createPath(xt) {
    let {pathname: Cn="/", search: as="", hash: cs=""} = xt;
    return as && as !== "?" && (Cn += as.charAt(0) === "?" ? as : "?" + as),
    cs && cs !== "#" && (Cn += cs.charAt(0) === "#" ? cs : "#" + cs),
    Cn
}
function parsePath(xt) {
    let Cn = {};
    if (xt) {
        let as = xt.indexOf("#");
        as >= 0 && (Cn.hash = xt.substr(as),
        xt = xt.substr(0, as));
        let cs = xt.indexOf("?");
        cs >= 0 && (Cn.search = xt.substr(cs),
        xt = xt.substr(0, cs)),
        xt && (Cn.pathname = xt)
    }
    return Cn
}
function getUrlBasedHistory(xt, Cn, as, cs) {
    cs === void 0 && (cs = {});
    let {window: Cs=document.defaultView, v5Compat: Ls=!1} = cs
      , Vs = Cs.history
      , Ws = Action.Pop
      , Xs = null
      , ga = ba();
    ga == null && (ga = 0,
    Vs.replaceState(_extends$1({}, Vs.state, {
        idx: ga
    }), ""));
    function ba() {
        return (Vs.state || {
            idx: null
        }).idx
    }
    function yl() {
        Ws = Action.Pop;
        let Cl = ba()
          , $l = Cl == null ? null : Cl - ga;
        ga = Cl,
        Xs && Xs({
            action: Ws,
            location: El.location,
            delta: $l
        })
    }
    function xl(Cl, $l) {
        Ws = Action.Push;
        let Sl = createLocation(El.location, Cl, $l);
        as && as(Sl, Cl),
        ga = ba() + 1;
        let Tl = getHistoryState(Sl, ga)
          , Rl = El.createHref(Sl);
        try {
            Vs.pushState(Tl, "", Rl)
        } catch (Il) {
            if (Il instanceof DOMException && Il.name === "DataCloneError")
                throw Il;
            Cs.location.assign(Rl)
        }
        Ls && Xs && Xs({
            action: Ws,
            location: El.location,
            delta: 1
        })
    }
    function wl(Cl, $l) {
        Ws = Action.Replace;
        let Sl = createLocation(El.location, Cl, $l);
        as && as(Sl, Cl),
        ga = ba();
        let Tl = getHistoryState(Sl, ga)
          , Rl = El.createHref(Sl);
        Vs.replaceState(Tl, "", Rl),
        Ls && Xs && Xs({
            action: Ws,
            location: El.location,
            delta: 0
        })
    }
    function _l(Cl) {
        let $l = Cs.location.origin !== "null" ? Cs.location.origin : Cs.location.href
          , Sl = typeof Cl == "string" ? Cl : createPath(Cl);
        return Sl = Sl.replace(/ $/, "%20"),
        invariant$1($l, "No window.location.(origin|href) available to create URL for href: " + Sl),
        new URL(Sl,$l)
    }
    let El = {
        get action() {
            return Ws
        },
        get location() {
            return xt(Cs, Vs)
        },
        listen(Cl) {
            if (Xs)
                throw new Error("A history only accepts one active listener");
            return Cs.addEventListener(PopStateEventType, yl),
            Xs = Cl,
            () => {
                Cs.removeEventListener(PopStateEventType, yl),
                Xs = null
            }
        },
        createHref(Cl) {
            return Cn(Cs, Cl)
        },
        createURL: _l,
        encodeLocation(Cl) {
            let $l = _l(Cl);
            return {
                pathname: $l.pathname,
                search: $l.search,
                hash: $l.hash
            }
        },
        push: xl,
        replace: wl,
        go(Cl) {
            return Vs.go(Cl)
        }
    };
    return El
}
var ResultType;
(function(xt) {
    xt.data = "data",
    xt.deferred = "deferred",
    xt.redirect = "redirect",
    xt.error = "error"
}
)(ResultType || (ResultType = {}));
function matchRoutes(xt, Cn, as) {
    return as === void 0 && (as = "/"),
    matchRoutesImpl(xt, Cn, as)
}
function matchRoutesImpl(xt, Cn, as, cs) {
    let Cs = typeof Cn == "string" ? parsePath(Cn) : Cn
      , Ls = stripBasename(Cs.pathname || "/", as);
    if (Ls == null)
        return null;
    let Vs = flattenRoutes(xt);
    rankRouteBranches(Vs);
    let Ws = null;
    for (let Xs = 0; Ws == null && Xs < Vs.length; ++Xs) {
        let ga = decodePath(Ls);
        Ws = matchRouteBranch(Vs[Xs], ga)
    }
    return Ws
}
function flattenRoutes(xt, Cn, as, cs) {
    Cn === void 0 && (Cn = []),
    as === void 0 && (as = []),
    cs === void 0 && (cs = "");
    let Cs = (Ls, Vs, Ws) => {
        let Xs = {
            relativePath: Ws === void 0 ? Ls.path || "" : Ws,
            caseSensitive: Ls.caseSensitive === !0,
            childrenIndex: Vs,
            route: Ls
        };
        Xs.relativePath.startsWith("/") && (invariant$1(Xs.relativePath.startsWith(cs), 'Absolute route path "' + Xs.relativePath + '" nested under path ' + ('"' + cs + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."),
        Xs.relativePath = Xs.relativePath.slice(cs.length));
        let ga = joinPaths([cs, Xs.relativePath])
          , ba = as.concat(Xs);
        Ls.children && Ls.children.length > 0 && (invariant$1(Ls.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + ga + '".')),
        flattenRoutes(Ls.children, Cn, ba, ga)),
        !(Ls.path == null && !Ls.index) && Cn.push({
            path: ga,
            score: computeScore(ga, Ls.index),
            routesMeta: ba
        })
    }
    ;
    return xt.forEach( (Ls, Vs) => {
        var Ws;
        if (Ls.path === "" || !((Ws = Ls.path) != null && Ws.includes("?")))
            Cs(Ls, Vs);
        else
            for (let Xs of explodeOptionalSegments(Ls.path))
                Cs(Ls, Vs, Xs)
    }
    ),
    Cn
}
function explodeOptionalSegments(xt) {
    let Cn = xt.split("/");
    if (Cn.length === 0)
        return [];
    let[as,...cs] = Cn
      , Cs = as.endsWith("?")
      , Ls = as.replace(/\?$/, "");
    if (cs.length === 0)
        return Cs ? [Ls, ""] : [Ls];
    let Vs = explodeOptionalSegments(cs.join("/"))
      , Ws = [];
    return Ws.push(...Vs.map(Xs => Xs === "" ? Ls : [Ls, Xs].join("/"))),
    Cs && Ws.push(...Vs),
    Ws.map(Xs => xt.startsWith("/") && Xs === "" ? "/" : Xs)
}
function rankRouteBranches(xt) {
    xt.sort( (Cn, as) => Cn.score !== as.score ? as.score - Cn.score : compareIndexes(Cn.routesMeta.map(cs => cs.childrenIndex), as.routesMeta.map(cs => cs.childrenIndex)))
}
const paramRe = /^:[\w-]+$/
  , dynamicSegmentValue = 3
  , indexRouteValue = 2
  , emptySegmentValue = 1
  , staticSegmentValue = 10
  , splatPenalty = -2
  , isSplat = xt => xt === "*";
function computeScore(xt, Cn) {
    let as = xt.split("/")
      , cs = as.length;
    return as.some(isSplat) && (cs += splatPenalty),
    Cn && (cs += indexRouteValue),
    as.filter(Cs => !isSplat(Cs)).reduce( (Cs, Ls) => Cs + (paramRe.test(Ls) ? dynamicSegmentValue : Ls === "" ? emptySegmentValue : staticSegmentValue), cs)
}
function compareIndexes(xt, Cn) {
    return xt.length === Cn.length && xt.slice(0, -1).every( (cs, Cs) => cs === Cn[Cs]) ? xt[xt.length - 1] - Cn[Cn.length - 1] : 0
}
function matchRouteBranch(xt, Cn, as) {
    let {routesMeta: cs} = xt
      , Cs = {}
      , Ls = "/"
      , Vs = [];
    for (let Ws = 0; Ws < cs.length; ++Ws) {
        let Xs = cs[Ws]
          , ga = Ws === cs.length - 1
          , ba = Ls === "/" ? Cn : Cn.slice(Ls.length) || "/"
          , yl = matchPath({
            path: Xs.relativePath,
            caseSensitive: Xs.caseSensitive,
            end: ga
        }, ba)
          , xl = Xs.route;
        if (!yl)
            return null;
        Object.assign(Cs, yl.params),
        Vs.push({
            params: Cs,
            pathname: joinPaths([Ls, yl.pathname]),
            pathnameBase: normalizePathname(joinPaths([Ls, yl.pathnameBase])),
            route: xl
        }),
        yl.pathnameBase !== "/" && (Ls = joinPaths([Ls, yl.pathnameBase]))
    }
    return Vs
}
function matchPath(xt, Cn) {
    typeof xt == "string" && (xt = {
        path: xt,
        caseSensitive: !1,
        end: !0
    });
    let[as,cs] = compilePath(xt.path, xt.caseSensitive, xt.end)
      , Cs = Cn.match(as);
    if (!Cs)
        return null;
    let Ls = Cs[0]
      , Vs = Ls.replace(/(.)\/+$/, "$1")
      , Ws = Cs.slice(1);
    return {
        params: cs.reduce( (ga, ba, yl) => {
            let {paramName: xl, isOptional: wl} = ba;
            if (xl === "*") {
                let El = Ws[yl] || "";
                Vs = Ls.slice(0, Ls.length - El.length).replace(/(.)\/+$/, "$1")
            }
            const _l = Ws[yl];
            return wl && !_l ? ga[xl] = void 0 : ga[xl] = (_l || "").replace(/%2F/g, "/"),
            ga
        }
        , {}),
        pathname: Ls,
        pathnameBase: Vs,
        pattern: xt
    }
}
function compilePath(xt, Cn, as) {
    Cn === void 0 && (Cn = !1),
    as === void 0 && (as = !0),
    warning$2(xt === "*" || !xt.endsWith("*") || xt.endsWith("/*"), 'Route path "' + xt + '" will be treated as if it were ' + ('"' + xt.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + xt.replace(/\*$/, "/*") + '".'));
    let cs = []
      , Cs = "^" + xt.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (Vs, Ws, Xs) => (cs.push({
        paramName: Ws,
        isOptional: Xs != null
    }),
    Xs ? "/?([^\\/]+)?" : "/([^\\/]+)"));
    return xt.endsWith("*") ? (cs.push({
        paramName: "*"
    }),
    Cs += xt === "*" || xt === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : as ? Cs += "\\/*$" : xt !== "" && xt !== "/" && (Cs += "(?:(?=\\/|$))"),
    [new RegExp(Cs,Cn ? void 0 : "i"), cs]
}
function decodePath(xt) {
    try {
        return xt.split("/").map(Cn => decodeURIComponent(Cn).replace(/\//g, "%2F")).join("/")
    } catch (Cn) {
        return warning$2(!1, 'The URL path "' + xt + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + Cn + ").")),
        xt
    }
}
function stripBasename(xt, Cn) {
    if (Cn === "/")
        return xt;
    if (!xt.toLowerCase().startsWith(Cn.toLowerCase()))
        return null;
    let as = Cn.endsWith("/") ? Cn.length - 1 : Cn.length
      , cs = xt.charAt(as);
    return cs && cs !== "/" ? null : xt.slice(as) || "/"
}
function resolvePath(xt, Cn) {
    Cn === void 0 && (Cn = "/");
    let {pathname: as, search: cs="", hash: Cs=""} = typeof xt == "string" ? parsePath(xt) : xt;
    return {
        pathname: as ? as.startsWith("/") ? as : resolvePathname(as, Cn) : Cn,
        search: normalizeSearch(cs),
        hash: normalizeHash(Cs)
    }
}
function resolvePathname(xt, Cn) {
    let as = Cn.replace(/\/+$/, "").split("/");
    return xt.split("/").forEach(Cs => {
        Cs === ".." ? as.length > 1 && as.pop() : Cs !== "." && as.push(Cs)
    }
    ),
    as.length > 1 ? as.join("/") : "/"
}
function getInvalidPathError(xt, Cn, as, cs) {
    return "Cannot include a '" + xt + "' character in a manually specified " + ("`to." + Cn + "` field [" + JSON.stringify(cs) + "].  Please separate it out to the ") + ("`to." + as + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
}
function getPathContributingMatches(xt) {
    return xt.filter( (Cn, as) => as === 0 || Cn.route.path && Cn.route.path.length > 0)
}
function getResolveToMatches(xt, Cn) {
    let as = getPathContributingMatches(xt);
    return Cn ? as.map( (cs, Cs) => Cs === xt.length - 1 ? cs.pathname : cs.pathnameBase) : as.map(cs => cs.pathnameBase)
}
function resolveTo(xt, Cn, as, cs) {
    cs === void 0 && (cs = !1);
    let Cs;
    typeof xt == "string" ? Cs = parsePath(xt) : (Cs = _extends$1({}, xt),
    invariant$1(!Cs.pathname || !Cs.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", Cs)),
    invariant$1(!Cs.pathname || !Cs.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", Cs)),
    invariant$1(!Cs.search || !Cs.search.includes("#"), getInvalidPathError("#", "search", "hash", Cs)));
    let Ls = xt === "" || Cs.pathname === "", Vs = Ls ? "/" : Cs.pathname, Ws;
    if (Vs == null)
        Ws = as;
    else {
        let yl = Cn.length - 1;
        if (!cs && Vs.startsWith("..")) {
            let xl = Vs.split("/");
            for (; xl[0] === ".."; )
                xl.shift(),
                yl -= 1;
            Cs.pathname = xl.join("/")
        }
        Ws = yl >= 0 ? Cn[yl] : "/"
    }
    let Xs = resolvePath(Cs, Ws)
      , ga = Vs && Vs !== "/" && Vs.endsWith("/")
      , ba = (Ls || Vs === ".") && as.endsWith("/");
    return !Xs.pathname.endsWith("/") && (ga || ba) && (Xs.pathname += "/"),
    Xs
}
const joinPaths = xt => xt.join("/").replace(/\/\/+/g, "/")
  , normalizePathname = xt => xt.replace(/\/+$/, "").replace(/^\/*/, "/")
  , normalizeSearch = xt => !xt || xt === "?" ? "" : xt.startsWith("?") ? xt : "?" + xt
  , normalizeHash = xt => !xt || xt === "#" ? "" : xt.startsWith("#") ? xt : "#" + xt;
function isRouteErrorResponse(xt) {
    return xt != null && typeof xt.status == "number" && typeof xt.statusText == "string" && typeof xt.internal == "boolean" && "data"in xt
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.24.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(xt) {
        for (var Cn = 1; Cn < arguments.length; Cn++) {
            var as = arguments[Cn];
            for (var cs in as)
                Object.prototype.hasOwnProperty.call(as, cs) && (xt[cs] = as[cs])
        }
        return xt
    }
    ,
    _extends.apply(this, arguments)
}
const DataRouterContext = reactExports.createContext(null)
  , DataRouterStateContext = reactExports.createContext(null)
  , NavigationContext = reactExports.createContext(null)
  , LocationContext = reactExports.createContext(null)
  , RouteContext = reactExports.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
})
  , RouteErrorContext = reactExports.createContext(null);
function useInRouterContext() {
    return reactExports.useContext(LocationContext) != null
}
function useLocation() {
    return useInRouterContext() || invariant$1(!1),
    reactExports.useContext(LocationContext).location
}
function useIsomorphicLayoutEffect$2(xt) {
    reactExports.useContext(NavigationContext).static || reactExports.useLayoutEffect(xt)
}
function useNavigate() {
    let {isDataRoute: xt} = reactExports.useContext(RouteContext);
    return xt ? useNavigateStable() : useNavigateUnstable()
}
function useNavigateUnstable() {
    useInRouterContext() || invariant$1(!1);
    let xt = reactExports.useContext(DataRouterContext)
      , {basename: Cn, future: as, navigator: cs} = reactExports.useContext(NavigationContext)
      , {matches: Cs} = reactExports.useContext(RouteContext)
      , {pathname: Ls} = useLocation()
      , Vs = JSON.stringify(getResolveToMatches(Cs, as.v7_relativeSplatPath))
      , Ws = reactExports.useRef(!1);
    return useIsomorphicLayoutEffect$2( () => {
        Ws.current = !0
    }
    ),
    reactExports.useCallback(function(ga, ba) {
        if (ba === void 0 && (ba = {}),
        !Ws.current)
            return;
        if (typeof ga == "number") {
            cs.go(ga);
            return
        }
        let yl = resolveTo(ga, JSON.parse(Vs), Ls, ba.relative === "path");
        xt == null && Cn !== "/" && (yl.pathname = yl.pathname === "/" ? Cn : joinPaths([Cn, yl.pathname])),
        (ba.replace ? cs.replace : cs.push)(yl, ba.state, ba)
    }, [Cn, cs, Vs, Ls, xt])
}
function useRoutes(xt, Cn) {
    return useRoutesImpl(xt, Cn)
}
function useRoutesImpl(xt, Cn, as, cs) {
    useInRouterContext() || invariant$1(!1);
    let {navigator: Cs} = reactExports.useContext(NavigationContext)
      , {matches: Ls} = reactExports.useContext(RouteContext)
      , Vs = Ls[Ls.length - 1]
      , Ws = Vs ? Vs.params : {};
    Vs && Vs.pathname;
    let Xs = Vs ? Vs.pathnameBase : "/";
    Vs && Vs.route;
    let ga = useLocation(), ba;
    if (Cn) {
        var yl;
        let Cl = typeof Cn == "string" ? parsePath(Cn) : Cn;
        Xs === "/" || (yl = Cl.pathname) != null && yl.startsWith(Xs) || invariant$1(!1),
        ba = Cl
    } else
        ba = ga;
    let xl = ba.pathname || "/"
      , wl = xl;
    if (Xs !== "/") {
        let Cl = Xs.replace(/^\//, "").split("/");
        wl = "/" + xl.replace(/^\//, "").split("/").slice(Cl.length).join("/")
    }
    let _l = matchRoutes(xt, {
        pathname: wl
    })
      , El = _renderMatches(_l && _l.map(Cl => Object.assign({}, Cl, {
        params: Object.assign({}, Ws, Cl.params),
        pathname: joinPaths([Xs, Cs.encodeLocation ? Cs.encodeLocation(Cl.pathname).pathname : Cl.pathname]),
        pathnameBase: Cl.pathnameBase === "/" ? Xs : joinPaths([Xs, Cs.encodeLocation ? Cs.encodeLocation(Cl.pathnameBase).pathname : Cl.pathnameBase])
    })), Ls, as, cs);
    return Cn && El ? reactExports.createElement(LocationContext.Provider, {
        value: {
            location: _extends({
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default"
            }, ba),
            navigationType: Action.Pop
        }
    }, El) : El
}
function DefaultErrorComponent() {
    let xt = useRouteError()
      , Cn = isRouteErrorResponse(xt) ? xt.status + " " + xt.statusText : xt instanceof Error ? xt.message : JSON.stringify(xt)
      , as = xt instanceof Error ? xt.stack : null
      , Cs = {
        padding: "0.5rem",
        backgroundColor: "rgba(200,200,200, 0.5)"
    };
    return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("h2", null, "Unexpected Application Error!"), reactExports.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, Cn), as ? reactExports.createElement("pre", {
        style: Cs
    }, as) : null, null)
}
const defaultErrorElement = reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
    constructor(Cn) {
        super(Cn),
        this.state = {
            location: Cn.location,
            revalidation: Cn.revalidation,
            error: Cn.error
        }
    }
    static getDerivedStateFromError(Cn) {
        return {
            error: Cn
        }
    }
    static getDerivedStateFromProps(Cn, as) {
        return as.location !== Cn.location || as.revalidation !== "idle" && Cn.revalidation === "idle" ? {
            error: Cn.error,
            location: Cn.location,
            revalidation: Cn.revalidation
        } : {
            error: Cn.error !== void 0 ? Cn.error : as.error,
            location: as.location,
            revalidation: Cn.revalidation || as.revalidation
        }
    }
    componentDidCatch(Cn, as) {
        console.error("React Router caught the following error during render", Cn, as)
    }
    render() {
        return this.state.error !== void 0 ? reactExports.createElement(RouteContext.Provider, {
            value: this.props.routeContext
        }, reactExports.createElement(RouteErrorContext.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
function RenderedRoute(xt) {
    let {routeContext: Cn, match: as, children: cs} = xt
      , Cs = reactExports.useContext(DataRouterContext);
    return Cs && Cs.static && Cs.staticContext && (as.route.errorElement || as.route.ErrorBoundary) && (Cs.staticContext._deepestRenderedBoundaryId = as.route.id),
    reactExports.createElement(RouteContext.Provider, {
        value: Cn
    }, cs)
}
function _renderMatches(xt, Cn, as, cs) {
    var Cs;
    if (Cn === void 0 && (Cn = []),
    as === void 0 && (as = null),
    cs === void 0 && (cs = null),
    xt == null) {
        var Ls;
        if ((Ls = as) != null && Ls.errors)
            xt = as.matches;
        else
            return null
    }
    let Vs = xt
      , Ws = (Cs = as) == null ? void 0 : Cs.errors;
    if (Ws != null) {
        let ba = Vs.findIndex(yl => yl.route.id && (Ws == null ? void 0 : Ws[yl.route.id]) !== void 0);
        ba >= 0 || invariant$1(!1),
        Vs = Vs.slice(0, Math.min(Vs.length, ba + 1))
    }
    let Xs = !1
      , ga = -1;
    if (as && cs && cs.v7_partialHydration)
        for (let ba = 0; ba < Vs.length; ba++) {
            let yl = Vs[ba];
            if ((yl.route.HydrateFallback || yl.route.hydrateFallbackElement) && (ga = ba),
            yl.route.id) {
                let {loaderData: xl, errors: wl} = as
                  , _l = yl.route.loader && xl[yl.route.id] === void 0 && (!wl || wl[yl.route.id] === void 0);
                if (yl.route.lazy || _l) {
                    Xs = !0,
                    ga >= 0 ? Vs = Vs.slice(0, ga + 1) : Vs = [Vs[0]];
                    break
                }
            }
        }
    return Vs.reduceRight( (ba, yl, xl) => {
        let wl, _l = !1, El = null, Cl = null;
        as && (wl = Ws && yl.route.id ? Ws[yl.route.id] : void 0,
        El = yl.route.errorElement || defaultErrorElement,
        Xs && (ga < 0 && xl === 0 ? (warningOnce("route-fallback"),
        _l = !0,
        Cl = null) : ga === xl && (_l = !0,
        Cl = yl.route.hydrateFallbackElement || null)));
        let $l = Cn.concat(Vs.slice(0, xl + 1))
          , Sl = () => {
            let Tl;
            return wl ? Tl = El : _l ? Tl = Cl : yl.route.Component ? Tl = reactExports.createElement(yl.route.Component, null) : yl.route.element ? Tl = yl.route.element : Tl = ba,
            reactExports.createElement(RenderedRoute, {
                match: yl,
                routeContext: {
                    outlet: ba,
                    matches: $l,
                    isDataRoute: as != null
                },
                children: Tl
            })
        }
        ;
        return as && (yl.route.ErrorBoundary || yl.route.errorElement || xl === 0) ? reactExports.createElement(RenderErrorBoundary, {
            location: as.location,
            revalidation: as.revalidation,
            component: El,
            error: wl,
            children: Sl(),
            routeContext: {
                outlet: null,
                matches: $l,
                isDataRoute: !0
            }
        }) : Sl()
    }
    , null)
}
var DataRouterHook$1 = function(xt) {
    return xt.UseBlocker = "useBlocker",
    xt.UseRevalidator = "useRevalidator",
    xt.UseNavigateStable = "useNavigate",
    xt
}(DataRouterHook$1 || {})
  , DataRouterStateHook$1 = function(xt) {
    return xt.UseBlocker = "useBlocker",
    xt.UseLoaderData = "useLoaderData",
    xt.UseActionData = "useActionData",
    xt.UseRouteError = "useRouteError",
    xt.UseNavigation = "useNavigation",
    xt.UseRouteLoaderData = "useRouteLoaderData",
    xt.UseMatches = "useMatches",
    xt.UseRevalidator = "useRevalidator",
    xt.UseNavigateStable = "useNavigate",
    xt.UseRouteId = "useRouteId",
    xt
}(DataRouterStateHook$1 || {});
function useDataRouterContext(xt) {
    let Cn = reactExports.useContext(DataRouterContext);
    return Cn || invariant$1(!1),
    Cn
}
function useDataRouterState(xt) {
    let Cn = reactExports.useContext(DataRouterStateContext);
    return Cn || invariant$1(!1),
    Cn
}
function useRouteContext(xt) {
    let Cn = reactExports.useContext(RouteContext);
    return Cn || invariant$1(!1),
    Cn
}
function useCurrentRouteId(xt) {
    let Cn = useRouteContext()
      , as = Cn.matches[Cn.matches.length - 1];
    return as.route.id || invariant$1(!1),
    as.route.id
}
function useRouteError() {
    var xt;
    let Cn = reactExports.useContext(RouteErrorContext)
      , as = useDataRouterState()
      , cs = useCurrentRouteId();
    return Cn !== void 0 ? Cn : (xt = as.errors) == null ? void 0 : xt[cs]
}
function useNavigateStable() {
    let {router: xt} = useDataRouterContext(DataRouterHook$1.UseNavigateStable)
      , Cn = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable)
      , as = reactExports.useRef(!1);
    return useIsomorphicLayoutEffect$2( () => {
        as.current = !0
    }
    ),
    reactExports.useCallback(function(Cs, Ls) {
        Ls === void 0 && (Ls = {}),
        as.current && (typeof Cs == "number" ? xt.navigate(Cs) : xt.navigate(Cs, _extends({
            fromRouteId: Cn
        }, Ls)))
    }, [xt, Cn])
}
const alreadyWarned = {};
function warningOnce(xt, Cn, as) {
    alreadyWarned[xt] || (alreadyWarned[xt] = !0)
}
function Navigate(xt) {
    let {to: Cn, replace: as, state: cs, relative: Cs} = xt;
    useInRouterContext() || invariant$1(!1);
    let {future: Ls, static: Vs} = reactExports.useContext(NavigationContext)
      , {matches: Ws} = reactExports.useContext(RouteContext)
      , {pathname: Xs} = useLocation()
      , ga = useNavigate()
      , ba = resolveTo(Cn, getResolveToMatches(Ws, Ls.v7_relativeSplatPath), Xs, Cs === "path")
      , yl = JSON.stringify(ba);
    return reactExports.useEffect( () => ga(JSON.parse(yl), {
        replace: as,
        state: cs,
        relative: Cs
    }), [ga, yl, Cs, as, cs]),
    null
}
function Route(xt) {
    invariant$1(!1)
}
function Router(xt) {
    let {basename: Cn="/", children: as=null, location: cs, navigationType: Cs=Action.Pop, navigator: Ls, static: Vs=!1, future: Ws} = xt;
    useInRouterContext() && invariant$1(!1);
    let Xs = Cn.replace(/^\/*/, "/")
      , ga = reactExports.useMemo( () => ({
        basename: Xs,
        navigator: Ls,
        static: Vs,
        future: _extends({
            v7_relativeSplatPath: !1
        }, Ws)
    }), [Xs, Ws, Ls, Vs]);
    typeof cs == "string" && (cs = parsePath(cs));
    let {pathname: ba="/", search: yl="", hash: xl="", state: wl=null, key: _l="default"} = cs
      , El = reactExports.useMemo( () => {
        let Cl = stripBasename(ba, Xs);
        return Cl == null ? null : {
            location: {
                pathname: Cl,
                search: yl,
                hash: xl,
                state: wl,
                key: _l
            },
            navigationType: Cs
        }
    }
    , [Xs, ba, yl, xl, wl, _l, Cs]);
    return El == null ? null : reactExports.createElement(NavigationContext.Provider, {
        value: ga
    }, reactExports.createElement(LocationContext.Provider, {
        children: as,
        value: El
    }))
}
function Routes(xt) {
    let {children: Cn, location: as} = xt;
    return useRoutes(createRoutesFromChildren(Cn), as)
}
new Promise( () => {}
);
function createRoutesFromChildren(xt, Cn) {
    Cn === void 0 && (Cn = []);
    let as = [];
    return reactExports.Children.forEach(xt, (cs, Cs) => {
        if (!reactExports.isValidElement(cs))
            return;
        let Ls = [...Cn, Cs];
        if (cs.type === reactExports.Fragment) {
            as.push.apply(as, createRoutesFromChildren(cs.props.children, Ls));
            return
        }
        cs.type !== Route && invariant$1(!1),
        !cs.props.index || !cs.props.children || invariant$1(!1);
        let Vs = {
            id: cs.props.id || Ls.join("-"),
            caseSensitive: cs.props.caseSensitive,
            element: cs.props.element,
            Component: cs.props.Component,
            index: cs.props.index,
            path: cs.props.path,
            loader: cs.props.loader,
            action: cs.props.action,
            errorElement: cs.props.errorElement,
            ErrorBoundary: cs.props.ErrorBoundary,
            hasErrorBoundary: cs.props.ErrorBoundary != null || cs.props.errorElement != null,
            shouldRevalidate: cs.props.shouldRevalidate,
            handle: cs.props.handle,
            lazy: cs.props.lazy
        };
        cs.props.children && (Vs.children = createRoutesFromChildren(cs.props.children, Ls)),
        as.push(Vs)
    }
    ),
    as
}
/**
 * React Router DOM v6.24.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
const REACT_ROUTER_VERSION = "6";
try {
    window.__reactRouterVersion = REACT_ROUTER_VERSION
} catch {}
const START_TRANSITION = "startTransition"
  , startTransitionImpl = t$6[START_TRANSITION];
function HashRouter(xt) {
    let {basename: Cn, children: as, future: cs, window: Cs} = xt
      , Ls = reactExports.useRef();
    Ls.current == null && (Ls.current = createHashHistory({
        window: Cs,
        v5Compat: !0
    }));
    let Vs = Ls.current
      , [Ws,Xs] = reactExports.useState({
        action: Vs.action,
        location: Vs.location
    })
      , {v7_startTransition: ga} = cs || {}
      , ba = reactExports.useCallback(yl => {
        ga && startTransitionImpl ? startTransitionImpl( () => Xs(yl)) : Xs(yl)
    }
    , [Xs, ga]);
    return reactExports.useLayoutEffect( () => Vs.listen(ba), [Vs, ba]),
    reactExports.createElement(Router, {
        basename: Cn,
        children: as,
        location: Ws.location,
        navigationType: Ws.action,
        navigator: Vs,
        future: cs
    })
}
var DataRouterHook;
(function(xt) {
    xt.UseScrollRestoration = "useScrollRestoration",
    xt.UseSubmit = "useSubmit",
    xt.UseSubmitFetcher = "useSubmitFetcher",
    xt.UseFetcher = "useFetcher",
    xt.useViewTransitionState = "useViewTransitionState"
}
)(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(xt) {
    xt.UseFetcher = "useFetcher",
    xt.UseFetchers = "useFetchers",
    xt.UseScrollRestoration = "useScrollRestoration"
}
)(DataRouterStateHook || (DataRouterStateHook = {}));
const LayoutGroupContext = reactExports.createContext({});
function useConstant(xt) {
    const Cn = reactExports.useRef(null);
    return Cn.current === null && (Cn.current = xt()),
    Cn.current
}
const PresenceContext = reactExports.createContext(null)
  , MotionConfigContext = reactExports.createContext({
    transformPagePoint: xt => xt,
    isStatic: !1,
    reducedMotion: "never"
});
class PopChildMeasure extends reactExports.Component {
    getSnapshotBeforeUpdate(Cn) {
        const as = this.props.childRef.current;
        if (as && Cn.isPresent && !this.props.isPresent) {
            const cs = this.props.sizeRef.current;
            cs.height = as.offsetHeight || 0,
            cs.width = as.offsetWidth || 0,
            cs.top = as.offsetTop,
            cs.left = as.offsetLeft
        }
        return null
    }
    componentDidUpdate() {}
    render() {
        return this.props.children
    }
}
function PopChild({children: xt, isPresent: Cn}) {
    const as = reactExports.useId()
      , cs = reactExports.useRef(null)
      , Cs = reactExports.useRef({
        width: 0,
        height: 0,
        top: 0,
        left: 0
    })
      , {nonce: Ls} = reactExports.useContext(MotionConfigContext);
    return reactExports.useInsertionEffect( () => {
        const {width: Vs, height: Ws, top: Xs, left: ga} = Cs.current;
        if (Cn || !cs.current || !Vs || !Ws)
            return;
        cs.current.dataset.motionPopId = as;
        const ba = document.createElement("style");
        return Ls && (ba.nonce = Ls),
        document.head.appendChild(ba),
        ba.sheet && ba.sheet.insertRule(`
          [data-motion-pop-id="${as}"] {
            position: absolute !important;
            width: ${Vs}px !important;
            height: ${Ws}px !important;
            top: ${Xs}px !important;
            left: ${ga}px !important;
          }
        `),
        () => {
            document.head.removeChild(ba)
        }
    }
    , [Cn]),
    jsxRuntimeExports.jsx(PopChildMeasure, {
        isPresent: Cn,
        childRef: cs,
        sizeRef: Cs,
        children: reactExports.cloneElement(xt, {
            ref: cs
        })
    })
}
const PresenceChild = ({children: xt, initial: Cn, isPresent: as, onExitComplete: cs, custom: Cs, presenceAffectsLayout: Ls, mode: Vs}) => {
    const Ws = useConstant(newChildrenMap)
      , Xs = reactExports.useId()
      , ga = reactExports.useCallback(yl => {
        Ws.set(yl, !0);
        for (const xl of Ws.values())
            if (!xl)
                return;
        cs && cs()
    }
    , [Ws, cs])
      , ba = reactExports.useMemo( () => ({
        id: Xs,
        initial: Cn,
        isPresent: as,
        custom: Cs,
        onExitComplete: ga,
        register: yl => (Ws.set(yl, !1),
        () => Ws.delete(yl))
    }), Ls ? [Math.random(), ga] : [as, ga]);
    return reactExports.useMemo( () => {
        Ws.forEach( (yl, xl) => Ws.set(xl, !1))
    }
    , [as]),
    reactExports.useEffect( () => {
        !as && !Ws.size && cs && cs()
    }
    , [as]),
    Vs === "popLayout" && (xt = jsxRuntimeExports.jsx(PopChild, {
        isPresent: as,
        children: xt
    })),
    jsxRuntimeExports.jsx(PresenceContext.Provider, {
        value: ba,
        children: xt
    })
}
;
function newChildrenMap() {
    return new Map
}
function usePresence(xt=!0) {
    const Cn = reactExports.useContext(PresenceContext);
    if (Cn === null)
        return [!0, null];
    const {isPresent: as, onExitComplete: cs, register: Cs} = Cn
      , Ls = reactExports.useId();
    reactExports.useEffect( () => {
        xt && Cs(Ls)
    }
    , [xt]);
    const Vs = reactExports.useCallback( () => xt && cs && cs(Ls), [Ls, cs, xt]);
    return !as && cs ? [!1, Vs] : [!0]
}
const getChildKey = xt => xt.key || "";
function onlyElements(xt) {
    const Cn = [];
    return reactExports.Children.forEach(xt, as => {
        reactExports.isValidElement(as) && Cn.push(as)
    }
    ),
    Cn
}
const isBrowser$1 = typeof window < "u"
  , useIsomorphicLayoutEffect$1 = isBrowser$1 ? reactExports.useLayoutEffect : reactExports.useEffect
  , AnimatePresence = ({children: xt, custom: Cn, initial: as=!0, onExitComplete: cs, presenceAffectsLayout: Cs=!0, mode: Ls="sync", propagate: Vs=!1}) => {
    const [Ws,Xs] = usePresence(Vs)
      , ga = reactExports.useMemo( () => onlyElements(xt), [xt])
      , ba = Vs && !Ws ? [] : ga.map(getChildKey)
      , yl = reactExports.useRef(!0)
      , xl = reactExports.useRef(ga)
      , wl = useConstant( () => new Map)
      , [_l,El] = reactExports.useState(ga)
      , [Cl,$l] = reactExports.useState(ga);
    useIsomorphicLayoutEffect$1( () => {
        yl.current = !1,
        xl.current = ga;
        for (let Rl = 0; Rl < Cl.length; Rl++) {
            const Il = getChildKey(Cl[Rl]);
            ba.includes(Il) ? wl.delete(Il) : wl.get(Il) !== !0 && wl.set(Il, !1)
        }
    }
    , [Cl, ba.length, ba.join("-")]);
    const Sl = [];
    if (ga !== _l) {
        let Rl = [...ga];
        for (let Il = 0; Il < Cl.length; Il++) {
            const Ml = Cl[Il]
              , Nl = getChildKey(Ml);
            ba.includes(Nl) || (Rl.splice(Il, 0, Ml),
            Sl.push(Ml))
        }
        Ls === "wait" && Sl.length && (Rl = Sl),
        $l(onlyElements(Rl)),
        El(ga);
        return
    }
    const {forceRender: Tl} = reactExports.useContext(LayoutGroupContext);
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: Cl.map(Rl => {
            const Il = getChildKey(Rl)
              , Ml = Vs && !Ws ? !1 : ga === Cl || ba.includes(Il)
              , Nl = () => {
                if (wl.has(Il))
                    wl.set(Il, !0);
                else
                    return;
                let Ll = !0;
                wl.forEach(Fl => {
                    Fl || (Ll = !1)
                }
                ),
                Ll && (Tl == null || Tl(),
                $l(xl.current),
                Vs && (Xs == null || Xs()),
                cs && cs())
            }
            ;
            return jsxRuntimeExports.jsx(PresenceChild, {
                isPresent: Ml,
                initial: !yl.current || as ? void 0 : !1,
                custom: Ml ? void 0 : Cn,
                presenceAffectsLayout: Cs,
                mode: Ls,
                onExitComplete: Ml ? void 0 : Nl,
                children: Rl
            }, Il)
        }
        )
    })
}
  , noop$3 = xt => xt;
let invariant = noop$3;
function memo(xt) {
    let Cn;
    return () => (Cn === void 0 && (Cn = xt()),
    Cn)
}
const progress = (xt, Cn, as) => {
    const cs = Cn - xt;
    return cs === 0 ? 1 : (as - xt) / cs
}
  , secondsToMilliseconds = xt => xt * 1e3
  , millisecondsToSeconds = xt => xt / 1e3
  , MotionGlobalConfig = {
    useManualTiming: !1
};
function createRenderStep(xt) {
    let Cn = new Set
      , as = new Set
      , cs = !1
      , Cs = !1;
    const Ls = new WeakSet;
    let Vs = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    };
    function Ws(ga) {
        Ls.has(ga) && (Xs.schedule(ga),
        xt()),
        ga(Vs)
    }
    const Xs = {
        schedule: (ga, ba=!1, yl=!1) => {
            const wl = yl && cs ? Cn : as;
            return ba && Ls.add(ga),
            wl.has(ga) || wl.add(ga),
            ga
        }
        ,
        cancel: ga => {
            as.delete(ga),
            Ls.delete(ga)
        }
        ,
        process: ga => {
            if (Vs = ga,
            cs) {
                Cs = !0;
                return
            }
            cs = !0,
            [Cn,as] = [as, Cn],
            Cn.forEach(Ws),
            Cn.clear(),
            cs = !1,
            Cs && (Cs = !1,
            Xs.process(ga))
        }
    };
    return Xs
}
const stepsOrder = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"]
  , maxElapsed = 40;
function createRenderBatcher(xt, Cn) {
    let as = !1
      , cs = !0;
    const Cs = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    }
      , Ls = () => as = !0
      , Vs = stepsOrder.reduce( ($l, Sl) => ($l[Sl] = createRenderStep(Ls),
    $l), {})
      , {read: Ws, resolveKeyframes: Xs, update: ga, preRender: ba, render: yl, postRender: xl} = Vs
      , wl = () => {
        const $l = performance.now();
        as = !1,
        Cs.delta = cs ? 1e3 / 60 : Math.max(Math.min($l - Cs.timestamp, maxElapsed), 1),
        Cs.timestamp = $l,
        Cs.isProcessing = !0,
        Ws.process(Cs),
        Xs.process(Cs),
        ga.process(Cs),
        ba.process(Cs),
        yl.process(Cs),
        xl.process(Cs),
        Cs.isProcessing = !1,
        as && Cn && (cs = !1,
        xt(wl))
    }
      , _l = () => {
        as = !0,
        cs = !0,
        Cs.isProcessing || xt(wl)
    }
    ;
    return {
        schedule: stepsOrder.reduce( ($l, Sl) => {
            const Tl = Vs[Sl];
            return $l[Sl] = (Rl, Il=!1, Ml=!1) => (as || _l(),
            Tl.schedule(Rl, Il, Ml)),
            $l
        }
        , {}),
        cancel: $l => {
            for (let Sl = 0; Sl < stepsOrder.length; Sl++)
                Vs[stepsOrder[Sl]].cancel($l)
        }
        ,
        state: Cs,
        steps: Vs
    }
}
const {schedule: frame$1, cancel: cancelFrame, state: frameData, steps: frameSteps} = createRenderBatcher(typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop$3, !0)
  , LazyContext = reactExports.createContext({
    strict: !1
})
  , featureProps = {
    animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
}
  , featureDefinitions = {};
for (const xt in featureProps)
    featureDefinitions[xt] = {
        isEnabled: Cn => featureProps[xt].some(as => !!Cn[as])
    };
function loadFeatures(xt) {
    for (const Cn in xt)
        featureDefinitions[Cn] = {
            ...featureDefinitions[Cn],
            ...xt[Cn]
        }
}
const validMotionProps = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);
function isValidMotionProp(xt) {
    return xt.startsWith("while") || xt.startsWith("drag") && xt !== "draggable" || xt.startsWith("layout") || xt.startsWith("onTap") || xt.startsWith("onPan") || xt.startsWith("onLayout") || validMotionProps.has(xt)
}
let shouldForward = xt => !isValidMotionProp(xt);
function loadExternalIsValidProp(xt) {
    xt && (shouldForward = Cn => Cn.startsWith("on") ? !isValidMotionProp(Cn) : xt(Cn))
}
try {
    loadExternalIsValidProp(require("@emotion/is-prop-valid").default)
} catch {}
function filterProps(xt, Cn, as) {
    const cs = {};
    for (const Cs in xt)
        Cs === "values" && typeof xt.values == "object" || (shouldForward(Cs) || as === !0 && isValidMotionProp(Cs) || !Cn && !isValidMotionProp(Cs) || xt.draggable && Cs.startsWith("onDrag")) && (cs[Cs] = xt[Cs]);
    return cs
}
function createDOMMotionComponentProxy(xt) {
    if (typeof Proxy > "u")
        return xt;
    const Cn = new Map
      , as = (...cs) => xt(...cs);
    return new Proxy(as,{
        get: (cs, Cs) => Cs === "create" ? xt : (Cn.has(Cs) || Cn.set(Cs, xt(Cs)),
        Cn.get(Cs))
    })
}
const MotionContext = reactExports.createContext({});
function isVariantLabel(xt) {
    return typeof xt == "string" || Array.isArray(xt)
}
function isAnimationControls(xt) {
    return xt !== null && typeof xt == "object" && typeof xt.start == "function"
}
const variantPriorityOrder = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]
  , variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(xt) {
    return isAnimationControls(xt.animate) || variantProps.some(Cn => isVariantLabel(xt[Cn]))
}
function isVariantNode(xt) {
    return !!(isControllingVariants(xt) || xt.variants)
}
function getCurrentTreeVariants(xt, Cn) {
    if (isControllingVariants(xt)) {
        const {initial: as, animate: cs} = xt;
        return {
            initial: as === !1 || isVariantLabel(as) ? as : void 0,
            animate: isVariantLabel(cs) ? cs : void 0
        }
    }
    return xt.inherit !== !1 ? Cn : {}
}
function useCreateMotionContext(xt) {
    const {initial: Cn, animate: as} = getCurrentTreeVariants(xt, reactExports.useContext(MotionContext));
    return reactExports.useMemo( () => ({
        initial: Cn,
        animate: as
    }), [variantLabelsAsDependency(Cn), variantLabelsAsDependency(as)])
}
function variantLabelsAsDependency(xt) {
    return Array.isArray(xt) ? xt.join(" ") : xt
}
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function isRefObject(xt) {
    return xt && typeof xt == "object" && Object.prototype.hasOwnProperty.call(xt, "current")
}
function useMotionRef(xt, Cn, as) {
    return reactExports.useCallback(cs => {
        cs && xt.onMount && xt.onMount(cs),
        Cn && (cs ? Cn.mount(cs) : Cn.unmount()),
        as && (typeof as == "function" ? as(cs) : isRefObject(as) && (as.current = cs))
    }
    , [Cn])
}
const camelToDash = xt => xt.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase()
  , optimizedAppearDataId = "framerAppearId"
  , optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId)
  , {schedule: microtask} = createRenderBatcher(queueMicrotask, !1)
  , SwitchLayoutGroupContext = reactExports.createContext({});
function useVisualElement(xt, Cn, as, cs, Cs) {
    var Ls, Vs;
    const {visualElement: Ws} = reactExports.useContext(MotionContext)
      , Xs = reactExports.useContext(LazyContext)
      , ga = reactExports.useContext(PresenceContext)
      , ba = reactExports.useContext(MotionConfigContext).reducedMotion
      , yl = reactExports.useRef(null);
    cs = cs || Xs.renderer,
    !yl.current && cs && (yl.current = cs(xt, {
        visualState: Cn,
        parent: Ws,
        props: as,
        presenceContext: ga,
        blockInitialAnimation: ga ? ga.initial === !1 : !1,
        reducedMotionConfig: ba
    }));
    const xl = yl.current
      , wl = reactExports.useContext(SwitchLayoutGroupContext);
    xl && !xl.projection && Cs && (xl.type === "html" || xl.type === "svg") && createProjectionNode$1(yl.current, as, Cs, wl);
    const _l = reactExports.useRef(!1);
    reactExports.useInsertionEffect( () => {
        xl && _l.current && xl.update(as, ga)
    }
    );
    const El = as[optimizedAppearDataAttribute]
      , Cl = reactExports.useRef(!!El && !(!((Ls = window.MotionHandoffIsComplete) === null || Ls === void 0) && Ls.call(window, El)) && ((Vs = window.MotionHasOptimisedAnimation) === null || Vs === void 0 ? void 0 : Vs.call(window, El)));
    return useIsomorphicLayoutEffect$1( () => {
        xl && (_l.current = !0,
        window.MotionIsMounted = !0,
        xl.updateFeatures(),
        microtask.render(xl.render),
        Cl.current && xl.animationState && xl.animationState.animateChanges())
    }
    ),
    reactExports.useEffect( () => {
        xl && (!Cl.current && xl.animationState && xl.animationState.animateChanges(),
        Cl.current && (queueMicrotask( () => {
            var $l;
            ($l = window.MotionHandoffMarkAsComplete) === null || $l === void 0 || $l.call(window, El)
        }
        ),
        Cl.current = !1))
    }
    ),
    xl
}
function createProjectionNode$1(xt, Cn, as, cs) {
    const {layoutId: Cs, layout: Ls, drag: Vs, dragConstraints: Ws, layoutScroll: Xs, layoutRoot: ga} = Cn;
    xt.projection = new as(xt.latestValues,Cn["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(xt.parent)),
    xt.projection.setOptions({
        layoutId: Cs,
        layout: Ls,
        alwaysMeasureLayout: !!Vs || Ws && isRefObject(Ws),
        visualElement: xt,
        animationType: typeof Ls == "string" ? Ls : "both",
        initialPromotionConfig: cs,
        layoutScroll: Xs,
        layoutRoot: ga
    })
}
function getClosestProjectingNode(xt) {
    if (xt)
        return xt.options.allowProjection !== !1 ? xt.projection : getClosestProjectingNode(xt.parent)
}
function createRendererMotionComponent({preloadedFeatures: xt, createVisualElement: Cn, useRender: as, useVisualState: cs, Component: Cs}) {
    var Ls, Vs;
    xt && loadFeatures(xt);
    function Ws(ga, ba) {
        let yl;
        const xl = {
            ...reactExports.useContext(MotionConfigContext),
            ...ga,
            layoutId: useLayoutId(ga)
        }
          , {isStatic: wl} = xl
          , _l = useCreateMotionContext(ga)
          , El = cs(ga, wl);
        if (!wl && isBrowser$1) {
            useStrictMode();
            const Cl = getProjectionFunctionality(xl);
            yl = Cl.MeasureLayout,
            _l.visualElement = useVisualElement(Cs, El, xl, Cn, Cl.ProjectionNode)
        }
        return jsxRuntimeExports.jsxs(MotionContext.Provider, {
            value: _l,
            children: [yl && _l.visualElement ? jsxRuntimeExports.jsx(yl, {
                visualElement: _l.visualElement,
                ...xl
            }) : null, as(Cs, ga, useMotionRef(El, _l.visualElement, ba), El, wl, _l.visualElement)]
        })
    }
    Ws.displayName = `motion.${typeof Cs == "string" ? Cs : `create(${(Vs = (Ls = Cs.displayName) !== null && Ls !== void 0 ? Ls : Cs.name) !== null && Vs !== void 0 ? Vs : ""})`}`;
    const Xs = reactExports.forwardRef(Ws);
    return Xs[motionComponentSymbol] = Cs,
    Xs
}
function useLayoutId({layoutId: xt}) {
    const Cn = reactExports.useContext(LayoutGroupContext).id;
    return Cn && xt !== void 0 ? Cn + "-" + xt : xt
}
function useStrictMode(xt, Cn) {
    reactExports.useContext(LazyContext).strict
}
function getProjectionFunctionality(xt) {
    const {drag: Cn, layout: as} = featureDefinitions;
    if (!Cn && !as)
        return {};
    const cs = {
        ...Cn,
        ...as
    };
    return {
        MeasureLayout: Cn != null && Cn.isEnabled(xt) || as != null && as.isEnabled(xt) ? cs.MeasureLayout : void 0,
        ProjectionNode: cs.ProjectionNode
    }
}
const lowercaseSVGElements = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
function isSVGComponent(xt) {
    return typeof xt != "string" || xt.includes("-") ? !1 : !!(lowercaseSVGElements.indexOf(xt) > -1 || /[A-Z]/u.test(xt))
}
function getValueState(xt) {
    const Cn = [{}, {}];
    return xt == null || xt.values.forEach( (as, cs) => {
        Cn[0][cs] = as.get(),
        Cn[1][cs] = as.getVelocity()
    }
    ),
    Cn
}
function resolveVariantFromProps(xt, Cn, as, cs) {
    if (typeof Cn == "function") {
        const [Cs,Ls] = getValueState(cs);
        Cn = Cn(as !== void 0 ? as : xt.custom, Cs, Ls)
    }
    if (typeof Cn == "string" && (Cn = xt.variants && xt.variants[Cn]),
    typeof Cn == "function") {
        const [Cs,Ls] = getValueState(cs);
        Cn = Cn(as !== void 0 ? as : xt.custom, Cs, Ls)
    }
    return Cn
}
const isKeyframesTarget = xt => Array.isArray(xt)
  , isCustomValue = xt => !!(xt && typeof xt == "object" && xt.mix && xt.toValue)
  , resolveFinalValueInKeyframes = xt => isKeyframesTarget(xt) ? xt[xt.length - 1] || 0 : xt
  , isMotionValue = xt => !!(xt && xt.getVelocity);
function resolveMotionValue(xt) {
    const Cn = isMotionValue(xt) ? xt.get() : xt;
    return isCustomValue(Cn) ? Cn.toValue() : Cn
}
function makeState({scrapeMotionValuesFromProps: xt, createRenderState: Cn, onUpdate: as}, cs, Cs, Ls) {
    const Vs = {
        latestValues: makeLatestValues(cs, Cs, Ls, xt),
        renderState: Cn()
    };
    return as && (Vs.onMount = Ws => as({
        props: cs,
        current: Ws,
        ...Vs
    }),
    Vs.onUpdate = Ws => as(Ws)),
    Vs
}
const makeUseVisualState = xt => (Cn, as) => {
    const cs = reactExports.useContext(MotionContext)
      , Cs = reactExports.useContext(PresenceContext)
      , Ls = () => makeState(xt, Cn, cs, Cs);
    return as ? Ls() : useConstant(Ls)
}
;
function makeLatestValues(xt, Cn, as, cs) {
    const Cs = {}
      , Ls = cs(xt, {});
    for (const xl in Ls)
        Cs[xl] = resolveMotionValue(Ls[xl]);
    let {initial: Vs, animate: Ws} = xt;
    const Xs = isControllingVariants(xt)
      , ga = isVariantNode(xt);
    Cn && ga && !Xs && xt.inherit !== !1 && (Vs === void 0 && (Vs = Cn.initial),
    Ws === void 0 && (Ws = Cn.animate));
    let ba = as ? as.initial === !1 : !1;
    ba = ba || Vs === !1;
    const yl = ba ? Ws : Vs;
    if (yl && typeof yl != "boolean" && !isAnimationControls(yl)) {
        const xl = Array.isArray(yl) ? yl : [yl];
        for (let wl = 0; wl < xl.length; wl++) {
            const _l = resolveVariantFromProps(xt, xl[wl]);
            if (_l) {
                const {transitionEnd: El, transition: Cl, ...$l} = _l;
                for (const Sl in $l) {
                    let Tl = $l[Sl];
                    if (Array.isArray(Tl)) {
                        const Rl = ba ? Tl.length - 1 : 0;
                        Tl = Tl[Rl]
                    }
                    Tl !== null && (Cs[Sl] = Tl)
                }
                for (const Sl in El)
                    Cs[Sl] = El[Sl]
            }
        }
    }
    return Cs
}
const transformPropOrder = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
  , transformProps = new Set(transformPropOrder)
  , checkStringStartsWith = xt => Cn => typeof Cn == "string" && Cn.startsWith(xt)
  , isCSSVariableName = checkStringStartsWith("--")
  , startsAsVariableToken = checkStringStartsWith("var(--")
  , isCSSVariableToken = xt => startsAsVariableToken(xt) ? singleCssVariableRegex.test(xt.split("/*")[0].trim()) : !1
  , singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu
  , getValueAsType = (xt, Cn) => Cn && typeof xt == "number" ? Cn.transform(xt) : xt
  , clamp$1 = (xt, Cn, as) => as > Cn ? Cn : as < xt ? xt : as
  , number$1 = {
    test: xt => typeof xt == "number",
    parse: parseFloat,
    transform: xt => xt
}
  , alpha = {
    ...number$1,
    transform: xt => clamp$1(0, 1, xt)
}
  , scale = {
    ...number$1,
    default: 1
}
  , createUnitType = xt => ({
    test: Cn => typeof Cn == "string" && Cn.endsWith(xt) && Cn.split(" ").length === 1,
    parse: parseFloat,
    transform: Cn => `${Cn}${xt}`
})
  , degrees = createUnitType("deg")
  , percent = createUnitType("%")
  , px = createUnitType("px")
  , vh = createUnitType("vh")
  , vw = createUnitType("vw")
  , progressPercentage = {
    ...percent,
    parse: xt => percent.parse(xt) / 100,
    transform: xt => percent.transform(xt * 100)
}
  , browserNumberValueTypes = {
    borderWidth: px,
    borderTopWidth: px,
    borderRightWidth: px,
    borderBottomWidth: px,
    borderLeftWidth: px,
    borderRadius: px,
    radius: px,
    borderTopLeftRadius: px,
    borderTopRightRadius: px,
    borderBottomRightRadius: px,
    borderBottomLeftRadius: px,
    width: px,
    maxWidth: px,
    height: px,
    maxHeight: px,
    top: px,
    right: px,
    bottom: px,
    left: px,
    padding: px,
    paddingTop: px,
    paddingRight: px,
    paddingBottom: px,
    paddingLeft: px,
    margin: px,
    marginTop: px,
    marginRight: px,
    marginBottom: px,
    marginLeft: px,
    backgroundPositionX: px,
    backgroundPositionY: px
}
  , transformValueTypes = {
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px,
    translateX: px,
    translateY: px,
    translateZ: px,
    x: px,
    y: px,
    z: px,
    perspective: px,
    transformPerspective: px,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px
}
  , int = {
    ...number$1,
    transform: Math.round
}
  , numberValueTypes = {
    ...browserNumberValueTypes,
    ...transformValueTypes,
    zIndex: int,
    size: px,
    fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int
}
  , translateAlias = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
}
  , numTransforms = transformPropOrder.length;
function buildTransform(xt, Cn, as) {
    let cs = ""
      , Cs = !0;
    for (let Ls = 0; Ls < numTransforms; Ls++) {
        const Vs = transformPropOrder[Ls]
          , Ws = xt[Vs];
        if (Ws === void 0)
            continue;
        let Xs = !0;
        if (typeof Ws == "number" ? Xs = Ws === (Vs.startsWith("scale") ? 1 : 0) : Xs = parseFloat(Ws) === 0,
        !Xs || as) {
            const ga = getValueAsType(Ws, numberValueTypes[Vs]);
            if (!Xs) {
                Cs = !1;
                const ba = translateAlias[Vs] || Vs;
                cs += `${ba}(${ga}) `
            }
            as && (Cn[Vs] = ga)
        }
    }
    return cs = cs.trim(),
    as ? cs = as(Cn, Cs ? "" : cs) : Cs && (cs = "none"),
    cs
}
function buildHTMLStyles(xt, Cn, as) {
    const {style: cs, vars: Cs, transformOrigin: Ls} = xt;
    let Vs = !1
      , Ws = !1;
    for (const Xs in Cn) {
        const ga = Cn[Xs];
        if (transformProps.has(Xs)) {
            Vs = !0;
            continue
        } else if (isCSSVariableName(Xs)) {
            Cs[Xs] = ga;
            continue
        } else {
            const ba = getValueAsType(ga, numberValueTypes[Xs]);
            Xs.startsWith("origin") ? (Ws = !0,
            Ls[Xs] = ba) : cs[Xs] = ba
        }
    }
    if (Cn.transform || (Vs || as ? cs.transform = buildTransform(Cn, xt.transform, as) : cs.transform && (cs.transform = "none")),
    Ws) {
        const {originX: Xs="50%", originY: ga="50%", originZ: ba=0} = Ls;
        cs.transformOrigin = `${Xs} ${ga} ${ba}`
    }
}
const dashKeys = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
}
  , camelKeys = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
};
function buildSVGPath(xt, Cn, as=1, cs=0, Cs=!0) {
    xt.pathLength = 1;
    const Ls = Cs ? dashKeys : camelKeys;
    xt[Ls.offset] = px.transform(-cs);
    const Vs = px.transform(Cn)
      , Ws = px.transform(as);
    xt[Ls.array] = `${Vs} ${Ws}`
}
function calcOrigin$1(xt, Cn, as) {
    return typeof xt == "string" ? xt : px.transform(Cn + as * xt)
}
function calcSVGTransformOrigin(xt, Cn, as) {
    const cs = calcOrigin$1(Cn, xt.x, xt.width)
      , Cs = calcOrigin$1(as, xt.y, xt.height);
    return `${cs} ${Cs}`
}
function buildSVGAttrs(xt, {attrX: Cn, attrY: as, attrScale: cs, originX: Cs, originY: Ls, pathLength: Vs, pathSpacing: Ws=1, pathOffset: Xs=0, ...ga}, ba, yl) {
    if (buildHTMLStyles(xt, ga, yl),
    ba) {
        xt.style.viewBox && (xt.attrs.viewBox = xt.style.viewBox);
        return
    }
    xt.attrs = xt.style,
    xt.style = {};
    const {attrs: xl, style: wl, dimensions: _l} = xt;
    xl.transform && (_l && (wl.transform = xl.transform),
    delete xl.transform),
    _l && (Cs !== void 0 || Ls !== void 0 || wl.transform) && (wl.transformOrigin = calcSVGTransformOrigin(_l, Cs !== void 0 ? Cs : .5, Ls !== void 0 ? Ls : .5)),
    Cn !== void 0 && (xl.x = Cn),
    as !== void 0 && (xl.y = as),
    cs !== void 0 && (xl.scale = cs),
    Vs !== void 0 && buildSVGPath(xl, Vs, Ws, Xs, !1)
}
const createHtmlRenderState = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
})
  , createSvgRenderState = () => ({
    ...createHtmlRenderState(),
    attrs: {}
})
  , isSVGTag = xt => typeof xt == "string" && xt.toLowerCase() === "svg";
function renderHTML(xt, {style: Cn, vars: as}, cs, Cs) {
    Object.assign(xt.style, Cn, Cs && Cs.getProjectionStyles(cs));
    for (const Ls in as)
        xt.style.setProperty(Ls, as[Ls])
}
const camelCaseAttributes = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
function renderSVG(xt, Cn, as, cs) {
    renderHTML(xt, Cn, void 0, cs);
    for (const Cs in Cn.attrs)
        xt.setAttribute(camelCaseAttributes.has(Cs) ? Cs : camelToDash(Cs), Cn.attrs[Cs])
}
const scaleCorrectors = {};
function addScaleCorrector(xt) {
    Object.assign(scaleCorrectors, xt)
}
function isForcedMotionValue(xt, {layout: Cn, layoutId: as}) {
    return transformProps.has(xt) || xt.startsWith("origin") || (Cn || as !== void 0) && (!!scaleCorrectors[xt] || xt === "opacity")
}
function scrapeMotionValuesFromProps$1(xt, Cn, as) {
    var cs;
    const {style: Cs} = xt
      , Ls = {};
    for (const Vs in Cs)
        (isMotionValue(Cs[Vs]) || Cn.style && isMotionValue(Cn.style[Vs]) || isForcedMotionValue(Vs, xt) || ((cs = as == null ? void 0 : as.getValue(Vs)) === null || cs === void 0 ? void 0 : cs.liveStyle) !== void 0) && (Ls[Vs] = Cs[Vs]);
    return Ls
}
function scrapeMotionValuesFromProps(xt, Cn, as) {
    const cs = scrapeMotionValuesFromProps$1(xt, Cn, as);
    for (const Cs in xt)
        if (isMotionValue(xt[Cs]) || isMotionValue(Cn[Cs])) {
            const Ls = transformPropOrder.indexOf(Cs) !== -1 ? "attr" + Cs.charAt(0).toUpperCase() + Cs.substring(1) : Cs;
            cs[Ls] = xt[Cs]
        }
    return cs
}
function updateSVGDimensions(xt, Cn) {
    try {
        Cn.dimensions = typeof xt.getBBox == "function" ? xt.getBBox() : xt.getBoundingClientRect()
    } catch {
        Cn.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }
    }
}
const layoutProps = ["x", "y", "width", "height", "cx", "cy", "r"]
  , svgMotionConfig = {
    useVisualState: makeUseVisualState({
        scrapeMotionValuesFromProps,
        createRenderState: createSvgRenderState,
        onUpdate: ({props: xt, prevProps: Cn, current: as, renderState: cs, latestValues: Cs}) => {
            if (!as)
                return;
            let Ls = !!xt.drag;
            if (!Ls) {
                for (const Ws in Cs)
                    if (transformProps.has(Ws)) {
                        Ls = !0;
                        break
                    }
            }
            if (!Ls)
                return;
            let Vs = !Cn;
            if (Cn)
                for (let Ws = 0; Ws < layoutProps.length; Ws++) {
                    const Xs = layoutProps[Ws];
                    xt[Xs] !== Cn[Xs] && (Vs = !0)
                }
            Vs && frame$1.read( () => {
                updateSVGDimensions(as, cs),
                frame$1.render( () => {
                    buildSVGAttrs(cs, Cs, isSVGTag(as.tagName), xt.transformTemplate),
                    renderSVG(as, cs)
                }
                )
            }
            )
        }
    })
}
  , htmlMotionConfig = {
    useVisualState: makeUseVisualState({
        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
        createRenderState: createHtmlRenderState
    })
};
function copyRawValuesOnly(xt, Cn, as) {
    for (const cs in Cn)
        !isMotionValue(Cn[cs]) && !isForcedMotionValue(cs, as) && (xt[cs] = Cn[cs])
}
function useInitialMotionValues({transformTemplate: xt}, Cn) {
    return reactExports.useMemo( () => {
        const as = createHtmlRenderState();
        return buildHTMLStyles(as, Cn, xt),
        Object.assign({}, as.vars, as.style)
    }
    , [Cn])
}
function useStyle(xt, Cn) {
    const as = xt.style || {}
      , cs = {};
    return copyRawValuesOnly(cs, as, xt),
    Object.assign(cs, useInitialMotionValues(xt, Cn)),
    cs
}
function useHTMLProps(xt, Cn) {
    const as = {}
      , cs = useStyle(xt, Cn);
    return xt.drag && xt.dragListener !== !1 && (as.draggable = !1,
    cs.userSelect = cs.WebkitUserSelect = cs.WebkitTouchCallout = "none",
    cs.touchAction = xt.drag === !0 ? "none" : `pan-${xt.drag === "x" ? "y" : "x"}`),
    xt.tabIndex === void 0 && (xt.onTap || xt.onTapStart || xt.whileTap) && (as.tabIndex = 0),
    as.style = cs,
    as
}
function useSVGProps(xt, Cn, as, cs) {
    const Cs = reactExports.useMemo( () => {
        const Ls = createSvgRenderState();
        return buildSVGAttrs(Ls, Cn, isSVGTag(cs), xt.transformTemplate),
        {
            ...Ls.attrs,
            style: {
                ...Ls.style
            }
        }
    }
    , [Cn]);
    if (xt.style) {
        const Ls = {};
        copyRawValuesOnly(Ls, xt.style, xt),
        Cs.style = {
            ...Ls,
            ...Cs.style
        }
    }
    return Cs
}
function createUseRender(xt=!1) {
    return (as, cs, Cs, {latestValues: Ls}, Vs) => {
        const Xs = (isSVGComponent(as) ? useSVGProps : useHTMLProps)(cs, Ls, Vs, as)
          , ga = filterProps(cs, typeof as == "string", xt)
          , ba = as !== reactExports.Fragment ? {
            ...ga,
            ...Xs,
            ref: Cs
        } : {}
          , {children: yl} = cs
          , xl = reactExports.useMemo( () => isMotionValue(yl) ? yl.get() : yl, [yl]);
        return reactExports.createElement(as, {
            ...ba,
            children: xl
        })
    }
}
function createMotionComponentFactory(xt, Cn) {
    return function(cs, {forwardMotionProps: Cs}={
        forwardMotionProps: !1
    }) {
        const Vs = {
            ...isSVGComponent(cs) ? svgMotionConfig : htmlMotionConfig,
            preloadedFeatures: xt,
            useRender: createUseRender(Cs),
            createVisualElement: Cn,
            Component: cs
        };
        return createRendererMotionComponent(Vs)
    }
}
function shallowCompare(xt, Cn) {
    if (!Array.isArray(Cn))
        return !1;
    const as = Cn.length;
    if (as !== xt.length)
        return !1;
    for (let cs = 0; cs < as; cs++)
        if (Cn[cs] !== xt[cs])
            return !1;
    return !0
}
function resolveVariant(xt, Cn, as) {
    const cs = xt.getProps();
    return resolveVariantFromProps(cs, Cn, as !== void 0 ? as : cs.custom, xt)
}
const supportsScrollTimeline = memo( () => window.ScrollTimeline !== void 0);
class BaseGroupPlaybackControls {
    constructor(Cn) {
        this.stop = () => this.runAll("stop"),
        this.animations = Cn.filter(Boolean)
    }
    get finished() {
        return Promise.all(this.animations.map(Cn => "finished"in Cn ? Cn.finished : Cn))
    }
    getAll(Cn) {
        return this.animations[0][Cn]
    }
    setAll(Cn, as) {
        for (let cs = 0; cs < this.animations.length; cs++)
            this.animations[cs][Cn] = as
    }
    attachTimeline(Cn, as) {
        const cs = this.animations.map(Cs => {
            if (supportsScrollTimeline() && Cs.attachTimeline)
                return Cs.attachTimeline(Cn);
            if (typeof as == "function")
                return as(Cs)
        }
        );
        return () => {
            cs.forEach( (Cs, Ls) => {
                Cs && Cs(),
                this.animations[Ls].stop()
            }
            )
        }
    }
    get time() {
        return this.getAll("time")
    }
    set time(Cn) {
        this.setAll("time", Cn)
    }
    get speed() {
        return this.getAll("speed")
    }
    set speed(Cn) {
        this.setAll("speed", Cn)
    }
    get startTime() {
        return this.getAll("startTime")
    }
    get duration() {
        let Cn = 0;
        for (let as = 0; as < this.animations.length; as++)
            Cn = Math.max(Cn, this.animations[as].duration);
        return Cn
    }
    runAll(Cn) {
        this.animations.forEach(as => as[Cn]())
    }
    flatten() {
        this.runAll("flatten")
    }
    play() {
        this.runAll("play")
    }
    pause() {
        this.runAll("pause")
    }
    cancel() {
        this.runAll("cancel")
    }
    complete() {
        this.runAll("complete")
    }
}
class GroupPlaybackControls extends BaseGroupPlaybackControls {
    then(Cn, as) {
        return Promise.all(this.animations).then(Cn).catch(as)
    }
}
function getValueTransition(xt, Cn) {
    return xt ? xt[Cn] || xt.default || xt : void 0
}
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(xt) {
    let Cn = 0;
    const as = 50;
    let cs = xt.next(Cn);
    for (; !cs.done && Cn < maxGeneratorDuration; )
        Cn += as,
        cs = xt.next(Cn);
    return Cn >= maxGeneratorDuration ? 1 / 0 : Cn
}
function isGenerator(xt) {
    return typeof xt == "function"
}
function attachTimeline(xt, Cn) {
    xt.timeline = Cn,
    xt.onfinish = null
}
const isBezierDefinition = xt => Array.isArray(xt) && typeof xt[0] == "number"
  , supportsFlags = {
    linearEasing: void 0
};
function memoSupports(xt, Cn) {
    const as = memo(xt);
    return () => {
        var cs;
        return (cs = supportsFlags[Cn]) !== null && cs !== void 0 ? cs : as()
    }
}
const supportsLinearEasing = memoSupports( () => {
    try {
        document.createElement("div").animate({
            opacity: 0
        }, {
            easing: "linear(0, 1)"
        })
    } catch {
        return !1
    }
    return !0
}
, "linearEasing")
  , generateLinearEasing = (xt, Cn, as=10) => {
    let cs = "";
    const Cs = Math.max(Math.round(Cn / as), 2);
    for (let Ls = 0; Ls < Cs; Ls++)
        cs += xt(progress(0, Cs - 1, Ls)) + ", ";
    return `linear(${cs.substring(0, cs.length - 2)})`
}
;
function isWaapiSupportedEasing(xt) {
    return !!(typeof xt == "function" && supportsLinearEasing() || !xt || typeof xt == "string" && (xt in supportedWaapiEasing || supportsLinearEasing()) || isBezierDefinition(xt) || Array.isArray(xt) && xt.every(isWaapiSupportedEasing))
}
const cubicBezierAsString = ([xt,Cn,as,cs]) => `cubic-bezier(${xt}, ${Cn}, ${as}, ${cs})`
  , supportedWaapiEasing = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: cubicBezierAsString([0, .65, .55, 1]),
    circOut: cubicBezierAsString([.55, 0, 1, .45]),
    backIn: cubicBezierAsString([.31, .01, .66, -.59]),
    backOut: cubicBezierAsString([.33, 1.53, .69, .99])
};
function mapEasingToNativeEasing(xt, Cn) {
    if (xt)
        return typeof xt == "function" && supportsLinearEasing() ? generateLinearEasing(xt, Cn) : isBezierDefinition(xt) ? cubicBezierAsString(xt) : Array.isArray(xt) ? xt.map(as => mapEasingToNativeEasing(as, Cn) || supportedWaapiEasing.easeOut) : supportedWaapiEasing[xt]
}
const isDragging = {
    x: !1,
    y: !1
};
function isDragActive() {
    return isDragging.x || isDragging.y
}
function resolveElements(xt, Cn, as) {
    var cs;
    if (xt instanceof Element)
        return [xt];
    if (typeof xt == "string") {
        let Cs = document;
        const Ls = (cs = void 0) !== null && cs !== void 0 ? cs : Cs.querySelectorAll(xt);
        return Ls ? Array.from(Ls) : []
    }
    return Array.from(xt)
}
function setupGesture$1(xt, Cn) {
    const as = resolveElements(xt)
      , cs = new AbortController
      , Cs = {
        passive: !0,
        ...Cn,
        signal: cs.signal
    };
    return [as, Cs, () => cs.abort()]
}
function filterEvents$1(xt) {
    return Cn => {
        Cn.pointerType === "touch" || isDragActive() || xt(Cn)
    }
}
function hover(xt, Cn, as={}) {
    const [cs,Cs,Ls] = setupGesture$1(xt, as)
      , Vs = filterEvents$1(Ws => {
        const {target: Xs} = Ws
          , ga = Cn(Ws);
        if (typeof ga != "function" || !Xs)
            return;
        const ba = filterEvents$1(yl => {
            ga(yl),
            Xs.removeEventListener("pointerleave", ba)
        }
        );
        Xs.addEventListener("pointerleave", ba, Cs)
    }
    );
    return cs.forEach(Ws => {
        Ws.addEventListener("pointerenter", Vs, Cs)
    }
    ),
    Ls
}
const isNodeOrChild = (xt, Cn) => Cn ? xt === Cn ? !0 : isNodeOrChild(xt, Cn.parentElement) : !1
  , isPrimaryPointer = xt => xt.pointerType === "mouse" ? typeof xt.button != "number" || xt.button <= 0 : xt.isPrimary !== !1
  , focusableElements = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);
function isElementKeyboardAccessible(xt) {
    return focusableElements.has(xt.tagName) || xt.tabIndex !== -1
}
const isPressing = new WeakSet;
function filterEvents(xt) {
    return Cn => {
        Cn.key === "Enter" && xt(Cn)
    }
}
function firePointerEvent(xt, Cn) {
    xt.dispatchEvent(new PointerEvent("pointer" + Cn,{
        isPrimary: !0,
        bubbles: !0
    }))
}
const enableKeyboardPress = (xt, Cn) => {
    const as = xt.currentTarget;
    if (!as)
        return;
    const cs = filterEvents( () => {
        if (isPressing.has(as))
            return;
        firePointerEvent(as, "down");
        const Cs = filterEvents( () => {
            firePointerEvent(as, "up")
        }
        )
          , Ls = () => firePointerEvent(as, "cancel");
        as.addEventListener("keyup", Cs, Cn),
        as.addEventListener("blur", Ls, Cn)
    }
    );
    as.addEventListener("keydown", cs, Cn),
    as.addEventListener("blur", () => as.removeEventListener("keydown", cs), Cn)
}
;
function isValidPressEvent(xt) {
    return isPrimaryPointer(xt) && !isDragActive()
}
function press(xt, Cn, as={}) {
    const [cs,Cs,Ls] = setupGesture$1(xt, as)
      , Vs = Ws => {
        const Xs = Ws.currentTarget;
        if (!isValidPressEvent(Ws) || isPressing.has(Xs))
            return;
        isPressing.add(Xs);
        const ga = Cn(Ws)
          , ba = (wl, _l) => {
            window.removeEventListener("pointerup", yl),
            window.removeEventListener("pointercancel", xl),
            !(!isValidPressEvent(wl) || !isPressing.has(Xs)) && (isPressing.delete(Xs),
            typeof ga == "function" && ga(wl, {
                success: _l
            }))
        }
          , yl = wl => {
            ba(wl, as.useGlobalTarget || isNodeOrChild(Xs, wl.target))
        }
          , xl = wl => {
            ba(wl, !1)
        }
        ;
        window.addEventListener("pointerup", yl, Cs),
        window.addEventListener("pointercancel", xl, Cs)
    }
    ;
    return cs.forEach(Ws => {
        !isElementKeyboardAccessible(Ws) && Ws.getAttribute("tabindex") === null && (Ws.tabIndex = 0),
        (as.useGlobalTarget ? window : Ws).addEventListener("pointerdown", Vs, Cs),
        Ws.addEventListener("focus", ga => enableKeyboardPress(ga, Cs), Cs)
    }
    ),
    Ls
}
function setDragLock(xt) {
    return xt === "x" || xt === "y" ? isDragging[xt] ? null : (isDragging[xt] = !0,
    () => {
        isDragging[xt] = !1
    }
    ) : isDragging.x || isDragging.y ? null : (isDragging.x = isDragging.y = !0,
    () => {
        isDragging.x = isDragging.y = !1
    }
    )
}
const positionalKeys = new Set(["width", "height", "top", "left", "right", "bottom", ...transformPropOrder]);
let now;
function clearTime() {
    now = void 0
}
const time = {
    now: () => (now === void 0 && time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now()),
    now),
    set: xt => {
        now = xt,
        queueMicrotask(clearTime)
    }
};
function addUniqueItem(xt, Cn) {
    xt.indexOf(Cn) === -1 && xt.push(Cn)
}
function removeItem(xt, Cn) {
    const as = xt.indexOf(Cn);
    as > -1 && xt.splice(as, 1)
}
class SubscriptionManager {
    constructor() {
        this.subscriptions = []
    }
    add(Cn) {
        return addUniqueItem(this.subscriptions, Cn),
        () => removeItem(this.subscriptions, Cn)
    }
    notify(Cn, as, cs) {
        const Cs = this.subscriptions.length;
        if (Cs)
            if (Cs === 1)
                this.subscriptions[0](Cn, as, cs);
            else
                for (let Ls = 0; Ls < Cs; Ls++) {
                    const Vs = this.subscriptions[Ls];
                    Vs && Vs(Cn, as, cs)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}
function velocityPerSecond(xt, Cn) {
    return Cn ? xt * (1e3 / Cn) : 0
}
const MAX_VELOCITY_DELTA = 30
  , isFloat = xt => !isNaN(parseFloat(xt));
class MotionValue {
    constructor(Cn, as={}) {
        this.version = "11.18.2",
        this.canTrackVelocity = null,
        this.events = {},
        this.updateAndNotify = (cs, Cs=!0) => {
            const Ls = time.now();
            this.updatedAt !== Ls && this.setPrevFrameValue(),
            this.prev = this.current,
            this.setCurrent(cs),
            this.current !== this.prev && this.events.change && this.events.change.notify(this.current),
            Cs && this.events.renderRequest && this.events.renderRequest.notify(this.current)
        }
        ,
        this.hasAnimated = !1,
        this.setCurrent(Cn),
        this.owner = as.owner
    }
    setCurrent(Cn) {
        this.current = Cn,
        this.updatedAt = time.now(),
        this.canTrackVelocity === null && Cn !== void 0 && (this.canTrackVelocity = isFloat(this.current))
    }
    setPrevFrameValue(Cn=this.current) {
        this.prevFrameValue = Cn,
        this.prevUpdatedAt = this.updatedAt
    }
    onChange(Cn) {
        return this.on("change", Cn)
    }
    on(Cn, as) {
        this.events[Cn] || (this.events[Cn] = new SubscriptionManager);
        const cs = this.events[Cn].add(as);
        return Cn === "change" ? () => {
            cs(),
            frame$1.read( () => {
                this.events.change.getSize() || this.stop()
            }
            )
        }
        : cs
    }
    clearListeners() {
        for (const Cn in this.events)
            this.events[Cn].clear()
    }
    attach(Cn, as) {
        this.passiveEffect = Cn,
        this.stopPassiveEffect = as
    }
    set(Cn, as=!0) {
        !as || !this.passiveEffect ? this.updateAndNotify(Cn, as) : this.passiveEffect(Cn, this.updateAndNotify)
    }
    setWithVelocity(Cn, as, cs) {
        this.set(as),
        this.prev = void 0,
        this.prevFrameValue = Cn,
        this.prevUpdatedAt = this.updatedAt - cs
    }
    jump(Cn, as=!0) {
        this.updateAndNotify(Cn),
        this.prev = Cn,
        this.prevUpdatedAt = this.prevFrameValue = void 0,
        as && this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
    get() {
        return this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        const Cn = time.now();
        if (!this.canTrackVelocity || this.prevFrameValue === void 0 || Cn - this.updatedAt > MAX_VELOCITY_DELTA)
            return 0;
        const as = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
        return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), as)
    }
    start(Cn) {
        return this.stop(),
        new Promise(as => {
            this.hasAnimated = !0,
            this.animation = Cn(as),
            this.events.animationStart && this.events.animationStart.notify()
        }
        ).then( () => {
            this.events.animationComplete && this.events.animationComplete.notify(),
            this.clearAnimation()
        }
        )
    }
    stop() {
        this.animation && (this.animation.stop(),
        this.events.animationCancel && this.events.animationCancel.notify()),
        this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        delete this.animation
    }
    destroy() {
        this.clearListeners(),
        this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
}
function motionValue(xt, Cn) {
    return new MotionValue(xt,Cn)
}
function setMotionValue(xt, Cn, as) {
    xt.hasValue(Cn) ? xt.getValue(Cn).set(as) : xt.addValue(Cn, motionValue(as))
}
function setTarget(xt, Cn) {
    const as = resolveVariant(xt, Cn);
    let {transitionEnd: cs={}, transition: Cs={}, ...Ls} = as || {};
    Ls = {
        ...Ls,
        ...cs
    };
    for (const Vs in Ls) {
        const Ws = resolveFinalValueInKeyframes(Ls[Vs]);
        setMotionValue(xt, Vs, Ws)
    }
}
function isWillChangeMotionValue(xt) {
    return !!(isMotionValue(xt) && xt.add)
}
function addValueToWillChange(xt, Cn) {
    const as = xt.getValue("willChange");
    if (isWillChangeMotionValue(as))
        return as.add(Cn)
}
function getOptimisedAppearId(xt) {
    return xt.props[optimizedAppearDataAttribute]
}
const calcBezier = (xt, Cn, as) => (((1 - 3 * as + 3 * Cn) * xt + (3 * as - 6 * Cn)) * xt + 3 * Cn) * xt
  , subdivisionPrecision = 1e-7
  , subdivisionMaxIterations = 12;
function binarySubdivide(xt, Cn, as, cs, Cs) {
    let Ls, Vs, Ws = 0;
    do
        Vs = Cn + (as - Cn) / 2,
        Ls = calcBezier(Vs, cs, Cs) - xt,
        Ls > 0 ? as = Vs : Cn = Vs;
    while (Math.abs(Ls) > subdivisionPrecision && ++Ws < subdivisionMaxIterations);
    return Vs
}
function cubicBezier(xt, Cn, as, cs) {
    if (xt === Cn && as === cs)
        return noop$3;
    const Cs = Ls => binarySubdivide(Ls, 0, 1, xt, as);
    return Ls => Ls === 0 || Ls === 1 ? Ls : calcBezier(Cs(Ls), Cn, cs)
}
const mirrorEasing = xt => Cn => Cn <= .5 ? xt(2 * Cn) / 2 : (2 - xt(2 * (1 - Cn))) / 2
  , reverseEasing = xt => Cn => 1 - xt(1 - Cn)
  , backOut = cubicBezier(.33, 1.53, .69, .99)
  , backIn = reverseEasing(backOut)
  , backInOut = mirrorEasing(backIn)
  , anticipate = xt => (xt *= 2) < 1 ? .5 * backIn(xt) : .5 * (2 - Math.pow(2, -10 * (xt - 1)))
  , circIn = xt => 1 - Math.sin(Math.acos(xt))
  , circOut = reverseEasing(circIn)
  , circInOut = mirrorEasing(circIn)
  , isZeroValueString = xt => /^0[^.\s]+$/u.test(xt);
function isNone(xt) {
    return typeof xt == "number" ? xt === 0 : xt !== null ? xt === "none" || xt === "0" || isZeroValueString(xt) : !0
}
const sanitize = xt => Math.round(xt * 1e5) / 1e5
  , floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function isNullish(xt) {
    return xt == null
}
const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu
  , isColorString = (xt, Cn) => as => !!(typeof as == "string" && singleColorRegex.test(as) && as.startsWith(xt) || Cn && !isNullish(as) && Object.prototype.hasOwnProperty.call(as, Cn))
  , splitColor = (xt, Cn, as) => cs => {
    if (typeof cs != "string")
        return cs;
    const [Cs,Ls,Vs,Ws] = cs.match(floatRegex);
    return {
        [xt]: parseFloat(Cs),
        [Cn]: parseFloat(Ls),
        [as]: parseFloat(Vs),
        alpha: Ws !== void 0 ? parseFloat(Ws) : 1
    }
}
  , clampRgbUnit = xt => clamp$1(0, 255, xt)
  , rgbUnit = {
    ...number$1,
    transform: xt => Math.round(clampRgbUnit(xt))
}
  , rgba = {
    test: isColorString("rgb", "red"),
    parse: splitColor("red", "green", "blue"),
    transform: ({red: xt, green: Cn, blue: as, alpha: cs=1}) => "rgba(" + rgbUnit.transform(xt) + ", " + rgbUnit.transform(Cn) + ", " + rgbUnit.transform(as) + ", " + sanitize(alpha.transform(cs)) + ")"
};
function parseHex(xt) {
    let Cn = ""
      , as = ""
      , cs = ""
      , Cs = "";
    return xt.length > 5 ? (Cn = xt.substring(1, 3),
    as = xt.substring(3, 5),
    cs = xt.substring(5, 7),
    Cs = xt.substring(7, 9)) : (Cn = xt.substring(1, 2),
    as = xt.substring(2, 3),
    cs = xt.substring(3, 4),
    Cs = xt.substring(4, 5),
    Cn += Cn,
    as += as,
    cs += cs,
    Cs += Cs),
    {
        red: parseInt(Cn, 16),
        green: parseInt(as, 16),
        blue: parseInt(cs, 16),
        alpha: Cs ? parseInt(Cs, 16) / 255 : 1
    }
}
const hex = {
    test: isColorString("#"),
    parse: parseHex,
    transform: rgba.transform
}
  , hsla = {
    test: isColorString("hsl", "hue"),
    parse: splitColor("hue", "saturation", "lightness"),
    transform: ({hue: xt, saturation: Cn, lightness: as, alpha: cs=1}) => "hsla(" + Math.round(xt) + ", " + percent.transform(sanitize(Cn)) + ", " + percent.transform(sanitize(as)) + ", " + sanitize(alpha.transform(cs)) + ")"
}
  , color = {
    test: xt => rgba.test(xt) || hex.test(xt) || hsla.test(xt),
    parse: xt => rgba.test(xt) ? rgba.parse(xt) : hsla.test(xt) ? hsla.parse(xt) : hex.parse(xt),
    transform: xt => typeof xt == "string" ? xt : xt.hasOwnProperty("red") ? rgba.transform(xt) : hsla.transform(xt)
}
  , colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function test(xt) {
    var Cn, as;
    return isNaN(xt) && typeof xt == "string" && (((Cn = xt.match(floatRegex)) === null || Cn === void 0 ? void 0 : Cn.length) || 0) + (((as = xt.match(colorRegex)) === null || as === void 0 ? void 0 : as.length) || 0) > 0
}
const NUMBER_TOKEN = "number"
  , COLOR_TOKEN = "color"
  , VAR_TOKEN = "var"
  , VAR_FUNCTION_TOKEN = "var("
  , SPLIT_TOKEN = "${}"
  , complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(xt) {
    const Cn = xt.toString()
      , as = []
      , cs = {
        color: [],
        number: [],
        var: []
    }
      , Cs = [];
    let Ls = 0;
    const Ws = Cn.replace(complexRegex, Xs => (color.test(Xs) ? (cs.color.push(Ls),
    Cs.push(COLOR_TOKEN),
    as.push(color.parse(Xs))) : Xs.startsWith(VAR_FUNCTION_TOKEN) ? (cs.var.push(Ls),
    Cs.push(VAR_TOKEN),
    as.push(Xs)) : (cs.number.push(Ls),
    Cs.push(NUMBER_TOKEN),
    as.push(parseFloat(Xs))),
    ++Ls,
    SPLIT_TOKEN)).split(SPLIT_TOKEN);
    return {
        values: as,
        split: Ws,
        indexes: cs,
        types: Cs
    }
}
function parseComplexValue(xt) {
    return analyseComplexValue(xt).values
}
function createTransformer(xt) {
    const {split: Cn, types: as} = analyseComplexValue(xt)
      , cs = Cn.length;
    return Cs => {
        let Ls = "";
        for (let Vs = 0; Vs < cs; Vs++)
            if (Ls += Cn[Vs],
            Cs[Vs] !== void 0) {
                const Ws = as[Vs];
                Ws === NUMBER_TOKEN ? Ls += sanitize(Cs[Vs]) : Ws === COLOR_TOKEN ? Ls += color.transform(Cs[Vs]) : Ls += Cs[Vs]
            }
        return Ls
    }
}
const convertNumbersToZero = xt => typeof xt == "number" ? 0 : xt;
function getAnimatableNone$1(xt) {
    const Cn = parseComplexValue(xt);
    return createTransformer(xt)(Cn.map(convertNumbersToZero))
}
const complex = {
    test,
    parse: parseComplexValue,
    createTransformer,
    getAnimatableNone: getAnimatableNone$1
}
  , maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(xt) {
    const [Cn,as] = xt.slice(0, -1).split("(");
    if (Cn === "drop-shadow")
        return xt;
    const [cs] = as.match(floatRegex) || [];
    if (!cs)
        return xt;
    const Cs = as.replace(cs, "");
    let Ls = maxDefaults.has(Cn) ? 1 : 0;
    return cs !== as && (Ls *= 100),
    Cn + "(" + Ls + Cs + ")"
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu
  , filter = {
    ...complex,
    getAnimatableNone: xt => {
        const Cn = xt.match(functionRegex);
        return Cn ? Cn.map(applyDefaultFilter).join(" ") : xt
    }
}
  , defaultValueTypes = {
    ...numberValueTypes,
    color,
    backgroundColor: color,
    outlineColor: color,
    fill: color,
    stroke: color,
    borderColor: color,
    borderTopColor: color,
    borderRightColor: color,
    borderBottomColor: color,
    borderLeftColor: color,
    filter,
    WebkitFilter: filter
}
  , getDefaultValueType = xt => defaultValueTypes[xt];
function getAnimatableNone(xt, Cn) {
    let as = getDefaultValueType(xt);
    return as !== filter && (as = complex),
    as.getAnimatableNone ? as.getAnimatableNone(Cn) : void 0
}
const invalidTemplates = new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(xt, Cn, as) {
    let cs = 0, Cs;
    for (; cs < xt.length && !Cs; ) {
        const Ls = xt[cs];
        typeof Ls == "string" && !invalidTemplates.has(Ls) && analyseComplexValue(Ls).values.length && (Cs = xt[cs]),
        cs++
    }
    if (Cs && as)
        for (const Ls of Cn)
            xt[Ls] = getAnimatableNone(as, Cs)
}
const isNumOrPxType = xt => xt === number$1 || xt === px
  , getPosFromMatrix = (xt, Cn) => parseFloat(xt.split(", ")[Cn])
  , getTranslateFromMatrix = (xt, Cn) => (as, {transform: cs}) => {
    if (cs === "none" || !cs)
        return 0;
    const Cs = cs.match(/^matrix3d\((.+)\)$/u);
    if (Cs)
        return getPosFromMatrix(Cs[1], Cn);
    {
        const Ls = cs.match(/^matrix\((.+)\)$/u);
        return Ls ? getPosFromMatrix(Ls[1], xt) : 0
    }
}
  , transformKeys = new Set(["x", "y", "z"])
  , nonTranslationalTransformKeys = transformPropOrder.filter(xt => !transformKeys.has(xt));
function removeNonTranslationalTransform(xt) {
    const Cn = [];
    return nonTranslationalTransformKeys.forEach(as => {
        const cs = xt.getValue(as);
        cs !== void 0 && (Cn.push([as, cs.get()]),
        cs.set(as.startsWith("scale") ? 1 : 0))
    }
    ),
    Cn
}
const positionalValues = {
    width: ({x: xt}, {paddingLeft: Cn="0", paddingRight: as="0"}) => xt.max - xt.min - parseFloat(Cn) - parseFloat(as),
    height: ({y: xt}, {paddingTop: Cn="0", paddingBottom: as="0"}) => xt.max - xt.min - parseFloat(Cn) - parseFloat(as),
    top: (xt, {top: Cn}) => parseFloat(Cn),
    left: (xt, {left: Cn}) => parseFloat(Cn),
    bottom: ({y: xt}, {top: Cn}) => parseFloat(Cn) + (xt.max - xt.min),
    right: ({x: xt}, {left: Cn}) => parseFloat(Cn) + (xt.max - xt.min),
    x: getTranslateFromMatrix(4, 13),
    y: getTranslateFromMatrix(5, 14)
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const toResolve = new Set;
let isScheduled = !1
  , anyNeedsMeasurement = !1;
function measureAllKeyframes() {
    if (anyNeedsMeasurement) {
        const xt = Array.from(toResolve).filter(cs => cs.needsMeasurement)
          , Cn = new Set(xt.map(cs => cs.element))
          , as = new Map;
        Cn.forEach(cs => {
            const Cs = removeNonTranslationalTransform(cs);
            Cs.length && (as.set(cs, Cs),
            cs.render())
        }
        ),
        xt.forEach(cs => cs.measureInitialState()),
        Cn.forEach(cs => {
            cs.render();
            const Cs = as.get(cs);
            Cs && Cs.forEach( ([Ls,Vs]) => {
                var Ws;
                (Ws = cs.getValue(Ls)) === null || Ws === void 0 || Ws.set(Vs)
            }
            )
        }
        ),
        xt.forEach(cs => cs.measureEndState()),
        xt.forEach(cs => {
            cs.suspendedScrollY !== void 0 && window.scrollTo(0, cs.suspendedScrollY)
        }
        )
    }
    anyNeedsMeasurement = !1,
    isScheduled = !1,
    toResolve.forEach(xt => xt.complete()),
    toResolve.clear()
}
function readAllKeyframes() {
    toResolve.forEach(xt => {
        xt.readKeyframes(),
        xt.needsMeasurement && (anyNeedsMeasurement = !0)
    }
    )
}
function flushKeyframeResolvers() {
    readAllKeyframes(),
    measureAllKeyframes()
}
class KeyframeResolver {
    constructor(Cn, as, cs, Cs, Ls, Vs=!1) {
        this.isComplete = !1,
        this.isAsync = !1,
        this.needsMeasurement = !1,
        this.isScheduled = !1,
        this.unresolvedKeyframes = [...Cn],
        this.onComplete = as,
        this.name = cs,
        this.motionValue = Cs,
        this.element = Ls,
        this.isAsync = Vs
    }
    scheduleResolve() {
        this.isScheduled = !0,
        this.isAsync ? (toResolve.add(this),
        isScheduled || (isScheduled = !0,
        frame$1.read(readAllKeyframes),
        frame$1.resolveKeyframes(measureAllKeyframes))) : (this.readKeyframes(),
        this.complete())
    }
    readKeyframes() {
        const {unresolvedKeyframes: Cn, name: as, element: cs, motionValue: Cs} = this;
        for (let Ls = 0; Ls < Cn.length; Ls++)
            if (Cn[Ls] === null)
                if (Ls === 0) {
                    const Vs = Cs == null ? void 0 : Cs.get()
                      , Ws = Cn[Cn.length - 1];
                    if (Vs !== void 0)
                        Cn[0] = Vs;
                    else if (cs && as) {
                        const Xs = cs.readValue(as, Ws);
                        Xs != null && (Cn[0] = Xs)
                    }
                    Cn[0] === void 0 && (Cn[0] = Ws),
                    Cs && Vs === void 0 && Cs.set(Cn[0])
                } else
                    Cn[Ls] = Cn[Ls - 1]
    }
    setFinalKeyframe() {}
    measureInitialState() {}
    renderEndStyles() {}
    measureEndState() {}
    complete() {
        this.isComplete = !0,
        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe),
        toResolve.delete(this)
    }
    cancel() {
        this.isComplete || (this.isScheduled = !1,
        toResolve.delete(this))
    }
    resume() {
        this.isComplete || this.scheduleResolve()
    }
}
const isNumericalString = xt => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(xt)
  , splitCSSVariableRegex = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function parseCSSVariable(xt) {
    const Cn = splitCSSVariableRegex.exec(xt);
    if (!Cn)
        return [, ];
    const [,as,cs,Cs] = Cn;
    return [`--${as ?? cs}`, Cs]
}
function getVariableValue(xt, Cn, as=1) {
    const [cs,Cs] = parseCSSVariable(xt);
    if (!cs)
        return;
    const Ls = window.getComputedStyle(Cn).getPropertyValue(cs);
    if (Ls) {
        const Vs = Ls.trim();
        return isNumericalString(Vs) ? parseFloat(Vs) : Vs
    }
    return isCSSVariableToken(Cs) ? getVariableValue(Cs, Cn, as + 1) : Cs
}
const testValueType = xt => Cn => Cn.test(xt)
  , auto = {
    test: xt => xt === "auto",
    parse: xt => xt
}
  , dimensionValueTypes = [number$1, px, percent, degrees, vw, vh, auto]
  , findDimensionValueType = xt => dimensionValueTypes.find(testValueType(xt));
class DOMKeyframesResolver extends KeyframeResolver {
    constructor(Cn, as, cs, Cs, Ls) {
        super(Cn, as, cs, Cs, Ls, !0)
    }
    readKeyframes() {
        const {unresolvedKeyframes: Cn, element: as, name: cs} = this;
        if (!as || !as.current)
            return;
        super.readKeyframes();
        for (let Xs = 0; Xs < Cn.length; Xs++) {
            let ga = Cn[Xs];
            if (typeof ga == "string" && (ga = ga.trim(),
            isCSSVariableToken(ga))) {
                const ba = getVariableValue(ga, as.current);
                ba !== void 0 && (Cn[Xs] = ba),
                Xs === Cn.length - 1 && (this.finalKeyframe = ga)
            }
        }
        if (this.resolveNoneKeyframes(),
        !positionalKeys.has(cs) || Cn.length !== 2)
            return;
        const [Cs,Ls] = Cn
          , Vs = findDimensionValueType(Cs)
          , Ws = findDimensionValueType(Ls);
        if (Vs !== Ws)
            if (isNumOrPxType(Vs) && isNumOrPxType(Ws))
                for (let Xs = 0; Xs < Cn.length; Xs++) {
                    const ga = Cn[Xs];
                    typeof ga == "string" && (Cn[Xs] = parseFloat(ga))
                }
            else
                this.needsMeasurement = !0
    }
    resolveNoneKeyframes() {
        const {unresolvedKeyframes: Cn, name: as} = this
          , cs = [];
        for (let Cs = 0; Cs < Cn.length; Cs++)
            isNone(Cn[Cs]) && cs.push(Cs);
        cs.length && makeNoneKeyframesAnimatable(Cn, cs, as)
    }
    measureInitialState() {
        const {element: Cn, unresolvedKeyframes: as, name: cs} = this;
        if (!Cn || !Cn.current)
            return;
        cs === "height" && (this.suspendedScrollY = window.pageYOffset),
        this.measuredOrigin = positionalValues[cs](Cn.measureViewportBox(), window.getComputedStyle(Cn.current)),
        as[0] = this.measuredOrigin;
        const Cs = as[as.length - 1];
        Cs !== void 0 && Cn.getValue(cs, Cs).jump(Cs, !1)
    }
    measureEndState() {
        var Cn;
        const {element: as, name: cs, unresolvedKeyframes: Cs} = this;
        if (!as || !as.current)
            return;
        const Ls = as.getValue(cs);
        Ls && Ls.jump(this.measuredOrigin, !1);
        const Vs = Cs.length - 1
          , Ws = Cs[Vs];
        Cs[Vs] = positionalValues[cs](as.measureViewportBox(), window.getComputedStyle(as.current)),
        Ws !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = Ws),
        !((Cn = this.removedTransforms) === null || Cn === void 0) && Cn.length && this.removedTransforms.forEach( ([Xs,ga]) => {
            as.getValue(Xs).set(ga)
        }
        ),
        this.resolveNoneKeyframes()
    }
}
const isAnimatable = (xt, Cn) => Cn === "zIndex" ? !1 : !!(typeof xt == "number" || Array.isArray(xt) || typeof xt == "string" && (complex.test(xt) || xt === "0") && !xt.startsWith("url("));
function hasKeyframesChanged(xt) {
    const Cn = xt[0];
    if (xt.length === 1)
        return !0;
    for (let as = 0; as < xt.length; as++)
        if (xt[as] !== Cn)
            return !0
}
function canAnimate(xt, Cn, as, cs) {
    const Cs = xt[0];
    if (Cs === null)
        return !1;
    if (Cn === "display" || Cn === "visibility")
        return !0;
    const Ls = xt[xt.length - 1]
      , Vs = isAnimatable(Cs, Cn)
      , Ws = isAnimatable(Ls, Cn);
    return !Vs || !Ws ? !1 : hasKeyframesChanged(xt) || (as === "spring" || isGenerator(as)) && cs
}
const isNotNull = xt => xt !== null;
function getFinalKeyframe(xt, {repeat: Cn, repeatType: as="loop"}, cs) {
    const Cs = xt.filter(isNotNull)
      , Ls = Cn && as !== "loop" && Cn % 2 === 1 ? 0 : Cs.length - 1;
    return !Ls || cs === void 0 ? Cs[Ls] : cs
}
const MAX_RESOLVE_DELAY = 40;
class BaseAnimation {
    constructor({autoplay: Cn=!0, delay: as=0, type: cs="keyframes", repeat: Cs=0, repeatDelay: Ls=0, repeatType: Vs="loop", ...Ws}) {
        this.isStopped = !1,
        this.hasAttemptedResolve = !1,
        this.createdAt = time.now(),
        this.options = {
            autoplay: Cn,
            delay: as,
            type: cs,
            repeat: Cs,
            repeatDelay: Ls,
            repeatType: Vs,
            ...Ws
        },
        this.updateFinishedPromise()
    }
    calcStartTime() {
        return this.resolvedAt ? this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : this.createdAt
    }
    get resolved() {
        return !this._resolved && !this.hasAttemptedResolve && flushKeyframeResolvers(),
        this._resolved
    }
    onKeyframesResolved(Cn, as) {
        this.resolvedAt = time.now(),
        this.hasAttemptedResolve = !0;
        const {name: cs, type: Cs, velocity: Ls, delay: Vs, onComplete: Ws, onUpdate: Xs, isGenerator: ga} = this.options;
        if (!ga && !canAnimate(Cn, cs, Cs, Ls))
            if (Vs)
                this.options.duration = 0;
            else {
                Xs && Xs(getFinalKeyframe(Cn, this.options, as)),
                Ws && Ws(),
                this.resolveFinishedPromise();
                return
            }
        const ba = this.initPlayback(Cn, as);
        ba !== !1 && (this._resolved = {
            keyframes: Cn,
            finalKeyframe: as,
            ...ba
        },
        this.onPostResolved())
    }
    onPostResolved() {}
    then(Cn, as) {
        return this.currentFinishedPromise.then(Cn, as)
    }
    flatten() {
        this.options.type = "keyframes",
        this.options.ease = "linear"
    }
    updateFinishedPromise() {
        this.currentFinishedPromise = new Promise(Cn => {
            this.resolveFinishedPromise = Cn
        }
        )
    }
}
const mixNumber$1 = (xt, Cn, as) => xt + (Cn - xt) * as;
function hueToRgb(xt, Cn, as) {
    return as < 0 && (as += 1),
    as > 1 && (as -= 1),
    as < 1 / 6 ? xt + (Cn - xt) * 6 * as : as < 1 / 2 ? Cn : as < 2 / 3 ? xt + (Cn - xt) * (2 / 3 - as) * 6 : xt
}
function hslaToRgba({hue: xt, saturation: Cn, lightness: as, alpha: cs}) {
    xt /= 360,
    Cn /= 100,
    as /= 100;
    let Cs = 0
      , Ls = 0
      , Vs = 0;
    if (!Cn)
        Cs = Ls = Vs = as;
    else {
        const Ws = as < .5 ? as * (1 + Cn) : as + Cn - as * Cn
          , Xs = 2 * as - Ws;
        Cs = hueToRgb(Xs, Ws, xt + 1 / 3),
        Ls = hueToRgb(Xs, Ws, xt),
        Vs = hueToRgb(Xs, Ws, xt - 1 / 3)
    }
    return {
        red: Math.round(Cs * 255),
        green: Math.round(Ls * 255),
        blue: Math.round(Vs * 255),
        alpha: cs
    }
}
function mixImmediate(xt, Cn) {
    return as => as > 0 ? Cn : xt
}
const mixLinearColor = (xt, Cn, as) => {
    const cs = xt * xt
      , Cs = as * (Cn * Cn - cs) + cs;
    return Cs < 0 ? 0 : Math.sqrt(Cs)
}
  , colorTypes = [hex, rgba, hsla]
  , getColorType = xt => colorTypes.find(Cn => Cn.test(xt));
function asRGBA(xt) {
    const Cn = getColorType(xt);
    if (!Cn)
        return !1;
    let as = Cn.parse(xt);
    return Cn === hsla && (as = hslaToRgba(as)),
    as
}
const mixColor = (xt, Cn) => {
    const as = asRGBA(xt)
      , cs = asRGBA(Cn);
    if (!as || !cs)
        return mixImmediate(xt, Cn);
    const Cs = {
        ...as
    };
    return Ls => (Cs.red = mixLinearColor(as.red, cs.red, Ls),
    Cs.green = mixLinearColor(as.green, cs.green, Ls),
    Cs.blue = mixLinearColor(as.blue, cs.blue, Ls),
    Cs.alpha = mixNumber$1(as.alpha, cs.alpha, Ls),
    rgba.transform(Cs))
}
  , combineFunctions = (xt, Cn) => as => Cn(xt(as))
  , pipe = (...xt) => xt.reduce(combineFunctions)
  , invisibleValues = new Set(["none", "hidden"]);
function mixVisibility(xt, Cn) {
    return invisibleValues.has(xt) ? as => as <= 0 ? xt : Cn : as => as >= 1 ? Cn : xt
}
function mixNumber(xt, Cn) {
    return as => mixNumber$1(xt, Cn, as)
}
function getMixer(xt) {
    return typeof xt == "number" ? mixNumber : typeof xt == "string" ? isCSSVariableToken(xt) ? mixImmediate : color.test(xt) ? mixColor : mixComplex : Array.isArray(xt) ? mixArray : typeof xt == "object" ? color.test(xt) ? mixColor : mixObject : mixImmediate
}
function mixArray(xt, Cn) {
    const as = [...xt]
      , cs = as.length
      , Cs = xt.map( (Ls, Vs) => getMixer(Ls)(Ls, Cn[Vs]));
    return Ls => {
        for (let Vs = 0; Vs < cs; Vs++)
            as[Vs] = Cs[Vs](Ls);
        return as
    }
}
function mixObject(xt, Cn) {
    const as = {
        ...xt,
        ...Cn
    }
      , cs = {};
    for (const Cs in as)
        xt[Cs] !== void 0 && Cn[Cs] !== void 0 && (cs[Cs] = getMixer(xt[Cs])(xt[Cs], Cn[Cs]));
    return Cs => {
        for (const Ls in cs)
            as[Ls] = cs[Ls](Cs);
        return as
    }
}
function matchOrder(xt, Cn) {
    var as;
    const cs = []
      , Cs = {
        color: 0,
        var: 0,
        number: 0
    };
    for (let Ls = 0; Ls < Cn.values.length; Ls++) {
        const Vs = Cn.types[Ls]
          , Ws = xt.indexes[Vs][Cs[Vs]]
          , Xs = (as = xt.values[Ws]) !== null && as !== void 0 ? as : 0;
        cs[Ls] = Xs,
        Cs[Vs]++
    }
    return cs
}
const mixComplex = (xt, Cn) => {
    const as = complex.createTransformer(Cn)
      , cs = analyseComplexValue(xt)
      , Cs = analyseComplexValue(Cn);
    return cs.indexes.var.length === Cs.indexes.var.length && cs.indexes.color.length === Cs.indexes.color.length && cs.indexes.number.length >= Cs.indexes.number.length ? invisibleValues.has(xt) && !Cs.values.length || invisibleValues.has(Cn) && !cs.values.length ? mixVisibility(xt, Cn) : pipe(mixArray(matchOrder(cs, Cs), Cs.values), as) : mixImmediate(xt, Cn)
}
;
function mix(xt, Cn, as) {
    return typeof xt == "number" && typeof Cn == "number" && typeof as == "number" ? mixNumber$1(xt, Cn, as) : getMixer(xt)(xt, Cn)
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(xt, Cn, as) {
    const cs = Math.max(Cn - velocitySampleDuration, 0);
    return velocityPerSecond(as - xt(cs), Cn - cs)
}
const springDefaults = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: .3,
    visualDuration: .3,
    restSpeed: {
        granular: .01,
        default: 2
    },
    restDelta: {
        granular: .005,
        default: .5
    },
    minDuration: .01,
    maxDuration: 10,
    minDamping: .05,
    maxDamping: 1
}
  , safeMin = .001;
function findSpring({duration: xt=springDefaults.duration, bounce: Cn=springDefaults.bounce, velocity: as=springDefaults.velocity, mass: cs=springDefaults.mass}) {
    let Cs, Ls, Vs = 1 - Cn;
    Vs = clamp$1(springDefaults.minDamping, springDefaults.maxDamping, Vs),
    xt = clamp$1(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(xt)),
    Vs < 1 ? (Cs = ga => {
        const ba = ga * Vs
          , yl = ba * xt
          , xl = ba - as
          , wl = calcAngularFreq(ga, Vs)
          , _l = Math.exp(-yl);
        return safeMin - xl / wl * _l
    }
    ,
    Ls = ga => {
        const yl = ga * Vs * xt
          , xl = yl * as + as
          , wl = Math.pow(Vs, 2) * Math.pow(ga, 2) * xt
          , _l = Math.exp(-yl)
          , El = calcAngularFreq(Math.pow(ga, 2), Vs);
        return (-Cs(ga) + safeMin > 0 ? -1 : 1) * ((xl - wl) * _l) / El
    }
    ) : (Cs = ga => {
        const ba = Math.exp(-ga * xt)
          , yl = (ga - as) * xt + 1;
        return -.001 + ba * yl
    }
    ,
    Ls = ga => {
        const ba = Math.exp(-ga * xt)
          , yl = (as - ga) * (xt * xt);
        return ba * yl
    }
    );
    const Ws = 5 / xt
      , Xs = approximateRoot(Cs, Ls, Ws);
    if (xt = secondsToMilliseconds(xt),
    isNaN(Xs))
        return {
            stiffness: springDefaults.stiffness,
            damping: springDefaults.damping,
            duration: xt
        };
    {
        const ga = Math.pow(Xs, 2) * cs;
        return {
            stiffness: ga,
            damping: Vs * 2 * Math.sqrt(cs * ga),
            duration: xt
        }
    }
}
const rootIterations = 12;
function approximateRoot(xt, Cn, as) {
    let cs = as;
    for (let Cs = 1; Cs < rootIterations; Cs++)
        cs = cs - xt(cs) / Cn(cs);
    return cs
}
function calcAngularFreq(xt, Cn) {
    return xt * Math.sqrt(1 - Cn * Cn)
}
const durationKeys = ["duration", "bounce"]
  , physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(xt, Cn) {
    return Cn.some(as => xt[as] !== void 0)
}
function getSpringOptions(xt) {
    let Cn = {
        velocity: springDefaults.velocity,
        stiffness: springDefaults.stiffness,
        damping: springDefaults.damping,
        mass: springDefaults.mass,
        isResolvedFromDuration: !1,
        ...xt
    };
    if (!isSpringType(xt, physicsKeys) && isSpringType(xt, durationKeys))
        if (xt.visualDuration) {
            const as = xt.visualDuration
              , cs = 2 * Math.PI / (as * 1.2)
              , Cs = cs * cs
              , Ls = 2 * clamp$1(.05, 1, 1 - (xt.bounce || 0)) * Math.sqrt(Cs);
            Cn = {
                ...Cn,
                mass: springDefaults.mass,
                stiffness: Cs,
                damping: Ls
            }
        } else {
            const as = findSpring(xt);
            Cn = {
                ...Cn,
                ...as,
                mass: springDefaults.mass
            },
            Cn.isResolvedFromDuration = !0
        }
    return Cn
}
function spring(xt=springDefaults.visualDuration, Cn=springDefaults.bounce) {
    const as = typeof xt != "object" ? {
        visualDuration: xt,
        keyframes: [0, 1],
        bounce: Cn
    } : xt;
    let {restSpeed: cs, restDelta: Cs} = as;
    const Ls = as.keyframes[0]
      , Vs = as.keyframes[as.keyframes.length - 1]
      , Ws = {
        done: !1,
        value: Ls
    }
      , {stiffness: Xs, damping: ga, mass: ba, duration: yl, velocity: xl, isResolvedFromDuration: wl} = getSpringOptions({
        ...as,
        velocity: -millisecondsToSeconds(as.velocity || 0)
    })
      , _l = xl || 0
      , El = ga / (2 * Math.sqrt(Xs * ba))
      , Cl = Vs - Ls
      , $l = millisecondsToSeconds(Math.sqrt(Xs / ba))
      , Sl = Math.abs(Cl) < 5;
    cs || (cs = Sl ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default),
    Cs || (Cs = Sl ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
    let Tl;
    if (El < 1) {
        const Il = calcAngularFreq($l, El);
        Tl = Ml => {
            const Nl = Math.exp(-El * $l * Ml);
            return Vs - Nl * ((_l + El * $l * Cl) / Il * Math.sin(Il * Ml) + Cl * Math.cos(Il * Ml))
        }
    } else if (El === 1)
        Tl = Il => Vs - Math.exp(-$l * Il) * (Cl + (_l + $l * Cl) * Il);
    else {
        const Il = $l * Math.sqrt(El * El - 1);
        Tl = Ml => {
            const Nl = Math.exp(-El * $l * Ml)
              , Ll = Math.min(Il * Ml, 300);
            return Vs - Nl * ((_l + El * $l * Cl) * Math.sinh(Ll) + Il * Cl * Math.cosh(Ll)) / Il
        }
    }
    const Rl = {
        calculatedDuration: wl && yl || null,
        next: Il => {
            const Ml = Tl(Il);
            if (wl)
                Ws.done = Il >= yl;
            else {
                let Nl = 0;
                El < 1 && (Nl = Il === 0 ? secondsToMilliseconds(_l) : calcGeneratorVelocity(Tl, Il, Ml));
                const Ll = Math.abs(Nl) <= cs
                  , Fl = Math.abs(Vs - Ml) <= Cs;
                Ws.done = Ll && Fl
            }
            return Ws.value = Ws.done ? Vs : Ml,
            Ws
        }
        ,
        toString: () => {
            const Il = Math.min(calcGeneratorDuration(Rl), maxGeneratorDuration)
              , Ml = generateLinearEasing(Nl => Rl.next(Il * Nl).value, Il, 30);
            return Il + "ms " + Ml
        }
    };
    return Rl
}
function inertia({keyframes: xt, velocity: Cn=0, power: as=.8, timeConstant: cs=325, bounceDamping: Cs=10, bounceStiffness: Ls=500, modifyTarget: Vs, min: Ws, max: Xs, restDelta: ga=.5, restSpeed: ba}) {
    const yl = xt[0]
      , xl = {
        done: !1,
        value: yl
    }
      , wl = Ll => Ws !== void 0 && Ll < Ws || Xs !== void 0 && Ll > Xs
      , _l = Ll => Ws === void 0 ? Xs : Xs === void 0 || Math.abs(Ws - Ll) < Math.abs(Xs - Ll) ? Ws : Xs;
    let El = as * Cn;
    const Cl = yl + El
      , $l = Vs === void 0 ? Cl : Vs(Cl);
    $l !== Cl && (El = $l - yl);
    const Sl = Ll => -El * Math.exp(-Ll / cs)
      , Tl = Ll => $l + Sl(Ll)
      , Rl = Ll => {
        const Fl = Sl(Ll)
          , Ul = Tl(Ll);
        xl.done = Math.abs(Fl) <= ga,
        xl.value = xl.done ? $l : Ul
    }
    ;
    let Il, Ml;
    const Nl = Ll => {
        wl(xl.value) && (Il = Ll,
        Ml = spring({
            keyframes: [xl.value, _l(xl.value)],
            velocity: calcGeneratorVelocity(Tl, Ll, xl.value),
            damping: Cs,
            stiffness: Ls,
            restDelta: ga,
            restSpeed: ba
        }))
    }
    ;
    return Nl(0),
    {
        calculatedDuration: null,
        next: Ll => {
            let Fl = !1;
            return !Ml && Il === void 0 && (Fl = !0,
            Rl(Ll),
            Nl(Ll)),
            Il !== void 0 && Ll >= Il ? Ml.next(Ll - Il) : (!Fl && Rl(Ll),
            xl)
        }
    }
}
const easeIn = cubicBezier(.42, 0, 1, 1)
  , easeOut = cubicBezier(0, 0, .58, 1)
  , easeInOut = cubicBezier(.42, 0, .58, 1)
  , isEasingArray = xt => Array.isArray(xt) && typeof xt[0] != "number"
  , easingLookup = {
    linear: noop$3,
    easeIn,
    easeInOut,
    easeOut,
    circIn,
    circInOut,
    circOut,
    backIn,
    backInOut,
    backOut,
    anticipate
}
  , easingDefinitionToFunction = xt => {
    if (isBezierDefinition(xt)) {
        invariant(xt.length === 4);
        const [Cn,as,cs,Cs] = xt;
        return cubicBezier(Cn, as, cs, Cs)
    } else if (typeof xt == "string")
        return easingLookup[xt];
    return xt
}
;
function createMixers(xt, Cn, as) {
    const cs = []
      , Cs = as || mix
      , Ls = xt.length - 1;
    for (let Vs = 0; Vs < Ls; Vs++) {
        let Ws = Cs(xt[Vs], xt[Vs + 1]);
        if (Cn) {
            const Xs = Array.isArray(Cn) ? Cn[Vs] || noop$3 : Cn;
            Ws = pipe(Xs, Ws)
        }
        cs.push(Ws)
    }
    return cs
}
function interpolate(xt, Cn, {clamp: as=!0, ease: cs, mixer: Cs}={}) {
    const Ls = xt.length;
    if (invariant(Ls === Cn.length),
    Ls === 1)
        return () => Cn[0];
    if (Ls === 2 && Cn[0] === Cn[1])
        return () => Cn[1];
    const Vs = xt[0] === xt[1];
    xt[0] > xt[Ls - 1] && (xt = [...xt].reverse(),
    Cn = [...Cn].reverse());
    const Ws = createMixers(Cn, cs, Cs)
      , Xs = Ws.length
      , ga = ba => {
        if (Vs && ba < xt[0])
            return Cn[0];
        let yl = 0;
        if (Xs > 1)
            for (; yl < xt.length - 2 && !(ba < xt[yl + 1]); yl++)
                ;
        const xl = progress(xt[yl], xt[yl + 1], ba);
        return Ws[yl](xl)
    }
    ;
    return as ? ba => ga(clamp$1(xt[0], xt[Ls - 1], ba)) : ga
}
function fillOffset(xt, Cn) {
    const as = xt[xt.length - 1];
    for (let cs = 1; cs <= Cn; cs++) {
        const Cs = progress(0, Cn, cs);
        xt.push(mixNumber$1(as, 1, Cs))
    }
}
function defaultOffset(xt) {
    const Cn = [0];
    return fillOffset(Cn, xt.length - 1),
    Cn
}
function convertOffsetToTimes(xt, Cn) {
    return xt.map(as => as * Cn)
}
function defaultEasing(xt, Cn) {
    return xt.map( () => Cn || easeInOut).splice(0, xt.length - 1)
}
function keyframes({duration: xt=300, keyframes: Cn, times: as, ease: cs="easeInOut"}) {
    const Cs = isEasingArray(cs) ? cs.map(easingDefinitionToFunction) : easingDefinitionToFunction(cs)
      , Ls = {
        done: !1,
        value: Cn[0]
    }
      , Vs = convertOffsetToTimes(as && as.length === Cn.length ? as : defaultOffset(Cn), xt)
      , Ws = interpolate(Vs, Cn, {
        ease: Array.isArray(Cs) ? Cs : defaultEasing(Cn, Cs)
    });
    return {
        calculatedDuration: xt,
        next: Xs => (Ls.value = Ws(Xs),
        Ls.done = Xs >= xt,
        Ls)
    }
}
const frameloopDriver = xt => {
    const Cn = ({timestamp: as}) => xt(as);
    return {
        start: () => frame$1.update(Cn, !0),
        stop: () => cancelFrame(Cn),
        now: () => frameData.isProcessing ? frameData.timestamp : time.now()
    }
}
  , generators = {
    decay: inertia,
    inertia,
    tween: keyframes,
    keyframes,
    spring
}
  , percentToProgress = xt => xt / 100;
class MainThreadAnimation extends BaseAnimation {
    constructor(Cn) {
        super(Cn),
        this.holdTime = null,
        this.cancelTime = null,
        this.currentTime = 0,
        this.playbackSpeed = 1,
        this.pendingPlayState = "running",
        this.startTime = null,
        this.state = "idle",
        this.stop = () => {
            if (this.resolver.cancel(),
            this.isStopped = !0,
            this.state === "idle")
                return;
            this.teardown();
            const {onStop: Xs} = this.options;
            Xs && Xs()
        }
        ;
        const {name: as, motionValue: cs, element: Cs, keyframes: Ls} = this.options
          , Vs = (Cs == null ? void 0 : Cs.KeyframeResolver) || KeyframeResolver
          , Ws = (Xs, ga) => this.onKeyframesResolved(Xs, ga);
        this.resolver = new Vs(Ls,Ws,as,cs,Cs),
        this.resolver.scheduleResolve()
    }
    flatten() {
        super.flatten(),
        this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes))
    }
    initPlayback(Cn) {
        const {type: as="keyframes", repeat: cs=0, repeatDelay: Cs=0, repeatType: Ls, velocity: Vs=0} = this.options
          , Ws = isGenerator(as) ? as : generators[as] || keyframes;
        let Xs, ga;
        Ws !== keyframes && typeof Cn[0] != "number" && (Xs = pipe(percentToProgress, mix(Cn[0], Cn[1])),
        Cn = [0, 100]);
        const ba = Ws({
            ...this.options,
            keyframes: Cn
        });
        Ls === "mirror" && (ga = Ws({
            ...this.options,
            keyframes: [...Cn].reverse(),
            velocity: -Vs
        })),
        ba.calculatedDuration === null && (ba.calculatedDuration = calcGeneratorDuration(ba));
        const {calculatedDuration: yl} = ba
          , xl = yl + Cs
          , wl = xl * (cs + 1) - Cs;
        return {
            generator: ba,
            mirroredGenerator: ga,
            mapPercentToKeyframes: Xs,
            calculatedDuration: yl,
            resolvedDuration: xl,
            totalDuration: wl
        }
    }
    onPostResolved() {
        const {autoplay: Cn=!0} = this.options;
        this.play(),
        this.pendingPlayState === "paused" || !Cn ? this.pause() : this.state = this.pendingPlayState
    }
    tick(Cn, as=!1) {
        const {resolved: cs} = this;
        if (!cs) {
            const {keyframes: Ll} = this.options;
            return {
                done: !0,
                value: Ll[Ll.length - 1]
            }
        }
        const {finalKeyframe: Cs, generator: Ls, mirroredGenerator: Vs, mapPercentToKeyframes: Ws, keyframes: Xs, calculatedDuration: ga, totalDuration: ba, resolvedDuration: yl} = cs;
        if (this.startTime === null)
            return Ls.next(0);
        const {delay: xl, repeat: wl, repeatType: _l, repeatDelay: El, onUpdate: Cl} = this.options;
        this.speed > 0 ? this.startTime = Math.min(this.startTime, Cn) : this.speed < 0 && (this.startTime = Math.min(Cn - ba / this.speed, this.startTime)),
        as ? this.currentTime = Cn : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(Cn - this.startTime) * this.speed;
        const $l = this.currentTime - xl * (this.speed >= 0 ? 1 : -1)
          , Sl = this.speed >= 0 ? $l < 0 : $l > ba;
        this.currentTime = Math.max($l, 0),
        this.state === "finished" && this.holdTime === null && (this.currentTime = ba);
        let Tl = this.currentTime
          , Rl = Ls;
        if (wl) {
            const Ll = Math.min(this.currentTime, ba) / yl;
            let Fl = Math.floor(Ll)
              , Ul = Ll % 1;
            !Ul && Ll >= 1 && (Ul = 1),
            Ul === 1 && Fl--,
            Fl = Math.min(Fl, wl + 1),
            !!(Fl % 2) && (_l === "reverse" ? (Ul = 1 - Ul,
            El && (Ul -= El / yl)) : _l === "mirror" && (Rl = Vs)),
            Tl = clamp$1(0, 1, Ul) * yl
        }
        const Il = Sl ? {
            done: !1,
            value: Xs[0]
        } : Rl.next(Tl);
        Ws && (Il.value = Ws(Il.value));
        let {done: Ml} = Il;
        !Sl && ga !== null && (Ml = this.speed >= 0 ? this.currentTime >= ba : this.currentTime <= 0);
        const Nl = this.holdTime === null && (this.state === "finished" || this.state === "running" && Ml);
        return Nl && Cs !== void 0 && (Il.value = getFinalKeyframe(Xs, this.options, Cs)),
        Cl && Cl(Il.value),
        Nl && this.finish(),
        Il
    }
    get duration() {
        const {resolved: Cn} = this;
        return Cn ? millisecondsToSeconds(Cn.calculatedDuration) : 0
    }
    get time() {
        return millisecondsToSeconds(this.currentTime)
    }
    set time(Cn) {
        Cn = secondsToMilliseconds(Cn),
        this.currentTime = Cn,
        this.holdTime !== null || this.speed === 0 ? this.holdTime = Cn : this.driver && (this.startTime = this.driver.now() - Cn / this.speed)
    }
    get speed() {
        return this.playbackSpeed
    }
    set speed(Cn) {
        const as = this.playbackSpeed !== Cn;
        this.playbackSpeed = Cn,
        as && (this.time = millisecondsToSeconds(this.currentTime))
    }
    play() {
        if (this.resolver.isScheduled || this.resolver.resume(),
        !this._resolved) {
            this.pendingPlayState = "running";
            return
        }
        if (this.isStopped)
            return;
        const {driver: Cn=frameloopDriver, onPlay: as, startTime: cs} = this.options;
        this.driver || (this.driver = Cn(Ls => this.tick(Ls))),
        as && as();
        const Cs = this.driver.now();
        this.holdTime !== null ? this.startTime = Cs - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = Cs) : this.startTime = cs ?? this.calcStartTime(),
        this.state === "finished" && this.updateFinishedPromise(),
        this.cancelTime = this.startTime,
        this.holdTime = null,
        this.state = "running",
        this.driver.start()
    }
    pause() {
        var Cn;
        if (!this._resolved) {
            this.pendingPlayState = "paused";
            return
        }
        this.state = "paused",
        this.holdTime = (Cn = this.currentTime) !== null && Cn !== void 0 ? Cn : 0
    }
    complete() {
        this.state !== "running" && this.play(),
        this.pendingPlayState = this.state = "finished",
        this.holdTime = null
    }
    finish() {
        this.teardown(),
        this.state = "finished";
        const {onComplete: Cn} = this.options;
        Cn && Cn()
    }
    cancel() {
        this.cancelTime !== null && this.tick(this.cancelTime),
        this.teardown(),
        this.updateFinishedPromise()
    }
    teardown() {
        this.state = "idle",
        this.stopDriver(),
        this.resolveFinishedPromise(),
        this.updateFinishedPromise(),
        this.startTime = this.cancelTime = null,
        this.resolver.cancel()
    }
    stopDriver() {
        this.driver && (this.driver.stop(),
        this.driver = void 0)
    }
    sample(Cn) {
        return this.startTime = 0,
        this.tick(Cn, !0)
    }
}
const acceleratedValues = new Set(["opacity", "clipPath", "filter", "transform"]);
function startWaapiAnimation(xt, Cn, as, {delay: cs=0, duration: Cs=300, repeat: Ls=0, repeatType: Vs="loop", ease: Ws="easeInOut", times: Xs}={}) {
    const ga = {
        [Cn]: as
    };
    Xs && (ga.offset = Xs);
    const ba = mapEasingToNativeEasing(Ws, Cs);
    return Array.isArray(ba) && (ga.easing = ba),
    xt.animate(ga, {
        delay: cs,
        duration: Cs,
        easing: Array.isArray(ba) ? "linear" : ba,
        fill: "both",
        iterations: Ls + 1,
        direction: Vs === "reverse" ? "alternate" : "normal"
    })
}
const supportsWaapi = memo( () => Object.hasOwnProperty.call(Element.prototype, "animate"))
  , sampleDelta = 10
  , maxDuration = 2e4;
function requiresPregeneratedKeyframes(xt) {
    return isGenerator(xt.type) || xt.type === "spring" || !isWaapiSupportedEasing(xt.ease)
}
function pregenerateKeyframes(xt, Cn) {
    const as = new MainThreadAnimation({
        ...Cn,
        keyframes: xt,
        repeat: 0,
        delay: 0,
        isGenerator: !0
    });
    let cs = {
        done: !1,
        value: xt[0]
    };
    const Cs = [];
    let Ls = 0;
    for (; !cs.done && Ls < maxDuration; )
        cs = as.sample(Ls),
        Cs.push(cs.value),
        Ls += sampleDelta;
    return {
        times: void 0,
        keyframes: Cs,
        duration: Ls - sampleDelta,
        ease: "linear"
    }
}
const unsupportedEasingFunctions = {
    anticipate,
    backInOut,
    circInOut
};
function isUnsupportedEase(xt) {
    return xt in unsupportedEasingFunctions
}
class AcceleratedAnimation extends BaseAnimation {
    constructor(Cn) {
        super(Cn);
        const {name: as, motionValue: cs, element: Cs, keyframes: Ls} = this.options;
        this.resolver = new DOMKeyframesResolver(Ls, (Vs, Ws) => this.onKeyframesResolved(Vs, Ws),as,cs,Cs),
        this.resolver.scheduleResolve()
    }
    initPlayback(Cn, as) {
        let {duration: cs=300, times: Cs, ease: Ls, type: Vs, motionValue: Ws, name: Xs, startTime: ga} = this.options;
        if (!Ws.owner || !Ws.owner.current)
            return !1;
        if (typeof Ls == "string" && supportsLinearEasing() && isUnsupportedEase(Ls) && (Ls = unsupportedEasingFunctions[Ls]),
        requiresPregeneratedKeyframes(this.options)) {
            const {onComplete: yl, onUpdate: xl, motionValue: wl, element: _l, ...El} = this.options
              , Cl = pregenerateKeyframes(Cn, El);
            Cn = Cl.keyframes,
            Cn.length === 1 && (Cn[1] = Cn[0]),
            cs = Cl.duration,
            Cs = Cl.times,
            Ls = Cl.ease,
            Vs = "keyframes"
        }
        const ba = startWaapiAnimation(Ws.owner.current, Xs, Cn, {
            ...this.options,
            duration: cs,
            times: Cs,
            ease: Ls
        });
        return ba.startTime = ga ?? this.calcStartTime(),
        this.pendingTimeline ? (attachTimeline(ba, this.pendingTimeline),
        this.pendingTimeline = void 0) : ba.onfinish = () => {
            const {onComplete: yl} = this.options;
            Ws.set(getFinalKeyframe(Cn, this.options, as)),
            yl && yl(),
            this.cancel(),
            this.resolveFinishedPromise()
        }
        ,
        {
            animation: ba,
            duration: cs,
            times: Cs,
            type: Vs,
            ease: Ls,
            keyframes: Cn
        }
    }
    get duration() {
        const {resolved: Cn} = this;
        if (!Cn)
            return 0;
        const {duration: as} = Cn;
        return millisecondsToSeconds(as)
    }
    get time() {
        const {resolved: Cn} = this;
        if (!Cn)
            return 0;
        const {animation: as} = Cn;
        return millisecondsToSeconds(as.currentTime || 0)
    }
    set time(Cn) {
        const {resolved: as} = this;
        if (!as)
            return;
        const {animation: cs} = as;
        cs.currentTime = secondsToMilliseconds(Cn)
    }
    get speed() {
        const {resolved: Cn} = this;
        if (!Cn)
            return 1;
        const {animation: as} = Cn;
        return as.playbackRate
    }
    set speed(Cn) {
        const {resolved: as} = this;
        if (!as)
            return;
        const {animation: cs} = as;
        cs.playbackRate = Cn
    }
    get state() {
        const {resolved: Cn} = this;
        if (!Cn)
            return "idle";
        const {animation: as} = Cn;
        return as.playState
    }
    get startTime() {
        const {resolved: Cn} = this;
        if (!Cn)
            return null;
        const {animation: as} = Cn;
        return as.startTime
    }
    attachTimeline(Cn) {
        if (!this._resolved)
            this.pendingTimeline = Cn;
        else {
            const {resolved: as} = this;
            if (!as)
                return noop$3;
            const {animation: cs} = as;
            attachTimeline(cs, Cn)
        }
        return noop$3
    }
    play() {
        if (this.isStopped)
            return;
        const {resolved: Cn} = this;
        if (!Cn)
            return;
        const {animation: as} = Cn;
        as.playState === "finished" && this.updateFinishedPromise(),
        as.play()
    }
    pause() {
        const {resolved: Cn} = this;
        if (!Cn)
            return;
        const {animation: as} = Cn;
        as.pause()
    }
    stop() {
        if (this.resolver.cancel(),
        this.isStopped = !0,
        this.state === "idle")
            return;
        this.resolveFinishedPromise(),
        this.updateFinishedPromise();
        const {resolved: Cn} = this;
        if (!Cn)
            return;
        const {animation: as, keyframes: cs, duration: Cs, type: Ls, ease: Vs, times: Ws} = Cn;
        if (as.playState === "idle" || as.playState === "finished")
            return;
        if (this.time) {
            const {motionValue: ga, onUpdate: ba, onComplete: yl, element: xl, ...wl} = this.options
              , _l = new MainThreadAnimation({
                ...wl,
                keyframes: cs,
                duration: Cs,
                type: Ls,
                ease: Vs,
                times: Ws,
                isGenerator: !0
            })
              , El = secondsToMilliseconds(this.time);
            ga.setWithVelocity(_l.sample(El - sampleDelta).value, _l.sample(El).value, sampleDelta)
        }
        const {onStop: Xs} = this.options;
        Xs && Xs(),
        this.cancel()
    }
    complete() {
        const {resolved: Cn} = this;
        Cn && Cn.animation.finish()
    }
    cancel() {
        const {resolved: Cn} = this;
        Cn && Cn.animation.cancel()
    }
    static supports(Cn) {
        const {motionValue: as, name: cs, repeatDelay: Cs, repeatType: Ls, damping: Vs, type: Ws} = Cn;
        if (!as || !as.owner || !(as.owner.current instanceof HTMLElement))
            return !1;
        const {onUpdate: Xs, transformTemplate: ga} = as.owner.getProps();
        return supportsWaapi() && cs && acceleratedValues.has(cs) && !Xs && !ga && !Cs && Ls !== "mirror" && Vs !== 0 && Ws !== "inertia"
    }
}
const underDampedSpring = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
}
  , criticallyDampedSpring = xt => ({
    type: "spring",
    stiffness: 550,
    damping: xt === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
})
  , keyframesTransition = {
    type: "keyframes",
    duration: .8
}
  , ease = {
    type: "keyframes",
    ease: [.25, .1, .35, 1],
    duration: .3
}
  , getDefaultTransition = (xt, {keyframes: Cn}) => Cn.length > 2 ? keyframesTransition : transformProps.has(xt) ? xt.startsWith("scale") ? criticallyDampedSpring(Cn[1]) : underDampedSpring : ease;
function isTransitionDefined({when: xt, delay: Cn, delayChildren: as, staggerChildren: cs, staggerDirection: Cs, repeat: Ls, repeatType: Vs, repeatDelay: Ws, from: Xs, elapsed: ga, ...ba}) {
    return !!Object.keys(ba).length
}
const animateMotionValue = (xt, Cn, as, cs={}, Cs, Ls) => Vs => {
    const Ws = getValueTransition(cs, xt) || {}
      , Xs = Ws.delay || cs.delay || 0;
    let {elapsed: ga=0} = cs;
    ga = ga - secondsToMilliseconds(Xs);
    let ba = {
        keyframes: Array.isArray(as) ? as : [null, as],
        ease: "easeOut",
        velocity: Cn.getVelocity(),
        ...Ws,
        delay: -ga,
        onUpdate: xl => {
            Cn.set(xl),
            Ws.onUpdate && Ws.onUpdate(xl)
        }
        ,
        onComplete: () => {
            Vs(),
            Ws.onComplete && Ws.onComplete()
        }
        ,
        name: xt,
        motionValue: Cn,
        element: Ls ? void 0 : Cs
    };
    isTransitionDefined(Ws) || (ba = {
        ...ba,
        ...getDefaultTransition(xt, ba)
    }),
    ba.duration && (ba.duration = secondsToMilliseconds(ba.duration)),
    ba.repeatDelay && (ba.repeatDelay = secondsToMilliseconds(ba.repeatDelay)),
    ba.from !== void 0 && (ba.keyframes[0] = ba.from);
    let yl = !1;
    if ((ba.type === !1 || ba.duration === 0 && !ba.repeatDelay) && (ba.duration = 0,
    ba.delay === 0 && (yl = !0)),
    yl && !Ls && Cn.get() !== void 0) {
        const xl = getFinalKeyframe(ba.keyframes, Ws);
        if (xl !== void 0)
            return frame$1.update( () => {
                ba.onUpdate(xl),
                ba.onComplete()
            }
            ),
            new GroupPlaybackControls([])
    }
    return !Ls && AcceleratedAnimation.supports(ba) ? new AcceleratedAnimation(ba) : new MainThreadAnimation(ba)
}
;
function shouldBlockAnimation({protectedKeys: xt, needsAnimating: Cn}, as) {
    const cs = xt.hasOwnProperty(as) && Cn[as] !== !0;
    return Cn[as] = !1,
    cs
}
function animateTarget(xt, Cn, {delay: as=0, transitionOverride: cs, type: Cs}={}) {
    var Ls;
    let {transition: Vs=xt.getDefaultTransition(), transitionEnd: Ws, ...Xs} = Cn;
    cs && (Vs = cs);
    const ga = []
      , ba = Cs && xt.animationState && xt.animationState.getState()[Cs];
    for (const yl in Xs) {
        const xl = xt.getValue(yl, (Ls = xt.latestValues[yl]) !== null && Ls !== void 0 ? Ls : null)
          , wl = Xs[yl];
        if (wl === void 0 || ba && shouldBlockAnimation(ba, yl))
            continue;
        const _l = {
            delay: as,
            ...getValueTransition(Vs || {}, yl)
        };
        let El = !1;
        if (window.MotionHandoffAnimation) {
            const $l = getOptimisedAppearId(xt);
            if ($l) {
                const Sl = window.MotionHandoffAnimation($l, yl, frame$1);
                Sl !== null && (_l.startTime = Sl,
                El = !0)
            }
        }
        addValueToWillChange(xt, yl),
        xl.start(animateMotionValue(yl, xl, wl, xt.shouldReduceMotion && positionalKeys.has(yl) ? {
            type: !1
        } : _l, xt, El));
        const Cl = xl.animation;
        Cl && ga.push(Cl)
    }
    return Ws && Promise.all(ga).then( () => {
        frame$1.update( () => {
            Ws && setTarget(xt, Ws)
        }
        )
    }
    ),
    ga
}
function animateVariant(xt, Cn, as={}) {
    var cs;
    const Cs = resolveVariant(xt, Cn, as.type === "exit" ? (cs = xt.presenceContext) === null || cs === void 0 ? void 0 : cs.custom : void 0);
    let {transition: Ls=xt.getDefaultTransition() || {}} = Cs || {};
    as.transitionOverride && (Ls = as.transitionOverride);
    const Vs = Cs ? () => Promise.all(animateTarget(xt, Cs, as)) : () => Promise.resolve()
      , Ws = xt.variantChildren && xt.variantChildren.size ? (ga=0) => {
        const {delayChildren: ba=0, staggerChildren: yl, staggerDirection: xl} = Ls;
        return animateChildren(xt, Cn, ba + ga, yl, xl, as)
    }
    : () => Promise.resolve()
      , {when: Xs} = Ls;
    if (Xs) {
        const [ga,ba] = Xs === "beforeChildren" ? [Vs, Ws] : [Ws, Vs];
        return ga().then( () => ba())
    } else
        return Promise.all([Vs(), Ws(as.delay)])
}
function animateChildren(xt, Cn, as=0, cs=0, Cs=1, Ls) {
    const Vs = []
      , Ws = (xt.variantChildren.size - 1) * cs
      , Xs = Cs === 1 ? (ga=0) => ga * cs : (ga=0) => Ws - ga * cs;
    return Array.from(xt.variantChildren).sort(sortByTreeOrder).forEach( (ga, ba) => {
        ga.notify("AnimationStart", Cn),
        Vs.push(animateVariant(ga, Cn, {
            ...Ls,
            delay: as + Xs(ba)
        }).then( () => ga.notify("AnimationComplete", Cn)))
    }
    ),
    Promise.all(Vs)
}
function sortByTreeOrder(xt, Cn) {
    return xt.sortNodePosition(Cn)
}
function animateVisualElement(xt, Cn, as={}) {
    xt.notify("AnimationStart", Cn);
    let cs;
    if (Array.isArray(Cn)) {
        const Cs = Cn.map(Ls => animateVariant(xt, Ls, as));
        cs = Promise.all(Cs)
    } else if (typeof Cn == "string")
        cs = animateVariant(xt, Cn, as);
    else {
        const Cs = typeof Cn == "function" ? resolveVariant(xt, Cn, as.custom) : Cn;
        cs = Promise.all(animateTarget(xt, Cs, as))
    }
    return cs.then( () => {
        xt.notify("AnimationComplete", Cn)
    }
    )
}
const numVariantProps = variantProps.length;
function getVariantContext(xt) {
    if (!xt)
        return;
    if (!xt.isControllingVariants) {
        const as = xt.parent ? getVariantContext(xt.parent) || {} : {};
        return xt.props.initial !== void 0 && (as.initial = xt.props.initial),
        as
    }
    const Cn = {};
    for (let as = 0; as < numVariantProps; as++) {
        const cs = variantProps[as]
          , Cs = xt.props[cs];
        (isVariantLabel(Cs) || Cs === !1) && (Cn[cs] = Cs)
    }
    return Cn
}
const reversePriorityOrder = [...variantPriorityOrder].reverse()
  , numAnimationTypes = variantPriorityOrder.length;
function animateList(xt) {
    return Cn => Promise.all(Cn.map( ({animation: as, options: cs}) => animateVisualElement(xt, as, cs)))
}
function createAnimationState(xt) {
    let Cn = animateList(xt)
      , as = createState()
      , cs = !0;
    const Cs = Xs => (ga, ba) => {
        var yl;
        const xl = resolveVariant(xt, ba, Xs === "exit" ? (yl = xt.presenceContext) === null || yl === void 0 ? void 0 : yl.custom : void 0);
        if (xl) {
            const {transition: wl, transitionEnd: _l, ...El} = xl;
            ga = {
                ...ga,
                ...El,
                ..._l
            }
        }
        return ga
    }
    ;
    function Ls(Xs) {
        Cn = Xs(xt)
    }
    function Vs(Xs) {
        const {props: ga} = xt
          , ba = getVariantContext(xt.parent) || {}
          , yl = []
          , xl = new Set;
        let wl = {}
          , _l = 1 / 0;
        for (let Cl = 0; Cl < numAnimationTypes; Cl++) {
            const $l = reversePriorityOrder[Cl]
              , Sl = as[$l]
              , Tl = ga[$l] !== void 0 ? ga[$l] : ba[$l]
              , Rl = isVariantLabel(Tl)
              , Il = $l === Xs ? Sl.isActive : null;
            Il === !1 && (_l = Cl);
            let Ml = Tl === ba[$l] && Tl !== ga[$l] && Rl;
            if (Ml && cs && xt.manuallyAnimateOnMount && (Ml = !1),
            Sl.protectedKeys = {
                ...wl
            },
            !Sl.isActive && Il === null || !Tl && !Sl.prevProp || isAnimationControls(Tl) || typeof Tl == "boolean")
                continue;
            const Nl = checkVariantsDidChange(Sl.prevProp, Tl);
            let Ll = Nl || $l === Xs && Sl.isActive && !Ml && Rl || Cl > _l && Rl
              , Fl = !1;
            const Ul = Array.isArray(Tl) ? Tl : [Tl];
            let Dl = Ul.reduce(Cs($l), {});
            Il === !1 && (Dl = {});
            const {prevResolvedValues: Zl={}} = Sl
              , Gl = {
                ...Zl,
                ...Dl
            }
              , Wl = pu => {
                Ll = !0,
                xl.has(pu) && (Fl = !0,
                xl.delete(pu)),
                Sl.needsAnimating[pu] = !0;
                const zl = xt.getValue(pu);
                zl && (zl.liveStyle = !1)
            }
            ;
            for (const pu in Gl) {
                const zl = Dl[pu]
                  , Yl = Zl[pu];
                if (wl.hasOwnProperty(pu))
                    continue;
                let lu = !1;
                isKeyframesTarget(zl) && isKeyframesTarget(Yl) ? lu = !shallowCompare(zl, Yl) : lu = zl !== Yl,
                lu ? zl != null ? Wl(pu) : xl.add(pu) : zl !== void 0 && xl.has(pu) ? Wl(pu) : Sl.protectedKeys[pu] = !0
            }
            Sl.prevProp = Tl,
            Sl.prevResolvedValues = Dl,
            Sl.isActive && (wl = {
                ...wl,
                ...Dl
            }),
            cs && xt.blockInitialAnimation && (Ll = !1),
            Ll && (!(Ml && Nl) || Fl) && yl.push(...Ul.map(pu => ({
                animation: pu,
                options: {
                    type: $l
                }
            })))
        }
        if (xl.size) {
            const Cl = {};
            xl.forEach($l => {
                const Sl = xt.getBaseTarget($l)
                  , Tl = xt.getValue($l);
                Tl && (Tl.liveStyle = !0),
                Cl[$l] = Sl ?? null
            }
            ),
            yl.push({
                animation: Cl
            })
        }
        let El = !!yl.length;
        return cs && (ga.initial === !1 || ga.initial === ga.animate) && !xt.manuallyAnimateOnMount && (El = !1),
        cs = !1,
        El ? Cn(yl) : Promise.resolve()
    }
    function Ws(Xs, ga) {
        var ba;
        if (as[Xs].isActive === ga)
            return Promise.resolve();
        (ba = xt.variantChildren) === null || ba === void 0 || ba.forEach(xl => {
            var wl;
            return (wl = xl.animationState) === null || wl === void 0 ? void 0 : wl.setActive(Xs, ga)
        }
        ),
        as[Xs].isActive = ga;
        const yl = Vs(Xs);
        for (const xl in as)
            as[xl].protectedKeys = {};
        return yl
    }
    return {
        animateChanges: Vs,
        setActive: Ws,
        setAnimateFunction: Ls,
        getState: () => as,
        reset: () => {
            as = createState(),
            cs = !0
        }
    }
}
function checkVariantsDidChange(xt, Cn) {
    return typeof Cn == "string" ? Cn !== xt : Array.isArray(Cn) ? !shallowCompare(Cn, xt) : !1
}
function createTypeState(xt=!1) {
    return {
        isActive: xt,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}
function createState() {
    return {
        animate: createTypeState(!0),
        whileInView: createTypeState(),
        whileHover: createTypeState(),
        whileTap: createTypeState(),
        whileDrag: createTypeState(),
        whileFocus: createTypeState(),
        exit: createTypeState()
    }
}
class Feature {
    constructor(Cn) {
        this.isMounted = !1,
        this.node = Cn
    }
    update() {}
}
class AnimationFeature extends Feature {
    constructor(Cn) {
        super(Cn),
        Cn.animationState || (Cn.animationState = createAnimationState(Cn))
    }
    updateAnimationControlsSubscription() {
        const {animate: Cn} = this.node.getProps();
        isAnimationControls(Cn) && (this.unmountControls = Cn.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        const {animate: Cn} = this.node.getProps()
          , {animate: as} = this.node.prevProps || {};
        Cn !== as && this.updateAnimationControlsSubscription()
    }
    unmount() {
        var Cn;
        this.node.animationState.reset(),
        (Cn = this.unmountControls) === null || Cn === void 0 || Cn.call(this)
    }
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
    constructor() {
        super(...arguments),
        this.id = id$1++
    }
    update() {
        if (!this.node.presenceContext)
            return;
        const {isPresent: Cn, onExitComplete: as} = this.node.presenceContext
          , {isPresent: cs} = this.node.prevPresenceContext || {};
        if (!this.node.animationState || Cn === cs)
            return;
        const Cs = this.node.animationState.setActive("exit", !Cn);
        as && !Cn && Cs.then( () => as(this.id))
    }
    mount() {
        const {register: Cn} = this.node.presenceContext || {};
        Cn && (this.unmount = Cn(this.id))
    }
    unmount() {}
}
const animations = {
    animation: {
        Feature: AnimationFeature
    },
    exit: {
        Feature: ExitAnimationFeature
    }
};
function addDomEvent(xt, Cn, as, cs={
    passive: !0
}) {
    return xt.addEventListener(Cn, as, cs),
    () => xt.removeEventListener(Cn, as)
}
function extractEventInfo(xt) {
    return {
        point: {
            x: xt.pageX,
            y: xt.pageY
        }
    }
}
const addPointerInfo = xt => Cn => isPrimaryPointer(Cn) && xt(Cn, extractEventInfo(Cn));
function addPointerEvent(xt, Cn, as, cs) {
    return addDomEvent(xt, Cn, addPointerInfo(as), cs)
}
const distance = (xt, Cn) => Math.abs(xt - Cn);
function distance2D(xt, Cn) {
    const as = distance(xt.x, Cn.x)
      , cs = distance(xt.y, Cn.y);
    return Math.sqrt(as ** 2 + cs ** 2)
}
class PanSession {
    constructor(Cn, as, {transformPagePoint: cs, contextWindow: Cs, dragSnapToOrigin: Ls=!1}={}) {
        if (this.startEvent = null,
        this.lastMoveEvent = null,
        this.lastMoveEventInfo = null,
        this.handlers = {},
        this.contextWindow = window,
        this.updatePoint = () => {
            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const yl = getPanInfo(this.lastMoveEventInfo, this.history)
              , xl = this.startEvent !== null
              , wl = distance2D(yl.offset, {
                x: 0,
                y: 0
            }) >= 3;
            if (!xl && !wl)
                return;
            const {point: _l} = yl
              , {timestamp: El} = frameData;
            this.history.push({
                ..._l,
                timestamp: El
            });
            const {onStart: Cl, onMove: $l} = this.handlers;
            xl || (Cl && Cl(this.lastMoveEvent, yl),
            this.startEvent = this.lastMoveEvent),
            $l && $l(this.lastMoveEvent, yl)
        }
        ,
        this.handlePointerMove = (yl, xl) => {
            this.lastMoveEvent = yl,
            this.lastMoveEventInfo = transformPoint(xl, this.transformPagePoint),
            frame$1.update(this.updatePoint, !0)
        }
        ,
        this.handlePointerUp = (yl, xl) => {
            this.end();
            const {onEnd: wl, onSessionEnd: _l, resumeAnimation: El} = this.handlers;
            if (this.dragSnapToOrigin && El && El(),
            !(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const Cl = getPanInfo(yl.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(xl, this.transformPagePoint), this.history);
            this.startEvent && wl && wl(yl, Cl),
            _l && _l(yl, Cl)
        }
        ,
        !isPrimaryPointer(Cn))
            return;
        this.dragSnapToOrigin = Ls,
        this.handlers = as,
        this.transformPagePoint = cs,
        this.contextWindow = Cs || window;
        const Vs = extractEventInfo(Cn)
          , Ws = transformPoint(Vs, this.transformPagePoint)
          , {point: Xs} = Ws
          , {timestamp: ga} = frameData;
        this.history = [{
            ...Xs,
            timestamp: ga
        }];
        const {onSessionStart: ba} = as;
        ba && ba(Cn, getPanInfo(Ws, this.history)),
        this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(Cn) {
        this.handlers = Cn
    }
    end() {
        this.removeListeners && this.removeListeners(),
        cancelFrame(this.updatePoint)
    }
}
function transformPoint(xt, Cn) {
    return Cn ? {
        point: Cn(xt.point)
    } : xt
}
function subtractPoint(xt, Cn) {
    return {
        x: xt.x - Cn.x,
        y: xt.y - Cn.y
    }
}
function getPanInfo({point: xt}, Cn) {
    return {
        point: xt,
        delta: subtractPoint(xt, lastDevicePoint(Cn)),
        offset: subtractPoint(xt, startDevicePoint(Cn)),
        velocity: getVelocity(Cn, .1)
    }
}
function startDevicePoint(xt) {
    return xt[0]
}
function lastDevicePoint(xt) {
    return xt[xt.length - 1]
}
function getVelocity(xt, Cn) {
    if (xt.length < 2)
        return {
            x: 0,
            y: 0
        };
    let as = xt.length - 1
      , cs = null;
    const Cs = lastDevicePoint(xt);
    for (; as >= 0 && (cs = xt[as],
    !(Cs.timestamp - cs.timestamp > secondsToMilliseconds(Cn))); )
        as--;
    if (!cs)
        return {
            x: 0,
            y: 0
        };
    const Ls = millisecondsToSeconds(Cs.timestamp - cs.timestamp);
    if (Ls === 0)
        return {
            x: 0,
            y: 0
        };
    const Vs = {
        x: (Cs.x - cs.x) / Ls,
        y: (Cs.y - cs.y) / Ls
    };
    return Vs.x === 1 / 0 && (Vs.x = 0),
    Vs.y === 1 / 0 && (Vs.y = 0),
    Vs
}
const SCALE_PRECISION = 1e-4
  , SCALE_MIN = 1 - SCALE_PRECISION
  , SCALE_MAX = 1 + SCALE_PRECISION
  , TRANSLATE_PRECISION = .01
  , TRANSLATE_MIN = 0 - TRANSLATE_PRECISION
  , TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(xt) {
    return xt.max - xt.min
}
function isNear(xt, Cn, as) {
    return Math.abs(xt - Cn) <= as
}
function calcAxisDelta(xt, Cn, as, cs=.5) {
    xt.origin = cs,
    xt.originPoint = mixNumber$1(Cn.min, Cn.max, xt.origin),
    xt.scale = calcLength(as) / calcLength(Cn),
    xt.translate = mixNumber$1(as.min, as.max, xt.origin) - xt.originPoint,
    (xt.scale >= SCALE_MIN && xt.scale <= SCALE_MAX || isNaN(xt.scale)) && (xt.scale = 1),
    (xt.translate >= TRANSLATE_MIN && xt.translate <= TRANSLATE_MAX || isNaN(xt.translate)) && (xt.translate = 0)
}
function calcBoxDelta(xt, Cn, as, cs) {
    calcAxisDelta(xt.x, Cn.x, as.x, cs ? cs.originX : void 0),
    calcAxisDelta(xt.y, Cn.y, as.y, cs ? cs.originY : void 0)
}
function calcRelativeAxis(xt, Cn, as) {
    xt.min = as.min + Cn.min,
    xt.max = xt.min + calcLength(Cn)
}
function calcRelativeBox(xt, Cn, as) {
    calcRelativeAxis(xt.x, Cn.x, as.x),
    calcRelativeAxis(xt.y, Cn.y, as.y)
}
function calcRelativeAxisPosition(xt, Cn, as) {
    xt.min = Cn.min - as.min,
    xt.max = xt.min + calcLength(Cn)
}
function calcRelativePosition(xt, Cn, as) {
    calcRelativeAxisPosition(xt.x, Cn.x, as.x),
    calcRelativeAxisPosition(xt.y, Cn.y, as.y)
}
function applyConstraints(xt, {min: Cn, max: as}, cs) {
    return Cn !== void 0 && xt < Cn ? xt = cs ? mixNumber$1(Cn, xt, cs.min) : Math.max(xt, Cn) : as !== void 0 && xt > as && (xt = cs ? mixNumber$1(as, xt, cs.max) : Math.min(xt, as)),
    xt
}
function calcRelativeAxisConstraints(xt, Cn, as) {
    return {
        min: Cn !== void 0 ? xt.min + Cn : void 0,
        max: as !== void 0 ? xt.max + as - (xt.max - xt.min) : void 0
    }
}
function calcRelativeConstraints(xt, {top: Cn, left: as, bottom: cs, right: Cs}) {
    return {
        x: calcRelativeAxisConstraints(xt.x, as, Cs),
        y: calcRelativeAxisConstraints(xt.y, Cn, cs)
    }
}
function calcViewportAxisConstraints(xt, Cn) {
    let as = Cn.min - xt.min
      , cs = Cn.max - xt.max;
    return Cn.max - Cn.min < xt.max - xt.min && ([as,cs] = [cs, as]),
    {
        min: as,
        max: cs
    }
}
function calcViewportConstraints(xt, Cn) {
    return {
        x: calcViewportAxisConstraints(xt.x, Cn.x),
        y: calcViewportAxisConstraints(xt.y, Cn.y)
    }
}
function calcOrigin(xt, Cn) {
    let as = .5;
    const cs = calcLength(xt)
      , Cs = calcLength(Cn);
    return Cs > cs ? as = progress(Cn.min, Cn.max - cs, xt.min) : cs > Cs && (as = progress(xt.min, xt.max - Cs, Cn.min)),
    clamp$1(0, 1, as)
}
function rebaseAxisConstraints(xt, Cn) {
    const as = {};
    return Cn.min !== void 0 && (as.min = Cn.min - xt.min),
    Cn.max !== void 0 && (as.max = Cn.max - xt.min),
    as
}
const defaultElastic = .35;
function resolveDragElastic(xt=defaultElastic) {
    return xt === !1 ? xt = 0 : xt === !0 && (xt = defaultElastic),
    {
        x: resolveAxisElastic(xt, "left", "right"),
        y: resolveAxisElastic(xt, "top", "bottom")
    }
}
function resolveAxisElastic(xt, Cn, as) {
    return {
        min: resolvePointElastic(xt, Cn),
        max: resolvePointElastic(xt, as)
    }
}
function resolvePointElastic(xt, Cn) {
    return typeof xt == "number" ? xt : xt[Cn] || 0
}
const createAxisDelta = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
})
  , createDelta = () => ({
    x: createAxisDelta(),
    y: createAxisDelta()
})
  , createAxis = () => ({
    min: 0,
    max: 0
})
  , createBox = () => ({
    x: createAxis(),
    y: createAxis()
});
function eachAxis(xt) {
    return [xt("x"), xt("y")]
}
function convertBoundingBoxToBox({top: xt, left: Cn, right: as, bottom: cs}) {
    return {
        x: {
            min: Cn,
            max: as
        },
        y: {
            min: xt,
            max: cs
        }
    }
}
function convertBoxToBoundingBox({x: xt, y: Cn}) {
    return {
        top: Cn.min,
        right: xt.max,
        bottom: Cn.max,
        left: xt.min
    }
}
function transformBoxPoints(xt, Cn) {
    if (!Cn)
        return xt;
    const as = Cn({
        x: xt.left,
        y: xt.top
    })
      , cs = Cn({
        x: xt.right,
        y: xt.bottom
    });
    return {
        top: as.y,
        left: as.x,
        bottom: cs.y,
        right: cs.x
    }
}
function isIdentityScale(xt) {
    return xt === void 0 || xt === 1
}
function hasScale({scale: xt, scaleX: Cn, scaleY: as}) {
    return !isIdentityScale(xt) || !isIdentityScale(Cn) || !isIdentityScale(as)
}
function hasTransform(xt) {
    return hasScale(xt) || has2DTranslate(xt) || xt.z || xt.rotate || xt.rotateX || xt.rotateY || xt.skewX || xt.skewY
}
function has2DTranslate(xt) {
    return is2DTranslate(xt.x) || is2DTranslate(xt.y)
}
function is2DTranslate(xt) {
    return xt && xt !== "0%"
}
function scalePoint(xt, Cn, as) {
    const cs = xt - as
      , Cs = Cn * cs;
    return as + Cs
}
function applyPointDelta(xt, Cn, as, cs, Cs) {
    return Cs !== void 0 && (xt = scalePoint(xt, Cs, cs)),
    scalePoint(xt, as, cs) + Cn
}
function applyAxisDelta(xt, Cn=0, as=1, cs, Cs) {
    xt.min = applyPointDelta(xt.min, Cn, as, cs, Cs),
    xt.max = applyPointDelta(xt.max, Cn, as, cs, Cs)
}
function applyBoxDelta(xt, {x: Cn, y: as}) {
    applyAxisDelta(xt.x, Cn.translate, Cn.scale, Cn.originPoint),
    applyAxisDelta(xt.y, as.translate, as.scale, as.originPoint)
}
const TREE_SCALE_SNAP_MIN = .999999999999
  , TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(xt, Cn, as, cs=!1) {
    const Cs = as.length;
    if (!Cs)
        return;
    Cn.x = Cn.y = 1;
    let Ls, Vs;
    for (let Ws = 0; Ws < Cs; Ws++) {
        Ls = as[Ws],
        Vs = Ls.projectionDelta;
        const {visualElement: Xs} = Ls.options;
        Xs && Xs.props.style && Xs.props.style.display === "contents" || (cs && Ls.options.layoutScroll && Ls.scroll && Ls !== Ls.root && transformBox(xt, {
            x: -Ls.scroll.offset.x,
            y: -Ls.scroll.offset.y
        }),
        Vs && (Cn.x *= Vs.x.scale,
        Cn.y *= Vs.y.scale,
        applyBoxDelta(xt, Vs)),
        cs && hasTransform(Ls.latestValues) && transformBox(xt, Ls.latestValues))
    }
    Cn.x < TREE_SCALE_SNAP_MAX && Cn.x > TREE_SCALE_SNAP_MIN && (Cn.x = 1),
    Cn.y < TREE_SCALE_SNAP_MAX && Cn.y > TREE_SCALE_SNAP_MIN && (Cn.y = 1)
}
function translateAxis(xt, Cn) {
    xt.min = xt.min + Cn,
    xt.max = xt.max + Cn
}
function transformAxis(xt, Cn, as, cs, Cs=.5) {
    const Ls = mixNumber$1(xt.min, xt.max, Cs);
    applyAxisDelta(xt, Cn, as, Ls, cs)
}
function transformBox(xt, Cn) {
    transformAxis(xt.x, Cn.x, Cn.scaleX, Cn.scale, Cn.originX),
    transformAxis(xt.y, Cn.y, Cn.scaleY, Cn.scale, Cn.originY)
}
function measureViewportBox(xt, Cn) {
    return convertBoundingBoxToBox(transformBoxPoints(xt.getBoundingClientRect(), Cn))
}
function measurePageBox(xt, Cn, as) {
    const cs = measureViewportBox(xt, as)
      , {scroll: Cs} = Cn;
    return Cs && (translateAxis(cs.x, Cs.offset.x),
    translateAxis(cs.y, Cs.offset.y)),
    cs
}
const getContextWindow = ({current: xt}) => xt ? xt.ownerDocument.defaultView : null
  , elementDragControls = new WeakMap;
class VisualElementDragControls {
    constructor(Cn) {
        this.openDragLock = null,
        this.isDragging = !1,
        this.currentDirection = null,
        this.originPoint = {
            x: 0,
            y: 0
        },
        this.constraints = !1,
        this.hasMutatedConstraints = !1,
        this.elastic = createBox(),
        this.visualElement = Cn
    }
    start(Cn, {snapToCursor: as=!1}={}) {
        const {presenceContext: cs} = this.visualElement;
        if (cs && cs.isPresent === !1)
            return;
        const Cs = ba => {
            const {dragSnapToOrigin: yl} = this.getProps();
            yl ? this.pauseAnimation() : this.stopAnimation(),
            as && this.snapToCursor(extractEventInfo(ba).point)
        }
          , Ls = (ba, yl) => {
            const {drag: xl, dragPropagation: wl, onDragStart: _l} = this.getProps();
            if (xl && !wl && (this.openDragLock && this.openDragLock(),
            this.openDragLock = setDragLock(xl),
            !this.openDragLock))
                return;
            this.isDragging = !0,
            this.currentDirection = null,
            this.resolveConstraints(),
            this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0,
            this.visualElement.projection.target = void 0),
            eachAxis(Cl => {
                let $l = this.getAxisMotionValue(Cl).get() || 0;
                if (percent.test($l)) {
                    const {projection: Sl} = this.visualElement;
                    if (Sl && Sl.layout) {
                        const Tl = Sl.layout.layoutBox[Cl];
                        Tl && ($l = calcLength(Tl) * (parseFloat($l) / 100))
                    }
                }
                this.originPoint[Cl] = $l
            }
            ),
            _l && frame$1.postRender( () => _l(ba, yl)),
            addValueToWillChange(this.visualElement, "transform");
            const {animationState: El} = this.visualElement;
            El && El.setActive("whileDrag", !0)
        }
          , Vs = (ba, yl) => {
            const {dragPropagation: xl, dragDirectionLock: wl, onDirectionLock: _l, onDrag: El} = this.getProps();
            if (!xl && !this.openDragLock)
                return;
            const {offset: Cl} = yl;
            if (wl && this.currentDirection === null) {
                this.currentDirection = getCurrentDirection(Cl),
                this.currentDirection !== null && _l && _l(this.currentDirection);
                return
            }
            this.updateAxis("x", yl.point, Cl),
            this.updateAxis("y", yl.point, Cl),
            this.visualElement.render(),
            El && El(ba, yl)
        }
          , Ws = (ba, yl) => this.stop(ba, yl)
          , Xs = () => eachAxis(ba => {
            var yl;
            return this.getAnimationState(ba) === "paused" && ((yl = this.getAxisMotionValue(ba).animation) === null || yl === void 0 ? void 0 : yl.play())
        }
        )
          , {dragSnapToOrigin: ga} = this.getProps();
        this.panSession = new PanSession(Cn,{
            onSessionStart: Cs,
            onStart: Ls,
            onMove: Vs,
            onSessionEnd: Ws,
            resumeAnimation: Xs
        },{
            transformPagePoint: this.visualElement.getTransformPagePoint(),
            dragSnapToOrigin: ga,
            contextWindow: getContextWindow(this.visualElement)
        })
    }
    stop(Cn, as) {
        const cs = this.isDragging;
        if (this.cancel(),
        !cs)
            return;
        const {velocity: Cs} = as;
        this.startAnimation(Cs);
        const {onDragEnd: Ls} = this.getProps();
        Ls && frame$1.postRender( () => Ls(Cn, as))
    }
    cancel() {
        this.isDragging = !1;
        const {projection: Cn, animationState: as} = this.visualElement;
        Cn && (Cn.isAnimationBlocked = !1),
        this.panSession && this.panSession.end(),
        this.panSession = void 0;
        const {dragPropagation: cs} = this.getProps();
        !cs && this.openDragLock && (this.openDragLock(),
        this.openDragLock = null),
        as && as.setActive("whileDrag", !1)
    }
    updateAxis(Cn, as, cs) {
        const {drag: Cs} = this.getProps();
        if (!cs || !shouldDrag(Cn, Cs, this.currentDirection))
            return;
        const Ls = this.getAxisMotionValue(Cn);
        let Vs = this.originPoint[Cn] + cs[Cn];
        this.constraints && this.constraints[Cn] && (Vs = applyConstraints(Vs, this.constraints[Cn], this.elastic[Cn])),
        Ls.set(Vs)
    }
    resolveConstraints() {
        var Cn;
        const {dragConstraints: as, dragElastic: cs} = this.getProps()
          , Cs = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (Cn = this.visualElement.projection) === null || Cn === void 0 ? void 0 : Cn.layout
          , Ls = this.constraints;
        as && isRefObject(as) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : as && Cs ? this.constraints = calcRelativeConstraints(Cs.layoutBox, as) : this.constraints = !1,
        this.elastic = resolveDragElastic(cs),
        Ls !== this.constraints && Cs && this.constraints && !this.hasMutatedConstraints && eachAxis(Vs => {
            this.constraints !== !1 && this.getAxisMotionValue(Vs) && (this.constraints[Vs] = rebaseAxisConstraints(Cs.layoutBox[Vs], this.constraints[Vs]))
        }
        )
    }
    resolveRefConstraints() {
        const {dragConstraints: Cn, onMeasureDragConstraints: as} = this.getProps();
        if (!Cn || !isRefObject(Cn))
            return !1;
        const cs = Cn.current
          , {projection: Cs} = this.visualElement;
        if (!Cs || !Cs.layout)
            return !1;
        const Ls = measurePageBox(cs, Cs.root, this.visualElement.getTransformPagePoint());
        let Vs = calcViewportConstraints(Cs.layout.layoutBox, Ls);
        if (as) {
            const Ws = as(convertBoxToBoundingBox(Vs));
            this.hasMutatedConstraints = !!Ws,
            Ws && (Vs = convertBoundingBoxToBox(Ws))
        }
        return Vs
    }
    startAnimation(Cn) {
        const {drag: as, dragMomentum: cs, dragElastic: Cs, dragTransition: Ls, dragSnapToOrigin: Vs, onDragTransitionEnd: Ws} = this.getProps()
          , Xs = this.constraints || {}
          , ga = eachAxis(ba => {
            if (!shouldDrag(ba, as, this.currentDirection))
                return;
            let yl = Xs && Xs[ba] || {};
            Vs && (yl = {
                min: 0,
                max: 0
            });
            const xl = Cs ? 200 : 1e6
              , wl = Cs ? 40 : 1e7
              , _l = {
                type: "inertia",
                velocity: cs ? Cn[ba] : 0,
                bounceStiffness: xl,
                bounceDamping: wl,
                timeConstant: 750,
                restDelta: 1,
                restSpeed: 10,
                ...Ls,
                ...yl
            };
            return this.startAxisValueAnimation(ba, _l)
        }
        );
        return Promise.all(ga).then(Ws)
    }
    startAxisValueAnimation(Cn, as) {
        const cs = this.getAxisMotionValue(Cn);
        return addValueToWillChange(this.visualElement, Cn),
        cs.start(animateMotionValue(Cn, cs, 0, as, this.visualElement, !1))
    }
    stopAnimation() {
        eachAxis(Cn => this.getAxisMotionValue(Cn).stop())
    }
    pauseAnimation() {
        eachAxis(Cn => {
            var as;
            return (as = this.getAxisMotionValue(Cn).animation) === null || as === void 0 ? void 0 : as.pause()
        }
        )
    }
    getAnimationState(Cn) {
        var as;
        return (as = this.getAxisMotionValue(Cn).animation) === null || as === void 0 ? void 0 : as.state
    }
    getAxisMotionValue(Cn) {
        const as = `_drag${Cn.toUpperCase()}`
          , cs = this.visualElement.getProps()
          , Cs = cs[as];
        return Cs || this.visualElement.getValue(Cn, (cs.initial ? cs.initial[Cn] : void 0) || 0)
    }
    snapToCursor(Cn) {
        eachAxis(as => {
            const {drag: cs} = this.getProps();
            if (!shouldDrag(as, cs, this.currentDirection))
                return;
            const {projection: Cs} = this.visualElement
              , Ls = this.getAxisMotionValue(as);
            if (Cs && Cs.layout) {
                const {min: Vs, max: Ws} = Cs.layout.layoutBox[as];
                Ls.set(Cn[as] - mixNumber$1(Vs, Ws, .5))
            }
        }
        )
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current)
            return;
        const {drag: Cn, dragConstraints: as} = this.getProps()
          , {projection: cs} = this.visualElement;
        if (!isRefObject(as) || !cs || !this.constraints)
            return;
        this.stopAnimation();
        const Cs = {
            x: 0,
            y: 0
        };
        eachAxis(Vs => {
            const Ws = this.getAxisMotionValue(Vs);
            if (Ws && this.constraints !== !1) {
                const Xs = Ws.get();
                Cs[Vs] = calcOrigin({
                    min: Xs,
                    max: Xs
                }, this.constraints[Vs])
            }
        }
        );
        const {transformTemplate: Ls} = this.visualElement.getProps();
        this.visualElement.current.style.transform = Ls ? Ls({}, "") : "none",
        cs.root && cs.root.updateScroll(),
        cs.updateLayout(),
        this.resolveConstraints(),
        eachAxis(Vs => {
            if (!shouldDrag(Vs, Cn, null))
                return;
            const Ws = this.getAxisMotionValue(Vs)
              , {min: Xs, max: ga} = this.constraints[Vs];
            Ws.set(mixNumber$1(Xs, ga, Cs[Vs]))
        }
        )
    }
    addListeners() {
        if (!this.visualElement.current)
            return;
        elementDragControls.set(this.visualElement, this);
        const Cn = this.visualElement.current
          , as = addPointerEvent(Cn, "pointerdown", Xs => {
            const {drag: ga, dragListener: ba=!0} = this.getProps();
            ga && ba && this.start(Xs)
        }
        )
          , cs = () => {
            const {dragConstraints: Xs} = this.getProps();
            isRefObject(Xs) && Xs.current && (this.constraints = this.resolveRefConstraints())
        }
          , {projection: Cs} = this.visualElement
          , Ls = Cs.addEventListener("measure", cs);
        Cs && !Cs.layout && (Cs.root && Cs.root.updateScroll(),
        Cs.updateLayout()),
        frame$1.read(cs);
        const Vs = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints())
          , Ws = Cs.addEventListener("didUpdate", ({delta: Xs, hasLayoutChanged: ga}) => {
            this.isDragging && ga && (eachAxis(ba => {
                const yl = this.getAxisMotionValue(ba);
                yl && (this.originPoint[ba] += Xs[ba].translate,
                yl.set(yl.get() + Xs[ba].translate))
            }
            ),
            this.visualElement.render())
        }
        );
        return () => {
            Vs(),
            as(),
            Ls(),
            Ws && Ws()
        }
    }
    getProps() {
        const Cn = this.visualElement.getProps()
          , {drag: as=!1, dragDirectionLock: cs=!1, dragPropagation: Cs=!1, dragConstraints: Ls=!1, dragElastic: Vs=defaultElastic, dragMomentum: Ws=!0} = Cn;
        return {
            ...Cn,
            drag: as,
            dragDirectionLock: cs,
            dragPropagation: Cs,
            dragConstraints: Ls,
            dragElastic: Vs,
            dragMomentum: Ws
        }
    }
}
function shouldDrag(xt, Cn, as) {
    return (Cn === !0 || Cn === xt) && (as === null || as === xt)
}
function getCurrentDirection(xt, Cn=10) {
    let as = null;
    return Math.abs(xt.y) > Cn ? as = "y" : Math.abs(xt.x) > Cn && (as = "x"),
    as
}
class DragGesture extends Feature {
    constructor(Cn) {
        super(Cn),
        this.removeGroupControls = noop$3,
        this.removeListeners = noop$3,
        this.controls = new VisualElementDragControls(Cn)
    }
    mount() {
        const {dragControls: Cn} = this.node.getProps();
        Cn && (this.removeGroupControls = Cn.subscribe(this.controls)),
        this.removeListeners = this.controls.addListeners() || noop$3
    }
    unmount() {
        this.removeGroupControls(),
        this.removeListeners()
    }
}
const asyncHandler = xt => (Cn, as) => {
    xt && frame$1.postRender( () => xt(Cn, as))
}
;
class PanGesture extends Feature {
    constructor() {
        super(...arguments),
        this.removePointerDownListener = noop$3
    }
    onPointerDown(Cn) {
        this.session = new PanSession(Cn,this.createPanHandlers(),{
            transformPagePoint: this.node.getTransformPagePoint(),
            contextWindow: getContextWindow(this.node)
        })
    }
    createPanHandlers() {
        const {onPanSessionStart: Cn, onPanStart: as, onPan: cs, onPanEnd: Cs} = this.node.getProps();
        return {
            onSessionStart: asyncHandler(Cn),
            onStart: asyncHandler(as),
            onMove: cs,
            onEnd: (Ls, Vs) => {
                delete this.session,
                Cs && frame$1.postRender( () => Cs(Ls, Vs))
            }
        }
    }
    mount() {
        this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", Cn => this.onPointerDown(Cn))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(),
        this.session && this.session.end()
    }
}
const globalProjectionState = {
    hasAnimatedSinceResize: !0,
    hasEverUpdated: !1
};
function pixelsToPercent(xt, Cn) {
    return Cn.max === Cn.min ? 0 : xt / (Cn.max - Cn.min) * 100
}
const correctBorderRadius = {
    correct: (xt, Cn) => {
        if (!Cn.target)
            return xt;
        if (typeof xt == "string")
            if (px.test(xt))
                xt = parseFloat(xt);
            else
                return xt;
        const as = pixelsToPercent(xt, Cn.target.x)
          , cs = pixelsToPercent(xt, Cn.target.y);
        return `${as}% ${cs}%`
    }
}
  , correctBoxShadow = {
    correct: (xt, {treeScale: Cn, projectionDelta: as}) => {
        const cs = xt
          , Cs = complex.parse(xt);
        if (Cs.length > 5)
            return cs;
        const Ls = complex.createTransformer(xt)
          , Vs = typeof Cs[0] != "number" ? 1 : 0
          , Ws = as.x.scale * Cn.x
          , Xs = as.y.scale * Cn.y;
        Cs[0 + Vs] /= Ws,
        Cs[1 + Vs] /= Xs;
        const ga = mixNumber$1(Ws, Xs, .5);
        return typeof Cs[2 + Vs] == "number" && (Cs[2 + Vs] /= ga),
        typeof Cs[3 + Vs] == "number" && (Cs[3 + Vs] /= ga),
        Ls(Cs)
    }
};
class MeasureLayoutWithContext extends reactExports.Component {
    componentDidMount() {
        const {visualElement: Cn, layoutGroup: as, switchLayoutGroup: cs, layoutId: Cs} = this.props
          , {projection: Ls} = Cn;
        addScaleCorrector(defaultScaleCorrectors),
        Ls && (as.group && as.group.add(Ls),
        cs && cs.register && Cs && cs.register(Ls),
        Ls.root.didUpdate(),
        Ls.addEventListener("animationComplete", () => {
            this.safeToRemove()
        }
        ),
        Ls.setOptions({
            ...Ls.options,
            onExitComplete: () => this.safeToRemove()
        })),
        globalProjectionState.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(Cn) {
        const {layoutDependency: as, visualElement: cs, drag: Cs, isPresent: Ls} = this.props
          , Vs = cs.projection;
        return Vs && (Vs.isPresent = Ls,
        Cs || Cn.layoutDependency !== as || as === void 0 ? Vs.willUpdate() : this.safeToRemove(),
        Cn.isPresent !== Ls && (Ls ? Vs.promote() : Vs.relegate() || frame$1.postRender( () => {
            const Ws = Vs.getStack();
            (!Ws || !Ws.members.length) && this.safeToRemove()
        }
        ))),
        null
    }
    componentDidUpdate() {
        const {projection: Cn} = this.props.visualElement;
        Cn && (Cn.root.didUpdate(),
        microtask.postRender( () => {
            !Cn.currentAnimation && Cn.isLead() && this.safeToRemove()
        }
        ))
    }
    componentWillUnmount() {
        const {visualElement: Cn, layoutGroup: as, switchLayoutGroup: cs} = this.props
          , {projection: Cs} = Cn;
        Cs && (Cs.scheduleCheckAfterUnmount(),
        as && as.group && as.group.remove(Cs),
        cs && cs.deregister && cs.deregister(Cs))
    }
    safeToRemove() {
        const {safeToRemove: Cn} = this.props;
        Cn && Cn()
    }
    render() {
        return null
    }
}
function MeasureLayout(xt) {
    const [Cn,as] = usePresence()
      , cs = reactExports.useContext(LayoutGroupContext);
    return jsxRuntimeExports.jsx(MeasureLayoutWithContext, {
        ...xt,
        layoutGroup: cs,
        switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext),
        isPresent: Cn,
        safeToRemove: as
    })
}
const defaultScaleCorrectors = {
    borderRadius: {
        ...correctBorderRadius,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
    },
    borderTopLeftRadius: correctBorderRadius,
    borderTopRightRadius: correctBorderRadius,
    borderBottomLeftRadius: correctBorderRadius,
    borderBottomRightRadius: correctBorderRadius,
    boxShadow: correctBoxShadow
};
function animateSingleValue(xt, Cn, as) {
    const cs = isMotionValue(xt) ? xt : motionValue(xt);
    return cs.start(animateMotionValue("", cs, Cn, as)),
    cs.animation
}
function isSVGElement(xt) {
    return xt instanceof SVGElement && xt.tagName !== "svg"
}
const compareByDepth = (xt, Cn) => xt.depth - Cn.depth;
class FlatTree {
    constructor() {
        this.children = [],
        this.isDirty = !1
    }
    add(Cn) {
        addUniqueItem(this.children, Cn),
        this.isDirty = !0
    }
    remove(Cn) {
        removeItem(this.children, Cn),
        this.isDirty = !0
    }
    forEach(Cn) {
        this.isDirty && this.children.sort(compareByDepth),
        this.isDirty = !1,
        this.children.forEach(Cn)
    }
}
function delay(xt, Cn) {
    const as = time.now()
      , cs = ({timestamp: Cs}) => {
        const Ls = Cs - as;
        Ls >= Cn && (cancelFrame(cs),
        xt(Ls - Cn))
    }
    ;
    return frame$1.read(cs, !0),
    () => cancelFrame(cs)
}
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"]
  , numBorders = borders.length
  , asNumber = xt => typeof xt == "string" ? parseFloat(xt) : xt
  , isPx = xt => typeof xt == "number" || px.test(xt);
function mixValues(xt, Cn, as, cs, Cs, Ls) {
    Cs ? (xt.opacity = mixNumber$1(0, as.opacity !== void 0 ? as.opacity : 1, easeCrossfadeIn(cs)),
    xt.opacityExit = mixNumber$1(Cn.opacity !== void 0 ? Cn.opacity : 1, 0, easeCrossfadeOut(cs))) : Ls && (xt.opacity = mixNumber$1(Cn.opacity !== void 0 ? Cn.opacity : 1, as.opacity !== void 0 ? as.opacity : 1, cs));
    for (let Vs = 0; Vs < numBorders; Vs++) {
        const Ws = `border${borders[Vs]}Radius`;
        let Xs = getRadius(Cn, Ws)
          , ga = getRadius(as, Ws);
        if (Xs === void 0 && ga === void 0)
            continue;
        Xs || (Xs = 0),
        ga || (ga = 0),
        Xs === 0 || ga === 0 || isPx(Xs) === isPx(ga) ? (xt[Ws] = Math.max(mixNumber$1(asNumber(Xs), asNumber(ga), cs), 0),
        (percent.test(ga) || percent.test(Xs)) && (xt[Ws] += "%")) : xt[Ws] = ga
    }
    (Cn.rotate || as.rotate) && (xt.rotate = mixNumber$1(Cn.rotate || 0, as.rotate || 0, cs))
}
function getRadius(xt, Cn) {
    return xt[Cn] !== void 0 ? xt[Cn] : xt.borderRadius
}
const easeCrossfadeIn = compress(0, .5, circOut)
  , easeCrossfadeOut = compress(.5, .95, noop$3);
function compress(xt, Cn, as) {
    return cs => cs < xt ? 0 : cs > Cn ? 1 : as(progress(xt, Cn, cs))
}
function copyAxisInto(xt, Cn) {
    xt.min = Cn.min,
    xt.max = Cn.max
}
function copyBoxInto(xt, Cn) {
    copyAxisInto(xt.x, Cn.x),
    copyAxisInto(xt.y, Cn.y)
}
function copyAxisDeltaInto(xt, Cn) {
    xt.translate = Cn.translate,
    xt.scale = Cn.scale,
    xt.originPoint = Cn.originPoint,
    xt.origin = Cn.origin
}
function removePointDelta(xt, Cn, as, cs, Cs) {
    return xt -= Cn,
    xt = scalePoint(xt, 1 / as, cs),
    Cs !== void 0 && (xt = scalePoint(xt, 1 / Cs, cs)),
    xt
}
function removeAxisDelta(xt, Cn=0, as=1, cs=.5, Cs, Ls=xt, Vs=xt) {
    if (percent.test(Cn) && (Cn = parseFloat(Cn),
    Cn = mixNumber$1(Vs.min, Vs.max, Cn / 100) - Vs.min),
    typeof Cn != "number")
        return;
    let Ws = mixNumber$1(Ls.min, Ls.max, cs);
    xt === Ls && (Ws -= Cn),
    xt.min = removePointDelta(xt.min, Cn, as, Ws, Cs),
    xt.max = removePointDelta(xt.max, Cn, as, Ws, Cs)
}
function removeAxisTransforms(xt, Cn, [as,cs,Cs], Ls, Vs) {
    removeAxisDelta(xt, Cn[as], Cn[cs], Cn[Cs], Cn.scale, Ls, Vs)
}
const xKeys = ["x", "scaleX", "originX"]
  , yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(xt, Cn, as, cs) {
    removeAxisTransforms(xt.x, Cn, xKeys, as ? as.x : void 0, cs ? cs.x : void 0),
    removeAxisTransforms(xt.y, Cn, yKeys, as ? as.y : void 0, cs ? cs.y : void 0)
}
function isAxisDeltaZero(xt) {
    return xt.translate === 0 && xt.scale === 1
}
function isDeltaZero(xt) {
    return isAxisDeltaZero(xt.x) && isAxisDeltaZero(xt.y)
}
function axisEquals(xt, Cn) {
    return xt.min === Cn.min && xt.max === Cn.max
}
function boxEquals(xt, Cn) {
    return axisEquals(xt.x, Cn.x) && axisEquals(xt.y, Cn.y)
}
function axisEqualsRounded(xt, Cn) {
    return Math.round(xt.min) === Math.round(Cn.min) && Math.round(xt.max) === Math.round(Cn.max)
}
function boxEqualsRounded(xt, Cn) {
    return axisEqualsRounded(xt.x, Cn.x) && axisEqualsRounded(xt.y, Cn.y)
}
function aspectRatio(xt) {
    return calcLength(xt.x) / calcLength(xt.y)
}
function axisDeltaEquals(xt, Cn) {
    return xt.translate === Cn.translate && xt.scale === Cn.scale && xt.originPoint === Cn.originPoint
}
class NodeStack {
    constructor() {
        this.members = []
    }
    add(Cn) {
        addUniqueItem(this.members, Cn),
        Cn.scheduleRender()
    }
    remove(Cn) {
        if (removeItem(this.members, Cn),
        Cn === this.prevLead && (this.prevLead = void 0),
        Cn === this.lead) {
            const as = this.members[this.members.length - 1];
            as && this.promote(as)
        }
    }
    relegate(Cn) {
        const as = this.members.findIndex(Cs => Cn === Cs);
        if (as === 0)
            return !1;
        let cs;
        for (let Cs = as; Cs >= 0; Cs--) {
            const Ls = this.members[Cs];
            if (Ls.isPresent !== !1) {
                cs = Ls;
                break
            }
        }
        return cs ? (this.promote(cs),
        !0) : !1
    }
    promote(Cn, as) {
        const cs = this.lead;
        if (Cn !== cs && (this.prevLead = cs,
        this.lead = Cn,
        Cn.show(),
        cs)) {
            cs.instance && cs.scheduleRender(),
            Cn.scheduleRender(),
            Cn.resumeFrom = cs,
            as && (Cn.resumeFrom.preserveOpacity = !0),
            cs.snapshot && (Cn.snapshot = cs.snapshot,
            Cn.snapshot.latestValues = cs.animationValues || cs.latestValues),
            Cn.root && Cn.root.isUpdating && (Cn.isLayoutDirty = !0);
            const {crossfade: Cs} = Cn.options;
            Cs === !1 && cs.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(Cn => {
            const {options: as, resumingFrom: cs} = Cn;
            as.onExitComplete && as.onExitComplete(),
            cs && cs.options.onExitComplete && cs.options.onExitComplete()
        }
        )
    }
    scheduleRender() {
        this.members.forEach(Cn => {
            Cn.instance && Cn.scheduleRender(!1)
        }
        )
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}
function buildProjectionTransform(xt, Cn, as) {
    let cs = "";
    const Cs = xt.x.translate / Cn.x
      , Ls = xt.y.translate / Cn.y
      , Vs = (as == null ? void 0 : as.z) || 0;
    if ((Cs || Ls || Vs) && (cs = `translate3d(${Cs}px, ${Ls}px, ${Vs}px) `),
    (Cn.x !== 1 || Cn.y !== 1) && (cs += `scale(${1 / Cn.x}, ${1 / Cn.y}) `),
    as) {
        const {transformPerspective: ga, rotate: ba, rotateX: yl, rotateY: xl, skewX: wl, skewY: _l} = as;
        ga && (cs = `perspective(${ga}px) ${cs}`),
        ba && (cs += `rotate(${ba}deg) `),
        yl && (cs += `rotateX(${yl}deg) `),
        xl && (cs += `rotateY(${xl}deg) `),
        wl && (cs += `skewX(${wl}deg) `),
        _l && (cs += `skewY(${_l}deg) `)
    }
    const Ws = xt.x.scale * Cn.x
      , Xs = xt.y.scale * Cn.y;
    return (Ws !== 1 || Xs !== 1) && (cs += `scale(${Ws}, ${Xs})`),
    cs || "none"
}
const metrics = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0
}
  , isDebug = typeof window < "u" && window.MotionDebug !== void 0
  , transformAxes = ["", "X", "Y", "Z"]
  , hiddenVisibility = {
    visibility: "hidden"
}
  , animationTarget = 1e3;
let id = 0;
function resetDistortingTransform(xt, Cn, as, cs) {
    const {latestValues: Cs} = Cn;
    Cs[xt] && (as[xt] = Cs[xt],
    Cn.setStaticValue(xt, 0),
    cs && (cs[xt] = 0))
}
function cancelTreeOptimisedTransformAnimations(xt) {
    if (xt.hasCheckedOptimisedAppear = !0,
    xt.root === xt)
        return;
    const {visualElement: Cn} = xt.options;
    if (!Cn)
        return;
    const as = getOptimisedAppearId(Cn);
    if (window.MotionHasOptimisedAnimation(as, "transform")) {
        const {layout: Cs, layoutId: Ls} = xt.options;
        window.MotionCancelOptimisedAnimation(as, "transform", frame$1, !(Cs || Ls))
    }
    const {parent: cs} = xt;
    cs && !cs.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(cs)
}
function createProjectionNode({attachResizeListener: xt, defaultParent: Cn, measureScroll: as, checkIsScrollRoot: cs, resetTransform: Cs}) {
    return class {
        constructor(Vs={}, Ws=Cn == null ? void 0 : Cn()) {
            this.id = id++,
            this.animationId = 0,
            this.children = new Set,
            this.options = {},
            this.isTreeAnimating = !1,
            this.isAnimationBlocked = !1,
            this.isLayoutDirty = !1,
            this.isProjectionDirty = !1,
            this.isSharedProjectionDirty = !1,
            this.isTransformDirty = !1,
            this.updateManuallyBlocked = !1,
            this.updateBlockedByResize = !1,
            this.isUpdating = !1,
            this.isSVG = !1,
            this.needsReset = !1,
            this.shouldResetTransform = !1,
            this.hasCheckedOptimisedAppear = !1,
            this.treeScale = {
                x: 1,
                y: 1
            },
            this.eventHandlers = new Map,
            this.hasTreeAnimated = !1,
            this.updateScheduled = !1,
            this.scheduleUpdate = () => this.update(),
            this.projectionUpdateScheduled = !1,
            this.checkUpdateFailed = () => {
                this.isUpdating && (this.isUpdating = !1,
                this.clearAllSnapshots())
            }
            ,
            this.updateProjection = () => {
                this.projectionUpdateScheduled = !1,
                isDebug && (metrics.totalNodes = metrics.resolvedTargetDeltas = metrics.recalculatedProjection = 0),
                this.nodes.forEach(propagateDirtyNodes),
                this.nodes.forEach(resolveTargetDelta),
                this.nodes.forEach(calcProjection),
                this.nodes.forEach(cleanDirtyNodes),
                isDebug && window.MotionDebug.record(metrics)
            }
            ,
            this.resolvedRelativeTargetAt = 0,
            this.hasProjected = !1,
            this.isVisible = !0,
            this.animationProgress = 0,
            this.sharedNodes = new Map,
            this.latestValues = Vs,
            this.root = Ws ? Ws.root || Ws : this,
            this.path = Ws ? [...Ws.path, Ws] : [],
            this.parent = Ws,
            this.depth = Ws ? Ws.depth + 1 : 0;
            for (let Xs = 0; Xs < this.path.length; Xs++)
                this.path[Xs].shouldResetTransform = !0;
            this.root === this && (this.nodes = new FlatTree)
        }
        addEventListener(Vs, Ws) {
            return this.eventHandlers.has(Vs) || this.eventHandlers.set(Vs, new SubscriptionManager),
            this.eventHandlers.get(Vs).add(Ws)
        }
        notifyListeners(Vs, ...Ws) {
            const Xs = this.eventHandlers.get(Vs);
            Xs && Xs.notify(...Ws)
        }
        hasListeners(Vs) {
            return this.eventHandlers.has(Vs)
        }
        mount(Vs, Ws=this.root.hasTreeAnimated) {
            if (this.instance)
                return;
            this.isSVG = isSVGElement(Vs),
            this.instance = Vs;
            const {layoutId: Xs, layout: ga, visualElement: ba} = this.options;
            if (ba && !ba.current && ba.mount(Vs),
            this.root.nodes.add(this),
            this.parent && this.parent.children.add(this),
            Ws && (ga || Xs) && (this.isLayoutDirty = !0),
            xt) {
                let yl;
                const xl = () => this.root.updateBlockedByResize = !1;
                xt(Vs, () => {
                    this.root.updateBlockedByResize = !0,
                    yl && yl(),
                    yl = delay(xl, 250),
                    globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1,
                    this.nodes.forEach(finishAnimation))
                }
                )
            }
            Xs && this.root.registerSharedNode(Xs, this),
            this.options.animate !== !1 && ba && (Xs || ga) && this.addEventListener("didUpdate", ({delta: yl, hasLayoutChanged: xl, hasRelativeTargetChanged: wl, layout: _l}) => {
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0,
                    this.relativeTarget = void 0;
                    return
                }
                const El = this.options.transition || ba.getDefaultTransition() || defaultLayoutTransition
                  , {onLayoutAnimationStart: Cl, onLayoutAnimationComplete: $l} = ba.getProps()
                  , Sl = !this.targetLayout || !boxEqualsRounded(this.targetLayout, _l) || wl
                  , Tl = !xl && wl;
                if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || Tl || xl && (Sl || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom,
                    this.resumingFrom.resumingFrom = void 0),
                    this.setAnimationOrigin(yl, Tl);
                    const Rl = {
                        ...getValueTransition(El, "layout"),
                        onPlay: Cl,
                        onComplete: $l
                    };
                    (ba.shouldReduceMotion || this.options.layoutRoot) && (Rl.delay = 0,
                    Rl.type = !1),
                    this.startAnimation(Rl)
                } else
                    xl || finishAnimation(this),
                    this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = _l
            }
            )
        }
        unmount() {
            this.options.layoutId && this.willUpdate(),
            this.root.nodes.remove(this);
            const Vs = this.getStack();
            Vs && Vs.remove(this),
            this.parent && this.parent.children.delete(this),
            this.instance = void 0,
            cancelFrame(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0,
            this.nodes && this.nodes.forEach(resetSkewAndRotation),
            this.animationId++)
        }
        getTransformTemplate() {
            const {visualElement: Vs} = this.options;
            return Vs && Vs.getProps().transformTemplate
        }
        willUpdate(Vs=!0) {
            if (this.root.hasTreeAnimated = !0,
            this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(this),
            !this.root.isUpdating && this.root.startUpdate(),
            this.isLayoutDirty)
                return;
            this.isLayoutDirty = !0;
            for (let ba = 0; ba < this.path.length; ba++) {
                const yl = this.path[ba];
                yl.shouldResetTransform = !0,
                yl.updateScroll("snapshot"),
                yl.options.layoutRoot && yl.willUpdate(!1)
            }
            const {layoutId: Ws, layout: Xs} = this.options;
            if (Ws === void 0 && !Xs)
                return;
            const ga = this.getTransformTemplate();
            this.prevTransformTemplateValue = ga ? ga(this.latestValues, "") : void 0,
            this.updateSnapshot(),
            Vs && this.notifyListeners("willUpdate")
        }
        update() {
            if (this.updateScheduled = !1,
            this.isUpdateBlocked()) {
                this.unblockUpdate(),
                this.clearAllSnapshots(),
                this.nodes.forEach(clearMeasurements);
                return
            }
            this.isUpdating || this.nodes.forEach(clearIsLayoutDirty),
            this.isUpdating = !1,
            this.nodes.forEach(resetTransformStyle),
            this.nodes.forEach(updateLayout),
            this.nodes.forEach(notifyLayoutUpdate),
            this.clearAllSnapshots();
            const Ws = time.now();
            frameData.delta = clamp$1(0, 1e3 / 60, Ws - frameData.timestamp),
            frameData.timestamp = Ws,
            frameData.isProcessing = !0,
            frameSteps.update.process(frameData),
            frameSteps.preRender.process(frameData),
            frameSteps.render.process(frameData),
            frameData.isProcessing = !1
        }
        didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0,
            microtask.read(this.scheduleUpdate))
        }
        clearAllSnapshots() {
            this.nodes.forEach(clearSnapshot),
            this.sharedNodes.forEach(removeLeadSnapshots)
        }
        scheduleUpdateProjection() {
            this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0,
            frame$1.preRender(this.updateProjection, !1, !0))
        }
        scheduleCheckAfterUnmount() {
            frame$1.postRender( () => {
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            }
            )
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure())
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(),
            !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
                return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let Xs = 0; Xs < this.path.length; Xs++)
                    this.path[Xs].updateScroll();
            const Vs = this.layout;
            this.layout = this.measure(!1),
            this.layoutCorrected = createBox(),
            this.isLayoutDirty = !1,
            this.projectionDelta = void 0,
            this.notifyListeners("measure", this.layout.layoutBox);
            const {visualElement: Ws} = this.options;
            Ws && Ws.notify("LayoutMeasure", this.layout.layoutBox, Vs ? Vs.layoutBox : void 0)
        }
        updateScroll(Vs="measure") {
            let Ws = !!(this.options.layoutScroll && this.instance);
            if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === Vs && (Ws = !1),
            Ws) {
                const Xs = cs(this.instance);
                this.scroll = {
                    animationId: this.root.animationId,
                    phase: Vs,
                    isRoot: Xs,
                    offset: as(this.instance),
                    wasRoot: this.scroll ? this.scroll.isRoot : Xs
                }
            }
        }
        resetTransform() {
            if (!Cs)
                return;
            const Vs = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout
              , Ws = this.projectionDelta && !isDeltaZero(this.projectionDelta)
              , Xs = this.getTransformTemplate()
              , ga = Xs ? Xs(this.latestValues, "") : void 0
              , ba = ga !== this.prevTransformTemplateValue;
            Vs && (Ws || hasTransform(this.latestValues) || ba) && (Cs(this.instance, ga),
            this.shouldResetTransform = !1,
            this.scheduleRender())
        }
        measure(Vs=!0) {
            const Ws = this.measurePageBox();
            let Xs = this.removeElementScroll(Ws);
            return Vs && (Xs = this.removeTransform(Xs)),
            roundBox(Xs),
            {
                animationId: this.root.animationId,
                measuredBox: Ws,
                layoutBox: Xs,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            var Vs;
            const {visualElement: Ws} = this.options;
            if (!Ws)
                return createBox();
            const Xs = Ws.measureViewportBox();
            if (!(((Vs = this.scroll) === null || Vs === void 0 ? void 0 : Vs.wasRoot) || this.path.some(checkNodeWasScrollRoot))) {
                const {scroll: ba} = this.root;
                ba && (translateAxis(Xs.x, ba.offset.x),
                translateAxis(Xs.y, ba.offset.y))
            }
            return Xs
        }
        removeElementScroll(Vs) {
            var Ws;
            const Xs = createBox();
            if (copyBoxInto(Xs, Vs),
            !((Ws = this.scroll) === null || Ws === void 0) && Ws.wasRoot)
                return Xs;
            for (let ga = 0; ga < this.path.length; ga++) {
                const ba = this.path[ga]
                  , {scroll: yl, options: xl} = ba;
                ba !== this.root && yl && xl.layoutScroll && (yl.wasRoot && copyBoxInto(Xs, Vs),
                translateAxis(Xs.x, yl.offset.x),
                translateAxis(Xs.y, yl.offset.y))
            }
            return Xs
        }
        applyTransform(Vs, Ws=!1) {
            const Xs = createBox();
            copyBoxInto(Xs, Vs);
            for (let ga = 0; ga < this.path.length; ga++) {
                const ba = this.path[ga];
                !Ws && ba.options.layoutScroll && ba.scroll && ba !== ba.root && transformBox(Xs, {
                    x: -ba.scroll.offset.x,
                    y: -ba.scroll.offset.y
                }),
                hasTransform(ba.latestValues) && transformBox(Xs, ba.latestValues)
            }
            return hasTransform(this.latestValues) && transformBox(Xs, this.latestValues),
            Xs
        }
        removeTransform(Vs) {
            const Ws = createBox();
            copyBoxInto(Ws, Vs);
            for (let Xs = 0; Xs < this.path.length; Xs++) {
                const ga = this.path[Xs];
                if (!ga.instance || !hasTransform(ga.latestValues))
                    continue;
                hasScale(ga.latestValues) && ga.updateSnapshot();
                const ba = createBox()
                  , yl = ga.measurePageBox();
                copyBoxInto(ba, yl),
                removeBoxTransforms(Ws, ga.latestValues, ga.snapshot ? ga.snapshot.layoutBox : void 0, ba)
            }
            return hasTransform(this.latestValues) && removeBoxTransforms(Ws, this.latestValues),
            Ws
        }
        setTargetDelta(Vs) {
            this.targetDelta = Vs,
            this.root.scheduleUpdateProjection(),
            this.isProjectionDirty = !0
        }
        setOptions(Vs) {
            this.options = {
                ...this.options,
                ...Vs,
                crossfade: Vs.crossfade !== void 0 ? Vs.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0,
            this.layout = void 0,
            this.snapshot = void 0,
            this.prevTransformTemplateValue = void 0,
            this.targetDelta = void 0,
            this.target = void 0,
            this.isLayoutDirty = !1
        }
        forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }
        resolveTargetDelta(Vs=!1) {
            var Ws;
            const Xs = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = Xs.isProjectionDirty),
            this.isTransformDirty || (this.isTransformDirty = Xs.isTransformDirty),
            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = Xs.isSharedProjectionDirty);
            const ga = !!this.resumingFrom || this !== Xs;
            if (!(Vs || ga && this.isSharedProjectionDirty || this.isProjectionDirty || !((Ws = this.parent) === null || Ws === void 0) && Ws.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
                return;
            const {layout: yl, layoutId: xl} = this.options;
            if (!(!this.layout || !(yl || xl))) {
                if (this.resolvedRelativeTargetAt = frameData.timestamp,
                !this.targetDelta && !this.relativeTarget) {
                    const wl = this.getClosestProjectingParent();
                    wl && wl.layout && this.animationProgress !== 1 ? (this.relativeParent = wl,
                    this.forceRelativeParentToResolveTarget(),
                    this.relativeTarget = createBox(),
                    this.relativeTargetOrigin = createBox(),
                    calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, wl.layout.layoutBox),
                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta)) {
                    if (this.target || (this.target = createBox(),
                    this.targetWithTransforms = createBox()),
                    this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(),
                    calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox),
                    applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox),
                    this.attemptToResolveRelativeTarget) {
                        this.attemptToResolveRelativeTarget = !1;
                        const wl = this.getClosestProjectingParent();
                        wl && !!wl.resumingFrom == !!this.resumingFrom && !wl.options.layoutScroll && wl.target && this.animationProgress !== 1 ? (this.relativeParent = wl,
                        this.forceRelativeParentToResolveTarget(),
                        this.relativeTarget = createBox(),
                        this.relativeTargetOrigin = createBox(),
                        calcRelativePosition(this.relativeTargetOrigin, this.target, wl.target),
                        copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    isDebug && metrics.resolvedTargetDeltas++
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)))
                return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var Vs;
            const Ws = this.getLead()
              , Xs = !!this.resumingFrom || this !== Ws;
            let ga = !0;
            if ((this.isProjectionDirty || !((Vs = this.parent) === null || Vs === void 0) && Vs.isProjectionDirty) && (ga = !1),
            Xs && (this.isSharedProjectionDirty || this.isTransformDirty) && (ga = !1),
            this.resolvedRelativeTargetAt === frameData.timestamp && (ga = !1),
            ga)
                return;
            const {layout: ba, layoutId: yl} = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation),
            this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
            !this.layout || !(ba || yl))
                return;
            copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
            const xl = this.treeScale.x
              , wl = this.treeScale.y;
            applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, Xs),
            Ws.layout && !Ws.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (Ws.target = Ws.layout.layoutBox,
            Ws.targetWithTransforms = createBox());
            const {target: _l} = Ws;
            if (!_l) {
                this.prevProjectionDelta && (this.createProjectionDeltas(),
                this.scheduleRender());
                return
            }
            !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x),
            copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y)),
            calcBoxDelta(this.projectionDelta, this.layoutCorrected, _l, this.latestValues),
            (this.treeScale.x !== xl || this.treeScale.y !== wl || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0,
            this.scheduleRender(),
            this.notifyListeners("projectionUpdate", _l)),
            isDebug && metrics.recalculatedProjection++
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(Vs=!0) {
            var Ws;
            if ((Ws = this.options.visualElement) === null || Ws === void 0 || Ws.scheduleRender(),
            Vs) {
                const Xs = this.getStack();
                Xs && Xs.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        createProjectionDeltas() {
            this.prevProjectionDelta = createDelta(),
            this.projectionDelta = createDelta(),
            this.projectionDeltaWithTransform = createDelta()
        }
        setAnimationOrigin(Vs, Ws=!1) {
            const Xs = this.snapshot
              , ga = Xs ? Xs.latestValues : {}
              , ba = {
                ...this.latestValues
            }
              , yl = createDelta();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0),
            this.attemptToResolveRelativeTarget = !Ws;
            const xl = createBox()
              , wl = Xs ? Xs.source : void 0
              , _l = this.layout ? this.layout.source : void 0
              , El = wl !== _l
              , Cl = this.getStack()
              , $l = !Cl || Cl.members.length <= 1
              , Sl = !!(El && !$l && this.options.crossfade === !0 && !this.path.some(hasOpacityCrossfade));
            this.animationProgress = 0;
            let Tl;
            this.mixTargetDelta = Rl => {
                const Il = Rl / 1e3;
                mixAxisDelta(yl.x, Vs.x, Il),
                mixAxisDelta(yl.y, Vs.y, Il),
                this.setTargetDelta(yl),
                this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (calcRelativePosition(xl, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
                mixBox(this.relativeTarget, this.relativeTargetOrigin, xl, Il),
                Tl && boxEquals(this.relativeTarget, Tl) && (this.isProjectionDirty = !1),
                Tl || (Tl = createBox()),
                copyBoxInto(Tl, this.relativeTarget)),
                El && (this.animationValues = ba,
                mixValues(ba, ga, this.latestValues, Il, Sl, $l)),
                this.root.scheduleUpdateProjection(),
                this.scheduleRender(),
                this.animationProgress = Il
            }
            ,
            this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(Vs) {
            this.notifyListeners("animationStart"),
            this.currentAnimation && this.currentAnimation.stop(),
            this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(),
            this.pendingAnimation && (cancelFrame(this.pendingAnimation),
            this.pendingAnimation = void 0),
            this.pendingAnimation = frame$1.update( () => {
                globalProjectionState.hasAnimatedSinceResize = !0,
                this.currentAnimation = animateSingleValue(0, animationTarget, {
                    ...Vs,
                    onUpdate: Ws => {
                        this.mixTargetDelta(Ws),
                        Vs.onUpdate && Vs.onUpdate(Ws)
                    }
                    ,
                    onComplete: () => {
                        Vs.onComplete && Vs.onComplete(),
                        this.completeAnimation()
                    }
                }),
                this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
                this.pendingAnimation = void 0
            }
            )
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0,
            this.resumingFrom.preserveOpacity = void 0);
            const Vs = this.getStack();
            Vs && Vs.exitAnimationComplete(),
            this.resumingFrom = this.currentAnimation = this.animationValues = void 0,
            this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(animationTarget),
            this.currentAnimation.stop()),
            this.completeAnimation()
        }
        applyTransformsToTarget() {
            const Vs = this.getLead();
            let {targetWithTransforms: Ws, target: Xs, layout: ga, latestValues: ba} = Vs;
            if (!(!Ws || !Xs || !ga)) {
                if (this !== Vs && this.layout && ga && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, ga.layoutBox)) {
                    Xs = this.target || createBox();
                    const yl = calcLength(this.layout.layoutBox.x);
                    Xs.x.min = Vs.target.x.min,
                    Xs.x.max = Xs.x.min + yl;
                    const xl = calcLength(this.layout.layoutBox.y);
                    Xs.y.min = Vs.target.y.min,
                    Xs.y.max = Xs.y.min + xl
                }
                copyBoxInto(Ws, Xs),
                transformBox(Ws, ba),
                calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, Ws, ba)
            }
        }
        registerSharedNode(Vs, Ws) {
            this.sharedNodes.has(Vs) || this.sharedNodes.set(Vs, new NodeStack),
            this.sharedNodes.get(Vs).add(Ws);
            const ga = Ws.options.initialPromotionConfig;
            Ws.promote({
                transition: ga ? ga.transition : void 0,
                preserveFollowOpacity: ga && ga.shouldPreserveFollowOpacity ? ga.shouldPreserveFollowOpacity(Ws) : void 0
            })
        }
        isLead() {
            const Vs = this.getStack();
            return Vs ? Vs.lead === this : !0
        }
        getLead() {
            var Vs;
            const {layoutId: Ws} = this.options;
            return Ws ? ((Vs = this.getStack()) === null || Vs === void 0 ? void 0 : Vs.lead) || this : this
        }
        getPrevLead() {
            var Vs;
            const {layoutId: Ws} = this.options;
            return Ws ? (Vs = this.getStack()) === null || Vs === void 0 ? void 0 : Vs.prevLead : void 0
        }
        getStack() {
            const {layoutId: Vs} = this.options;
            if (Vs)
                return this.root.sharedNodes.get(Vs)
        }
        promote({needsReset: Vs, transition: Ws, preserveFollowOpacity: Xs}={}) {
            const ga = this.getStack();
            ga && ga.promote(this, Xs),
            Vs && (this.projectionDelta = void 0,
            this.needsReset = !0),
            Ws && this.setOptions({
                transition: Ws
            })
        }
        relegate() {
            const Vs = this.getStack();
            return Vs ? Vs.relegate(this) : !1
        }
        resetSkewAndRotation() {
            const {visualElement: Vs} = this.options;
            if (!Vs)
                return;
            let Ws = !1;
            const {latestValues: Xs} = Vs;
            if ((Xs.z || Xs.rotate || Xs.rotateX || Xs.rotateY || Xs.rotateZ || Xs.skewX || Xs.skewY) && (Ws = !0),
            !Ws)
                return;
            const ga = {};
            Xs.z && resetDistortingTransform("z", Vs, ga, this.animationValues);
            for (let ba = 0; ba < transformAxes.length; ba++)
                resetDistortingTransform(`rotate${transformAxes[ba]}`, Vs, ga, this.animationValues),
                resetDistortingTransform(`skew${transformAxes[ba]}`, Vs, ga, this.animationValues);
            Vs.render();
            for (const ba in ga)
                Vs.setStaticValue(ba, ga[ba]),
                this.animationValues && (this.animationValues[ba] = ga[ba]);
            Vs.scheduleRender()
        }
        getProjectionStyles(Vs) {
            var Ws, Xs;
            if (!this.instance || this.isSVG)
                return;
            if (!this.isVisible)
                return hiddenVisibility;
            const ga = {
                visibility: ""
            }
              , ba = this.getTransformTemplate();
            if (this.needsReset)
                return this.needsReset = !1,
                ga.opacity = "",
                ga.pointerEvents = resolveMotionValue(Vs == null ? void 0 : Vs.pointerEvents) || "",
                ga.transform = ba ? ba(this.latestValues, "") : "none",
                ga;
            const yl = this.getLead();
            if (!this.projectionDelta || !this.layout || !yl.target) {
                const El = {};
                return this.options.layoutId && (El.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1,
                El.pointerEvents = resolveMotionValue(Vs == null ? void 0 : Vs.pointerEvents) || ""),
                this.hasProjected && !hasTransform(this.latestValues) && (El.transform = ba ? ba({}, "") : "none",
                this.hasProjected = !1),
                El
            }
            const xl = yl.animationValues || yl.latestValues;
            this.applyTransformsToTarget(),
            ga.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, xl),
            ba && (ga.transform = ba(xl, ga.transform));
            const {x: wl, y: _l} = this.projectionDelta;
            ga.transformOrigin = `${wl.origin * 100}% ${_l.origin * 100}% 0`,
            yl.animationValues ? ga.opacity = yl === this ? (Xs = (Ws = xl.opacity) !== null && Ws !== void 0 ? Ws : this.latestValues.opacity) !== null && Xs !== void 0 ? Xs : 1 : this.preserveOpacity ? this.latestValues.opacity : xl.opacityExit : ga.opacity = yl === this ? xl.opacity !== void 0 ? xl.opacity : "" : xl.opacityExit !== void 0 ? xl.opacityExit : 0;
            for (const El in scaleCorrectors) {
                if (xl[El] === void 0)
                    continue;
                const {correct: Cl, applyTo: $l} = scaleCorrectors[El]
                  , Sl = ga.transform === "none" ? xl[El] : Cl(xl[El], yl);
                if ($l) {
                    const Tl = $l.length;
                    for (let Rl = 0; Rl < Tl; Rl++)
                        ga[$l[Rl]] = Sl
                } else
                    ga[El] = Sl
            }
            return this.options.layoutId && (ga.pointerEvents = yl === this ? resolveMotionValue(Vs == null ? void 0 : Vs.pointerEvents) || "" : "none"),
            ga
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(Vs => {
                var Ws;
                return (Ws = Vs.currentAnimation) === null || Ws === void 0 ? void 0 : Ws.stop()
            }
            ),
            this.root.nodes.forEach(clearMeasurements),
            this.root.sharedNodes.clear()
        }
    }
}
function updateLayout(xt) {
    xt.updateLayout()
}
function notifyLayoutUpdate(xt) {
    var Cn;
    const as = ((Cn = xt.resumeFrom) === null || Cn === void 0 ? void 0 : Cn.snapshot) || xt.snapshot;
    if (xt.isLead() && xt.layout && as && xt.hasListeners("didUpdate")) {
        const {layoutBox: cs, measuredBox: Cs} = xt.layout
          , {animationType: Ls} = xt.options
          , Vs = as.source !== xt.layout.source;
        Ls === "size" ? eachAxis(yl => {
            const xl = Vs ? as.measuredBox[yl] : as.layoutBox[yl]
              , wl = calcLength(xl);
            xl.min = cs[yl].min,
            xl.max = xl.min + wl
        }
        ) : shouldAnimatePositionOnly(Ls, as.layoutBox, cs) && eachAxis(yl => {
            const xl = Vs ? as.measuredBox[yl] : as.layoutBox[yl]
              , wl = calcLength(cs[yl]);
            xl.max = xl.min + wl,
            xt.relativeTarget && !xt.currentAnimation && (xt.isProjectionDirty = !0,
            xt.relativeTarget[yl].max = xt.relativeTarget[yl].min + wl)
        }
        );
        const Ws = createDelta();
        calcBoxDelta(Ws, cs, as.layoutBox);
        const Xs = createDelta();
        Vs ? calcBoxDelta(Xs, xt.applyTransform(Cs, !0), as.measuredBox) : calcBoxDelta(Xs, cs, as.layoutBox);
        const ga = !isDeltaZero(Ws);
        let ba = !1;
        if (!xt.resumeFrom) {
            const yl = xt.getClosestProjectingParent();
            if (yl && !yl.resumeFrom) {
                const {snapshot: xl, layout: wl} = yl;
                if (xl && wl) {
                    const _l = createBox();
                    calcRelativePosition(_l, as.layoutBox, xl.layoutBox);
                    const El = createBox();
                    calcRelativePosition(El, cs, wl.layoutBox),
                    boxEqualsRounded(_l, El) || (ba = !0),
                    yl.options.layoutRoot && (xt.relativeTarget = El,
                    xt.relativeTargetOrigin = _l,
                    xt.relativeParent = yl)
                }
            }
        }
        xt.notifyListeners("didUpdate", {
            layout: cs,
            snapshot: as,
            delta: Xs,
            layoutDelta: Ws,
            hasLayoutChanged: ga,
            hasRelativeTargetChanged: ba
        })
    } else if (xt.isLead()) {
        const {onExitComplete: cs} = xt.options;
        cs && cs()
    }
    xt.options.transition = void 0
}
function propagateDirtyNodes(xt) {
    isDebug && metrics.totalNodes++,
    xt.parent && (xt.isProjecting() || (xt.isProjectionDirty = xt.parent.isProjectionDirty),
    xt.isSharedProjectionDirty || (xt.isSharedProjectionDirty = !!(xt.isProjectionDirty || xt.parent.isProjectionDirty || xt.parent.isSharedProjectionDirty)),
    xt.isTransformDirty || (xt.isTransformDirty = xt.parent.isTransformDirty))
}
function cleanDirtyNodes(xt) {
    xt.isProjectionDirty = xt.isSharedProjectionDirty = xt.isTransformDirty = !1
}
function clearSnapshot(xt) {
    xt.clearSnapshot()
}
function clearMeasurements(xt) {
    xt.clearMeasurements()
}
function clearIsLayoutDirty(xt) {
    xt.isLayoutDirty = !1
}
function resetTransformStyle(xt) {
    const {visualElement: Cn} = xt.options;
    Cn && Cn.getProps().onBeforeLayoutMeasure && Cn.notify("BeforeLayoutMeasure"),
    xt.resetTransform()
}
function finishAnimation(xt) {
    xt.finishAnimation(),
    xt.targetDelta = xt.relativeTarget = xt.target = void 0,
    xt.isProjectionDirty = !0
}
function resolveTargetDelta(xt) {
    xt.resolveTargetDelta()
}
function calcProjection(xt) {
    xt.calcProjection()
}
function resetSkewAndRotation(xt) {
    xt.resetSkewAndRotation()
}
function removeLeadSnapshots(xt) {
    xt.removeLeadSnapshot()
}
function mixAxisDelta(xt, Cn, as) {
    xt.translate = mixNumber$1(Cn.translate, 0, as),
    xt.scale = mixNumber$1(Cn.scale, 1, as),
    xt.origin = Cn.origin,
    xt.originPoint = Cn.originPoint
}
function mixAxis(xt, Cn, as, cs) {
    xt.min = mixNumber$1(Cn.min, as.min, cs),
    xt.max = mixNumber$1(Cn.max, as.max, cs)
}
function mixBox(xt, Cn, as, cs) {
    mixAxis(xt.x, Cn.x, as.x, cs),
    mixAxis(xt.y, Cn.y, as.y, cs)
}
function hasOpacityCrossfade(xt) {
    return xt.animationValues && xt.animationValues.opacityExit !== void 0
}
const defaultLayoutTransition = {
    duration: .45,
    ease: [.4, 0, .1, 1]
}
  , userAgentContains = xt => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(xt)
  , roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$3;
function roundAxis(xt) {
    xt.min = roundPoint(xt.min),
    xt.max = roundPoint(xt.max)
}
function roundBox(xt) {
    roundAxis(xt.x),
    roundAxis(xt.y)
}
function shouldAnimatePositionOnly(xt, Cn, as) {
    return xt === "position" || xt === "preserve-aspect" && !isNear(aspectRatio(Cn), aspectRatio(as), .2)
}
function checkNodeWasScrollRoot(xt) {
    var Cn;
    return xt !== xt.root && ((Cn = xt.scroll) === null || Cn === void 0 ? void 0 : Cn.wasRoot)
}
const DocumentProjectionNode = createProjectionNode({
    attachResizeListener: (xt, Cn) => addDomEvent(xt, "resize", Cn),
    measureScroll: () => ({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => !0
})
  , rootProjectionNode = {
    current: void 0
}
  , HTMLProjectionNode = createProjectionNode({
    measureScroll: xt => ({
        x: xt.scrollLeft,
        y: xt.scrollTop
    }),
    defaultParent: () => {
        if (!rootProjectionNode.current) {
            const xt = new DocumentProjectionNode({});
            xt.mount(window),
            xt.setOptions({
                layoutScroll: !0
            }),
            rootProjectionNode.current = xt
        }
        return rootProjectionNode.current
    }
    ,
    resetTransform: (xt, Cn) => {
        xt.style.transform = Cn !== void 0 ? Cn : "none"
    }
    ,
    checkIsScrollRoot: xt => window.getComputedStyle(xt).position === "fixed"
})
  , drag = {
    pan: {
        Feature: PanGesture
    },
    drag: {
        Feature: DragGesture,
        ProjectionNode: HTMLProjectionNode,
        MeasureLayout
    }
};
function handleHoverEvent(xt, Cn, as) {
    const {props: cs} = xt;
    xt.animationState && cs.whileHover && xt.animationState.setActive("whileHover", as === "Start");
    const Cs = "onHover" + as
      , Ls = cs[Cs];
    Ls && frame$1.postRender( () => Ls(Cn, extractEventInfo(Cn)))
}
class HoverGesture extends Feature {
    mount() {
        const {current: Cn} = this.node;
        Cn && (this.unmount = hover(Cn, as => (handleHoverEvent(this.node, as, "Start"),
        cs => handleHoverEvent(this.node, cs, "End"))))
    }
    unmount() {}
}
class FocusGesture extends Feature {
    constructor() {
        super(...arguments),
        this.isActive = !1
    }
    onFocus() {
        let Cn = !1;
        try {
            Cn = this.node.current.matches(":focus-visible")
        } catch {
            Cn = !0
        }
        !Cn || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0),
        this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1),
        this.isActive = !1)
    }
    mount() {
        this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()))
    }
    unmount() {}
}
function handlePressEvent(xt, Cn, as) {
    const {props: cs} = xt;
    xt.animationState && cs.whileTap && xt.animationState.setActive("whileTap", as === "Start");
    const Cs = "onTap" + (as === "End" ? "" : as)
      , Ls = cs[Cs];
    Ls && frame$1.postRender( () => Ls(Cn, extractEventInfo(Cn)))
}
class PressGesture extends Feature {
    mount() {
        const {current: Cn} = this.node;
        Cn && (this.unmount = press(Cn, as => (handlePressEvent(this.node, as, "Start"),
        (cs, {success: Cs}) => handlePressEvent(this.node, cs, Cs ? "End" : "Cancel")), {
            useGlobalTarget: this.node.props.globalTapTarget
        }))
    }
    unmount() {}
}
const observerCallbacks = new WeakMap
  , observers = new WeakMap
  , fireObserverCallback = xt => {
    const Cn = observerCallbacks.get(xt.target);
    Cn && Cn(xt)
}
  , fireAllObserverCallbacks = xt => {
    xt.forEach(fireObserverCallback)
}
;
function initIntersectionObserver({root: xt, ...Cn}) {
    const as = xt || document;
    observers.has(as) || observers.set(as, {});
    const cs = observers.get(as)
      , Cs = JSON.stringify(Cn);
    return cs[Cs] || (cs[Cs] = new IntersectionObserver(fireAllObserverCallbacks,{
        root: xt,
        ...Cn
    })),
    cs[Cs]
}
function observeIntersection(xt, Cn, as) {
    const cs = initIntersectionObserver(Cn);
    return observerCallbacks.set(xt, as),
    cs.observe(xt),
    () => {
        observerCallbacks.delete(xt),
        cs.unobserve(xt)
    }
}
const thresholdNames = {
    some: 0,
    all: 1
};
class InViewFeature extends Feature {
    constructor() {
        super(...arguments),
        this.hasEnteredView = !1,
        this.isInView = !1
    }
    startObserver() {
        this.unmount();
        const {viewport: Cn={}} = this.node.getProps()
          , {root: as, margin: cs, amount: Cs="some", once: Ls} = Cn
          , Vs = {
            root: as ? as.current : void 0,
            rootMargin: cs,
            threshold: typeof Cs == "number" ? Cs : thresholdNames[Cs]
        }
          , Ws = Xs => {
            const {isIntersecting: ga} = Xs;
            if (this.isInView === ga || (this.isInView = ga,
            Ls && !ga && this.hasEnteredView))
                return;
            ga && (this.hasEnteredView = !0),
            this.node.animationState && this.node.animationState.setActive("whileInView", ga);
            const {onViewportEnter: ba, onViewportLeave: yl} = this.node.getProps()
              , xl = ga ? ba : yl;
            xl && xl(Xs)
        }
        ;
        return observeIntersection(this.node.current, Vs, Ws)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u")
            return;
        const {props: Cn, prevProps: as} = this.node;
        ["amount", "margin", "root"].some(hasViewportOptionChanged(Cn, as)) && this.startObserver()
    }
    unmount() {}
}
function hasViewportOptionChanged({viewport: xt={}}, {viewport: Cn={}}={}) {
    return as => xt[as] !== Cn[as]
}
const gestureAnimations = {
    inView: {
        Feature: InViewFeature
    },
    tap: {
        Feature: PressGesture
    },
    focus: {
        Feature: FocusGesture
    },
    hover: {
        Feature: HoverGesture
    }
}
  , layout = {
    layout: {
        ProjectionNode: HTMLProjectionNode,
        MeasureLayout
    }
}
  , prefersReducedMotion = {
    current: null
}
  , hasReducedMotionListener = {
    current: !1
};
function initPrefersReducedMotion() {
    if (hasReducedMotionListener.current = !0,
    !!isBrowser$1)
        if (window.matchMedia) {
            const xt = window.matchMedia("(prefers-reduced-motion)")
              , Cn = () => prefersReducedMotion.current = xt.matches;
            xt.addListener(Cn),
            Cn()
        } else
            prefersReducedMotion.current = !1
}
const valueTypes = [...dimensionValueTypes, color, complex]
  , findValueType = xt => valueTypes.find(testValueType(xt))
  , visualElementStore = new WeakMap;
function updateMotionValuesFromProps(xt, Cn, as) {
    for (const cs in Cn) {
        const Cs = Cn[cs]
          , Ls = as[cs];
        if (isMotionValue(Cs))
            xt.addValue(cs, Cs);
        else if (isMotionValue(Ls))
            xt.addValue(cs, motionValue(Cs, {
                owner: xt
            }));
        else if (Ls !== Cs)
            if (xt.hasValue(cs)) {
                const Vs = xt.getValue(cs);
                Vs.liveStyle === !0 ? Vs.jump(Cs) : Vs.hasAnimated || Vs.set(Cs)
            } else {
                const Vs = xt.getStaticValue(cs);
                xt.addValue(cs, motionValue(Vs !== void 0 ? Vs : Cs, {
                    owner: xt
                }))
            }
    }
    for (const cs in as)
        Cn[cs] === void 0 && xt.removeValue(cs);
    return Cn
}
const propEventHandlers = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"];
class VisualElement {
    scrapeMotionValuesFromProps(Cn, as, cs) {
        return {}
    }
    constructor({parent: Cn, props: as, presenceContext: cs, reducedMotionConfig: Cs, blockInitialAnimation: Ls, visualState: Vs}, Ws={}) {
        this.current = null,
        this.children = new Set,
        this.isVariantNode = !1,
        this.isControllingVariants = !1,
        this.shouldReduceMotion = null,
        this.values = new Map,
        this.KeyframeResolver = KeyframeResolver,
        this.features = {},
        this.valueSubscriptions = new Map,
        this.prevMotionValues = {},
        this.events = {},
        this.propEventSubscriptions = {},
        this.notifyUpdate = () => this.notify("Update", this.latestValues),
        this.render = () => {
            this.current && (this.triggerBuild(),
            this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }
        ,
        this.renderScheduledAt = 0,
        this.scheduleRender = () => {
            const wl = time.now();
            this.renderScheduledAt < wl && (this.renderScheduledAt = wl,
            frame$1.render(this.render, !1, !0))
        }
        ;
        const {latestValues: Xs, renderState: ga, onUpdate: ba} = Vs;
        this.onUpdate = ba,
        this.latestValues = Xs,
        this.baseTarget = {
            ...Xs
        },
        this.initialValues = as.initial ? {
            ...Xs
        } : {},
        this.renderState = ga,
        this.parent = Cn,
        this.props = as,
        this.presenceContext = cs,
        this.depth = Cn ? Cn.depth + 1 : 0,
        this.reducedMotionConfig = Cs,
        this.options = Ws,
        this.blockInitialAnimation = !!Ls,
        this.isControllingVariants = isControllingVariants(as),
        this.isVariantNode = isVariantNode(as),
        this.isVariantNode && (this.variantChildren = new Set),
        this.manuallyAnimateOnMount = !!(Cn && Cn.current);
        const {willChange: yl, ...xl} = this.scrapeMotionValuesFromProps(as, {}, this);
        for (const wl in xl) {
            const _l = xl[wl];
            Xs[wl] !== void 0 && isMotionValue(_l) && _l.set(Xs[wl], !1)
        }
    }
    mount(Cn) {
        this.current = Cn,
        visualElementStore.set(Cn, this),
        this.projection && !this.projection.instance && this.projection.mount(Cn),
        this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
        this.values.forEach( (as, cs) => this.bindToMotionValue(cs, as)),
        hasReducedMotionListener.current || initPrefersReducedMotion(),
        this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : prefersReducedMotion.current,
        this.parent && this.parent.children.add(this),
        this.update(this.props, this.presenceContext)
    }
    unmount() {
        visualElementStore.delete(this.current),
        this.projection && this.projection.unmount(),
        cancelFrame(this.notifyUpdate),
        cancelFrame(this.render),
        this.valueSubscriptions.forEach(Cn => Cn()),
        this.valueSubscriptions.clear(),
        this.removeFromVariantTree && this.removeFromVariantTree(),
        this.parent && this.parent.children.delete(this);
        for (const Cn in this.events)
            this.events[Cn].clear();
        for (const Cn in this.features) {
            const as = this.features[Cn];
            as && (as.unmount(),
            as.isMounted = !1)
        }
        this.current = null
    }
    bindToMotionValue(Cn, as) {
        this.valueSubscriptions.has(Cn) && this.valueSubscriptions.get(Cn)();
        const cs = transformProps.has(Cn)
          , Cs = as.on("change", Ws => {
            this.latestValues[Cn] = Ws,
            this.props.onUpdate && frame$1.preRender(this.notifyUpdate),
            cs && this.projection && (this.projection.isTransformDirty = !0)
        }
        )
          , Ls = as.on("renderRequest", this.scheduleRender);
        let Vs;
        window.MotionCheckAppearSync && (Vs = window.MotionCheckAppearSync(this, Cn, as)),
        this.valueSubscriptions.set(Cn, () => {
            Cs(),
            Ls(),
            Vs && Vs(),
            as.owner && as.stop()
        }
        )
    }
    sortNodePosition(Cn) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== Cn.type ? 0 : this.sortInstanceNodePosition(this.current, Cn.current)
    }
    updateFeatures() {
        let Cn = "animation";
        for (Cn in featureDefinitions) {
            const as = featureDefinitions[Cn];
            if (!as)
                continue;
            const {isEnabled: cs, Feature: Cs} = as;
            if (!this.features[Cn] && Cs && cs(this.props) && (this.features[Cn] = new Cs(this)),
            this.features[Cn]) {
                const Ls = this.features[Cn];
                Ls.isMounted ? Ls.update() : (Ls.mount(),
                Ls.isMounted = !0)
            }
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox()
    }
    getStaticValue(Cn) {
        return this.latestValues[Cn]
    }
    setStaticValue(Cn, as) {
        this.latestValues[Cn] = as
    }
    update(Cn, as) {
        (Cn.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
        this.prevProps = this.props,
        this.props = Cn,
        this.prevPresenceContext = this.presenceContext,
        this.presenceContext = as;
        for (let cs = 0; cs < propEventHandlers.length; cs++) {
            const Cs = propEventHandlers[cs];
            this.propEventSubscriptions[Cs] && (this.propEventSubscriptions[Cs](),
            delete this.propEventSubscriptions[Cs]);
            const Ls = "on" + Cs
              , Vs = Cn[Ls];
            Vs && (this.propEventSubscriptions[Cs] = this.on(Cs, Vs))
        }
        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(Cn, this.prevProps, this), this.prevMotionValues),
        this.handleChildMotionValue && this.handleChildMotionValue(),
        this.onUpdate && this.onUpdate(this)
    }
    getProps() {
        return this.props
    }
    getVariant(Cn) {
        return this.props.variants ? this.props.variants[Cn] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    addVariantChild(Cn) {
        const as = this.getClosestVariantNode();
        if (as)
            return as.variantChildren && as.variantChildren.add(Cn),
            () => as.variantChildren.delete(Cn)
    }
    addValue(Cn, as) {
        const cs = this.values.get(Cn);
        as !== cs && (cs && this.removeValue(Cn),
        this.bindToMotionValue(Cn, as),
        this.values.set(Cn, as),
        this.latestValues[Cn] = as.get())
    }
    removeValue(Cn) {
        this.values.delete(Cn);
        const as = this.valueSubscriptions.get(Cn);
        as && (as(),
        this.valueSubscriptions.delete(Cn)),
        delete this.latestValues[Cn],
        this.removeValueFromRenderState(Cn, this.renderState)
    }
    hasValue(Cn) {
        return this.values.has(Cn)
    }
    getValue(Cn, as) {
        if (this.props.values && this.props.values[Cn])
            return this.props.values[Cn];
        let cs = this.values.get(Cn);
        return cs === void 0 && as !== void 0 && (cs = motionValue(as === null ? void 0 : as, {
            owner: this
        }),
        this.addValue(Cn, cs)),
        cs
    }
    readValue(Cn, as) {
        var cs;
        let Cs = this.latestValues[Cn] !== void 0 || !this.current ? this.latestValues[Cn] : (cs = this.getBaseTargetFromProps(this.props, Cn)) !== null && cs !== void 0 ? cs : this.readValueFromInstance(this.current, Cn, this.options);
        return Cs != null && (typeof Cs == "string" && (isNumericalString(Cs) || isZeroValueString(Cs)) ? Cs = parseFloat(Cs) : !findValueType(Cs) && complex.test(as) && (Cs = getAnimatableNone(Cn, as)),
        this.setBaseTarget(Cn, isMotionValue(Cs) ? Cs.get() : Cs)),
        isMotionValue(Cs) ? Cs.get() : Cs
    }
    setBaseTarget(Cn, as) {
        this.baseTarget[Cn] = as
    }
    getBaseTarget(Cn) {
        var as;
        const {initial: cs} = this.props;
        let Cs;
        if (typeof cs == "string" || typeof cs == "object") {
            const Vs = resolveVariantFromProps(this.props, cs, (as = this.presenceContext) === null || as === void 0 ? void 0 : as.custom);
            Vs && (Cs = Vs[Cn])
        }
        if (cs && Cs !== void 0)
            return Cs;
        const Ls = this.getBaseTargetFromProps(this.props, Cn);
        return Ls !== void 0 && !isMotionValue(Ls) ? Ls : this.initialValues[Cn] !== void 0 && Cs === void 0 ? void 0 : this.baseTarget[Cn]
    }
    on(Cn, as) {
        return this.events[Cn] || (this.events[Cn] = new SubscriptionManager),
        this.events[Cn].add(as)
    }
    notify(Cn, ...as) {
        this.events[Cn] && this.events[Cn].notify(...as)
    }
}
class DOMVisualElement extends VisualElement {
    constructor() {
        super(...arguments),
        this.KeyframeResolver = DOMKeyframesResolver
    }
    sortInstanceNodePosition(Cn, as) {
        return Cn.compareDocumentPosition(as) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(Cn, as) {
        return Cn.style ? Cn.style[as] : void 0
    }
    removeValueFromRenderState(Cn, {vars: as, style: cs}) {
        delete as[Cn],
        delete cs[Cn]
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(),
        delete this.childSubscription);
        const {children: Cn} = this.props;
        isMotionValue(Cn) && (this.childSubscription = Cn.on("change", as => {
            this.current && (this.current.textContent = `${as}`)
        }
        ))
    }
}
function getComputedStyle$1(xt) {
    return window.getComputedStyle(xt)
}
class HTMLVisualElement extends DOMVisualElement {
    constructor() {
        super(...arguments),
        this.type = "html",
        this.renderInstance = renderHTML
    }
    readValueFromInstance(Cn, as) {
        if (transformProps.has(as)) {
            const cs = getDefaultValueType(as);
            return cs && cs.default || 0
        } else {
            const cs = getComputedStyle$1(Cn)
              , Cs = (isCSSVariableName(as) ? cs.getPropertyValue(as) : cs[as]) || 0;
            return typeof Cs == "string" ? Cs.trim() : Cs
        }
    }
    measureInstanceViewportBox(Cn, {transformPagePoint: as}) {
        return measureViewportBox(Cn, as)
    }
    build(Cn, as, cs) {
        buildHTMLStyles(Cn, as, cs.transformTemplate)
    }
    scrapeMotionValuesFromProps(Cn, as, cs) {
        return scrapeMotionValuesFromProps$1(Cn, as, cs)
    }
}
class SVGVisualElement extends DOMVisualElement {
    constructor() {
        super(...arguments),
        this.type = "svg",
        this.isSVGTag = !1,
        this.measureInstanceViewportBox = createBox
    }
    getBaseTargetFromProps(Cn, as) {
        return Cn[as]
    }
    readValueFromInstance(Cn, as) {
        if (transformProps.has(as)) {
            const cs = getDefaultValueType(as);
            return cs && cs.default || 0
        }
        return as = camelCaseAttributes.has(as) ? as : camelToDash(as),
        Cn.getAttribute(as)
    }
    scrapeMotionValuesFromProps(Cn, as, cs) {
        return scrapeMotionValuesFromProps(Cn, as, cs)
    }
    build(Cn, as, cs) {
        buildSVGAttrs(Cn, as, this.isSVGTag, cs.transformTemplate)
    }
    renderInstance(Cn, as, cs, Cs) {
        renderSVG(Cn, as, cs, Cs)
    }
    mount(Cn) {
        this.isSVGTag = isSVGTag(Cn.tagName),
        super.mount(Cn)
    }
}
const createDomVisualElement = (xt, Cn) => isSVGComponent(xt) ? new SVGVisualElement(Cn) : new HTMLVisualElement(Cn,{
    allowProjection: xt !== reactExports.Fragment
})
  , createMotionComponent = createMotionComponentFactory({
    ...animations,
    ...gestureAnimations,
    ...drag,
    ...layout
}, createDomVisualElement)
  , motion = createDOMMotionComponentProxy(createMotionComponent);
function useAnimationFrame(xt) {
    const Cn = reactExports.useRef(0)
      , {isStatic: as} = reactExports.useContext(MotionConfigContext);
    reactExports.useEffect( () => {
        if (as)
            return;
        const cs = ({timestamp: Cs, delta: Ls}) => {
            Cn.current || (Cn.current = Cs),
            xt(Cs - Cn.current, Ls)
        }
        ;
        return frame$1.update(cs, !0),
        () => cancelFrame(cs)
    }
    , [xt])
}
const page = "_page_1grz0_1"
  , pageHeadersWrapper = "_pageHeadersWrapper_1grz0_24"
  , safeArea = "_safeArea_1grz0_34"
  , pageControlsWrapper = "_pageControlsWrapper_1grz0_37"
  , pageContentWrapper = "_pageContentWrapper_1grz0_43"
  , styles$1s = {
    page,
    pageHeadersWrapper,
    safeArea,
    pageControlsWrapper,
    pageContentWrapper
}
  , createStoreImpl = xt => {
    let Cn;
    const as = new Set
      , cs = (ga, ba) => {
        const yl = typeof ga == "function" ? ga(Cn) : ga;
        if (!Object.is(yl, Cn)) {
            const xl = Cn;
            Cn = ba ?? (typeof yl != "object" || yl === null) ? yl : Object.assign({}, Cn, yl),
            as.forEach(wl => wl(Cn, xl))
        }
    }
      , Cs = () => Cn
      , Ws = {
        setState: cs,
        getState: Cs,
        getInitialState: () => Xs,
        subscribe: ga => (as.add(ga),
        () => as.delete(ga))
    }
      , Xs = Cn = xt(cs, Cs, Ws);
    return Ws
}
  , createStore = xt => xt ? createStoreImpl(xt) : createStoreImpl
  , identity$1 = xt => xt;
function useStore(xt, Cn=identity$1) {
    const as = React__default.useSyncExternalStore(xt.subscribe, () => Cn(xt.getState()), () => Cn(xt.getInitialState()));
    return React__default.useDebugValue(as),
    as
}
const createImpl = xt => {
    const Cn = createStore(xt)
      , as = cs => useStore(Cn, cs);
    return Object.assign(as, Cn),
    as
}
  , create = xt => createImpl
  , getApiUrl = xt => window.location.hostname.toLocaleLowerCase() === "localhost" ? xt : window.API_URL ? `${window.location.protocol}//${window.API_URL}${xt}` : `${window.location.protocol}//api.mrkt.io${xt}`
  , createSlice = xt => (Cn, as) => xt(Cn, as)
  , preloadImage = xt => new Promise(Cn => {
    try {
        const as = document.createElement("img");
        as.src = xt,
        as.style.display = "none",
        document.body.appendChild(as),
        as.addEventListener("load", () => {
            console.log(`Image ${xt} loaded`),
            Cn()
        }
        ),
        setTimeout( () => Cn(), 1e3)
    } catch (as) {
        console.error("Error while preload image:", as)
    }
}
)
  , primaryImagesList = [];
var COMMON_INTERVALS = (xt => (xt.GAME_STATS_POLLING = "game_stats_polling",
xt.PUBLIC_EVENTS_POLLING = "public_events_polling",
xt.SOCIAL_TASKS_POLLING = "social_tasks_polling",
xt.LEADERBOARDS_POLLING = "leaderboards_polling",
xt.PASSPORT_SHARE_TASK_POLLING = "passport_share_task_polling",
xt.PVP_DATA_POLLING = "pvp_data_polling",
xt.SPOTLIGHT_POLLING = "spotlight_polling",
xt.GA_POLLING = "ga_polling",
xt.HI_POLLING = "hi_pooling",
xt.PENDING_WITHDRAW_POLLING = "pending_withdraw_polling",
xt))(COMMON_INTERVALS || {})
  , COMMON_TASKS = (xt => (xt.EXPIRE_EVENT = "expire_event",
xt.MONITOR_SOCIAL_TASK = "monitor_social_task",
xt.PVP_EVENT_END = "PVP_EVENT_END",
xt.PLAY_WELCOME_VIDEO = "play_welcome_video",
xt.WAIT_SCREEN_END = "wait_screen_end",
xt))(COMMON_TASKS || {});
const timersSlice = createSlice( (xt, Cn) => ({
    intervals: new Map,
    tasks: new Map,
    pollingTasks: new Map,
    bootstrap: () => {
        logInfo("Bootstrap timers")
    }
    ,
    startInterval: (as, cs, Cs) => {
        const Ls = Cn().timers.intervals.get(as);
        Ls && Ls.isRunning && Ls.intervalId && (clearInterval(Ls.intervalId),
        Cn().timers.intervals.delete(as));
        const Vs = {
            intervalId: null,
            isRunning: !0,
            startedAt: new Date,
            interval: cs
        };
        Cs(),
        logInfo(`Start interval: ${as}`),
        Vs.intervalId = setInterval(Cs, cs),
        Cn().timers.intervals.set(as, Vs)
    }
    ,
    stopInterval: as => {
        const cs = Cn().timers.intervals.get(as);
        cs && cs.isRunning && cs.intervalId && (logInfo(`Stop interval: ${as}`),
        clearInterval(cs.intervalId),
        cs.intervalId = null,
        cs.interval = null,
        cs.isRunning = !1,
        cs.startedAt = null,
        Cn().timers.intervals.set(as, cs))
    }
    ,
    isIntervalRunning: as => {
        const cs = Cn().timers.intervals.get(as);
        return !!(cs && cs.isRunning)
    }
    ,
    startTask: (as, cs, Cs) => {
        const Ls = Cn().timers.tasks.get(as);
        Ls && Ls.timerId && (clearTimeout(Ls.timerId),
        Cn().timers.tasks.delete(as));
        const Vs = {
            timerId: null,
            startedAt: new Date,
            executionAt: cs
        }
          , Ws = cs.getTime() - new Date().getTime();
        console.log(Ws),
        Ws > 0 ? (logInfo(`Start task: ${as}`),
        Vs.timerId = setTimeout(Cs, Ws),
        Cn().timers.tasks.set(as, Vs)) : (logInfo(`Execute task immediately: ${as}`),
        Cs())
    }
    ,
    stopTask: as => {
        const cs = Cn().timers.tasks.get(as);
        cs && cs.timerId && (logInfo(`Stop task: ${as}`),
        clearTimeout(cs.timerId),
        Cn().timers.tasks.delete(as))
    }
    ,
    startPolling: (as, cs, Cs={}) => {
        const {interval: Ls=1e3, maxAttempts: Vs=60} = Cs
          , Ws = Cn().timers.pollingTasks.get(as);
        Ws != null && Ws.intervalId && (clearInterval(Ws.intervalId),
        Cn().timers.pollingTasks.delete(as));
        const Xs = {
            intervalId: null,
            isRunning: !0,
            startedAt: new Date,
            interval: Ls,
            attemptCount: 0,
            maxAttempts: Vs
        }
          , ga = async () => {
            Xs.attemptCount++;
            try {
                (await cs() || Xs.attemptCount >= Xs.maxAttempts) && Cn().timers.stopPolling(as)
            } catch {
                Xs.attemptCount >= Xs.maxAttempts && Cn().timers.stopPolling(as)
            }
        }
        ;
        ga(),
        Xs.intervalId = setInterval(ga, Ls),
        Cn().timers.pollingTasks.set(as, Xs)
    }
    ,
    stopPolling: as => {
        const cs = Cn().timers.pollingTasks.get(as);
        cs != null && cs.intervalId && (clearInterval(cs.intervalId),
        cs.isRunning = !1,
        Cn().timers.pollingTasks.delete(as))
    }
}));
var APP_STATE = (xt => (xt.LOADING = "loading",
xt.AUTHORIZATION = "authorization",
xt.BOOTSTRAP_LOADING = "bootstrap_loading",
xt.BOOTSTRAP_LOADED = "bootstrap_loaded",
xt.INITIALIZING = "initializing",
xt.ONBOARDING = "onboarding",
xt.READY = "ready",
xt.ERROR = "error",
xt))(APP_STATE || {});
const appSlice = createSlice( (xt, Cn) => ({
    state: "loading",
    maintenance: !1,
    forbidden: !1,
    isAdmin: !1,
    targetWallet: "",
    minDepositAmount: 0,
    minWithdrawAmount: 0,
    minSalePrice: 0,
    freeSalesCount: 0,
    relayerBotName: "",
    maxBatchSaleGifts: 0,
    maxReturnGifts: 0,
    returnGiftPrice: 0,
    salePrice: 0,
    inGameLink: "",
    minQueryLength: 0,
    maxQueryLength: 0,
    maxSalePrice: 0,
    promotePrice: 0,
    salesFee: 0,
    maxBatchBuy: 0,
    appBotName: "",
    maxChatsForGiveaway: 0,
    maxGiveawayGifts: 0,
    giveawayPrizeFeeCost: 0,
    privateGiveawayFee: 0,
    giveawayTicketFee: 0,
    giveawayDurations: [],
    giveawayMaxTicketsCount: 0,
    minNonFreeGiveawayPrice: 0,
    welcomeBannerDismissed: localStorage.getItem("welcomeBannerDismissed") === "true",
    leaderboardId: 0,
    serverTime: null,
    initialOffset: null,
    shouldShowWaitScreen: !0,
    startDate: null,
    isOnPrelaunch: !1,
    tradingVolumeLevels: [],
    setWelcomeBannerDismissed: as => {
        typeof window < "u" && localStorage.setItem("welcomeBannerDismissed", String(as)),
        xt(cs => ({
            app: {
                ...cs.app,
                welcomeBannerDismissed: as
            }
        }))
    }
    ,
    bootstrap: async () => {
        try {
            xt(ga => ({
                app: {
                    ...ga.app,
                    state: "authorization"
                }
            })),
            await Cn().profile.writeFingerprints();
            const as = Cn().auth.authorization;
            if (!Cn().auth.accessToken && await as() === "forbidden") {
                xt(ba => ({
                    app: {
                        ...ba.app,
                        forbidden: !0
                    }
                }));
                return
            }
            xt(ga => ({
                app: {
                    ...ga.app,
                    state: "bootstrap_loading"
                }
            }));
            const cs = await fetch(getApiUrl("/api/v1/me"));
            (cs.status === 403 || !cs.ok) && xt(ga => ({
                app: {
                    ...ga.app,
                    forbidden: !0
                }
            }));
            const Cs = await cs.json();
            xt(ga => ({
                app: {
                    ...ga.app,
                    isAdmin: Cs.category === "Admin" || Cs.category === "Tester"
                }
            })),
            Cn().app.parseGameConfigs(Cs.configs);
            const Ls = new Date(Cs.serverTime)
              , Vs = Ls.getTime() - new Date().getTime()
              , Ws = new Date("2025-05-13T19:00:00.372+00:00")
              , Xs = Ws > Ls;
            if (await Promise.all([...primaryImagesList.map(preloadImage), Cn().profile.loadLocales(), Cn().profile.loadLocale("en", !0), Cn().profile.loadLocale(), Cn().wallet.fetchBalance(), Cn().referrals.fetchReferralsWithWallets(), Cn().transaction.checkTransaction(), Cn().myGifts.checkIsHiSaid(), Cn().promotions.prefetchPromotionsPromise(), Cn().myGifts.prefetchMyGiftsPromise(), Cn().profile.fetchGiftsCount()]),
            xt(ga => ({
                app: {
                    ...ga.app,
                    targetWallet: Cs.walletForPayment,
                    inGameLink: Cs.inGameLink,
                    serverTime: Ls,
                    startDate: Ws,
                    initialOffset: Vs,
                    shouldShowWaitScreen: Xs
                },
                profile: {
                    ...ga.profile,
                    fullName: Cs.fullName,
                    locale: Cs.currentLanguage,
                    allowsPm: Cs.allowsPm,
                    photo: Cs.photo,
                    refUrl: Cs.refUrl,
                    currentLanguageCode: Cs.currentLanguageCode,
                    id: Cs.id,
                    payerId: Cs.payerId,
                    isVIP: Cs.isVIP,
                    referralRevenueCoef: Cs.referralRevenueCoef || 0
                },
                wallet: {
                    ...ga.wallet,
                    ton: Cs.wallet.ton
                }
            })),
            Xs && Ws && Vs !== null) {
                const ga = new Date(Ws.getTime() - Vs);
                Cn().timers.startTask(COMMON_TASKS.WAIT_SCREEN_END, ga, () => {
                    window.location.reload()
                }
                )
            }
        } catch (as) {
            console.log("bootstrap error", as)
        } finally {
            xt(as => ({
                app: {
                    ...as.app,
                    state: "ready"
                }
            }))
        }
    }
    ,
    parseGameConfigs: as => {
        const cs = {};
        as.forEach(Cs => {
            switch (Cs.key) {
            case "IsOnMaintenance":
                cs.maintenance = Cs.value.toLowerCase() === "true";
                return;
            case "MinDepositAmount":
                cs.minDepositAmount = Number(Cs.value);
                return;
            case "MinNanoTonsWithdraw":
                cs.minWithdrawAmount = Number(Cs.value);
                return;
            case "PreloaderLeaderboardId":
                cs.leaderboardId = Number(Cs.value);
                return;
            case "RelayerBotName":
                cs.relayerBotName = Cs.value;
                return;
            case "MinSalePrice":
                cs.minSalePrice = Number(Cs.value);
                return;
            case "FreeSalesCount":
                cs.freeSalesCount = Number(Cs.value);
                return;
            case "MaxBatchSaleGifts":
                cs.maxBatchSaleGifts = Number(Cs.value);
                return;
            case "MaxReturnGifts":
                cs.maxReturnGifts = Number(Cs.value);
                return;
            case "SalePrice":
                cs.salePrice = Number(Cs.value);
                return;
            case "MinQueryLength":
                cs.minQueryLength = Number(Cs.value);
                return;
            case "MaxQueryLength":
                cs.maxQueryLength = Number(Cs.value);
                return;
            case "MaxSalePrice":
                cs.maxSalePrice = Number(Cs.value);
                return;
            case "PromotePrice":
                cs.promotePrice = Number(Cs.value);
                return;
            case "SalesFee":
                cs.salesFee = Number(Cs.value);
                return;
            case "MaxBatchBuy":
                cs.maxBatchBuy = Number(Cs.value);
                return;
            case "AppBotName":
                cs.appBotName = Cs.value;
                return;
            case "MaxChatsForGiveaway":
                cs.maxChatsForGiveaway = Number(Cs.value);
                return;
            case "MaxGiveawayGifts":
                cs.maxGiveawayGifts = Number(Cs.value);
                return;
            case "GiveawayPrizeFeeCost":
                cs.giveawayPrizeFeeCost = Number(Cs.value);
                return;
            case "PrivateGiveawayFee":
                cs.privateGiveawayFee = Number(Cs.value);
                return;
            case "GiveawayTicketFee":
                cs.giveawayTicketFee = Number(Cs.value);
                return;
            case "GiveawayDurations":
                cs.giveawayDurations = JSON.parse(Cs.value);
                return;
            case "GiveawayMaxTicketsCount":
                cs.giveawayMaxTicketsCount = Number(Cs.value);
                return;
            case "MinNonFreeGiveawayPrice":
                cs.minNonFreeGiveawayPrice = Number(Cs.value);
                return;
            case "ReturnGiftPrice":
                cs.returnGiftPrice = Number(Cs.value);
                return;
            case "IsOnPrelaunch":
                cs.isOnPrelaunch = Cs.value.toLowerCase() === "true";
                return;
            case "TradingVolumeLevels":
                cs.tradingVolumeLevels = JSON.parse(Cs.value);
                return
            }
        }
        ),
        xt(Cs => ({
            app: {
                ...Cs.app,
                ...cs
            }
        }))
    }
    ,
    openLink: function(as) {
        window.Telegram.WebApp && (as.startsWith("https://t.me/") ? window.Telegram.WebApp.openTelegramLink(as) : window.Telegram.WebApp.openLink(as))
    }
}))
  , authSlice = createSlice( (xt, Cn) => ({
    accessToken: "",
    userId: "",
    is_premium: !1,
    allow_pm: !1,
    isFirstTime: !1,
    authorization: async () => {
        let as, cs = {
            data: "query_id=AAH-a9B2AAAAAP5r0HY1H6bj&user=%7B%22id%22%3A" + as + "%2C%22first_name%22%3A%22%D0%90%D0%BD%D0%B4%D1%80%D0%B5%D0%B9%22%2C%22last_name%22%3A%22%22%2C%22username%22%3A%22dev_" + as + "%22%2C%22language_code%22%3A%22ru%22%2C%22is_premium%22%3Atrue%2C%22allows_write_to_pm%22%3Atrue%7D&auth_date=1718024871&hash=0815b674dc347c04ec33de877196c0106b2bb7001727ee9efd66dc08ea88ff1c"
        }, Cs = !1, Ls = !1;
        if (window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe && window.Telegram.WebApp.initDataUnsafe.user) {
            const Vs = window.Telegram.WebApp
              , Ws = Vs.initDataUnsafe.user
              , Xs = Ws == null ? void 0 : Ws.photo_url;
            as = Ws.id,
            cs = {
                data: Vs.initData,
                ...Xs ? {
                    photo: Xs
                } : {}
            },
            Cs = Ws.is_premium || !1,
            Ls = Ws.allows_write_to_pm || !1,
            xt(ga => ({
                profile: {
                    ...ga.profile,
                    tgUser: Ws
                }
            }))
        }
        try {
            const Ws = await fetch(getApiUrl("/api/v1/auth"), {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    ...cs,
                    appId: null
                })
            });
            if (Ws.status === 403)
                return xt(ba => ({
                    app: {
                        ...ba.app,
                        forbidden: !0
                    }
                })),
                await Ws.text() || "forbidden";
            if (!Ws.ok)
                return xt(ga => ({
                    app: {
                        ...ga.app,
                        state: APP_STATE.ERROR,
                        forbidden: !0
                    }
                })),
                "forbidden";
            const Xs = await Ws.json();
            xt(ga => ({
                auth: {
                    ...ga.auth,
                    accessToken: Xs.token,
                    userId: as,
                    is_premium: Cs,
                    allow_pm: Ls,
                    isFirstTime: Xs.isFirstTime
                }
            })),
            Xs.giftId && Cn().gifts.getGiftInfo(Xs.giftId),
            Xs.giveawayId && Cn().giveaways.openGiveaway(Xs.giveawayId),
            Xs.feedEventId && Cn().feed.getAndOpenFeedEvent(Xs.feedEventId)
        } catch (Vs) {
            return console.error("Auth error", Vs),
            xt(Ws => ({
                app: {
                    ...Ws.app,
                    state: APP_STATE.ERROR,
                    forbidden: !0
                }
            })),
            "forbidden"
        }
    }
}))
  , isIterable = xt => Symbol.iterator in xt
  , hasIterableEntries = xt => "entries"in xt
  , compareEntries = (xt, Cn) => {
    const as = xt instanceof Map ? xt : new Map(xt.entries())
      , cs = Cn instanceof Map ? Cn : new Map(Cn.entries());
    if (as.size !== cs.size)
        return !1;
    for (const [Cs,Ls] of as)
        if (!Object.is(Ls, cs.get(Cs)))
            return !1;
    return !0
}
  , compareIterables = (xt, Cn) => {
    const as = xt[Symbol.iterator]()
      , cs = Cn[Symbol.iterator]();
    let Cs = as.next()
      , Ls = cs.next();
    for (; !Cs.done && !Ls.done; ) {
        if (!Object.is(Cs.value, Ls.value))
            return !1;
        Cs = as.next(),
        Ls = cs.next()
    }
    return !!Cs.done && !!Ls.done
}
;
function shallow(xt, Cn) {
    return Object.is(xt, Cn) ? !0 : typeof xt != "object" || xt === null || typeof Cn != "object" || Cn === null ? !1 : !isIterable(xt) || !isIterable(Cn) ? compareEntries({
        entries: () => Object.entries(xt)
    }, {
        entries: () => Object.entries(Cn)
    }) : hasIterableEntries(xt) && hasIterableEntries(Cn) ? compareEntries(xt, Cn) : compareIterables(xt, Cn)
}
function useShallow(xt) {
    const Cn = React__default.useRef(void 0);
    return as => {
        const cs = xt(as);
        return shallow(Cn.current, cs) ? Cn.current : Cn.current = cs
    }
}
const localesSlice = createSlice( (xt, Cn) => ({
    locales: [],
    locale: "",
    loadLocale: async as => {
        try {
            const Cs = await (await fetch(`/locales/${as}.json`)).json();
            instance.addResourceBundle(as, "translation", Cs, !0, !0),
            xt(Ls => ({
                locales: {
                    ...Ls.locales,
                    locale: as
                }
            }))
        } catch {}
    }
    ,
    loadLocales: async () => {
        try {
            const cs = await (await fetch("/locales/list.json")).json();
            xt(Cs => ({
                locales: {
                    ...Cs.locales,
                    locales: cs
                }
            }))
        } catch {}
    }
    ,
    updateCurrentLanguage: as => {
        instance.changeLanguage(as),
        xt(cs => ({
            locales: {
                ...cs.locales,
                locale: as
            }
        }))
    }
}));
var version$1 = "4.6.1";
function wait(xt, Cn) {
    return new Promise(function(as) {
        return setTimeout(as, xt, Cn)
    }
    )
}
function releaseEventLoop() {
    return new Promise(function(xt) {
        var Cn = new MessageChannel;
        Cn.port1.onmessage = function() {
            return xt()
        }
        ,
        Cn.port2.postMessage(null)
    }
    )
}
function requestIdleCallbackIfAvailable(xt, Cn) {
    Cn === void 0 && (Cn = 1 / 0);
    var as = window.requestIdleCallback;
    return as ? new Promise(function(cs) {
        return as.call(window, function() {
            return cs()
        }, {
            timeout: Cn
        })
    }
    ) : wait(Math.min(xt, Cn))
}
function isPromise(xt) {
    return !!xt && typeof xt.then == "function"
}
function awaitIfAsync(xt, Cn) {
    try {
        var as = xt();
        isPromise(as) ? as.then(function(cs) {
            return Cn(!0, cs)
        }, function(cs) {
            return Cn(!1, cs)
        }) : Cn(!0, as)
    } catch (cs) {
        Cn(!1, cs)
    }
}
function mapWithBreaks(xt, Cn, as) {
    return as === void 0 && (as = 16),
    __awaiter(this, void 0, void 0, function() {
        var cs, Cs, Ls, Vs;
        return __generator(this, function(Ws) {
            switch (Ws.label) {
            case 0:
                cs = Array(xt.length),
                Cs = Date.now(),
                Ls = 0,
                Ws.label = 1;
            case 1:
                return Ls < xt.length ? (cs[Ls] = Cn(xt[Ls], Ls),
                Vs = Date.now(),
                Vs >= Cs + as ? (Cs = Vs,
                [4, releaseEventLoop()]) : [3, 3]) : [3, 4];
            case 2:
                Ws.sent(),
                Ws.label = 3;
            case 3:
                return ++Ls,
                [3, 1];
            case 4:
                return [2, cs]
            }
        })
    })
}
function suppressUnhandledRejectionWarning(xt) {
    return xt.then(void 0, function() {}),
    xt
}
function includes(xt, Cn) {
    for (var as = 0, cs = xt.length; as < cs; ++as)
        if (xt[as] === Cn)
            return !0;
    return !1
}
function excludes(xt, Cn) {
    return !includes(xt, Cn)
}
function toInt(xt) {
    return parseInt(xt)
}
function toFloat(xt) {
    return parseFloat(xt)
}
function replaceNaN(xt, Cn) {
    return typeof xt == "number" && isNaN(xt) ? Cn : xt
}
function countTruthy(xt) {
    return xt.reduce(function(Cn, as) {
        return Cn + (as ? 1 : 0)
    }, 0)
}
function round(xt, Cn) {
    if (Cn === void 0 && (Cn = 1),
    Math.abs(Cn) >= 1)
        return Math.round(xt / Cn) * Cn;
    var as = 1 / Cn;
    return Math.round(xt * as) / as
}
function parseSimpleCssSelector(xt) {
    for (var Cn, as, cs = "Unexpected syntax '".concat(xt, "'"), Cs = /^\s*([a-z-]*)(.*)$/i.exec(xt), Ls = Cs[1] || void 0, Vs = {}, Ws = /([.:#][\w-]+|\[.+?\])/gi, Xs = function(xl, wl) {
        Vs[xl] = Vs[xl] || [],
        Vs[xl].push(wl)
    }; ; ) {
        var ga = Ws.exec(Cs[2]);
        if (!ga)
            break;
        var ba = ga[0];
        switch (ba[0]) {
        case ".":
            Xs("class", ba.slice(1));
            break;
        case "#":
            Xs("id", ba.slice(1));
            break;
        case "[":
            {
                var yl = /^\[([\w-]+)([~|^$*]?=("(.*?)"|([\w-]+)))?(\s+[is])?\]$/.exec(ba);
                if (yl)
                    Xs(yl[1], (as = (Cn = yl[4]) !== null && Cn !== void 0 ? Cn : yl[5]) !== null && as !== void 0 ? as : "");
                else
                    throw new Error(cs);
                break
            }
        default:
            throw new Error(cs)
        }
    }
    return [Ls, Vs]
}
function getUTF8Bytes(xt) {
    for (var Cn = new Uint8Array(xt.length), as = 0; as < xt.length; as++) {
        var cs = xt.charCodeAt(as);
        if (cs > 127)
            return new TextEncoder().encode(xt);
        Cn[as] = cs
    }
    return Cn
}
function x64Add(xt, Cn) {
    var as = xt[0] >>> 16
      , cs = xt[0] & 65535
      , Cs = xt[1] >>> 16
      , Ls = xt[1] & 65535
      , Vs = Cn[0] >>> 16
      , Ws = Cn[0] & 65535
      , Xs = Cn[1] >>> 16
      , ga = Cn[1] & 65535
      , ba = 0
      , yl = 0
      , xl = 0
      , wl = 0;
    wl += Ls + ga,
    xl += wl >>> 16,
    wl &= 65535,
    xl += Cs + Xs,
    yl += xl >>> 16,
    xl &= 65535,
    yl += cs + Ws,
    ba += yl >>> 16,
    yl &= 65535,
    ba += as + Vs,
    ba &= 65535,
    xt[0] = ba << 16 | yl,
    xt[1] = xl << 16 | wl
}
function x64Multiply(xt, Cn) {
    var as = xt[0] >>> 16
      , cs = xt[0] & 65535
      , Cs = xt[1] >>> 16
      , Ls = xt[1] & 65535
      , Vs = Cn[0] >>> 16
      , Ws = Cn[0] & 65535
      , Xs = Cn[1] >>> 16
      , ga = Cn[1] & 65535
      , ba = 0
      , yl = 0
      , xl = 0
      , wl = 0;
    wl += Ls * ga,
    xl += wl >>> 16,
    wl &= 65535,
    xl += Cs * ga,
    yl += xl >>> 16,
    xl &= 65535,
    xl += Ls * Xs,
    yl += xl >>> 16,
    xl &= 65535,
    yl += cs * ga,
    ba += yl >>> 16,
    yl &= 65535,
    yl += Cs * Xs,
    ba += yl >>> 16,
    yl &= 65535,
    yl += Ls * Ws,
    ba += yl >>> 16,
    yl &= 65535,
    ba += as * ga + cs * Xs + Cs * Ws + Ls * Vs,
    ba &= 65535,
    xt[0] = ba << 16 | yl,
    xt[1] = xl << 16 | wl
}
function x64Rotl(xt, Cn) {
    var as = xt[0];
    Cn %= 64,
    Cn === 32 ? (xt[0] = xt[1],
    xt[1] = as) : Cn < 32 ? (xt[0] = as << Cn | xt[1] >>> 32 - Cn,
    xt[1] = xt[1] << Cn | as >>> 32 - Cn) : (Cn -= 32,
    xt[0] = xt[1] << Cn | as >>> 32 - Cn,
    xt[1] = as << Cn | xt[1] >>> 32 - Cn)
}
function x64LeftShift(xt, Cn) {
    Cn %= 64,
    Cn !== 0 && (Cn < 32 ? (xt[0] = xt[1] >>> 32 - Cn,
    xt[1] = xt[1] << Cn) : (xt[0] = xt[1] << Cn - 32,
    xt[1] = 0))
}
function x64Xor(xt, Cn) {
    xt[0] ^= Cn[0],
    xt[1] ^= Cn[1]
}
var F1 = [4283543511, 3981806797]
  , F2 = [3301882366, 444984403];
function x64Fmix(xt) {
    var Cn = [0, xt[0] >>> 1];
    x64Xor(xt, Cn),
    x64Multiply(xt, F1),
    Cn[1] = xt[0] >>> 1,
    x64Xor(xt, Cn),
    x64Multiply(xt, F2),
    Cn[1] = xt[0] >>> 1,
    x64Xor(xt, Cn)
}
var C1 = [2277735313, 289559509]
  , C2 = [1291169091, 658871167]
  , M$1$1 = [0, 5]
  , N1 = [0, 1390208809]
  , N2 = [0, 944331445];
function x64hash128(xt, Cn) {
    var as = getUTF8Bytes(xt);
    Cn = Cn || 0;
    var cs = [0, as.length], Cs = cs[1] % 16, Ls = cs[1] - Cs, Vs = [0, Cn], Ws = [0, Cn], Xs = [0, 0], ga = [0, 0], ba;
    for (ba = 0; ba < Ls; ba = ba + 16)
        Xs[0] = as[ba + 4] | as[ba + 5] << 8 | as[ba + 6] << 16 | as[ba + 7] << 24,
        Xs[1] = as[ba] | as[ba + 1] << 8 | as[ba + 2] << 16 | as[ba + 3] << 24,
        ga[0] = as[ba + 12] | as[ba + 13] << 8 | as[ba + 14] << 16 | as[ba + 15] << 24,
        ga[1] = as[ba + 8] | as[ba + 9] << 8 | as[ba + 10] << 16 | as[ba + 11] << 24,
        x64Multiply(Xs, C1),
        x64Rotl(Xs, 31),
        x64Multiply(Xs, C2),
        x64Xor(Vs, Xs),
        x64Rotl(Vs, 27),
        x64Add(Vs, Ws),
        x64Multiply(Vs, M$1$1),
        x64Add(Vs, N1),
        x64Multiply(ga, C2),
        x64Rotl(ga, 33),
        x64Multiply(ga, C1),
        x64Xor(Ws, ga),
        x64Rotl(Ws, 31),
        x64Add(Ws, Vs),
        x64Multiply(Ws, M$1$1),
        x64Add(Ws, N2);
    Xs[0] = 0,
    Xs[1] = 0,
    ga[0] = 0,
    ga[1] = 0;
    var yl = [0, 0];
    switch (Cs) {
    case 15:
        yl[1] = as[ba + 14],
        x64LeftShift(yl, 48),
        x64Xor(ga, yl);
    case 14:
        yl[1] = as[ba + 13],
        x64LeftShift(yl, 40),
        x64Xor(ga, yl);
    case 13:
        yl[1] = as[ba + 12],
        x64LeftShift(yl, 32),
        x64Xor(ga, yl);
    case 12:
        yl[1] = as[ba + 11],
        x64LeftShift(yl, 24),
        x64Xor(ga, yl);
    case 11:
        yl[1] = as[ba + 10],
        x64LeftShift(yl, 16),
        x64Xor(ga, yl);
    case 10:
        yl[1] = as[ba + 9],
        x64LeftShift(yl, 8),
        x64Xor(ga, yl);
    case 9:
        yl[1] = as[ba + 8],
        x64Xor(ga, yl),
        x64Multiply(ga, C2),
        x64Rotl(ga, 33),
        x64Multiply(ga, C1),
        x64Xor(Ws, ga);
    case 8:
        yl[1] = as[ba + 7],
        x64LeftShift(yl, 56),
        x64Xor(Xs, yl);
    case 7:
        yl[1] = as[ba + 6],
        x64LeftShift(yl, 48),
        x64Xor(Xs, yl);
    case 6:
        yl[1] = as[ba + 5],
        x64LeftShift(yl, 40),
        x64Xor(Xs, yl);
    case 5:
        yl[1] = as[ba + 4],
        x64LeftShift(yl, 32),
        x64Xor(Xs, yl);
    case 4:
        yl[1] = as[ba + 3],
        x64LeftShift(yl, 24),
        x64Xor(Xs, yl);
    case 3:
        yl[1] = as[ba + 2],
        x64LeftShift(yl, 16),
        x64Xor(Xs, yl);
    case 2:
        yl[1] = as[ba + 1],
        x64LeftShift(yl, 8),
        x64Xor(Xs, yl);
    case 1:
        yl[1] = as[ba],
        x64Xor(Xs, yl),
        x64Multiply(Xs, C1),
        x64Rotl(Xs, 31),
        x64Multiply(Xs, C2),
        x64Xor(Vs, Xs)
    }
    return x64Xor(Vs, cs),
    x64Xor(Ws, cs),
    x64Add(Vs, Ws),
    x64Add(Ws, Vs),
    x64Fmix(Vs),
    x64Fmix(Ws),
    x64Add(Vs, Ws),
    x64Add(Ws, Vs),
    ("00000000" + (Vs[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (Vs[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (Ws[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (Ws[1] >>> 0).toString(16)).slice(-8)
}
function errorToObject(xt) {
    var Cn;
    return __assign({
        name: xt.name,
        message: xt.message,
        stack: (Cn = xt.stack) === null || Cn === void 0 ? void 0 : Cn.split(`
`)
    }, xt)
}
function isFunctionNative(xt) {
    return /^function\s.*?\{\s*\[native code]\s*}$/.test(String(xt))
}
function isFinalResultLoaded(xt) {
    return typeof xt != "function"
}
function loadSource(xt, Cn) {
    var as = suppressUnhandledRejectionWarning(new Promise(function(cs) {
        var Cs = Date.now();
        awaitIfAsync(xt.bind(null, Cn), function() {
            for (var Ls = [], Vs = 0; Vs < arguments.length; Vs++)
                Ls[Vs] = arguments[Vs];
            var Ws = Date.now() - Cs;
            if (!Ls[0])
                return cs(function() {
                    return {
                        error: Ls[1],
                        duration: Ws
                    }
                });
            var Xs = Ls[1];
            if (isFinalResultLoaded(Xs))
                return cs(function() {
                    return {
                        value: Xs,
                        duration: Ws
                    }
                });
            cs(function() {
                return new Promise(function(ga) {
                    var ba = Date.now();
                    awaitIfAsync(Xs, function() {
                        for (var yl = [], xl = 0; xl < arguments.length; xl++)
                            yl[xl] = arguments[xl];
                        var wl = Ws + Date.now() - ba;
                        if (!yl[0])
                            return ga({
                                error: yl[1],
                                duration: wl
                            });
                        ga({
                            value: yl[1],
                            duration: wl
                        })
                    })
                }
                )
            })
        })
    }
    ));
    return function() {
        return as.then(function(Cs) {
            return Cs()
        })
    }
}
function loadSources(xt, Cn, as, cs) {
    var Cs = Object.keys(xt).filter(function(Vs) {
        return excludes(as, Vs)
    })
      , Ls = suppressUnhandledRejectionWarning(mapWithBreaks(Cs, function(Vs) {
        return loadSource(xt[Vs], Cn)
    }, cs));
    return function() {
        return __awaiter(this, void 0, void 0, function() {
            var Ws, Xs, ga, ba, yl;
            return __generator(this, function(xl) {
                switch (xl.label) {
                case 0:
                    return [4, Ls];
                case 1:
                    return Ws = xl.sent(),
                    [4, mapWithBreaks(Ws, function(wl) {
                        return suppressUnhandledRejectionWarning(wl())
                    }, cs)];
                case 2:
                    return Xs = xl.sent(),
                    [4, Promise.all(Xs)];
                case 3:
                    for (ga = xl.sent(),
                    ba = {},
                    yl = 0; yl < Cs.length; ++yl)
                        ba[Cs[yl]] = ga[yl];
                    return [2, ba]
                }
            })
        })
    }
}
function isTrident() {
    var xt = window
      , Cn = navigator;
    return countTruthy(["MSCSSMatrix"in xt, "msSetImmediate"in xt, "msIndexedDB"in xt, "msMaxTouchPoints"in Cn, "msPointerEnabled"in Cn]) >= 4
}
function isEdgeHTML() {
    var xt = window
      , Cn = navigator;
    return countTruthy(["msWriteProfilerMark"in xt, "MSStream"in xt, "msLaunchUri"in Cn, "msSaveBlob"in Cn]) >= 3 && !isTrident()
}
function isChromium() {
    var xt = window
      , Cn = navigator;
    return countTruthy(["webkitPersistentStorage"in Cn, "webkitTemporaryStorage"in Cn, (Cn.vendor || "").indexOf("Google") === 0, "webkitResolveLocalFileSystemURL"in xt, "BatteryManager"in xt, "webkitMediaStream"in xt, "webkitSpeechGrammar"in xt]) >= 5
}
function isWebKit() {
    var xt = window
      , Cn = navigator;
    return countTruthy(["ApplePayError"in xt, "CSSPrimitiveValue"in xt, "Counter"in xt, Cn.vendor.indexOf("Apple") === 0, "RGBColor"in xt, "WebKitMediaKeys"in xt]) >= 4
}
function isDesktopWebKit() {
    var xt = window
      , Cn = xt.HTMLElement
      , as = xt.Document;
    return countTruthy(["safari"in xt, !("ongestureend"in xt), !("TouchEvent"in xt), !("orientation"in xt), Cn && !("autocapitalize"in Cn.prototype), as && "pointerLockElement"in as.prototype]) >= 4
}
function isSafariWebKit() {
    var xt = window;
    return isFunctionNative(xt.print) && String(xt.browser) === "[object WebPageNamespace]"
}
function isGecko() {
    var xt, Cn, as = window;
    return countTruthy(["buildID"in navigator, "MozAppearance"in ((Cn = (xt = document.documentElement) === null || xt === void 0 ? void 0 : xt.style) !== null && Cn !== void 0 ? Cn : {}), "onmozfullscreenchange"in as, "mozInnerScreenX"in as, "CSSMozDocumentRule"in as, "CanvasCaptureMediaStream"in as]) >= 4
}
function isChromium86OrNewer() {
    var xt = window;
    return countTruthy([!("MediaSettingsRange"in xt), "RTCEncodedAudioFrame"in xt, "" + xt.Intl == "[object Intl]", "" + xt.Reflect == "[object Reflect]"]) >= 3
}
function isChromium122OrNewer() {
    var xt = window
      , Cn = xt.URLPattern;
    return countTruthy(["union"in Set.prototype, "Iterator"in xt, Cn && "hasRegExpGroups"in Cn.prototype, "RGB8"in WebGLRenderingContext.prototype]) >= 3
}
function isWebKit606OrNewer() {
    var xt = window;
    return countTruthy(["DOMRectList"in xt, "RTCPeerConnectionIceEvent"in xt, "SVGGeometryElement"in xt, "ontransitioncancel"in xt]) >= 3
}
function isWebKit616OrNewer() {
    var xt = window
      , Cn = navigator
      , as = xt.CSS
      , cs = xt.HTMLButtonElement;
    return countTruthy([!("getStorageUpdates"in Cn), cs && "popover"in cs.prototype, "CSSCounterStyleRule"in xt, as.supports("font-size-adjust: ex-height 0.5"), as.supports("text-transform: full-width")]) >= 4
}
function isIPad() {
    if (navigator.platform === "iPad")
        return !0;
    var xt = screen
      , Cn = xt.width / xt.height;
    return countTruthy(["MediaSource"in window, !!Element.prototype.webkitRequestFullscreen, Cn > .65 && Cn < 1.53]) >= 2
}
function getFullscreenElement() {
    var xt = document;
    return xt.fullscreenElement || xt.msFullscreenElement || xt.mozFullScreenElement || xt.webkitFullscreenElement || null
}
function exitFullscreen() {
    var xt = document;
    return (xt.exitFullscreen || xt.msExitFullscreen || xt.mozCancelFullScreen || xt.webkitExitFullscreen).call(xt)
}
function isAndroid() {
    var xt = isChromium()
      , Cn = isGecko()
      , as = window
      , cs = navigator
      , Cs = "connection";
    return xt ? countTruthy([!("SharedWorker"in as), cs[Cs] && "ontypechange"in cs[Cs], !("sinkId"in new Audio)]) >= 2 : Cn ? countTruthy(["onorientationchange"in as, "orientation"in as, /android/i.test(cs.appVersion)]) >= 2 : !1
}
function isSamsungInternet() {
    var xt = navigator
      , Cn = window
      , as = Audio.prototype
      , cs = Cn.visualViewport;
    return countTruthy(["srLatency"in as, "srChannelCount"in as, "devicePosture"in xt, cs && "segments"in cs, "getTextInformation"in Image.prototype]) >= 3
}
function getAudioFingerprint() {
    return doesBrowserPerformAntifingerprinting$1() ? -4 : getUnstableAudioFingerprint()
}
function getUnstableAudioFingerprint() {
    var xt = window
      , Cn = xt.OfflineAudioContext || xt.webkitOfflineAudioContext;
    if (!Cn)
        return -2;
    if (doesBrowserSuspendAudioContext())
        return -1;
    var as = 4500
      , cs = 5e3
      , Cs = new Cn(1,cs,44100)
      , Ls = Cs.createOscillator();
    Ls.type = "triangle",
    Ls.frequency.value = 1e4;
    var Vs = Cs.createDynamicsCompressor();
    Vs.threshold.value = -50,
    Vs.knee.value = 40,
    Vs.ratio.value = 12,
    Vs.attack.value = 0,
    Vs.release.value = .25,
    Ls.connect(Vs),
    Vs.connect(Cs.destination),
    Ls.start(0);
    var Ws = startRenderingAudio(Cs)
      , Xs = Ws[0]
      , ga = Ws[1]
      , ba = suppressUnhandledRejectionWarning(Xs.then(function(yl) {
        return getHash(yl.getChannelData(0).subarray(as))
    }, function(yl) {
        if (yl.name === "timeout" || yl.name === "suspended")
            return -3;
        throw yl
    }));
    return function() {
        return ga(),
        ba
    }
}
function doesBrowserSuspendAudioContext() {
    return isWebKit() && !isDesktopWebKit() && !isWebKit606OrNewer()
}
function doesBrowserPerformAntifingerprinting$1() {
    return isWebKit() && isWebKit616OrNewer() && isSafariWebKit() || isChromium() && isSamsungInternet() && isChromium122OrNewer()
}
function startRenderingAudio(xt) {
    var Cn = 3
      , as = 500
      , cs = 500
      , Cs = 5e3
      , Ls = function() {}
      , Vs = new Promise(function(Ws, Xs) {
        var ga = !1
          , ba = 0
          , yl = 0;
        xt.oncomplete = function(_l) {
            return Ws(_l.renderedBuffer)
        }
        ;
        var xl = function() {
            setTimeout(function() {
                return Xs(makeInnerError("timeout"))
            }, Math.min(cs, yl + Cs - Date.now()))
        }
          , wl = function() {
            try {
                var _l = xt.startRendering();
                switch (isPromise(_l) && suppressUnhandledRejectionWarning(_l),
                xt.state) {
                case "running":
                    yl = Date.now(),
                    ga && xl();
                    break;
                case "suspended":
                    document.hidden || ba++,
                    ga && ba >= Cn ? Xs(makeInnerError("suspended")) : setTimeout(wl, as);
                    break
                }
            } catch (El) {
                Xs(El)
            }
        };
        wl(),
        Ls = function() {
            ga || (ga = !0,
            yl > 0 && xl())
        }
    }
    );
    return [Vs, Ls]
}
function getHash(xt) {
    for (var Cn = 0, as = 0; as < xt.length; ++as)
        Cn += Math.abs(xt[as]);
    return Cn
}
function makeInnerError(xt) {
    var Cn = new Error(xt);
    return Cn.name = xt,
    Cn
}
function withIframe(xt, Cn, as) {
    var cs, Cs, Ls;
    return as === void 0 && (as = 50),
    __awaiter(this, void 0, void 0, function() {
        var Vs, Ws;
        return __generator(this, function(Xs) {
            switch (Xs.label) {
            case 0:
                Vs = document,
                Xs.label = 1;
            case 1:
                return Vs.body ? [3, 3] : [4, wait(as)];
            case 2:
                return Xs.sent(),
                [3, 1];
            case 3:
                Ws = Vs.createElement("iframe"),
                Xs.label = 4;
            case 4:
                return Xs.trys.push([4, , 10, 11]),
                [4, new Promise(function(ga, ba) {
                    var yl = !1
                      , xl = function() {
                        yl = !0,
                        ga()
                    }
                      , wl = function(Cl) {
                        yl = !0,
                        ba(Cl)
                    };
                    Ws.onload = xl,
                    Ws.onerror = wl;
                    var _l = Ws.style;
                    _l.setProperty("display", "block", "important"),
                    _l.position = "absolute",
                    _l.top = "0",
                    _l.left = "0",
                    _l.visibility = "hidden",
                    Cn && "srcdoc"in Ws ? Ws.srcdoc = Cn : Ws.src = "about:blank",
                    Vs.body.appendChild(Ws);
                    var El = function() {
                        var Cl, $l;
                        yl || ((($l = (Cl = Ws.contentWindow) === null || Cl === void 0 ? void 0 : Cl.document) === null || $l === void 0 ? void 0 : $l.readyState) === "complete" ? xl() : setTimeout(El, 10))
                    };
                    El()
                }
                )];
            case 5:
                Xs.sent(),
                Xs.label = 6;
            case 6:
                return !((Cs = (cs = Ws.contentWindow) === null || cs === void 0 ? void 0 : cs.document) === null || Cs === void 0) && Cs.body ? [3, 8] : [4, wait(as)];
            case 7:
                return Xs.sent(),
                [3, 6];
            case 8:
                return [4, xt(Ws, Ws.contentWindow)];
            case 9:
                return [2, Xs.sent()];
            case 10:
                return (Ls = Ws.parentNode) === null || Ls === void 0 || Ls.removeChild(Ws),
                [7];
            case 11:
                return [2]
            }
        })
    })
}
function selectorToElement(xt) {
    for (var Cn = parseSimpleCssSelector(xt), as = Cn[0], cs = Cn[1], Cs = document.createElement(as ?? "div"), Ls = 0, Vs = Object.keys(cs); Ls < Vs.length; Ls++) {
        var Ws = Vs[Ls]
          , Xs = cs[Ws].join(" ");
        Ws === "style" ? addStyleString(Cs.style, Xs) : Cs.setAttribute(Ws, Xs)
    }
    return Cs
}
function addStyleString(xt, Cn) {
    for (var as = 0, cs = Cn.split(";"); as < cs.length; as++) {
        var Cs = cs[as]
          , Ls = /^\s*([\w-]+)\s*:\s*(.+?)(\s*!([\w-]+))?\s*$/.exec(Cs);
        if (Ls) {
            var Vs = Ls[1]
              , Ws = Ls[2]
              , Xs = Ls[4];
            xt.setProperty(Vs, Ws, Xs || "")
        }
    }
}
function isAnyParentCrossOrigin() {
    for (var xt = window; ; ) {
        var Cn = xt.parent;
        if (!Cn || Cn === xt)
            return !1;
        try {
            if (Cn.location.origin !== xt.location.origin)
                return !0
        } catch (as) {
            if (as instanceof Error && as.name === "SecurityError")
                return !0;
            throw as
        }
        xt = Cn
    }
}
var testString = "mmMwWLliI0O&1"
  , textSize = "48px"
  , baseFonts = ["monospace", "sans-serif", "serif"]
  , fontList = ["sans-serif-thin", "ARNO PRO", "Agency FB", "Arabic Typesetting", "Arial Unicode MS", "AvantGarde Bk BT", "BankGothic Md BT", "Batang", "Bitstream Vera Sans Mono", "Calibri", "Century", "Century Gothic", "Clarendon", "EUROSTILE", "Franklin Gothic", "Futura Bk BT", "Futura Md BT", "GOTHAM", "Gill Sans", "HELV", "Haettenschweiler", "Helvetica Neue", "Humanst521 BT", "Leelawadee", "Letter Gothic", "Levenim MT", "Lucida Bright", "Lucida Sans", "Menlo", "MS Mincho", "MS Outlook", "MS Reference Specialty", "MS UI Gothic", "MT Extra", "MYRIAD PRO", "Marlett", "Meiryo UI", "Microsoft Uighur", "Minion Pro", "Monotype Corsiva", "PMingLiU", "Pristina", "SCRIPTINA", "Segoe UI Light", "Serifa", "SimHei", "Small Fonts", "Staccato222 BT", "TRAJAN PRO", "Univers CE 55 Medium", "Vrinda", "ZWAdobeF"];
function getFonts() {
    var xt = this;
    return withIframe(function(Cn, as) {
        var cs = as.document;
        return __awaiter(xt, void 0, void 0, function() {
            var Cs, Ls, Vs, Ws, Xs, ga, ba, yl, xl, wl, _l, El;
            return __generator(this, function(Cl) {
                for (Cs = cs.body,
                Cs.style.fontSize = textSize,
                Ls = cs.createElement("div"),
                Ls.style.setProperty("visibility", "hidden", "important"),
                Vs = {},
                Ws = {},
                Xs = function($l) {
                    var Sl = cs.createElement("span")
                      , Tl = Sl.style;
                    return Tl.position = "absolute",
                    Tl.top = "0",
                    Tl.left = "0",
                    Tl.fontFamily = $l,
                    Sl.textContent = testString,
                    Ls.appendChild(Sl),
                    Sl
                }
                ,
                ga = function($l, Sl) {
                    return Xs("'".concat($l, "',").concat(Sl))
                }
                ,
                ba = function() {
                    return baseFonts.map(Xs)
                }
                ,
                yl = function() {
                    for (var $l = {}, Sl = function(Ml) {
                        $l[Ml] = baseFonts.map(function(Nl) {
                            return ga(Ml, Nl)
                        })
                    }, Tl = 0, Rl = fontList; Tl < Rl.length; Tl++) {
                        var Il = Rl[Tl];
                        Sl(Il)
                    }
                    return $l
                }
                ,
                xl = function($l) {
                    return baseFonts.some(function(Sl, Tl) {
                        return $l[Tl].offsetWidth !== Vs[Sl] || $l[Tl].offsetHeight !== Ws[Sl]
                    })
                }
                ,
                wl = ba(),
                _l = yl(),
                Cs.appendChild(Ls),
                El = 0; El < baseFonts.length; El++)
                    Vs[baseFonts[El]] = wl[El].offsetWidth,
                    Ws[baseFonts[El]] = wl[El].offsetHeight;
                return [2, fontList.filter(function($l) {
                    return xl(_l[$l])
                })]
            })
        })
    })
}
function getPlugins() {
    var xt = navigator.plugins;
    if (xt) {
        for (var Cn = [], as = 0; as < xt.length; ++as) {
            var cs = xt[as];
            if (cs) {
                for (var Cs = [], Ls = 0; Ls < cs.length; ++Ls) {
                    var Vs = cs[Ls];
                    Cs.push({
                        type: Vs.type,
                        suffixes: Vs.suffixes
                    })
                }
                Cn.push({
                    name: cs.name,
                    description: cs.description,
                    mimeTypes: Cs
                })
            }
        }
        return Cn
    }
}
function getCanvasFingerprint() {
    return getUnstableCanvasFingerprint(doesBrowserPerformAntifingerprinting())
}
function getUnstableCanvasFingerprint(xt) {
    var Cn, as = !1, cs, Cs, Ls = makeCanvasContext(), Vs = Ls[0], Ws = Ls[1];
    return isSupported(Vs, Ws) ? (as = doesSupportWinding(Ws),
    xt ? cs = Cs = "skipped" : (Cn = renderImages(Vs, Ws),
    cs = Cn[0],
    Cs = Cn[1])) : cs = Cs = "unsupported",
    {
        winding: as,
        geometry: cs,
        text: Cs
    }
}
function makeCanvasContext() {
    var xt = document.createElement("canvas");
    return xt.width = 1,
    xt.height = 1,
    [xt, xt.getContext("2d")]
}
function isSupported(xt, Cn) {
    return !!(Cn && xt.toDataURL)
}
function doesSupportWinding(xt) {
    return xt.rect(0, 0, 10, 10),
    xt.rect(2, 2, 6, 6),
    !xt.isPointInPath(5, 5, "evenodd")
}
function renderImages(xt, Cn) {
    renderTextImage(xt, Cn);
    var as = canvasToString(xt)
      , cs = canvasToString(xt);
    if (as !== cs)
        return ["unstable", "unstable"];
    renderGeometryImage(xt, Cn);
    var Cs = canvasToString(xt);
    return [Cs, as]
}
function renderTextImage(xt, Cn) {
    xt.width = 240,
    xt.height = 60,
    Cn.textBaseline = "alphabetic",
    Cn.fillStyle = "#f60",
    Cn.fillRect(100, 1, 62, 20),
    Cn.fillStyle = "#069",
    Cn.font = '11pt "Times New Roman"';
    var as = "Cwm fjordbank gly ".concat("");
    Cn.fillText(as, 2, 15),
    Cn.fillStyle = "rgba(102, 204, 0, 0.2)",
    Cn.font = "18pt Arial",
    Cn.fillText(as, 4, 45)
}
function renderGeometryImage(xt, Cn) {
    xt.width = 122,
    xt.height = 110,
    Cn.globalCompositeOperation = "multiply";
    for (var as = 0, cs = [["#f2f", 40, 40], ["#2ff", 80, 40], ["#ff2", 60, 80]]; as < cs.length; as++) {
        var Cs = cs[as]
          , Ls = Cs[0]
          , Vs = Cs[1]
          , Ws = Cs[2];
        Cn.fillStyle = Ls,
        Cn.beginPath(),
        Cn.arc(Vs, Ws, 40, 0, Math.PI * 2, !0),
        Cn.closePath(),
        Cn.fill()
    }
    Cn.fillStyle = "#f9c",
    Cn.arc(60, 60, 60, 0, Math.PI * 2, !0),
    Cn.arc(60, 60, 20, 0, Math.PI * 2, !0),
    Cn.fill("evenodd")
}
function canvasToString(xt) {
    return xt.toDataURL()
}
function doesBrowserPerformAntifingerprinting() {
    return isWebKit() && isWebKit616OrNewer() && isSafariWebKit()
}
function getTouchSupport() {
    var xt = navigator, Cn = 0, as;
    xt.maxTouchPoints !== void 0 ? Cn = toInt(xt.maxTouchPoints) : xt.msMaxTouchPoints !== void 0 && (Cn = xt.msMaxTouchPoints);
    try {
        document.createEvent("TouchEvent"),
        as = !0
    } catch {
        as = !1
    }
    var cs = "ontouchstart"in window;
    return {
        maxTouchPoints: Cn,
        touchEvent: as,
        touchStart: cs
    }
}
function getOsCpu() {
    return navigator.oscpu
}
function getLanguages() {
    var xt = navigator
      , Cn = []
      , as = xt.language || xt.userLanguage || xt.browserLanguage || xt.systemLanguage;
    if (as !== void 0 && Cn.push([as]),
    Array.isArray(xt.languages))
        isChromium() && isChromium86OrNewer() || Cn.push(xt.languages);
    else if (typeof xt.languages == "string") {
        var cs = xt.languages;
        cs && Cn.push(cs.split(","))
    }
    return Cn
}
function getColorDepth() {
    return window.screen.colorDepth
}
function getDeviceMemory() {
    return replaceNaN(toFloat(navigator.deviceMemory), void 0)
}
function getScreenResolution() {
    if (!(isWebKit() && isWebKit616OrNewer() && isSafariWebKit()))
        return getUnstableScreenResolution()
}
function getUnstableScreenResolution() {
    var xt = screen
      , Cn = function(cs) {
        return replaceNaN(toInt(cs), null)
    }
      , as = [Cn(xt.width), Cn(xt.height)];
    return as.sort().reverse(),
    as
}
var screenFrameCheckInterval = 2500, roundingPrecision = 10, screenFrameBackup, screenFrameSizeTimeoutId;
function watchScreenFrame() {
    if (screenFrameSizeTimeoutId === void 0) {
        var xt = function() {
            var Cn = getCurrentScreenFrame();
            isFrameSizeNull(Cn) ? screenFrameSizeTimeoutId = setTimeout(xt, screenFrameCheckInterval) : (screenFrameBackup = Cn,
            screenFrameSizeTimeoutId = void 0)
        };
        xt()
    }
}
function getUnstableScreenFrame() {
    var xt = this;
    return watchScreenFrame(),
    function() {
        return __awaiter(xt, void 0, void 0, function() {
            var Cn;
            return __generator(this, function(as) {
                switch (as.label) {
                case 0:
                    return Cn = getCurrentScreenFrame(),
                    isFrameSizeNull(Cn) ? screenFrameBackup ? [2, __spreadArray([], screenFrameBackup, !0)] : getFullscreenElement() ? [4, exitFullscreen()] : [3, 2] : [3, 2];
                case 1:
                    as.sent(),
                    Cn = getCurrentScreenFrame(),
                    as.label = 2;
                case 2:
                    return isFrameSizeNull(Cn) || (screenFrameBackup = Cn),
                    [2, Cn]
                }
            })
        })
    }
}
function getScreenFrame() {
    var xt = this;
    if (isWebKit() && isWebKit616OrNewer() && isSafariWebKit())
        return function() {
            return Promise.resolve(void 0)
        }
        ;
    var Cn = getUnstableScreenFrame();
    return function() {
        return __awaiter(xt, void 0, void 0, function() {
            var as, cs;
            return __generator(this, function(Cs) {
                switch (Cs.label) {
                case 0:
                    return [4, Cn()];
                case 1:
                    return as = Cs.sent(),
                    cs = function(Ls) {
                        return Ls === null ? null : round(Ls, roundingPrecision)
                    }
                    ,
                    [2, [cs(as[0]), cs(as[1]), cs(as[2]), cs(as[3])]]
                }
            })
        })
    }
}
function getCurrentScreenFrame() {
    var xt = screen;
    return [replaceNaN(toFloat(xt.availTop), null), replaceNaN(toFloat(xt.width) - toFloat(xt.availWidth) - replaceNaN(toFloat(xt.availLeft), 0), null), replaceNaN(toFloat(xt.height) - toFloat(xt.availHeight) - replaceNaN(toFloat(xt.availTop), 0), null), replaceNaN(toFloat(xt.availLeft), null)]
}
function isFrameSizeNull(xt) {
    for (var Cn = 0; Cn < 4; ++Cn)
        if (xt[Cn])
            return !1;
    return !0
}
function getHardwareConcurrency() {
    return replaceNaN(toInt(navigator.hardwareConcurrency), void 0)
}
function getTimezone() {
    var xt, Cn = (xt = window.Intl) === null || xt === void 0 ? void 0 : xt.DateTimeFormat;
    if (Cn) {
        var as = new Cn().resolvedOptions().timeZone;
        if (as)
            return as
    }
    var cs = -getTimezoneOffset();
    return "UTC".concat(cs >= 0 ? "+" : "").concat(cs)
}
function getTimezoneOffset() {
    var xt = new Date().getFullYear();
    return Math.max(toFloat(new Date(xt,0,1).getTimezoneOffset()), toFloat(new Date(xt,6,1).getTimezoneOffset()))
}
function getSessionStorage() {
    try {
        return !!window.sessionStorage
    } catch {
        return !0
    }
}
function getLocalStorage() {
    try {
        return !!window.localStorage
    } catch {
        return !0
    }
}
function getIndexedDB() {
    if (!(isTrident() || isEdgeHTML()))
        try {
            return !!window.indexedDB
        } catch {
            return !0
        }
}
function getOpenDatabase() {
    return !!window.openDatabase
}
function getCpuClass() {
    return navigator.cpuClass
}
function getPlatform() {
    var xt = navigator.platform;
    return xt === "MacIntel" && isWebKit() && !isDesktopWebKit() ? isIPad() ? "iPad" : "iPhone" : xt
}
function getVendor() {
    return navigator.vendor || ""
}
function getVendorFlavors() {
    for (var xt = [], Cn = 0, as = ["chrome", "safari", "__crWeb", "__gCrWeb", "yandex", "__yb", "__ybro", "__firefox__", "__edgeTrackingPreventionStatistics", "webkit", "oprt", "samsungAr", "ucweb", "UCShellJava", "puffinDevice"]; Cn < as.length; Cn++) {
        var cs = as[Cn]
          , Cs = window[cs];
        Cs && typeof Cs == "object" && xt.push(cs)
    }
    return xt.sort()
}
function areCookiesEnabled() {
    var xt = document;
    try {
        xt.cookie = "cookietest=1; SameSite=Strict;";
        var Cn = xt.cookie.indexOf("cookietest=") !== -1;
        return xt.cookie = "cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT",
        Cn
    } catch {
        return !1
    }
}
function getFilters() {
    var xt = atob;
    return {
        abpIndo: ["#Iklan-Melayang", "#Kolom-Iklan-728", "#SidebarIklan-wrapper", '[title="ALIENBOLA" i]', xt("I0JveC1CYW5uZXItYWRz")],
        abpvn: [".quangcao", "#mobileCatfish", xt("LmNsb3NlLWFkcw=="), '[id^="bn_bottom_fixed_"]', "#pmadv"],
        adBlockFinland: [".mainostila", xt("LnNwb25zb3JpdA=="), ".ylamainos", xt("YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd"), xt("YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd")],
        adBlockPersian: ["#navbar_notice_50", ".kadr", 'TABLE[width="140px"]', "#divAgahi", xt("YVtocmVmXj0iaHR0cDovL2cxLnYuZndtcm0ubmV0L2FkLyJd")],
        adBlockWarningRemoval: ["#adblock-honeypot", ".adblocker-root", ".wp_adblock_detect", xt("LmhlYWRlci1ibG9ja2VkLWFk"), xt("I2FkX2Jsb2NrZXI=")],
        adGuardAnnoyances: [".hs-sosyal", "#cookieconsentdiv", 'div[class^="app_gdpr"]', ".as-oil", '[data-cypress="soft-push-notification-modal"]'],
        adGuardBase: [".BetterJsPopOverlay", xt("I2FkXzMwMFgyNTA="), xt("I2Jhbm5lcmZsb2F0MjI="), xt("I2NhbXBhaWduLWJhbm5lcg=="), xt("I0FkLUNvbnRlbnQ=")],
        adGuardChinese: [xt("LlppX2FkX2FfSA=="), xt("YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd"), "#widget-quan", xt("YVtocmVmKj0iLzg0OTkyMDIwLnh5eiJd"), xt("YVtocmVmKj0iLjE5NTZobC5jb20vIl0=")],
        adGuardFrench: ["#pavePub", xt("LmFkLWRlc2t0b3AtcmVjdGFuZ2xl"), ".mobile_adhesion", ".widgetadv", xt("LmFkc19iYW4=")],
        adGuardGerman: ['aside[data-portal-id="leaderboard"]'],
        adGuardJapanese: ["#kauli_yad_1", xt("YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0="), xt("Ll9wb3BJbl9pbmZpbml0ZV9hZA=="), xt("LmFkZ29vZ2xl"), xt("Ll9faXNib29zdFJldHVybkFk")],
        adGuardMobile: [xt("YW1wLWF1dG8tYWRz"), xt("LmFtcF9hZA=="), 'amp-embed[type="24smi"]', "#mgid_iframe1", xt("I2FkX2ludmlld19hcmVh")],
        adGuardRussian: [xt("YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0="), xt("LnJlY2xhbWE="), 'div[id^="smi2adblock"]', xt("ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd"), "#psyduckpockeball"],
        adGuardSocial: [xt("YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0="), xt("YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0="), ".etsy-tweet", "#inlineShare", ".popup-social"],
        adGuardSpanishPortuguese: ["#barraPublicidade", "#Publicidade", "#publiEspecial", "#queTooltip", ".cnt-publi"],
        adGuardTrackingProtection: ["#qoo-counter", xt("YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ=="), xt("YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0="), xt("YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ=="), "#top100counter"],
        adGuardTurkish: ["#backkapat", xt("I3Jla2xhbWk="), xt("YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0="), xt("YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd"), xt("YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ==")],
        bulgarian: [xt("dGQjZnJlZW5ldF90YWJsZV9hZHM="), "#ea_intext_div", ".lapni-pop-over", "#xenium_hot_offers"],
        easyList: [".yb-floorad", xt("LndpZGdldF9wb19hZHNfd2lkZ2V0"), xt("LnRyYWZmaWNqdW5reS1hZA=="), ".textad_headline", xt("LnNwb25zb3JlZC10ZXh0LWxpbmtz")],
        easyListChina: [xt("LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ=="), xt("LmZyb250cGFnZUFkdk0="), "#taotaole", "#aafoot.top_box", ".cfa_popup"],
        easyListCookie: [".ezmob-footer", ".cc-CookieWarning", "[data-cookie-number]", xt("LmF3LWNvb2tpZS1iYW5uZXI="), ".sygnal24-gdpr-modal-wrap"],
        easyListCzechSlovak: ["#onlajny-stickers", xt("I3Jla2xhbW5pLWJveA=="), xt("LnJla2xhbWEtbWVnYWJvYXJk"), ".sklik", xt("W2lkXj0ic2tsaWtSZWtsYW1hIl0=")],
        easyListDutch: [xt("I2FkdmVydGVudGll"), xt("I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw=="), ".adstekst", xt("YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0="), "#semilo-lrectangle"],
        easyListGermany: ["#SSpotIMPopSlider", xt("LnNwb25zb3JsaW5rZ3J1ZW4="), xt("I3dlcmJ1bmdza3k="), xt("I3Jla2xhbWUtcmVjaHRzLW1pdHRl"), xt("YVtocmVmXj0iaHR0cHM6Ly9iZDc0Mi5jb20vIl0=")],
        easyListItaly: [xt("LmJveF9hZHZfYW5udW5jaQ=="), ".sb-box-pubbliredazionale", xt("YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd"), xt("YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd"), xt("YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ==")],
        easyListLithuania: [xt("LnJla2xhbW9zX3RhcnBhcw=="), xt("LnJla2xhbW9zX251b3JvZG9z"), xt("aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd"), xt("aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd"), xt("aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd")],
        estonian: [xt("QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==")],
        fanboyAnnoyances: ["#ac-lre-player", ".navigate-to-top", "#subscribe_popup", ".newsletter_holder", "#back-top"],
        fanboyAntiFacebook: [".util-bar-module-firefly-visible"],
        fanboyEnhancedTrackers: [".open.pushModal", "#issuem-leaky-paywall-articles-zero-remaining-nag", "#sovrn_container", 'div[class$="-hide"][zoompage-fontsize][style="display: block;"]', ".BlockNag__Card"],
        fanboySocial: ["#FollowUs", "#meteored_share", "#social_follow", ".article-sharer", ".community__social-desc"],
        frellwitSwedish: [xt("YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ=="), xt("YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ=="), "article.category-samarbete", xt("ZGl2LmhvbGlkQWRz"), "ul.adsmodern"],
        greekAdBlock: [xt("QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd"), xt("QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ=="), xt("QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd"), "DIV.agores300", "TABLE.advright"],
        hungarian: ["#cemp_doboz", ".optimonk-iframe-container", xt("LmFkX19tYWlu"), xt("W2NsYXNzKj0iR29vZ2xlQWRzIl0="), "#hirdetesek_box"],
        iDontCareAboutCookies: ['.alert-info[data-block-track*="CookieNotice"]', ".ModuleTemplateCookieIndicator", ".o--cookies--container", "#cookies-policy-sticky", "#stickyCookieBar"],
        icelandicAbp: [xt("QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ==")],
        latvian: [xt("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0="), xt("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ==")],
        listKr: [xt("YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0="), xt("I2xpdmVyZUFkV3JhcHBlcg=="), xt("YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ=="), xt("aW5zLmZhc3R2aWV3LWFk"), ".revenue_unit_item.dable"],
        listeAr: [xt("LmdlbWluaUxCMUFk"), ".right-and-left-sponsers", xt("YVtocmVmKj0iLmFmbGFtLmluZm8iXQ=="), xt("YVtocmVmKj0iYm9vcmFxLm9yZyJd"), xt("YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd")],
        listeFr: [xt("YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ=="), xt("I2FkY29udGFpbmVyX3JlY2hlcmNoZQ=="), xt("YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0="), ".site-pub-interstitiel", 'div[id^="crt-"][data-criteo-id]'],
        officialPolish: ["#ceneo-placeholder-ceneo-12", xt("W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd"), xt("YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ=="), xt("YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ=="), xt("ZGl2I3NrYXBpZWNfYWQ=")],
        ro: [xt("YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd"), xt("YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd"), xt("YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0="), xt("YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd"), 'a[href^="/url/"]'],
        ruAd: [xt("YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd"), xt("YVtocmVmKj0iLy91dGltZy5ydS8iXQ=="), xt("YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0="), "#pgeldiz", ".yandex-rtb-block"],
        thaiAds: ["a[href*=macau-uta-popup]", xt("I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA=="), xt("LmFkczMwMHM="), ".bumq", ".img-kosana"],
        webAnnoyancesUltralist: ["#mod-social-share-2", "#social-tools", xt("LmN0cGwtZnVsbGJhbm5lcg=="), ".zergnet-recommend", ".yt.btn-link.btn-md.btn"]
    }
}
function getDomBlockers(xt) {
    var Cn = xt === void 0 ? {} : xt
      , as = Cn.debug;
    return __awaiter(this, void 0, void 0, function() {
        var cs, Cs, Ls, Vs, Ws, Xs;
        return __generator(this, function(ga) {
            switch (ga.label) {
            case 0:
                return isApplicable() ? (cs = getFilters(),
                Cs = Object.keys(cs),
                Ls = (Xs = []).concat.apply(Xs, Cs.map(function(ba) {
                    return cs[ba]
                })),
                [4, getBlockedSelectors(Ls)]) : [2, void 0];
            case 1:
                return Vs = ga.sent(),
                as && printDebug(cs, Vs),
                Ws = Cs.filter(function(ba) {
                    var yl = cs[ba]
                      , xl = countTruthy(yl.map(function(wl) {
                        return Vs[wl]
                    }));
                    return xl > yl.length * .6
                }),
                Ws.sort(),
                [2, Ws]
            }
        })
    })
}
function isApplicable() {
    return isWebKit() || isAndroid()
}
function getBlockedSelectors(xt) {
    var Cn;
    return __awaiter(this, void 0, void 0, function() {
        var as, cs, Cs, Ls, Xs, Vs, Ws, Xs;
        return __generator(this, function(ga) {
            switch (ga.label) {
            case 0:
                for (as = document,
                cs = as.createElement("div"),
                Cs = new Array(xt.length),
                Ls = {},
                forceShow(cs),
                Xs = 0; Xs < xt.length; ++Xs)
                    Vs = selectorToElement(xt[Xs]),
                    Vs.tagName === "DIALOG" && Vs.show(),
                    Ws = as.createElement("div"),
                    forceShow(Ws),
                    Ws.appendChild(Vs),
                    cs.appendChild(Ws),
                    Cs[Xs] = Vs;
                ga.label = 1;
            case 1:
                return as.body ? [3, 3] : [4, wait(50)];
            case 2:
                return ga.sent(),
                [3, 1];
            case 3:
                as.body.appendChild(cs);
                try {
                    for (Xs = 0; Xs < xt.length; ++Xs)
                        Cs[Xs].offsetParent || (Ls[xt[Xs]] = !0)
                } finally {
                    (Cn = cs.parentNode) === null || Cn === void 0 || Cn.removeChild(cs)
                }
                return [2, Ls]
            }
        })
    })
}
function forceShow(xt) {
    xt.style.setProperty("visibility", "hidden", "important"),
    xt.style.setProperty("display", "block", "important")
}
function printDebug(xt, Cn) {
    for (var as = "DOM blockers debug:\n```", cs = 0, Cs = Object.keys(xt); cs < Cs.length; cs++) {
        var Ls = Cs[cs];
        as += `
`.concat(Ls, ":");
        for (var Vs = 0, Ws = xt[Ls]; Vs < Ws.length; Vs++) {
            var Xs = Ws[Vs];
            as += `
  `.concat(Cn[Xs] ? "" : "", " ").concat(Xs)
        }
    }
    console.log("".concat(as, "\n```"))
}
function getColorGamut() {
    for (var xt = 0, Cn = ["rec2020", "p3", "srgb"]; xt < Cn.length; xt++) {
        var as = Cn[xt];
        if (matchMedia("(color-gamut: ".concat(as, ")")).matches)
            return as
    }
}
function areColorsInverted() {
    if (doesMatch$5("inverted"))
        return !0;
    if (doesMatch$5("none"))
        return !1
}
function doesMatch$5(xt) {
    return matchMedia("(inverted-colors: ".concat(xt, ")")).matches
}
function areColorsForced() {
    if (doesMatch$4("active"))
        return !0;
    if (doesMatch$4("none"))
        return !1
}
function doesMatch$4(xt) {
    return matchMedia("(forced-colors: ".concat(xt, ")")).matches
}
var maxValueToCheck = 100;
function getMonochromeDepth() {
    if (matchMedia("(min-monochrome: 0)").matches) {
        for (var xt = 0; xt <= maxValueToCheck; ++xt)
            if (matchMedia("(max-monochrome: ".concat(xt, ")")).matches)
                return xt;
        throw new Error("Too high value")
    }
}
function getContrastPreference() {
    if (doesMatch$3("no-preference"))
        return 0;
    if (doesMatch$3("high") || doesMatch$3("more"))
        return 1;
    if (doesMatch$3("low") || doesMatch$3("less"))
        return -1;
    if (doesMatch$3("forced"))
        return 10
}
function doesMatch$3(xt) {
    return matchMedia("(prefers-contrast: ".concat(xt, ")")).matches
}
function isMotionReduced() {
    if (doesMatch$2("reduce"))
        return !0;
    if (doesMatch$2("no-preference"))
        return !1
}
function doesMatch$2(xt) {
    return matchMedia("(prefers-reduced-motion: ".concat(xt, ")")).matches
}
function isTransparencyReduced() {
    if (doesMatch$1("reduce"))
        return !0;
    if (doesMatch$1("no-preference"))
        return !1
}
function doesMatch$1(xt) {
    return matchMedia("(prefers-reduced-transparency: ".concat(xt, ")")).matches
}
function isHDR() {
    if (doesMatch("high"))
        return !0;
    if (doesMatch("standard"))
        return !1
}
function doesMatch(xt) {
    return matchMedia("(dynamic-range: ".concat(xt, ")")).matches
}
var M$5 = Math
  , fallbackFn = function() {
    return 0
};
function getMathFingerprint() {
    var xt = M$5.acos || fallbackFn
      , Cn = M$5.acosh || fallbackFn
      , as = M$5.asin || fallbackFn
      , cs = M$5.asinh || fallbackFn
      , Cs = M$5.atanh || fallbackFn
      , Ls = M$5.atan || fallbackFn
      , Vs = M$5.sin || fallbackFn
      , Ws = M$5.sinh || fallbackFn
      , Xs = M$5.cos || fallbackFn
      , ga = M$5.cosh || fallbackFn
      , ba = M$5.tan || fallbackFn
      , yl = M$5.tanh || fallbackFn
      , xl = M$5.exp || fallbackFn
      , wl = M$5.expm1 || fallbackFn
      , _l = M$5.log1p || fallbackFn
      , El = function(Ll) {
        return M$5.pow(M$5.PI, Ll)
    }
      , Cl = function(Ll) {
        return M$5.log(Ll + M$5.sqrt(Ll * Ll - 1))
    }
      , $l = function(Ll) {
        return M$5.log(Ll + M$5.sqrt(Ll * Ll + 1))
    }
      , Sl = function(Ll) {
        return M$5.log((1 + Ll) / (1 - Ll)) / 2
    }
      , Tl = function(Ll) {
        return M$5.exp(Ll) - 1 / M$5.exp(Ll) / 2
    }
      , Rl = function(Ll) {
        return (M$5.exp(Ll) + 1 / M$5.exp(Ll)) / 2
    }
      , Il = function(Ll) {
        return M$5.exp(Ll) - 1
    }
      , Ml = function(Ll) {
        return (M$5.exp(2 * Ll) - 1) / (M$5.exp(2 * Ll) + 1)
    }
      , Nl = function(Ll) {
        return M$5.log(1 + Ll)
    };
    return {
        acos: xt(.12312423423423424),
        acosh: Cn(1e308),
        acoshPf: Cl(1e154),
        asin: as(.12312423423423424),
        asinh: cs(1),
        asinhPf: $l(1),
        atanh: Cs(.5),
        atanhPf: Sl(.5),
        atan: Ls(.5),
        sin: Vs(-1e300),
        sinh: Ws(1),
        sinhPf: Tl(1),
        cos: Xs(10.000000000123),
        cosh: ga(1),
        coshPf: Rl(1),
        tan: ba(-1e300),
        tanh: yl(1),
        tanhPf: Ml(1),
        exp: xl(1),
        expm1: wl(1),
        expm1Pf: Il(1),
        log1p: _l(10),
        log1pPf: Nl(10),
        powPI: El(-100)
    }
}
var defaultText = "mmMwWLliI0fiflO&1"
  , presets = {
    default: [],
    apple: [{
        font: "-apple-system-body"
    }],
    serif: [{
        fontFamily: "serif"
    }],
    sans: [{
        fontFamily: "sans-serif"
    }],
    mono: [{
        fontFamily: "monospace"
    }],
    min: [{
        fontSize: "1px"
    }],
    system: [{
        fontFamily: "system-ui"
    }]
};
function getFontPreferences() {
    return withNaturalFonts(function(xt, Cn) {
        for (var as = {}, cs = {}, Cs = 0, Ls = Object.keys(presets); Cs < Ls.length; Cs++) {
            var Vs = Ls[Cs]
              , Ws = presets[Vs]
              , Xs = Ws[0]
              , ga = Xs === void 0 ? {} : Xs
              , ba = Ws[1]
              , yl = ba === void 0 ? defaultText : ba
              , xl = xt.createElement("span");
            xl.textContent = yl,
            xl.style.whiteSpace = "nowrap";
            for (var wl = 0, _l = Object.keys(ga); wl < _l.length; wl++) {
                var El = _l[wl]
                  , Cl = ga[El];
                Cl !== void 0 && (xl.style[El] = Cl)
            }
            as[Vs] = xl,
            Cn.append(xt.createElement("br"), xl)
        }
        for (var $l = 0, Sl = Object.keys(presets); $l < Sl.length; $l++) {
            var Vs = Sl[$l];
            cs[Vs] = as[Vs].getBoundingClientRect().width
        }
        return cs
    })
}
function withNaturalFonts(xt, Cn) {
    return Cn === void 0 && (Cn = 4e3),
    withIframe(function(as, cs) {
        var Cs = cs.document
          , Ls = Cs.body
          , Vs = Ls.style;
        Vs.width = "".concat(Cn, "px"),
        Vs.webkitTextSizeAdjust = Vs.textSizeAdjust = "none",
        isChromium() ? Ls.style.zoom = "".concat(1 / cs.devicePixelRatio) : isWebKit() && (Ls.style.zoom = "reset");
        var Ws = Cs.createElement("div");
        return Ws.textContent = __spreadArray([], Array(Cn / 20 << 0), !0).map(function() {
            return "word"
        }).join(" "),
        Ls.appendChild(Ws),
        xt(Cs, Ls)
    }, '<!doctype html><html><head><meta name="viewport" content="width=device-width, initial-scale=1">')
}
function isPdfViewerEnabled() {
    return navigator.pdfViewerEnabled
}
function getArchitecture() {
    var xt = new Float32Array(1)
      , Cn = new Uint8Array(xt.buffer);
    return xt[0] = 1 / 0,
    xt[0] = xt[0] - xt[0],
    Cn[3]
}
function getApplePayState() {
    var xt = window.ApplePaySession;
    if (typeof (xt == null ? void 0 : xt.canMakePayments) != "function")
        return -1;
    if (willPrintConsoleError())
        return -3;
    try {
        return xt.canMakePayments() ? 1 : 0
    } catch (Cn) {
        return getStateFromError(Cn)
    }
}
var willPrintConsoleError = isAnyParentCrossOrigin;
function getStateFromError(xt) {
    if (xt instanceof Error && xt.name === "InvalidAccessError" && /\bfrom\b.*\binsecure\b/i.test(xt.message))
        return -2;
    throw xt
}
function getPrivateClickMeasurement() {
    var xt, Cn = document.createElement("a"), as = (xt = Cn.attributionSourceId) !== null && xt !== void 0 ? xt : Cn.attributionsourceid;
    return as === void 0 ? void 0 : String(as)
}
var STATUS_NO_GL_CONTEXT = -1
  , STATUS_GET_PARAMETER_NOT_A_FUNCTION = -2
  , validContextParameters = new Set([10752, 2849, 2884, 2885, 2886, 2928, 2929, 2930, 2931, 2932, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2978, 3024, 3042, 3088, 3089, 3106, 3107, 32773, 32777, 32777, 32823, 32824, 32936, 32937, 32938, 32939, 32968, 32969, 32970, 32971, 3317, 33170, 3333, 3379, 3386, 33901, 33902, 34016, 34024, 34076, 3408, 3410, 3411, 3412, 3413, 3414, 3415, 34467, 34816, 34817, 34818, 34819, 34877, 34921, 34930, 35660, 35661, 35724, 35738, 35739, 36003, 36004, 36005, 36347, 36348, 36349, 37440, 37441, 37443, 7936, 7937, 7938])
  , validExtensionParams = new Set([34047, 35723, 36063, 34852, 34853, 34854, 34229, 36392, 36795, 38449])
  , shaderTypes = ["FRAGMENT_SHADER", "VERTEX_SHADER"]
  , precisionTypes = ["LOW_FLOAT", "MEDIUM_FLOAT", "HIGH_FLOAT", "LOW_INT", "MEDIUM_INT", "HIGH_INT"]
  , rendererInfoExtensionName = "WEBGL_debug_renderer_info"
  , polygonModeExtensionName = "WEBGL_polygon_mode";
function getWebGlBasics(xt) {
    var Cn, as, cs, Cs, Ls, Vs, Ws = xt.cache, Xs = getWebGLContext(Ws);
    if (!Xs)
        return STATUS_NO_GL_CONTEXT;
    if (!isValidParameterGetter(Xs))
        return STATUS_GET_PARAMETER_NOT_A_FUNCTION;
    var ga = shouldAvoidDebugRendererInfo() ? null : Xs.getExtension(rendererInfoExtensionName);
    return {
        version: ((Cn = Xs.getParameter(Xs.VERSION)) === null || Cn === void 0 ? void 0 : Cn.toString()) || "",
        vendor: ((as = Xs.getParameter(Xs.VENDOR)) === null || as === void 0 ? void 0 : as.toString()) || "",
        vendorUnmasked: ga ? (cs = Xs.getParameter(ga.UNMASKED_VENDOR_WEBGL)) === null || cs === void 0 ? void 0 : cs.toString() : "",
        renderer: ((Cs = Xs.getParameter(Xs.RENDERER)) === null || Cs === void 0 ? void 0 : Cs.toString()) || "",
        rendererUnmasked: ga ? (Ls = Xs.getParameter(ga.UNMASKED_RENDERER_WEBGL)) === null || Ls === void 0 ? void 0 : Ls.toString() : "",
        shadingLanguageVersion: ((Vs = Xs.getParameter(Xs.SHADING_LANGUAGE_VERSION)) === null || Vs === void 0 ? void 0 : Vs.toString()) || ""
    }
}
function getWebGlExtensions(xt) {
    var Cn = xt.cache
      , as = getWebGLContext(Cn);
    if (!as)
        return STATUS_NO_GL_CONTEXT;
    if (!isValidParameterGetter(as))
        return STATUS_GET_PARAMETER_NOT_A_FUNCTION;
    var cs = as.getSupportedExtensions()
      , Cs = as.getContextAttributes()
      , Ls = []
      , Vs = []
      , Ws = []
      , Xs = []
      , ga = [];
    if (Cs)
        for (var ba = 0, yl = Object.keys(Cs); ba < yl.length; ba++) {
            var xl = yl[ba];
            Vs.push("".concat(xl, "=").concat(Cs[xl]))
        }
    for (var wl = getConstantsFromPrototype(as), _l = 0, El = wl; _l < El.length; _l++) {
        var Cl = El[_l]
          , $l = as[Cl];
        Ws.push("".concat(Cl, "=").concat($l).concat(validContextParameters.has($l) ? "=".concat(as.getParameter($l)) : ""))
    }
    if (cs)
        for (var Sl = 0, Tl = cs; Sl < Tl.length; Sl++) {
            var Rl = Tl[Sl];
            if (!(Rl === rendererInfoExtensionName && shouldAvoidDebugRendererInfo() || Rl === polygonModeExtensionName && shouldAvoidPolygonModeExtensions())) {
                var Il = as.getExtension(Rl);
                if (!Il) {
                    Ls.push(Rl);
                    continue
                }
                for (var Ml = 0, Nl = getConstantsFromPrototype(Il); Ml < Nl.length; Ml++) {
                    var Cl = Nl[Ml]
                      , $l = Il[Cl];
                    Xs.push("".concat(Cl, "=").concat($l).concat(validExtensionParams.has($l) ? "=".concat(as.getParameter($l)) : ""))
                }
            }
        }
    for (var Ll = 0, Fl = shaderTypes; Ll < Fl.length; Ll++)
        for (var Ul = Fl[Ll], Dl = 0, Zl = precisionTypes; Dl < Zl.length; Dl++) {
            var Gl = Zl[Dl]
              , Wl = getShaderPrecision(as, Ul, Gl);
            ga.push("".concat(Ul, ".").concat(Gl, "=").concat(Wl.join(",")))
        }
    return Xs.sort(),
    Ws.sort(),
    {
        contextAttributes: Vs,
        parameters: Ws,
        shaderPrecisions: ga,
        extensions: cs,
        extensionParameters: Xs,
        unsupportedExtensions: Ls
    }
}
function getWebGLContext(xt) {
    if (xt.webgl)
        return xt.webgl.context;
    var Cn = document.createElement("canvas"), as;
    Cn.addEventListener("webglCreateContextError", function() {
        return as = void 0
    });
    for (var cs = 0, Cs = ["webgl", "experimental-webgl"]; cs < Cs.length; cs++) {
        var Ls = Cs[cs];
        try {
            as = Cn.getContext(Ls)
        } catch {}
        if (as)
            break
    }
    return xt.webgl = {
        context: as
    },
    as
}
function getShaderPrecision(xt, Cn, as) {
    var cs = xt.getShaderPrecisionFormat(xt[Cn], xt[as]);
    return cs ? [cs.rangeMin, cs.rangeMax, cs.precision] : []
}
function getConstantsFromPrototype(xt) {
    var Cn = Object.keys(xt.__proto__);
    return Cn.filter(isConstantLike)
}
function isConstantLike(xt) {
    return typeof xt == "string" && !xt.match(/[^A-Z0-9_x]/)
}
function shouldAvoidDebugRendererInfo() {
    return isGecko()
}
function shouldAvoidPolygonModeExtensions() {
    return isChromium() || isWebKit()
}
function isValidParameterGetter(xt) {
    return typeof xt.getParameter == "function"
}
function getAudioContextBaseLatency() {
    var xt, Cn = isAndroid() || isWebKit();
    return Cn ? window.AudioContext && (xt = new AudioContext().baseLatency) !== null && xt !== void 0 ? xt : -1 : -2
}
function getDateTimeLocale() {
    if (!window.Intl)
        return -1;
    var xt = window.Intl.DateTimeFormat;
    if (!xt)
        return -2;
    var Cn = xt().resolvedOptions().locale;
    return !Cn && Cn !== "" ? -3 : Cn
}
var sources = {
    fonts: getFonts,
    domBlockers: getDomBlockers,
    fontPreferences: getFontPreferences,
    audio: getAudioFingerprint,
    screenFrame: getScreenFrame,
    canvas: getCanvasFingerprint,
    osCpu: getOsCpu,
    languages: getLanguages,
    colorDepth: getColorDepth,
    deviceMemory: getDeviceMemory,
    screenResolution: getScreenResolution,
    hardwareConcurrency: getHardwareConcurrency,
    timezone: getTimezone,
    sessionStorage: getSessionStorage,
    localStorage: getLocalStorage,
    indexedDB: getIndexedDB,
    openDatabase: getOpenDatabase,
    cpuClass: getCpuClass,
    platform: getPlatform,
    plugins: getPlugins,
    touchSupport: getTouchSupport,
    vendor: getVendor,
    vendorFlavors: getVendorFlavors,
    cookiesEnabled: areCookiesEnabled,
    colorGamut: getColorGamut,
    invertedColors: areColorsInverted,
    forcedColors: areColorsForced,
    monochrome: getMonochromeDepth,
    contrast: getContrastPreference,
    reducedMotion: isMotionReduced,
    reducedTransparency: isTransparencyReduced,
    hdr: isHDR,
    math: getMathFingerprint,
    pdfViewerEnabled: isPdfViewerEnabled,
    architecture: getArchitecture,
    applePay: getApplePayState,
    privateClickMeasurement: getPrivateClickMeasurement,
    audioBaseLatency: getAudioContextBaseLatency,
    dateTimeLocale: getDateTimeLocale,
    webGlBasics: getWebGlBasics,
    webGlExtensions: getWebGlExtensions
};
function loadBuiltinSources(xt) {
    return loadSources(sources, xt, [])
}
var commentTemplate = "$ if upgrade to Pro: https://fpjs.dev/pro";
function getConfidence(xt) {
    var Cn = getOpenConfidenceScore(xt)
      , as = deriveProConfidenceScore(Cn);
    return {
        score: Cn,
        comment: commentTemplate.replace(/\$/g, "".concat(as))
    }
}
function getOpenConfidenceScore(xt) {
    if (isAndroid())
        return .4;
    if (isWebKit())
        return isDesktopWebKit() && !(isWebKit616OrNewer() && isSafariWebKit()) ? .5 : .3;
    var Cn = "value"in xt.platform ? xt.platform.value : "";
    return /^Win/.test(Cn) ? .6 : /^Mac/.test(Cn) ? .5 : .7
}
function deriveProConfidenceScore(xt) {
    return round(.99 + .01 * xt, 1e-4)
}
function componentsToCanonicalString(xt) {
    for (var Cn = "", as = 0, cs = Object.keys(xt).sort(); as < cs.length; as++) {
        var Cs = cs[as]
          , Ls = xt[Cs]
          , Vs = "error"in Ls ? "error" : JSON.stringify(Ls.value);
        Cn += "".concat(Cn ? "|" : "").concat(Cs.replace(/([:|\\])/g, "\\$1"), ":").concat(Vs)
    }
    return Cn
}
function componentsToDebugString(xt) {
    return JSON.stringify(xt, function(Cn, as) {
        return as instanceof Error ? errorToObject(as) : as
    }, 2)
}
function hashComponents(xt) {
    return x64hash128(componentsToCanonicalString(xt))
}
function makeLazyGetResult(xt) {
    var Cn, as = getConfidence(xt);
    return {
        get visitorId() {
            return Cn === void 0 && (Cn = hashComponents(this.components)),
            Cn
        },
        set visitorId(cs) {
            Cn = cs
        },
        confidence: as,
        components: xt,
        version: version$1
    }
}
function prepareForSources(xt) {
    return xt === void 0 && (xt = 50),
    requestIdleCallbackIfAvailable(xt, xt * 2)
}
function makeAgent(xt, Cn) {
    var as = Date.now();
    return {
        get: function(cs) {
            return __awaiter(this, void 0, void 0, function() {
                var Cs, Ls, Vs;
                return __generator(this, function(Ws) {
                    switch (Ws.label) {
                    case 0:
                        return Cs = Date.now(),
                        [4, xt()];
                    case 1:
                        return Ls = Ws.sent(),
                        Vs = makeLazyGetResult(Ls),
                        (Cn || cs != null && cs.debug) && console.log("Copy the text below to get the debug data:\n\n```\nversion: ".concat(Vs.version, `
userAgent: `).concat(navigator.userAgent, `
timeBetweenLoadAndGet: `).concat(Cs - as, `
visitorId: `).concat(Vs.visitorId, `
components: `).concat(componentsToDebugString(Ls), "\n```")),
                        [2, Vs]
                    }
                })
            })
        }
    }
}
function monitor() {
    if (!(window.__fpjs_d_m || Math.random() >= .001))
        try {
            var xt = new XMLHttpRequest;
            xt.open("get", "https://m1.openfpcdn.io/fingerprintjs/v".concat(version$1, "/npm-monitoring"), !0),
            xt.send()
        } catch (Cn) {
            console.error(Cn)
        }
}
function load(xt) {
    var Cn;
    return xt === void 0 && (xt = {}),
    __awaiter(this, void 0, void 0, function() {
        var as, cs, Cs;
        return __generator(this, function(Ls) {
            switch (Ls.label) {
            case 0:
                return (!((Cn = xt.monitoring) !== null && Cn !== void 0) || Cn) && monitor(),
                as = xt.delayFallback,
                cs = xt.debug,
                [4, prepareForSources(as)];
            case 1:
                return Ls.sent(),
                Cs = loadBuiltinSources({
                    cache: {},
                    debug: cs
                }),
                [2, makeAgent(Cs, cs)]
            }
        })
    })
}
var index$1 = {
    load,
    hashComponents,
    componentsToDebugString
};
function replaceEscapedNewlines(xt) {
    const Cn = {};
    for (const [as,cs] of Object.entries(xt))
        Cn[as] = cs.replace(/\\n/g, `
`);
    return Cn
}
function buildFormatLongFn(xt) {
    return (Cn={}) => {
        const as = Cn.width ? String(Cn.width) : xt.defaultWidth;
        return xt.formats[as] || xt.formats[xt.defaultWidth]
    }
}
function buildLocalizeFn(xt) {
    return (Cn, as) => {
        const cs = as != null && as.context ? String(as.context) : "standalone";
        let Cs;
        if (cs === "formatting" && xt.formattingValues) {
            const Vs = xt.defaultFormattingWidth || xt.defaultWidth
              , Ws = as != null && as.width ? String(as.width) : Vs;
            Cs = xt.formattingValues[Ws] || xt.formattingValues[Vs]
        } else {
            const Vs = xt.defaultWidth
              , Ws = as != null && as.width ? String(as.width) : xt.defaultWidth;
            Cs = xt.values[Ws] || xt.values[Vs]
        }
        const Ls = xt.argumentCallback ? xt.argumentCallback(Cn) : Cn;
        return Cs[Ls]
    }
}
function buildMatchFn(xt) {
    return (Cn, as={}) => {
        const cs = as.width
          , Cs = cs && xt.matchPatterns[cs] || xt.matchPatterns[xt.defaultMatchWidth]
          , Ls = Cn.match(Cs);
        if (!Ls)
            return null;
        const Vs = Ls[0]
          , Ws = cs && xt.parsePatterns[cs] || xt.parsePatterns[xt.defaultParseWidth]
          , Xs = Array.isArray(Ws) ? findIndex(Ws, yl => yl.test(Vs)) : findKey(Ws, yl => yl.test(Vs));
        let ga;
        ga = xt.valueCallback ? xt.valueCallback(Xs) : Xs,
        ga = as.valueCallback ? as.valueCallback(ga) : ga;
        const ba = Cn.slice(Vs.length);
        return {
            value: ga,
            rest: ba
        }
    }
}
function findKey(xt, Cn) {
    for (const as in xt)
        if (Object.prototype.hasOwnProperty.call(xt, as) && Cn(xt[as]))
            return as
}
function findIndex(xt, Cn) {
    for (let as = 0; as < xt.length; as++)
        if (Cn(xt[as]))
            return as
}
function buildMatchPatternFn(xt) {
    return (Cn, as={}) => {
        const cs = Cn.match(xt.matchPattern);
        if (!cs)
            return null;
        const Cs = cs[0]
          , Ls = Cn.match(xt.parsePattern);
        if (!Ls)
            return null;
        let Vs = xt.valueCallback ? xt.valueCallback(Ls[0]) : Ls[0];
        Vs = as.valueCallback ? as.valueCallback(Vs) : Vs;
        const Ws = Cn.slice(Cs.length);
        return {
            value: Vs,
            rest: Ws
        }
    }
}
const millisecondsInWeek = 6048e5
  , millisecondsInDay = 864e5
  , constructFromSymbol = Symbol.for("constructDateFrom");
function constructFrom(xt, Cn) {
    return typeof xt == "function" ? xt(Cn) : xt && typeof xt == "object" && constructFromSymbol in xt ? xt[constructFromSymbol](Cn) : xt instanceof Date ? new xt.constructor(Cn) : new Date(Cn)
}
function normalizeDates(xt, ...Cn) {
    const as = constructFrom.bind(null, xt || Cn.find(cs => typeof cs == "object"));
    return Cn.map(as)
}
let defaultOptions$1 = {};
function getDefaultOptions() {
    return defaultOptions$1
}
function setDefaultOptions$1(xt) {
    defaultOptions$1 = xt
}
function toDate(xt, Cn) {
    return constructFrom(Cn || xt, xt)
}
function startOfWeek(xt, Cn) {
    var Ws, Xs, ga, ba;
    const as = getDefaultOptions()
      , cs = (Cn == null ? void 0 : Cn.weekStartsOn) ?? ((Xs = (Ws = Cn == null ? void 0 : Cn.locale) == null ? void 0 : Ws.options) == null ? void 0 : Xs.weekStartsOn) ?? as.weekStartsOn ?? ((ba = (ga = as.locale) == null ? void 0 : ga.options) == null ? void 0 : ba.weekStartsOn) ?? 0
      , Cs = toDate(xt, Cn == null ? void 0 : Cn.in)
      , Ls = Cs.getDay()
      , Vs = (Ls < cs ? 7 : 0) + Ls - cs;
    return Cs.setDate(Cs.getDate() - Vs),
    Cs.setHours(0, 0, 0, 0),
    Cs
}
function isSameWeek(xt, Cn, as) {
    const [cs,Cs] = normalizeDates(as == null ? void 0 : as.in, xt, Cn);
    return +startOfWeek(cs, as) == +startOfWeek(Cs, as)
}
const formatDistanceLocale$1 = {
    lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
    },
    xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
    },
    xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
    },
    aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
    },
    xHours: {
        one: "1 hour",
        other: "{{count}} hours"
    },
    xDays: {
        one: "1 day",
        other: "{{count}} days"
    },
    aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
    },
    xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
    },
    aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
    },
    xMonths: {
        one: "1 month",
        other: "{{count}} months"
    },
    aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
    },
    xYears: {
        one: "1 year",
        other: "{{count}} years"
    },
    overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
    },
    almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
    }
}
  , formatDistance$1 = (xt, Cn, as) => {
    let cs;
    const Cs = formatDistanceLocale$1[xt];
    return typeof Cs == "string" ? cs = Cs : Cn === 1 ? cs = Cs.one : cs = Cs.other.replace("{{count}}", Cn.toString()),
    as != null && as.addSuffix ? as.comparison && as.comparison > 0 ? "in " + cs : cs + " ago" : cs
}
  , formatRelativeLocale$1 = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
}
  , formatRelative$1 = (xt, Cn, as, cs) => formatRelativeLocale$1[xt]
  , eraValues$1 = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
}
  , quarterValues$1 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}
  , monthValues$1 = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
}
  , dayValues$1 = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
}
  , dayPeriodValues$1 = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    }
}
  , formattingDayPeriodValues$1 = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    }
}
  , ordinalNumber$1 = (xt, Cn) => {
    const as = Number(xt)
      , cs = as % 100;
    if (cs > 20 || cs < 10)
        switch (cs % 10) {
        case 1:
            return as + "st";
        case 2:
            return as + "nd";
        case 3:
            return as + "rd"
        }
    return as + "th"
}
  , localize$1 = {
    ordinalNumber: ordinalNumber$1,
    era: buildLocalizeFn({
        values: eraValues$1,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues$1,
        defaultWidth: "wide",
        argumentCallback: xt => xt - 1
    }),
    month: buildLocalizeFn({
        values: monthValues$1,
        defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues$1,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$1,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$1,
        defaultFormattingWidth: "wide"
    })
}
  , matchOrdinalNumberPattern$1 = /^(\d+)(th|st|nd|rd)?/i
  , parseOrdinalNumberPattern$1 = /\d+/i
  , matchEraPatterns$1 = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
}
  , parseEraPatterns$1 = {
    any: [/^b/i, /^(a|c)/i]
}
  , matchQuarterPatterns$1 = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
}
  , parseQuarterPatterns$1 = {
    any: [/1/i, /2/i, /3/i, /4/i]
}
  , matchMonthPatterns$1 = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}
  , parseMonthPatterns$1 = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
}
  , matchDayPatterns$1 = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}
  , parseDayPatterns$1 = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}
  , matchDayPeriodPatterns$1 = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}
  , parseDayPeriodPatterns$1 = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
    }
}
  , match$1 = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$1,
        parsePattern: parseOrdinalNumberPattern$1,
        valueCallback: xt => parseInt(xt, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns$1,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$1,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$1,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$1,
        defaultParseWidth: "any",
        valueCallback: xt => xt + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns$1,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$1,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns$1,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$1,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$1,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$1,
        defaultParseWidth: "any"
    })
}
  , dateFormats$1 = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
}
  , timeFormats$1 = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
}
  , dateTimeFormats$1 = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
}
  , formatLong$1 = {
    date: buildFormatLongFn({
        formats: dateFormats$1,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats$1,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1,
        defaultWidth: "full"
    })
}
  , enUS = {
    code: "en-US",
    formatDistance: formatDistance$1,
    formatLong: formatLong$1,
    formatRelative: formatRelative$1,
    localize: localize$1,
    match: match$1,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
function declension(xt, Cn) {
    if (xt.one !== void 0 && Cn === 1)
        return xt.one;
    const as = Cn % 10
      , cs = Cn % 100;
    return as === 1 && cs !== 11 ? xt.singularNominative.replace("{{count}}", String(Cn)) : as >= 2 && as <= 4 && (cs < 10 || cs > 20) ? xt.singularGenitive.replace("{{count}}", String(Cn)) : xt.pluralGenitive.replace("{{count}}", String(Cn))
}
function buildLocalizeTokenFn(xt) {
    return (Cn, as) => as != null && as.addSuffix ? as.comparison && as.comparison > 0 ? xt.future ? declension(xt.future, Cn) : " " + declension(xt.regular, Cn) : xt.past ? declension(xt.past, Cn) : declension(xt.regular, Cn) + " " : declension(xt.regular, Cn)
}
const formatDistanceLocale = {
    lessThanXSeconds: buildLocalizeTokenFn({
        regular: {
            one: " ",
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            one: ",   ",
            singularNominative: ",   {{count}} ",
            singularGenitive: ",   {{count}} ",
            pluralGenitive: ",   {{count}} "
        }
    }),
    xSeconds: buildLocalizeTokenFn({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        },
        past: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        },
        future: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        }
    }),
    halfAMinute: (xt, Cn) => Cn != null && Cn.addSuffix ? Cn.comparison && Cn.comparison > 0 ? " " : " " : "",
    lessThanXMinutes: buildLocalizeTokenFn({
        regular: {
            one: " ",
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            one: ",   ",
            singularNominative: ",   {{count}} ",
            singularGenitive: ",   {{count}} ",
            pluralGenitive: ",   {{count}} "
        }
    }),
    xMinutes: buildLocalizeTokenFn({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        },
        past: {
            singularNominative: "{{count}}  ",
            singularGenitive: "{{count}}  ",
            pluralGenitive: "{{count}}  "
        },
        future: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        }
    }),
    aboutXHours: buildLocalizeTokenFn({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xHours: buildLocalizeTokenFn({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    xDays: buildLocalizeTokenFn({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    aboutXWeeks: buildLocalizeTokenFn({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xWeeks: buildLocalizeTokenFn({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    aboutXMonths: buildLocalizeTokenFn({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xMonths: buildLocalizeTokenFn({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    aboutXYears: buildLocalizeTokenFn({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    }),
    xYears: buildLocalizeTokenFn({
        regular: {
            singularNominative: "{{count}} ",
            singularGenitive: "{{count}} ",
            pluralGenitive: "{{count}} "
        }
    }),
    overXYears: buildLocalizeTokenFn({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: ",   {{count}} ",
            singularGenitive: ",   {{count}} ",
            pluralGenitive: ",   {{count}} "
        }
    }),
    almostXYears: buildLocalizeTokenFn({
        regular: {
            singularNominative: " {{count}} ",
            singularGenitive: " {{count}} ",
            pluralGenitive: " {{count}} "
        },
        future: {
            singularNominative: "  {{count}} ",
            singularGenitive: "  {{count}} ",
            pluralGenitive: "  {{count}} "
        }
    })
}
  , formatDistance = (xt, Cn, as) => formatDistanceLocale[xt](Cn, as)
  , dateFormats = {
    full: "EEEE, d MMMM y '.'",
    long: "d MMMM y '.'",
    medium: "d MMM y '.'",
    short: "dd.MM.y"
}
  , timeFormats = {
    full: "H:mm:ss zzzz",
    long: "H:mm:ss z",
    medium: "H:mm:ss",
    short: "H:mm"
}
  , dateTimeFormats = {
    any: "{{date}}, {{time}}"
}
  , formatLong = {
    date: buildFormatLongFn({
        formats: dateFormats,
        defaultWidth: "full"
    }),
    time: buildFormatLongFn({
        formats: timeFormats,
        defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats,
        defaultWidth: "any"
    })
}
  , accusativeWeekdays = ["", "", "", "", "", "", ""];
function lastWeek(xt) {
    const Cn = accusativeWeekdays[xt];
    switch (xt) {
    case 0:
        return "'  " + Cn + " ' p";
    case 1:
    case 2:
    case 4:
        return "'  " + Cn + " ' p";
    case 3:
    case 5:
    case 6:
        return "'  " + Cn + " ' p"
    }
}
function thisWeek(xt) {
    const Cn = accusativeWeekdays[xt];
    return xt === 2 ? "' " + Cn + " ' p" : "' " + Cn + " ' p"
}
function nextWeek(xt) {
    const Cn = accusativeWeekdays[xt];
    switch (xt) {
    case 0:
        return "'  " + Cn + " ' p";
    case 1:
    case 2:
    case 4:
        return "'  " + Cn + " ' p";
    case 3:
    case 5:
    case 6:
        return "'  " + Cn + " ' p"
    }
}
const formatRelativeLocale = {
    lastWeek: (xt, Cn, as) => {
        const cs = xt.getDay();
        return isSameWeek(xt, Cn, as) ? thisWeek(cs) : lastWeek(cs)
    }
    ,
    yesterday: "' ' p",
    today: "' ' p",
    tomorrow: "' ' p",
    nextWeek: (xt, Cn, as) => {
        const cs = xt.getDay();
        return isSameWeek(xt, Cn, as) ? thisWeek(cs) : nextWeek(cs)
    }
    ,
    other: "P"
}
  , formatRelative = (xt, Cn, as, cs) => {
    const Cs = formatRelativeLocale[xt];
    return typeof Cs == "function" ? Cs(Cn, as, cs) : Cs
}
  , eraValues = {
    narrow: [" ..", ".."],
    abbreviated: [" . .", ". ."],
    wide: ["  ", " "]
}
  , quarterValues = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["1- .", "2- .", "3- .", "4- ."],
    wide: ["1- ", "2- ", "3- ", "4- "]
}
  , monthValues = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [".", ".", "", ".", "", "", "", ".", ".", ".", ".", "."],
    wide: ["", "", "", "", "", "", "", "", "", "", "", ""]
}
  , formattingMonthValues = {
    narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
    abbreviated: [".", ".", ".", ".", "", ".", ".", ".", ".", ".", ".", "."],
    wide: ["", "", "", "", "", "", "", "", "", "", "", ""]
}
  , dayValues = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: ["", "", "", "", "", "", ""]
}
  , dayPeriodValues = {
    narrow: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: "",
        afternoon: "",
        evening: ".",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: "",
        afternoon: "",
        evening: ".",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
}
  , formattingDayPeriodValues = {
    narrow: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: "",
        afternoon: "",
        evening: ".",
        night: ""
    },
    abbreviated: {
        am: "",
        pm: "",
        midnight: ".",
        noon: ".",
        morning: "",
        afternoon: "",
        evening: ".",
        night: ""
    },
    wide: {
        am: "",
        pm: "",
        midnight: "",
        noon: "",
        morning: "",
        afternoon: "",
        evening: "",
        night: ""
    }
}
  , ordinalNumber = (xt, Cn) => {
    const as = Number(xt)
      , cs = Cn == null ? void 0 : Cn.unit;
    let Cs;
    return cs === "date" ? Cs = "-" : cs === "week" || cs === "minute" || cs === "second" ? Cs = "-" : Cs = "-",
    as + Cs
}
  , localize = {
    ordinalNumber,
    era: buildLocalizeFn({
        values: eraValues,
        defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
        values: quarterValues,
        defaultWidth: "wide",
        argumentCallback: xt => xt - 1
    }),
    month: buildLocalizeFn({
        values: monthValues,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues,
        defaultFormattingWidth: "wide"
    }),
    day: buildLocalizeFn({
        values: dayValues,
        defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues,
        defaultWidth: "any",
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: "wide"
    })
}
  , matchOrdinalNumberPattern = /^(\d+)(-?(||||||||||))?/i
  , parseOrdinalNumberPattern = /\d+/i
  , matchEraPatterns = {
    narrow: /^(( )?\.?\s?\.?)/i,
    abbreviated: /^(( )?\.?\s?\.?)/i,
    wide: /^(  | | )/i
}
  , parseEraPatterns = {
    any: [/^/i, /^/i]
}
  , matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^[1234](-?[]??)? .?/i,
    wide: /^[1234](-?[]??)? /i
}
  , parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i]
}
  , matchMonthPatterns = {
    narrow: /^[]/i,
    abbreviated: /^(||?||[]|[]?|[]?||?||?|)\.?/i,
    wide: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[]|[])/i
}
  , parseMonthPatterns = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
}
  , matchDayPatterns = {
    narrow: /^[]/i,
    short: /^(|||||||||||)\.?/i,
    abbreviated: /^(||||||||||||).?/i,
    wide: /^([]|?|?|[]|?|[]|[])/i
}
  , parseDayPatterns = {
    narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
    any: [/^[]/i, /^[]/i, /^/i, /^/i, /^/i, /^[]/i, /^[]/i]
}
  , matchDayPeriodPatterns = {
    narrow: /^([]|\.?|\.?|[]|||\.?|[])/i,
    abbreviated: /^([]|\.?|\.?|[]|||\.?|[])/i,
    wide: /^([]|||[]|||?|[])/i
}
  , parseDayPeriodPatterns = {
    any: {
        am: /^/i,
        pm: /^/i,
        midnight: /^/i,
        noon: /^/i,
        morning: /^/i,
        afternoon: /^[]/i,
        evening: /^/i,
        night: /^/i
    }
}
  , match = {
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: xt => parseInt(xt, 10)
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns,
        defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: "any",
        valueCallback: xt => xt + 1
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: "any"
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns,
        defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: "any"
    })
}
  , ru = {
    code: "ru",
    formatDistance,
    formatLong,
    formatRelative,
    localize,
    match,
    options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
    }
};
function startOfISOWeek(xt, Cn) {
    return startOfWeek(xt, {
        ...Cn,
        weekStartsOn: 1
    })
}
function getISOWeekYear(xt, Cn) {
    const as = toDate(xt, Cn == null ? void 0 : Cn.in)
      , cs = as.getFullYear()
      , Cs = constructFrom(as, 0);
    Cs.setFullYear(cs + 1, 0, 4),
    Cs.setHours(0, 0, 0, 0);
    const Ls = startOfISOWeek(Cs)
      , Vs = constructFrom(as, 0);
    Vs.setFullYear(cs, 0, 4),
    Vs.setHours(0, 0, 0, 0);
    const Ws = startOfISOWeek(Vs);
    return as.getTime() >= Ls.getTime() ? cs + 1 : as.getTime() >= Ws.getTime() ? cs : cs - 1
}
function getTimezoneOffsetInMilliseconds(xt) {
    const Cn = toDate(xt)
      , as = new Date(Date.UTC(Cn.getFullYear(), Cn.getMonth(), Cn.getDate(), Cn.getHours(), Cn.getMinutes(), Cn.getSeconds(), Cn.getMilliseconds()));
    return as.setUTCFullYear(Cn.getFullYear()),
    +xt - +as
}
function startOfDay(xt, Cn) {
    const as = toDate(xt, Cn == null ? void 0 : Cn.in);
    return as.setHours(0, 0, 0, 0),
    as
}
function differenceInCalendarDays(xt, Cn, as) {
    const [cs,Cs] = normalizeDates(as == null ? void 0 : as.in, xt, Cn)
      , Ls = startOfDay(cs)
      , Vs = startOfDay(Cs)
      , Ws = +Ls - getTimezoneOffsetInMilliseconds(Ls)
      , Xs = +Vs - getTimezoneOffsetInMilliseconds(Vs);
    return Math.round((Ws - Xs) / millisecondsInDay)
}
function startOfISOWeekYear(xt, Cn) {
    const as = getISOWeekYear(xt, Cn)
      , cs = constructFrom(xt, 0);
    return cs.setFullYear(as, 0, 4),
    cs.setHours(0, 0, 0, 0),
    startOfISOWeek(cs)
}
function isDate(xt) {
    return xt instanceof Date || typeof xt == "object" && Object.prototype.toString.call(xt) === "[object Date]"
}
function isValid$1(xt) {
    return !(!isDate(xt) && typeof xt != "number" || isNaN(+toDate(xt)))
}
function startOfYear(xt, Cn) {
    const as = toDate(xt, Cn == null ? void 0 : Cn.in);
    return as.setFullYear(as.getFullYear(), 0, 1),
    as.setHours(0, 0, 0, 0),
    as
}
function getDayOfYear(xt, Cn) {
    const as = toDate(xt, Cn == null ? void 0 : Cn.in);
    return differenceInCalendarDays(as, startOfYear(as)) + 1
}
function getISOWeek(xt, Cn) {
    const as = toDate(xt, Cn == null ? void 0 : Cn.in)
      , cs = +startOfISOWeek(as) - +startOfISOWeekYear(as);
    return Math.round(cs / millisecondsInWeek) + 1
}
function getWeekYear(xt, Cn) {
    var ba, yl, xl, wl;
    const as = toDate(xt, Cn == null ? void 0 : Cn.in)
      , cs = as.getFullYear()
      , Cs = getDefaultOptions()
      , Ls = (Cn == null ? void 0 : Cn.firstWeekContainsDate) ?? ((yl = (ba = Cn == null ? void 0 : Cn.locale) == null ? void 0 : ba.options) == null ? void 0 : yl.firstWeekContainsDate) ?? Cs.firstWeekContainsDate ?? ((wl = (xl = Cs.locale) == null ? void 0 : xl.options) == null ? void 0 : wl.firstWeekContainsDate) ?? 1
      , Vs = constructFrom((Cn == null ? void 0 : Cn.in) || xt, 0);
    Vs.setFullYear(cs + 1, 0, Ls),
    Vs.setHours(0, 0, 0, 0);
    const Ws = startOfWeek(Vs, Cn)
      , Xs = constructFrom((Cn == null ? void 0 : Cn.in) || xt, 0);
    Xs.setFullYear(cs, 0, Ls),
    Xs.setHours(0, 0, 0, 0);
    const ga = startOfWeek(Xs, Cn);
    return +as >= +Ws ? cs + 1 : +as >= +ga ? cs : cs - 1
}
function startOfWeekYear(xt, Cn) {
    var Ws, Xs, ga, ba;
    const as = getDefaultOptions()
      , cs = (Cn == null ? void 0 : Cn.firstWeekContainsDate) ?? ((Xs = (Ws = Cn == null ? void 0 : Cn.locale) == null ? void 0 : Ws.options) == null ? void 0 : Xs.firstWeekContainsDate) ?? as.firstWeekContainsDate ?? ((ba = (ga = as.locale) == null ? void 0 : ga.options) == null ? void 0 : ba.firstWeekContainsDate) ?? 1
      , Cs = getWeekYear(xt, Cn)
      , Ls = constructFrom((Cn == null ? void 0 : Cn.in) || xt, 0);
    return Ls.setFullYear(Cs, 0, cs),
    Ls.setHours(0, 0, 0, 0),
    startOfWeek(Ls, Cn)
}
function getWeek(xt, Cn) {
    const as = toDate(xt, Cn == null ? void 0 : Cn.in)
      , cs = +startOfWeek(as, Cn) - +startOfWeekYear(as, Cn);
    return Math.round(cs / millisecondsInWeek) + 1
}
function addLeadingZeros(xt, Cn) {
    const as = xt < 0 ? "-" : ""
      , cs = Math.abs(xt).toString().padStart(Cn, "0");
    return as + cs
}
const lightFormatters = {
    y(xt, Cn) {
        const as = xt.getFullYear()
          , cs = as > 0 ? as : 1 - as;
        return addLeadingZeros(Cn === "yy" ? cs % 100 : cs, Cn.length)
    },
    M(xt, Cn) {
        const as = xt.getMonth();
        return Cn === "M" ? String(as + 1) : addLeadingZeros(as + 1, 2)
    },
    d(xt, Cn) {
        return addLeadingZeros(xt.getDate(), Cn.length)
    },
    a(xt, Cn) {
        const as = xt.getHours() / 12 >= 1 ? "pm" : "am";
        switch (Cn) {
        case "a":
        case "aa":
            return as.toUpperCase();
        case "aaa":
            return as;
        case "aaaaa":
            return as[0];
        case "aaaa":
        default:
            return as === "am" ? "a.m." : "p.m."
        }
    },
    h(xt, Cn) {
        return addLeadingZeros(xt.getHours() % 12 || 12, Cn.length)
    },
    H(xt, Cn) {
        return addLeadingZeros(xt.getHours(), Cn.length)
    },
    m(xt, Cn) {
        return addLeadingZeros(xt.getMinutes(), Cn.length)
    },
    s(xt, Cn) {
        return addLeadingZeros(xt.getSeconds(), Cn.length)
    },
    S(xt, Cn) {
        const as = Cn.length
          , cs = xt.getMilliseconds()
          , Cs = Math.trunc(cs * Math.pow(10, as - 3));
        return addLeadingZeros(Cs, Cn.length)
    }
}
  , dayPeriodEnum = {
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
}
  , formatters = {
    G: function(xt, Cn, as) {
        const cs = xt.getFullYear() > 0 ? 1 : 0;
        switch (Cn) {
        case "G":
        case "GG":
        case "GGG":
            return as.era(cs, {
                width: "abbreviated"
            });
        case "GGGGG":
            return as.era(cs, {
                width: "narrow"
            });
        case "GGGG":
        default:
            return as.era(cs, {
                width: "wide"
            })
        }
    },
    y: function(xt, Cn, as) {
        if (Cn === "yo") {
            const cs = xt.getFullYear()
              , Cs = cs > 0 ? cs : 1 - cs;
            return as.ordinalNumber(Cs, {
                unit: "year"
            })
        }
        return lightFormatters.y(xt, Cn)
    },
    Y: function(xt, Cn, as, cs) {
        const Cs = getWeekYear(xt, cs)
          , Ls = Cs > 0 ? Cs : 1 - Cs;
        if (Cn === "YY") {
            const Vs = Ls % 100;
            return addLeadingZeros(Vs, 2)
        }
        return Cn === "Yo" ? as.ordinalNumber(Ls, {
            unit: "year"
        }) : addLeadingZeros(Ls, Cn.length)
    },
    R: function(xt, Cn) {
        const as = getISOWeekYear(xt);
        return addLeadingZeros(as, Cn.length)
    },
    u: function(xt, Cn) {
        const as = xt.getFullYear();
        return addLeadingZeros(as, Cn.length)
    },
    Q: function(xt, Cn, as) {
        const cs = Math.ceil((xt.getMonth() + 1) / 3);
        switch (Cn) {
        case "Q":
            return String(cs);
        case "QQ":
            return addLeadingZeros(cs, 2);
        case "Qo":
            return as.ordinalNumber(cs, {
                unit: "quarter"
            });
        case "QQQ":
            return as.quarter(cs, {
                width: "abbreviated",
                context: "formatting"
            });
        case "QQQQQ":
            return as.quarter(cs, {
                width: "narrow",
                context: "formatting"
            });
        case "QQQQ":
        default:
            return as.quarter(cs, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    q: function(xt, Cn, as) {
        const cs = Math.ceil((xt.getMonth() + 1) / 3);
        switch (Cn) {
        case "q":
            return String(cs);
        case "qq":
            return addLeadingZeros(cs, 2);
        case "qo":
            return as.ordinalNumber(cs, {
                unit: "quarter"
            });
        case "qqq":
            return as.quarter(cs, {
                width: "abbreviated",
                context: "standalone"
            });
        case "qqqqq":
            return as.quarter(cs, {
                width: "narrow",
                context: "standalone"
            });
        case "qqqq":
        default:
            return as.quarter(cs, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    M: function(xt, Cn, as) {
        const cs = xt.getMonth();
        switch (Cn) {
        case "M":
        case "MM":
            return lightFormatters.M(xt, Cn);
        case "Mo":
            return as.ordinalNumber(cs + 1, {
                unit: "month"
            });
        case "MMM":
            return as.month(cs, {
                width: "abbreviated",
                context: "formatting"
            });
        case "MMMMM":
            return as.month(cs, {
                width: "narrow",
                context: "formatting"
            });
        case "MMMM":
        default:
            return as.month(cs, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    L: function(xt, Cn, as) {
        const cs = xt.getMonth();
        switch (Cn) {
        case "L":
            return String(cs + 1);
        case "LL":
            return addLeadingZeros(cs + 1, 2);
        case "Lo":
            return as.ordinalNumber(cs + 1, {
                unit: "month"
            });
        case "LLL":
            return as.month(cs, {
                width: "abbreviated",
                context: "standalone"
            });
        case "LLLLL":
            return as.month(cs, {
                width: "narrow",
                context: "standalone"
            });
        case "LLLL":
        default:
            return as.month(cs, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    w: function(xt, Cn, as, cs) {
        const Cs = getWeek(xt, cs);
        return Cn === "wo" ? as.ordinalNumber(Cs, {
            unit: "week"
        }) : addLeadingZeros(Cs, Cn.length)
    },
    I: function(xt, Cn, as) {
        const cs = getISOWeek(xt);
        return Cn === "Io" ? as.ordinalNumber(cs, {
            unit: "week"
        }) : addLeadingZeros(cs, Cn.length)
    },
    d: function(xt, Cn, as) {
        return Cn === "do" ? as.ordinalNumber(xt.getDate(), {
            unit: "date"
        }) : lightFormatters.d(xt, Cn)
    },
    D: function(xt, Cn, as) {
        const cs = getDayOfYear(xt);
        return Cn === "Do" ? as.ordinalNumber(cs, {
            unit: "dayOfYear"
        }) : addLeadingZeros(cs, Cn.length)
    },
    E: function(xt, Cn, as) {
        const cs = xt.getDay();
        switch (Cn) {
        case "E":
        case "EE":
        case "EEE":
            return as.day(cs, {
                width: "abbreviated",
                context: "formatting"
            });
        case "EEEEE":
            return as.day(cs, {
                width: "narrow",
                context: "formatting"
            });
        case "EEEEEE":
            return as.day(cs, {
                width: "short",
                context: "formatting"
            });
        case "EEEE":
        default:
            return as.day(cs, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    e: function(xt, Cn, as, cs) {
        const Cs = xt.getDay()
          , Ls = (Cs - cs.weekStartsOn + 8) % 7 || 7;
        switch (Cn) {
        case "e":
            return String(Ls);
        case "ee":
            return addLeadingZeros(Ls, 2);
        case "eo":
            return as.ordinalNumber(Ls, {
                unit: "day"
            });
        case "eee":
            return as.day(Cs, {
                width: "abbreviated",
                context: "formatting"
            });
        case "eeeee":
            return as.day(Cs, {
                width: "narrow",
                context: "formatting"
            });
        case "eeeeee":
            return as.day(Cs, {
                width: "short",
                context: "formatting"
            });
        case "eeee":
        default:
            return as.day(Cs, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    c: function(xt, Cn, as, cs) {
        const Cs = xt.getDay()
          , Ls = (Cs - cs.weekStartsOn + 8) % 7 || 7;
        switch (Cn) {
        case "c":
            return String(Ls);
        case "cc":
            return addLeadingZeros(Ls, Cn.length);
        case "co":
            return as.ordinalNumber(Ls, {
                unit: "day"
            });
        case "ccc":
            return as.day(Cs, {
                width: "abbreviated",
                context: "standalone"
            });
        case "ccccc":
            return as.day(Cs, {
                width: "narrow",
                context: "standalone"
            });
        case "cccccc":
            return as.day(Cs, {
                width: "short",
                context: "standalone"
            });
        case "cccc":
        default:
            return as.day(Cs, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    i: function(xt, Cn, as) {
        const cs = xt.getDay()
          , Cs = cs === 0 ? 7 : cs;
        switch (Cn) {
        case "i":
            return String(Cs);
        case "ii":
            return addLeadingZeros(Cs, Cn.length);
        case "io":
            return as.ordinalNumber(Cs, {
                unit: "day"
            });
        case "iii":
            return as.day(cs, {
                width: "abbreviated",
                context: "formatting"
            });
        case "iiiii":
            return as.day(cs, {
                width: "narrow",
                context: "formatting"
            });
        case "iiiiii":
            return as.day(cs, {
                width: "short",
                context: "formatting"
            });
        case "iiii":
        default:
            return as.day(cs, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    a: function(xt, Cn, as) {
        const Cs = xt.getHours() / 12 >= 1 ? "pm" : "am";
        switch (Cn) {
        case "a":
        case "aa":
            return as.dayPeriod(Cs, {
                width: "abbreviated",
                context: "formatting"
            });
        case "aaa":
            return as.dayPeriod(Cs, {
                width: "abbreviated",
                context: "formatting"
            }).toLowerCase();
        case "aaaaa":
            return as.dayPeriod(Cs, {
                width: "narrow",
                context: "formatting"
            });
        case "aaaa":
        default:
            return as.dayPeriod(Cs, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    b: function(xt, Cn, as) {
        const cs = xt.getHours();
        let Cs;
        switch (cs === 12 ? Cs = dayPeriodEnum.noon : cs === 0 ? Cs = dayPeriodEnum.midnight : Cs = cs / 12 >= 1 ? "pm" : "am",
        Cn) {
        case "b":
        case "bb":
            return as.dayPeriod(Cs, {
                width: "abbreviated",
                context: "formatting"
            });
        case "bbb":
            return as.dayPeriod(Cs, {
                width: "abbreviated",
                context: "formatting"
            }).toLowerCase();
        case "bbbbb":
            return as.dayPeriod(Cs, {
                width: "narrow",
                context: "formatting"
            });
        case "bbbb":
        default:
            return as.dayPeriod(Cs, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    B: function(xt, Cn, as) {
        const cs = xt.getHours();
        let Cs;
        switch (cs >= 17 ? Cs = dayPeriodEnum.evening : cs >= 12 ? Cs = dayPeriodEnum.afternoon : cs >= 4 ? Cs = dayPeriodEnum.morning : Cs = dayPeriodEnum.night,
        Cn) {
        case "B":
        case "BB":
        case "BBB":
            return as.dayPeriod(Cs, {
                width: "abbreviated",
                context: "formatting"
            });
        case "BBBBB":
            return as.dayPeriod(Cs, {
                width: "narrow",
                context: "formatting"
            });
        case "BBBB":
        default:
            return as.dayPeriod(Cs, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    h: function(xt, Cn, as) {
        if (Cn === "ho") {
            let cs = xt.getHours() % 12;
            return cs === 0 && (cs = 12),
            as.ordinalNumber(cs, {
                unit: "hour"
            })
        }
        return lightFormatters.h(xt, Cn)
    },
    H: function(xt, Cn, as) {
        return Cn === "Ho" ? as.ordinalNumber(xt.getHours(), {
            unit: "hour"
        }) : lightFormatters.H(xt, Cn)
    },
    K: function(xt, Cn, as) {
        const cs = xt.getHours() % 12;
        return Cn === "Ko" ? as.ordinalNumber(cs, {
            unit: "hour"
        }) : addLeadingZeros(cs, Cn.length)
    },
    k: function(xt, Cn, as) {
        let cs = xt.getHours();
        return cs === 0 && (cs = 24),
        Cn === "ko" ? as.ordinalNumber(cs, {
            unit: "hour"
        }) : addLeadingZeros(cs, Cn.length)
    },
    m: function(xt, Cn, as) {
        return Cn === "mo" ? as.ordinalNumber(xt.getMinutes(), {
            unit: "minute"
        }) : lightFormatters.m(xt, Cn)
    },
    s: function(xt, Cn, as) {
        return Cn === "so" ? as.ordinalNumber(xt.getSeconds(), {
            unit: "second"
        }) : lightFormatters.s(xt, Cn)
    },
    S: function(xt, Cn) {
        return lightFormatters.S(xt, Cn)
    },
    X: function(xt, Cn, as) {
        const cs = xt.getTimezoneOffset();
        if (cs === 0)
            return "Z";
        switch (Cn) {
        case "X":
            return formatTimezoneWithOptionalMinutes(cs);
        case "XXXX":
        case "XX":
            return formatTimezone(cs);
        case "XXXXX":
        case "XXX":
        default:
            return formatTimezone(cs, ":")
        }
    },
    x: function(xt, Cn, as) {
        const cs = xt.getTimezoneOffset();
        switch (Cn) {
        case "x":
            return formatTimezoneWithOptionalMinutes(cs);
        case "xxxx":
        case "xx":
            return formatTimezone(cs);
        case "xxxxx":
        case "xxx":
        default:
            return formatTimezone(cs, ":")
        }
    },
    O: function(xt, Cn, as) {
        const cs = xt.getTimezoneOffset();
        switch (Cn) {
        case "O":
        case "OO":
        case "OOO":
            return "GMT" + formatTimezoneShort(cs, ":");
        case "OOOO":
        default:
            return "GMT" + formatTimezone(cs, ":")
        }
    },
    z: function(xt, Cn, as) {
        const cs = xt.getTimezoneOffset();
        switch (Cn) {
        case "z":
        case "zz":
        case "zzz":
            return "GMT" + formatTimezoneShort(cs, ":");
        case "zzzz":
        default:
            return "GMT" + formatTimezone(cs, ":")
        }
    },
    t: function(xt, Cn, as) {
        const cs = Math.trunc(+xt / 1e3);
        return addLeadingZeros(cs, Cn.length)
    },
    T: function(xt, Cn, as) {
        return addLeadingZeros(+xt, Cn.length)
    }
};
function formatTimezoneShort(xt, Cn="") {
    const as = xt > 0 ? "-" : "+"
      , cs = Math.abs(xt)
      , Cs = Math.trunc(cs / 60)
      , Ls = cs % 60;
    return Ls === 0 ? as + String(Cs) : as + String(Cs) + Cn + addLeadingZeros(Ls, 2)
}
function formatTimezoneWithOptionalMinutes(xt, Cn) {
    return xt % 60 === 0 ? (xt > 0 ? "-" : "+") + addLeadingZeros(Math.abs(xt) / 60, 2) : formatTimezone(xt, Cn)
}
function formatTimezone(xt, Cn="") {
    const as = xt > 0 ? "-" : "+"
      , cs = Math.abs(xt)
      , Cs = addLeadingZeros(Math.trunc(cs / 60), 2)
      , Ls = addLeadingZeros(cs % 60, 2);
    return as + Cs + Cn + Ls
}
const dateLongFormatter = (xt, Cn) => {
    switch (xt) {
    case "P":
        return Cn.date({
            width: "short"
        });
    case "PP":
        return Cn.date({
            width: "medium"
        });
    case "PPP":
        return Cn.date({
            width: "long"
        });
    case "PPPP":
    default:
        return Cn.date({
            width: "full"
        })
    }
}
  , timeLongFormatter = (xt, Cn) => {
    switch (xt) {
    case "p":
        return Cn.time({
            width: "short"
        });
    case "pp":
        return Cn.time({
            width: "medium"
        });
    case "ppp":
        return Cn.time({
            width: "long"
        });
    case "pppp":
    default:
        return Cn.time({
            width: "full"
        })
    }
}
  , dateTimeLongFormatter = (xt, Cn) => {
    const as = xt.match(/(P+)(p+)?/) || []
      , cs = as[1]
      , Cs = as[2];
    if (!Cs)
        return dateLongFormatter(xt, Cn);
    let Ls;
    switch (cs) {
    case "P":
        Ls = Cn.dateTime({
            width: "short"
        });
        break;
    case "PP":
        Ls = Cn.dateTime({
            width: "medium"
        });
        break;
    case "PPP":
        Ls = Cn.dateTime({
            width: "long"
        });
        break;
    case "PPPP":
    default:
        Ls = Cn.dateTime({
            width: "full"
        });
        break
    }
    return Ls.replace("{{date}}", dateLongFormatter(cs, Cn)).replace("{{time}}", timeLongFormatter(Cs, Cn))
}
  , longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
}
  , dayOfYearTokenRE = /^D+$/
  , weekYearTokenRE = /^Y+$/
  , throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(xt) {
    return dayOfYearTokenRE.test(xt)
}
function isProtectedWeekYearToken(xt) {
    return weekYearTokenRE.test(xt)
}
function warnOrThrowProtectedError(xt, Cn, as) {
    const cs = message(xt, Cn, as);
    if (console.warn(cs),
    throwTokens.includes(xt))
        throw new RangeError(cs)
}
function message(xt, Cn, as) {
    const cs = xt[0] === "Y" ? "years" : "days of the month";
    return `Use \`${xt.toLowerCase()}\` instead of \`${xt}\` (in \`${Cn}\`) for formatting ${cs} to the input \`${as}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`
}
const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g
  , longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g
  , escapedStringRegExp = /^'([^]*?)'?$/
  , doubleQuoteRegExp = /''/g
  , unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(xt, Cn, as) {
    var ba, yl, xl, wl;
    const cs = getDefaultOptions()
      , Cs = cs.locale ?? enUS
      , Ls = cs.firstWeekContainsDate ?? ((yl = (ba = cs.locale) == null ? void 0 : ba.options) == null ? void 0 : yl.firstWeekContainsDate) ?? 1
      , Vs = cs.weekStartsOn ?? ((wl = (xl = cs.locale) == null ? void 0 : xl.options) == null ? void 0 : wl.weekStartsOn) ?? 0
      , Ws = toDate(xt, as == null ? void 0 : as.in);
    if (!isValid$1(Ws))
        throw new RangeError("Invalid time value");
    let Xs = Cn.match(longFormattingTokensRegExp).map(_l => {
        const El = _l[0];
        if (El === "p" || El === "P") {
            const Cl = longFormatters[El];
            return Cl(_l, Cs.formatLong)
        }
        return _l
    }
    ).join("").match(formattingTokensRegExp).map(_l => {
        if (_l === "''")
            return {
                isToken: !1,
                value: "'"
            };
        const El = _l[0];
        if (El === "'")
            return {
                isToken: !1,
                value: cleanEscapedString(_l)
            };
        if (formatters[El])
            return {
                isToken: !0,
                value: _l
            };
        if (El.match(unescapedLatinCharacterRegExp))
            throw new RangeError("Format string contains an unescaped latin alphabet character `" + El + "`");
        return {
            isToken: !1,
            value: _l
        }
    }
    );
    Cs.localize.preprocessor && (Xs = Cs.localize.preprocessor(Ws, Xs));
    const ga = {
        firstWeekContainsDate: Ls,
        weekStartsOn: Vs,
        locale: Cs
    };
    return Xs.map(_l => {
        if (!_l.isToken)
            return _l.value;
        const El = _l.value;
        (isProtectedWeekYearToken(El) || isProtectedDayOfYearToken(El)) && warnOrThrowProtectedError(El, Cn, String(xt));
        const Cl = formatters[El[0]];
        return Cl(Ws, El, Cs.localize, ga)
    }
    ).join("")
}
function cleanEscapedString(xt) {
    const Cn = xt.match(escapedStringRegExp);
    return Cn ? Cn[1].replace(doubleQuoteRegExp, "'") : xt
}
function setDefaultOptions(xt) {
    const Cn = {}
      , as = getDefaultOptions();
    for (const cs in as)
        Object.prototype.hasOwnProperty.call(as, cs) && (Cn[cs] = as[cs]);
    for (const cs in xt)
        Object.prototype.hasOwnProperty.call(xt, cs) && (xt[cs] === void 0 ? delete Cn[cs] : Cn[cs] = xt[cs]);
    setDefaultOptions$1(Cn)
}
const getDefaultLocale = () => {
    let xt = "en";
    if (window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe && window.Telegram.WebApp.initDataUnsafe.user && window.Telegram.WebApp.initDataUnsafe.user.language_code) {
        const Cn = window.Telegram.WebApp.initDataUnsafe.user.language_code.toLowerCase().substring(0, 2);
        (Cn === "ru" || Cn === "fa") && (xt = Cn)
    }
    return xt
}
  , profileSlice = createSlice( (xt, Cn) => ({
    fullName: "",
    id: 0,
    pvpBadge: null,
    locale: getDefaultLocale(),
    allowsPm: !1,
    photo: null,
    refUrl: null,
    currentLanguageCode: null,
    isVIP: !1,
    isWalletConnectBonusClaimed: !1,
    shownModalForPassports: [],
    deviceId: null,
    payerId: "",
    tgUser: null,
    referralRevenueCoef: 0,
    giftsCount: 0,
    salesFee: 0,
    discount: 0,
    setSalesFee: as => {
        xt(cs => ({
            profile: {
                ...cs.profile,
                salesFee: as
            }
        }))
    }
    ,
    setDiscount: as => {
        xt(cs => ({
            profile: {
                ...cs.profile,
                discount: as
            }
        }))
    }
    ,
    updateCurrentLanguage: async as => {
        const cs = {
            currentLanguage: as
        };
        await fetch(getApiUrl("/api/v1/language"), {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(cs)
        })
    }
    ,
    loadLocales: async () => {
        try {
            const cs = await (await fetch(getApiUrl("/api/v1/locales"), {
                headers: {}
            })).json();
            xt(Cs => ({
                locales: {
                    ...Cs.locales,
                    locales: cs
                }
            }))
        } catch {}
    }
    ,
    loadLocale: async (as, cs) => {
        const Cs = as || Cn().profile.locale;
        Cs !== "en" && setDefaultOptions({
            locale: {
                ru
            }[Cs]
        });
        const Vs = await (await fetch(getApiUrl("/api/v1/get_locale"), {
            method: "POST",
            headers: {
                Accept: "application/json",
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                locale: Cs
            })
        })).json()
          , Ws = getI18n().addResources(Cs, "translation", replaceEscapedNewlines(Vs));
        as && !cs && xt(Xs => ({
            profile: {
                ...Xs.profile,
                locale: as
            },
            locales: {
                ...Xs.locales,
                locale: as
            }
        })),
        cs || Cs && Ws.language !== Cs && Ws.changeLanguage(Cs)
    }
    ,
    writeFingerprints: async () => {
        const Cs = await (await index$1.load()).get();
        xt(Ls => ({
            profile: {
                ...Ls.profile,
                deviceId: Cs.visitorId
            }
        }))
    }
    ,
    fetchGiftsCount: async () => {
        try {
            const cs = await (await fetch(getApiUrl("/api/v1/gifts/my-gifts-count"))).json();
            xt(Cs => ({
                profile: {
                    ...Cs.profile,
                    giftsCount: cs
                }
            }))
        } catch (as) {
            console.error("Error while fetching my gifts count", as)
        }
    }
}))
  , walletSlice = createSlice( (xt, Cn) => ({
    balance: {
        hard: 0,
        soft: 0,
        stars: 0,
        starsForWithdraw: 0,
        totalHard: 0,
        friendsCount: 0
    },
    ton: "",
    setHardBalance: as => {
        xt(cs => ({
            wallet: {
                ...cs.wallet,
                balance: {
                    ...cs.wallet.balance,
                    hard: as
                }
            }
        }))
    }
    ,
    updateWallet: async as => {
        const cs = Cn().profile.deviceId
          , Cs = await fetch(getApiUrl("/api/v1/wallet"), {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                ton: as,
                deviceId: cs
            })
        });
        if (!Cs.ok)
            return;
        const Ls = await Cs.json();
        xt(Vs => ({
            wallet: {
                ...Vs.wallet,
                ton: Ls.ton
            }
        }))
    }
    ,
    fetchBalance: async () => {
        const cs = await (await fetch(getApiUrl("/api/v1/balance"))).json();
        xt(Cs => ({
            wallet: {
                ...Cs.wallet,
                balance: {
                    hard: cs.hard,
                    soft: cs.soft,
                    stars: cs.stars,
                    starsForWithdraw: cs.starsFotWithdraw,
                    totalHard: cs.totalHard,
                    friendsCount: cs.friendsCount
                }
            }
        }))
    }
    ,
    updateBalance: async () => {
        await Cn().wallet.fetchBalance()
    }
}));
var HANDLER_NAMES = (xt => (xt.PAGE_BACK_HANDLER = "PAGE_BACK_HANDLER",
xt.MODAL_CLOSE_HANDLER = "MODAL_CLOSE_HANDLER",
xt))(HANDLER_NAMES || {});
const backButtonSlice = createSlice( (xt, Cn) => {
    let as = null;
    const cs = () => {
        try {
            as && Hc.offClick(as);
            const Cs = Cn().backButton.handlerStack;
            if (Cs.length > 0) {
                const Ls = Cs[Cs.length - 1];
                as = () => {
                    typeof Ls.handler == "function" && Ls.handler()
                }
                ,
                Hc.onClick(as),
                Hc.show()
            } else
                as = null,
                Hc.hide()
        } catch (Cs) {
            console.error(Cs)
        }
    }
    ;
    return {
        handlerStack: [],
        addBackButtonHandler: (Cs, Ls) => {
            const {handlerStack: Vs} = Cn().backButton;
            if (!Vs.find(Xs => Xs.name === Cs)) {
                const Xs = [...Vs, {
                    name: Cs,
                    handler: Ls
                }];
                xt(ga => ({
                    backButton: {
                        ...ga.backButton,
                        handlerStack: Xs
                    }
                })),
                cs()
            }
        }
        ,
        removeBackButtonHandler: Cs => {
            const {handlerStack: Ls} = Cn().backButton
              , Vs = Ls.filter(Ws => Ws.name !== Cs);
            xt(Ws => ({
                backButton: {
                    ...Ws.backButton,
                    handlerStack: Vs
                }
            })),
            cs()
        }
    }
}
);
var ModalNames = (xt => (xt.CANCEL_SALE_CONFIRM = "CANCEL_SALE_CONFIRM",
xt.LIST_GIFT_PRICE = "LIST_GIFT_PRICE",
xt.LIST_GIFT_CONFIRM = "LIST_GIFT_CONFIRM",
xt.WITHDRAW_GIFT_CONFIRM = "WITHDRAW_GIFT_CONFIRM",
xt.MULTIPLE_WITHDRAW_CONFIRM = "MULTIPLE_WITHDRAW_CONFIRM",
xt.ERROR = "ERROR",
xt.CONGRATS = "CONGRATS",
xt.GIFT_OVERVIEW = "GIFT_OVERVIEW",
xt.MY_GIFTS_ACTIONS = "MY_GIFTS_ACTIONS",
xt.LISTING_SALES_LIMIT = "LISTING_SALES_LIMIT",
xt.MULTIPLE_LISTING_PRICE = "MULTIPLE_LISTING_PRICE",
xt.MULTIPLE_LISTING_CONFIRM = "MULTIPLE_LISTING_CONFIRM",
xt.DEPOSIT = "DEPOSIT",
xt.WITHDRAW = "WITHDRAW",
xt.WALLET_DISCONNECT_COFIRM = "WALLET_DISCONNECT_COFIRM",
xt.FILTERS_ALL = "FILTERS_ALL",
xt.FILTERS_COLLECTION = "FILTERS_COLLECTION",
xt.FILTERS_MODEL = "FILTERS_MODEL",
xt.FILTERS_BACKDROP = "FILTERS_BACKDROP",
xt.FILTERS_SYMBOL = "FILTERS_SYMBOL",
xt.FILTERS_PRICE = "FILTERS_PRICE",
xt.SORT = "SORT",
xt.CART = "CART",
xt.OUT_OF_STOCK = "OUT_OF_STOCK",
xt.PROOF_OF_PURCHASE = "PROOF_OF_PURCHASE",
xt.SWEEP = "SWEEP",
xt.REFRESH_FEED = "REFRESH_FEED",
xt.QUICK_BUY = "QUICK_BUY",
xt.QUICK_BUY_PROOF_OF_PURCHASE = "QUICK_BUY_PROOF_OF_PURCHASE",
xt.GIFT_PROMOTION_CONFIRM = "GIFT_PROMOTION_CONFIRM",
xt.GIFT_PROMOTION_SUCCESS = "GIFT_PROMOTION_SUCCESS",
xt.GA_CREATION = "GA_CREATION",
xt.GA_PARTISIPATION = "GA_PARTISIPATION",
xt.GA_RESULT_INFO = "GA_RESULT_INFO",
xt.GA_REWARD = "GA_REWARD",
xt.FEED_SORT = "FEED_SORT",
xt.FEED_FILTERS_ALL = "FEED_FILTERS_ALL",
xt.SWEEP_BUNDLE = "SWEEP_BUNDLE",
xt))(ModalNames || {});
const modalSlice = createSlice( (xt, Cn) => ({
    queue: [],
    addModal: (as, cs=0, Cs={}) => {
        const Ls = Cn().modal.queue
          , Vs = `${as}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        Ls.push({
            name: as,
            order: cs,
            id: Vs,
            params: Cs
        });
        const Ws = Ls.sort( (Xs, ga) => Xs.order - ga.order);
        xt(Xs => ({
            modal: {
                ...Xs.modal,
                queue: Ws
            }
        }))
    }
    ,
    removeModal: as => {
        const cs = Cn().modal.queue
          , Cs = cs.findIndex(Ls => Ls.name === as);
        if (Cs !== -1) {
            const Ls = [...cs];
            Ls.splice(Cs, 1),
            xt(Vs => ({
                modal: {
                    ...Vs.modal,
                    queue: Ls
                }
            }))
        }
    }
}))
  , navigationSlice = createSlice( (xt, Cn) => ({
    previousPath: "/",
    currentPath: "/",
    lastKnownPositions: {},
    shouldUpdatePath: !1,
    setPath: as => {
        xt(cs => cs.navigation.currentPath === as ? {} : {
            navigation: {
                ...cs.navigation,
                previousPath: cs.navigation.currentPath,
                currentPath: as
            }
        })
    }
    ,
    setShouldUpdatePath: as => {
        xt(cs => ({
            navigation: {
                ...cs.navigation,
                shouldUpdatePath: as
            }
        }))
    }
    ,
    updatePositions: as => {
        xt(cs => ({
            navigation: {
                ...cs.navigation,
                lastKnownPositions: {
                    ...cs.navigation.lastKnownPositions,
                    ...as
                }
            }
        }))
    }
}));
var GiftOrdering = (xt => (xt.None = "None",
xt.ListingTime = "ListingTime",
xt.Price = "Price",
xt.ModelRarity = "ModelRarity",
xt.BackgroundRarity = "BackgroundRarity",
xt.SymbolRarity = "SymbolRarity",
xt))(GiftOrdering || {});
const DEFAULT_PAGE_SIZE = 20
  , fetchGifts = async (xt, Cn) => {
    try {
        const as = xt * DEFAULT_PAGE_SIZE
          , cs = Cn && "promotedFirst"in Cn ? Cn.promotedFirst : !1;
        return await (await fetch(getApiUrl("/api/v1/gifts/saling"), {
            method: "POST",
            body: JSON.stringify({
                count: DEFAULT_PAGE_SIZE,
                offset: as,
                ...Cn,
                promotedFirst: !!cs
            }),
            headers: {
                "Content-Type": "application/json"
            }
        })).json()
    } catch (as) {
        return console.error("Error while fetching gifts", as),
        []
    }
}
  , prefetchInitialGifts = async xt => {
    try {
        const Cn = {
            ordering: GiftOrdering.None,
            lowToHigh: !1,
            query: null,
            number: null,
            collectionNames: [],
            modelNames: [],
            backdropNames: [],
            symbolNames: [],
            minPrice: null,
            maxPrice: null,
            mintable: null
        };
        return await (await fetch(getApiUrl("/api/v1/gifts/saling"), {
            method: "POST",
            body: JSON.stringify({
                count: DEFAULT_PAGE_SIZE,
                offset: 0,
                ...Cn,
                promotedFirst: xt
            }),
            headers: {
                "Content-Type": "application/json"
            }
        })).json()
    } catch {
        return console.error("Error while prefetching gifts"),
        []
    }
}
  , buyGifts = async xt => {
    const Cn = await fetch(getApiUrl("/api/v1/gifts/buy"), {
        method: "POST",
        body: JSON.stringify({
            ids: xt.map(cs => cs.id)
        }),
        headers: {
            "Content-Type": "application/json"
        }
    });
    if (!Cn.ok)
        throw new Error("Failed to withdraw gift");
    return {
        giftsForPurchase: xt,
        purchasedGifts: await Cn.json()
    }
}
  , fetchMyGifts = async (xt, Cn, as) => {
    try {
        const cs = xt * DEFAULT_PAGE_SIZE;
        return await (await fetch(getApiUrl("/api/v1/gifts"), {
            method: "POST",
            body: JSON.stringify({
                isListed: Cn,
                count: DEFAULT_PAGE_SIZE,
                offset: cs,
                ...as,
                promotedFirst: !0
            }),
            headers: {
                "Content-Type": "application/json"
            }
        })).json()
    } catch (cs) {
        return console.error("Error while fetching my gifts", cs),
        []
    }
}
  , prefetchInitialMyGifts = async xt => {
    try {
        const Cn = {
            ordering: GiftOrdering.None,
            lowToHigh: !1,
            promotedFirst: !1,
            query: null,
            number: null,
            collectionNames: [],
            modelNames: [],
            backdropNames: [],
            symbolNames: [],
            minPrice: null,
            maxPrice: null,
            mintable: null
        };
        return await (await fetch(getApiUrl("/api/v1/gifts"), {
            method: "POST",
            body: JSON.stringify({
                isListed: xt,
                count: DEFAULT_PAGE_SIZE,
                offset: 0,
                ...Cn
            }),
            headers: {
                "Content-Type": "application/json"
            }
        })).json()
    } catch (Cn) {
        return console.error("Error while prefetching my gifts", Cn),
        []
    }
}
  , cancelSale = async xt => (await fetch(getApiUrl("/api/v1/gifts/sale/cancel"), {
    method: "POST",
    body: JSON.stringify({
        ids: xt
    }),
    headers: {
        "Content-Type": "application/json"
    }
})).json()
  , listGifts = async (xt, Cn) => await (await fetch(getApiUrl("/api/v1/gifts/sale"), {
    method: "POST",
    body: JSON.stringify({
        ids: xt,
        price: Cn
    }),
    headers: {
        "Content-Type": "application/json"
    }
})).json()
  , withdrawGift = async xt => {
    const Cn = await fetch(getApiUrl("/api/v1/gifts/return"), {
        method: "POST",
        body: JSON.stringify({
            ids: xt
        }),
        headers: {
            "Content-Type": "application/json"
        }
    });
    if (!Cn.ok)
        throw new Error("Failed to withdraw gift");
    return await Cn.json()
}
  , myGiftsSlice = (xt, Cn) => ({
    listingPrice: null,
    error: null,
    selectedGiftForCancellation: null,
    selectedGiftForListing: null,
    currentTab: "listed",
    multipleMode: null,
    selectedItems: [],
    isHiSaid: !1,
    selectedGiftForPromotion: null,
    prefetchedListedGifts: [],
    prefetchedUnlistedGifts: [],
    checkIsHiSaid: async () => {
        try {
            const cs = await (await fetch(getApiUrl("/api/v1/is-known-by-relayer"))).json();
            xt(Cs => ({
                myGifts: {
                    ...Cs.myGifts,
                    isHiSaid: cs
                }
            }))
        } catch {}
    }
    ,
    startIsHaiPolling: async () => {
        Cn().timers.startInterval(COMMON_INTERVALS.HI_POLLING, 2e3, async () => {
            await Cn().myGifts.checkIsHiSaid(),
            Cn().myGifts.isHiSaid && Cn().timers.stopInterval(COMMON_INTERVALS.HI_POLLING)
        }
        )
    }
    ,
    setCurrentTab: as => {
        xt(cs => ({
            myGifts: {
                ...cs.myGifts,
                currentTab: as
            }
        }))
    }
    ,
    setMultipleMode: as => {
        xt(cs => ({
            myGifts: {
                ...cs.myGifts,
                multipleMode: as,
                selectedItems: []
            }
        }))
    }
    ,
    toggleSelectedItem: as => {
        xt(cs => {
            const Ls = cs.myGifts.selectedItems.some(Vs => Vs.id === as.id) ? cs.myGifts.selectedItems.filter(Vs => Vs.id !== as.id) : [...cs.myGifts.selectedItems, as];
            return {
                myGifts: {
                    ...cs.myGifts,
                    selectedItems: Ls
                }
            }
        }
        )
    }
    ,
    clearSelectedItems: () => {
        xt(as => ({
            myGifts: {
                ...as.myGifts,
                selectedItems: []
            }
        }))
    }
    ,
    setListingPrice: as => xt(cs => ({
        myGifts: {
            ...cs.myGifts,
            listingPrice: as
        }
    })),
    listGift: as => {
        const cs = Cn();
        as.salesCount >= cs.app.freeSalesCount ? cs.modal.addModal(ModalNames.LISTING_SALES_LIMIT) : cs.modal.addModal(ModalNames.LIST_GIFT_PRICE),
        xt(Cs => ({
            myGifts: {
                ...Cs.myGifts,
                selectedGiftForListing: as
            }
        }))
    }
    ,
    cancelSale: as => {
        xt(cs => ({
            myGifts: {
                ...cs.myGifts,
                selectedGiftForCancellation: as
            }
        }))
    }
    ,
    clearSelectedGift: () => {
        xt(as => ({
            myGifts: {
                ...as.myGifts,
                selectedGiftForCancellation: null,
                selectedGiftForListing: null,
                selectedGiftForSharing: null,
                selectedGiftForPromotion: null
            }
        }))
    }
    ,
    setSelectedGiftForPromotion: as => {
        xt(cs => ({
            myGifts: {
                ...cs.myGifts,
                selectedGiftForPromotion: as
            }
        }))
    }
    ,
    getMaxSelectableItems: () => {
        const as = Cn();
        switch (as.myGifts.multipleMode) {
        case "giveaway":
            return as.app.maxGiveawayGifts;
        case "listing":
            return as.app.maxBatchSaleGifts;
        case "withdraw":
            return as.app.maxReturnGifts;
        default:
            return 0
        }
    }
    ,
    prefetchMyGiftsPromise: async () => {
        try {
            const [as,cs] = await Promise.all([prefetchInitialMyGifts(!0), prefetchInitialMyGifts(!1)]);
            xt(Cs => ({
                myGifts: {
                    ...Cs.myGifts,
                    prefetchedListedGifts: as,
                    prefetchedUnlistedGifts: cs
                }
            }))
        } catch (as) {
            console.error("Error while prefetching my gifts", as)
        }
    }
})
  , giftDisplaySlice = (xt, Cn) => ({
    itemWidth: 148,
    setItemWidth: as => {
        xt(cs => ({
            giftDisplay: {
                ...cs.giftDisplay,
                itemWidth: as
            }
        }))
    }
})
  , giftsSlice = (xt, Cn) => ({
    selectedGiftForOverview: null,
    selectedGiftForQuickBuy: null,
    prefetchedGifts: [],
    setSelectedGiftForOverview: as => {
        xt(cs => ({
            gifts: {
                ...cs.gifts,
                selectedGiftForOverview: as
            }
        }))
    }
    ,
    setSelectedGiftForQuickBuy: as => {
        xt(cs => ({
            gifts: {
                ...cs.gifts,
                selectedGiftForQuickBuy: as
            }
        }))
    }
    ,
    getGiftInfo: async as => {
        const Cs = await (await fetch(getApiUrl("/api/v1/gifts/gift/" + as))).json();
        Cs && (Cn().gifts.setSelectedGiftForOverview(Cs),
        Cn().modal.addModal(ModalNames.GIFT_OVERVIEW))
    }
})
  , referralsSlice = createSlice( (xt, Cn) => ({
    referralsWithWalletsCount: 0,
    referralsWithWallets: [],
    fetchReferralsWithWallets: async () => {
        const cs = await (await fetch(getApiUrl("/api/v1/referrals/with-wallet-count"), {
            method: "GET",
            headers: {
                "Content-Type": "application/json"
            }
        })).json();
        xt(Cs => ({
            referrals: {
                ...Cs.referrals,
                referralsWithWalletsCount: cs
            }
        }))
    }
    ,
    getReferralShareMessageId: async () => await (await fetch(getApiUrl("/api/v1/referrals/share-message"), {
        method: "GET",
        headers: {
            "Content-Type": "application/json"
        }
    })).text()
}))
  , cartSlice = (xt, Cn) => ({
    gifts: [],
    selectedGifts: [],
    boughtGifts: [],
    selectGift: as => {
        const cs = Cn().cart
          , Cs = cs.gifts.find(Vs => Vs.id === as)
          , Ls = cs.selectedGifts.some(Vs => Vs.id === (Cs == null ? void 0 : Cs.id));
        Cs && !Ls && xt(Vs => ({
            cart: {
                ...Vs.cart,
                selectedGifts: [...Vs.cart.selectedGifts, Cs]
            }
        }))
    }
    ,
    unselectGift: as => {
        const Cs = Cn().cart.selectedGifts.filter(Ls => Ls.id !== as);
        xt(Ls => ({
            cart: {
                ...Ls.cart,
                selectedGifts: Cs
            }
        }))
    }
    ,
    selectAll: () => {
        const as = Cn().cart.gifts;
        xt(cs => ({
            cart: {
                ...cs.cart,
                selectedGifts: as
            }
        }))
    }
    ,
    unselectAll: () => {
        xt(as => ({
            cart: {
                ...as.cart,
                selectedGifts: []
            }
        }))
    }
    ,
    addToCart: as => {
        const cs = Cn()
          , Cs = cs.app.maxBatchBuy > cs.cart.gifts.length;
        !cs.cart.gifts.some(Vs => Vs.id === as.id) && Cs && xt(Vs => ({
            cart: {
                ...Vs.cart,
                gifts: [...Vs.cart.gifts, as]
            }
        }))
    }
    ,
    removeFromCart: as => {
        const cs = Cn().cart.gifts.filter(Cs => Cs.id !== as);
        xt(Cs => ({
            cart: {
                ...Cs.cart,
                gifts: cs
            }
        }))
    }
    ,
    clearCart: () => {
        xt(as => ({
            cart: {
                ...as.cart,
                gifts: []
            }
        }))
    }
    ,
    setBoughtGifts: as => {
        xt(cs => ({
            cart: {
                ...cs.cart,
                boughtGifts: as
            }
        }))
    }
})
  , claimTransaction = async xt => await (await fetch(getApiUrl(`/api/v1/transactions/${xt}`), {
    method: "POST"
})).json()
  , getAwaitingTransactions = async () => {
    try {
        return await (await fetch(getApiUrl("/api/v1/transactions/await"))).json()
    } catch {
        return []
    }
}
  , transactionsSlice = createSlice( (xt, Cn) => ({
    monitorTransactions: async () => {
        let cs = 0;
        const Cs = Cn();
        for (; cs < 120 && (cs++,
        !await Cs.transaction.checkTransaction()); )
            await new Promise(Vs => setTimeout(Vs, 1e3))
    }
    ,
    checkTransaction: async () => {
        const as = Cn();
        try {
            const Cs = (await getAwaitingTransactions()).filter(Ls => !Ls.isClaimed);
            return Cs.length ? (await Promise.all(Cs.map(Ls => claimTransaction(Ls.id))),
            await Cn().wallet.updateBalance(),
            as.modal.addModal(ModalNames.CONGRATS, 0, {
                image: "/images/common/green-check-mark.png",
                title: "text_success_deposit",
                message: "text_ton_workload",
                buttonText: "button_gotrade"
            }),
            !0) : !1
        } catch {
            return !1
        }
    }
}))
  , createWithdrawRequest = async (xt, Cn) => await await fetch(getApiUrl(`/api/v1/wallet/withdraw/tons?nanoTONs=${xt}&wallet=${Cn}`), {
    method: "GET"
})
  , checkPendingWithdrawalRequests = async xt => {
    const Cn = xt.filter(Cs => !!Cs);
    return (await (await fetch(getApiUrl("/api/v1/history/by-ids"), {
        method: "POST",
        body: JSON.stringify({
            ids: Cn
        }),
        headers: {
            "Content-Type": "application/json"
        }
    })).json()).filter(Cs => Cs.status === "Pending")
}
  , withdrawSlice = createSlice( (xt, Cn) => ({
    isWithdrawPending: !1,
    checkPendingWithdraw: async () => {
        try {
            const as = Cn().history.pendingWithdrawals;
            if (as.length === 0)
                return;
            const cs = await checkPendingWithdrawalRequests(as.map(Cs => Cs.historyId));
            cs.length !== as.length && Cn().history.fetchHistory(!0),
            cs.length || Cn().withdraw.stopPendingWithdrawPolling()
        } catch (as) {
            console.error(as)
        }
    }
    ,
    startPendingWithdrawPolling: () => {
        Cn().history.pendingWithdrawals.length > 0 && Cn().timers.startInterval(COMMON_INTERVALS.PENDING_WITHDRAW_POLLING, 1e4, () => {
            Cn().withdraw.checkPendingWithdraw()
        }
        )
    }
    ,
    stopPendingWithdrawPolling: () => {
        Cn().timers.stopInterval(COMMON_INTERVALS.PENDING_WITHDRAW_POLLING)
    }
    ,
    requestTonWithdraw: async (as, cs) => {
        let Cs = null;
        try {
            xt(Ls => ({
                withdraw: {
                    ...Ls.withdraw,
                    isWithdrawPending: !0
                }
            })),
            Cs = await createWithdrawRequest(as, cs),
            Cn().wallet.updateBalance(),
            Cn().history.fetchHistory(!0),
            Cn().withdraw.startPendingWithdrawPolling()
        } catch (Ls) {
            console.error(Ls)
        } finally {
            return xt(Ls => ({
                withdraw: {
                    ...Ls.withdraw,
                    isWithdrawPending: !1
                }
            })),
            Cs
        }
    }
}));
var FeedType = (xt => (xt.Sale = "Sale",
xt.Listing = "Listing",
xt))(FeedType || {})
  , FeedOrdering = (xt => (xt.Latest = "Latest",
xt.Price = "Price",
xt.GiftNumber = "GiftNumber",
xt))(FeedOrdering || {});
const FILTERS_STORAGE_KEY = "mrkt_filters"
  , getFromStorage = (xt, Cn) => {
    if (typeof window > "u")
        return Cn;
    try {
        const as = localStorage.getItem(xt);
        return as ? JSON.parse(as) : Cn
    } catch (as) {
        return console.error(`Error reading ${xt} from localStorage:`, as),
        Cn
    }
}
  , saveToStorage = (xt, Cn) => {
    if (!(typeof window > "u"))
        try {
            localStorage.setItem(xt, JSON.stringify(Cn))
        } catch (as) {
            console.error(`Error saving ${xt} to localStorage:`, as)
        }
}
  , baseFilterValue = {
    mintable: null,
    collectionNames: [],
    modelNames: [],
    backdropNames: [],
    symbolNames: [],
    minPrice: null,
    maxPrice: null,
    number: null
}
  , defaultFilterValues = {
    ...baseFilterValue,
    type: []
}
  , filtersSlice = (xt, Cn) => {
    const as = getFromStorage(FILTERS_STORAGE_KEY, {
        filters: defaultFilterValues,
        ordering: GiftOrdering.None,
        lowToHigh: !1,
        promotedFirst: !1,
        query: null,
        feedOrdering: FeedOrdering.Latest,
        feedLowToHigh: !1
    });
    return {
        filters: as.filters,
        ordering: as.ordering,
        lowToHigh: as.lowToHigh,
        promotedFirst: as.promotedFirst,
        query: as.query,
        feedOrdering: as.feedOrdering,
        feedLowToHigh: as.feedLowToHigh,
        setFilters: cs => {
            const Cs = "type"in cs
              , Ls = {
                collectionNames: cs.collectionNames,
                modelNames: cs.modelNames,
                backdropNames: cs.backdropNames,
                number: cs.number,
                symbolNames: "symbolNames"in cs ? cs.symbolNames : [],
                minPrice: "minPrice"in cs ? cs.minPrice : null,
                maxPrice: "maxPrice"in cs ? cs.maxPrice : null,
                mintable: "mintable"in cs ? cs.mintable : null,
                type: Cs ? cs.type : []
            };
            Ls.minPrice !== null && Ls.maxPrice !== null && Number(Ls.minPrice) > Number(Ls.maxPrice) && ([Ls.minPrice,Ls.maxPrice] = [Ls.maxPrice, Ls.minPrice]),
            xt(Vs => {
                const Ws = {
                    filters: {
                        ...Vs.filters,
                        filters: Ls
                    }
                };
                return saveToStorage(FILTERS_STORAGE_KEY, {
                    ...as,
                    filters: Ls
                }),
                Ws
            }
            )
        }
        ,
        resetFilters: () => {
            xt(cs => {
                const Cs = {
                    filters: {
                        ...cs.filters,
                        filters: defaultFilterValues,
                        ordering: GiftOrdering.None,
                        lowToHigh: !1,
                        query: null
                    }
                };
                return saveToStorage(FILTERS_STORAGE_KEY, {
                    ...as,
                    filters: defaultFilterValues,
                    ordering: GiftOrdering.None,
                    lowToHigh: !1,
                    query: null
                }),
                Cs
            }
            )
        }
        ,
        resetCollections: () => {
            xt(cs => {
                const Cs = {
                    ...cs.filters.filters,
                    collectionNames: []
                }
                  , Ls = {
                    filters: {
                        ...cs.filters,
                        filters: Cs
                    }
                };
                return saveToStorage(FILTERS_STORAGE_KEY, {
                    ...as,
                    filters: Cs
                }),
                Ls
            }
            )
        }
        ,
        resetModels: () => {
            xt(cs => {
                const Cs = {
                    ...cs.filters.filters,
                    modelNames: []
                }
                  , Ls = {
                    filters: {
                        ...cs.filters,
                        filters: Cs
                    }
                };
                return saveToStorage(FILTERS_STORAGE_KEY, {
                    ...as,
                    filters: Cs
                }),
                Ls
            }
            )
        }
        ,
        resetBackdrops: () => {
            xt(cs => {
                const Cs = {
                    ...cs.filters.filters,
                    backdropNames: []
                }
                  , Ls = {
                    filters: {
                        ...cs.filters,
                        filters: Cs
                    }
                };
                return saveToStorage(FILTERS_STORAGE_KEY, {
                    ...as,
                    filters: Cs
                }),
                Ls
            }
            )
        }
        ,
        resetSymbols: () => {
            xt(cs => {
                const Cs = {
                    ...cs.filters.filters,
                    symbolNames: []
                }
                  , Ls = {
                    filters: {
                        ...cs.filters,
                        filters: Cs
                    }
                };
                return saveToStorage(FILTERS_STORAGE_KEY, {
                    ...as,
                    filters: Cs
                }),
                Ls
            }
            )
        }
        ,
        resetPrice: () => {
            xt(cs => {
                const Cs = {
                    ...cs.filters.filters,
                    minPrice: null,
                    maxPrice: null
                }
                  , Ls = {
                    filters: {
                        ...cs.filters,
                        filters: Cs
                    }
                };
                return saveToStorage(FILTERS_STORAGE_KEY, {
                    ...as,
                    filters: Cs
                }),
                Ls
            }
            )
        }
        ,
        setLowToHigh: cs => {
            xt(Cs => {
                const Ls = {
                    filters: {
                        ...Cs.filters,
                        lowToHigh: cs
                    }
                };
                return saveToStorage(FILTERS_STORAGE_KEY, {
                    ...as,
                    lowToHigh: cs
                }),
                Ls
            }
            )
        }
        ,
        setOrdering: cs => {
            xt(Cs => {
                const Ls = {
                    filters: {
                        ...Cs.filters,
                        ordering: cs
                    }
                };
                return saveToStorage(FILTERS_STORAGE_KEY, {
                    ...as,
                    ordering: cs
                }),
                Ls
            }
            )
        }
        ,
        setPromotedFirst: cs => {
            xt(Cs => {
                const Ls = {
                    filters: {
                        ...Cs.filters,
                        promotedFirst: cs
                    }
                };
                return saveToStorage(FILTERS_STORAGE_KEY, {
                    ...as,
                    promotedFirst: cs
                }),
                Ls
            }
            )
        }
        ,
        setQuery: cs => {
            xt(Cs => {
                const Ls = {
                    filters: {
                        ...Cs.filters,
                        query: cs
                    }
                };
                return saveToStorage(FILTERS_STORAGE_KEY, {
                    ...as,
                    query: cs
                }),
                Ls
            }
            )
        }
        ,
        setFeedOrdering: cs => {
            xt(Cs => {
                const Ls = {
                    filters: {
                        ...Cs.filters,
                        feedOrdering: cs
                    }
                };
                return saveToStorage(FILTERS_STORAGE_KEY, {
                    ...as,
                    feedOrdering: cs
                }),
                Ls
            }
            )
        }
        ,
        setFeedLowToHigh: cs => {
            xt(Cs => {
                const Ls = {
                    filters: {
                        ...Cs.filters,
                        feedLowToHigh: cs
                    }
                };
                return saveToStorage(FILTERS_STORAGE_KEY, {
                    ...as,
                    feedLowToHigh: cs
                }),
                Ls
            }
            )
        }
    }
}
  , DEFAULT_HISTORY_PAGE_SIZE = 20
  , historySlice = createSlice( (xt, Cn) => ({
    items: [],
    isLoading: !1,
    hasError: !1,
    hasReachedEnd: !1,
    lastDate: new Date,
    pendingWithdrawals: [],
    processedItems: [],
    getPendingWithdrawals: () => Cn().history.items.filter(as => as.type === "withdraw" && as.status === "Pending"),
    getProcessedItems: () => Cn().history.items.filter(as => !(as.type === "withdraw" && as.status === "Pending") && !(as.type === "giveaway_sell_ticket" && !as.amount)),
    fetchHistory: async (as=!1) => {
        const cs = Cn().history;
        if (!(cs.isLoading || cs.hasError)) {
            xt(Cs => ({
                history: {
                    ...Cs.history,
                    isLoading: !0,
                    hasError: !1,
                    items: as ? [] : Cs.history.items,
                    hasReachedEnd: as ? !1 : Cs.history.hasReachedEnd,
                    lastDate: as ? new Date : Cs.history.lastDate
                }
            }));
            try {
                const Cs = await fetch(getApiUrl(`/api/v1/history?from=${Cn().history.lastDate.toISOString()}&limit=${DEFAULT_HISTORY_PAGE_SIZE}`), {
                    method: "GET"
                });
                if (!Cs.ok)
                    throw new Error("Failed to fetch history");
                const Ls = await Cs.json();
                xt(Xs => ({
                    history: {
                        ...Xs.history,
                        items: [...Xs.history.items, ...Ls],
                        isLoading: !1,
                        hasReachedEnd: Ls.length < DEFAULT_HISTORY_PAGE_SIZE,
                        lastDate: new Date(Ls[Ls.length - 1].date || Xs.history.lastDate)
                    }
                }));
                const Vs = Cn().history.getPendingWithdrawals()
                  , Ws = Cn().history.getProcessedItems();
                xt(Xs => ({
                    history: {
                        ...Xs.history,
                        pendingWithdrawals: Vs,
                        processedItems: Ws
                    }
                }))
            } catch (Cs) {
                console.error("Error fetching wallet history:", Cs),
                xt(Ls => ({
                    history: {
                        ...Ls.history,
                        isLoading: !1,
                        hasError: !0,
                        hasReachedEnd: !0
                    }
                }))
            }
        }
    }
}))
  , giveawaysSlice = (xt, Cn) => ({
    selectedGiveaway: null,
    externalGiveawayId: null,
    activeTab: "Paid",
    setActiveTab: as => {
        xt(cs => ({
            giveaways: {
                ...cs.giveaways,
                activeTab: as
            }
        }))
    }
    ,
    setSelectedGiveaway: as => {
        xt(cs => ({
            giveaways: {
                ...cs.giveaways,
                selectedGiveaway: as
            }
        }))
    }
    ,
    openGiveaway: async as => {
        Cn().navigation.setShouldUpdatePath(!0),
        Cn().navigation.setPath("/giveaways"),
        xt(cs => ({
            giveaways: {
                ...cs.giveaways,
                externalGiveawayId: as
            }
        })),
        Cn().modal.addModal(ModalNames.GA_PARTISIPATION)
    }
})
  , DEFAULT_PROMOTIONS_PAGE_SIZE = 20
  , INITIAL_PREFETCH_SIZE = 10
  , fetchPromotions = async (xt, Cn) => {
    try {
        const as = xt * DEFAULT_PROMOTIONS_PAGE_SIZE;
        return await (await fetch(getApiUrl("/api/v1/gifts/promotions"), {
            method: "POST",
            body: JSON.stringify({
                count: DEFAULT_PROMOTIONS_PAGE_SIZE,
                offset: as,
                ...Cn,
                promotedFirst: !0
            }),
            headers: {
                "Content-Type": "application/json"
            }
        })).json()
    } catch (as) {
        return console.error("error while fetching promotions", as),
        []
    }
}
  , prefetchInitialPromotions = async () => {
    try {
        return await (await fetch(getApiUrl("/api/v1/gifts/promotions"), {
            method: "POST",
            body: JSON.stringify({
                count: INITIAL_PREFETCH_SIZE,
                offset: 0,
                collectionNames: [],
                modelNames: [],
                backdropNames: [],
                symbolNames: [],
                minPrice: null,
                maxPrice: null,
                mintable: null,
                number: null,
                ordering: "None",
                lowToHigh: !1,
                query: null
            }),
            headers: {
                "Content-Type": "application/json"
            }
        })).json()
    } catch (xt) {
        return console.error("Error while prefetching promotions", xt),
        []
    }
}
  , promoteGift = async xt => await fetch(getApiUrl(`/api/v1/gifts/promote/${xt}`), {
    method: "Post",
    headers: {
        "Content-Type": "application/json"
    }
});
var QueryKeys = (xt => (xt.gifts = "gifts",
xt.myGifts = "my-gifts",
xt.collections = "collections",
xt.models = "models",
xt.backdrops = "backdrops",
xt.symbols = "symbols",
xt.promotions = "promotions",
xt.referralsCount = "referralsCount",
xt.referralsRevenue = "referralsRevenue",
xt.history = "history",
xt.giveaways = "giveaways",
xt.giveawayGetValidationStatus = "giveaway-get-validation-status",
xt.giveawayInfo = "giveaway-info",
xt.giftsStats = "gifts-stats",
xt.giveawayNotifications = "giveaway-notifications",
xt.feed = "feed",
xt))(QueryKeys || {})
  , Subscribable = class {
    constructor() {
        this.listeners = new Set,
        this.subscribe = this.subscribe.bind(this)
    }
    subscribe(xt) {
        return this.listeners.add(xt),
        this.onSubscribe(),
        () => {
            this.listeners.delete(xt),
            this.onUnsubscribe()
        }
    }
    hasListeners() {
        return this.listeners.size > 0
    }
    onSubscribe() {}
    onUnsubscribe() {}
}
  , isServer = typeof window > "u" || "Deno"in globalThis;
function noop$2() {}
function functionalUpdate(xt, Cn) {
    return typeof xt == "function" ? xt(Cn) : xt
}
function isValidTimeout(xt) {
    return typeof xt == "number" && xt >= 0 && xt !== 1 / 0
}
function timeUntilStale(xt, Cn) {
    return Math.max(xt + (Cn || 0) - Date.now(), 0)
}
function resolveStaleTime(xt, Cn) {
    return typeof xt == "function" ? xt(Cn) : xt
}
function resolveEnabled(xt, Cn) {
    return typeof xt == "function" ? xt(Cn) : xt
}
function matchQuery(xt, Cn) {
    const {type: as="all", exact: cs, fetchStatus: Cs, predicate: Ls, queryKey: Vs, stale: Ws} = xt;
    if (Vs) {
        if (cs) {
            if (Cn.queryHash !== hashQueryKeyByOptions(Vs, Cn.options))
                return !1
        } else if (!partialMatchKey(Cn.queryKey, Vs))
            return !1
    }
    if (as !== "all") {
        const Xs = Cn.isActive();
        if (as === "active" && !Xs || as === "inactive" && Xs)
            return !1
    }
    return !(typeof Ws == "boolean" && Cn.isStale() !== Ws || Cs && Cs !== Cn.state.fetchStatus || Ls && !Ls(Cn))
}
function matchMutation(xt, Cn) {
    const {exact: as, status: cs, predicate: Cs, mutationKey: Ls} = xt;
    if (Ls) {
        if (!Cn.options.mutationKey)
            return !1;
        if (as) {
            if (hashKey(Cn.options.mutationKey) !== hashKey(Ls))
                return !1
        } else if (!partialMatchKey(Cn.options.mutationKey, Ls))
            return !1
    }
    return !(cs && Cn.state.status !== cs || Cs && !Cs(Cn))
}
function hashQueryKeyByOptions(xt, Cn) {
    return ((Cn == null ? void 0 : Cn.queryKeyHashFn) || hashKey)(xt)
}
function hashKey(xt) {
    return JSON.stringify(xt, (Cn, as) => isPlainObject$1(as) ? Object.keys(as).sort().reduce( (cs, Cs) => (cs[Cs] = as[Cs],
    cs), {}) : as)
}
function partialMatchKey(xt, Cn) {
    return xt === Cn ? !0 : typeof xt != typeof Cn ? !1 : xt && Cn && typeof xt == "object" && typeof Cn == "object" ? Object.keys(Cn).every(as => partialMatchKey(xt[as], Cn[as])) : !1
}
function replaceEqualDeep(xt, Cn) {
    if (xt === Cn)
        return xt;
    const as = isPlainArray(xt) && isPlainArray(Cn);
    if (as || isPlainObject$1(xt) && isPlainObject$1(Cn)) {
        const cs = as ? xt : Object.keys(xt)
          , Cs = cs.length
          , Ls = as ? Cn : Object.keys(Cn)
          , Vs = Ls.length
          , Ws = as ? [] : {};
        let Xs = 0;
        for (let ga = 0; ga < Vs; ga++) {
            const ba = as ? ga : Ls[ga];
            (!as && cs.includes(ba) || as) && xt[ba] === void 0 && Cn[ba] === void 0 ? (Ws[ba] = void 0,
            Xs++) : (Ws[ba] = replaceEqualDeep(xt[ba], Cn[ba]),
            Ws[ba] === xt[ba] && xt[ba] !== void 0 && Xs++)
        }
        return Cs === Vs && Xs === Cs ? xt : Ws
    }
    return Cn
}
function shallowEqualObjects(xt, Cn) {
    if (!Cn || Object.keys(xt).length !== Object.keys(Cn).length)
        return !1;
    for (const as in xt)
        if (xt[as] !== Cn[as])
            return !1;
    return !0
}
function isPlainArray(xt) {
    return Array.isArray(xt) && xt.length === Object.keys(xt).length
}
function isPlainObject$1(xt) {
    if (!hasObjectPrototype(xt))
        return !1;
    const Cn = xt.constructor;
    if (Cn === void 0)
        return !0;
    const as = Cn.prototype;
    return !(!hasObjectPrototype(as) || !as.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(xt) !== Object.prototype)
}
function hasObjectPrototype(xt) {
    return Object.prototype.toString.call(xt) === "[object Object]"
}
function sleep(xt) {
    return new Promise(Cn => {
        setTimeout(Cn, xt)
    }
    )
}
function replaceData(xt, Cn, as) {
    return typeof as.structuralSharing == "function" ? as.structuralSharing(xt, Cn) : as.structuralSharing !== !1 ? replaceEqualDeep(xt, Cn) : Cn
}
function keepPreviousData(xt) {
    return xt
}
function addToEnd(xt, Cn, as=0) {
    const cs = [...xt, Cn];
    return as && cs.length > as ? cs.slice(1) : cs
}
function addToStart(xt, Cn, as=0) {
    const cs = [Cn, ...xt];
    return as && cs.length > as ? cs.slice(0, -1) : cs
}
var skipToken = Symbol();
function ensureQueryFn(xt, Cn) {
    return !xt.queryFn && (Cn != null && Cn.initialPromise) ? () => Cn.initialPromise : !xt.queryFn || xt.queryFn === skipToken ? () => Promise.reject(new Error(`Missing queryFn: '${xt.queryHash}'`)) : xt.queryFn
}
var Am, bm, Vm, O1, FocusManager = (O1 = class extends Subscribable {
    constructor() {
        super();
        ip(this, Am);
        ip(this, bm);
        ip(this, Vm);
        Zu(this, Vm, Cn => {
            if (!isServer && window.addEventListener) {
                const as = () => Cn();
                return window.addEventListener("visibilitychange", as, !1),
                () => {
                    window.removeEventListener("visibilitychange", as)
                }
            }
        }
        )
    }
    onSubscribe() {
        du(this, bm) || this.setEventListener(du(this, Vm))
    }
    onUnsubscribe() {
        var Cn;
        this.hasListeners() || ((Cn = du(this, bm)) == null || Cn.call(this),
        Zu(this, bm, void 0))
    }
    setEventListener(Cn) {
        var as;
        Zu(this, Vm, Cn),
        (as = du(this, bm)) == null || as.call(this),
        Zu(this, bm, Cn(cs => {
            typeof cs == "boolean" ? this.setFocused(cs) : this.onFocus()
        }
        ))
    }
    setFocused(Cn) {
        du(this, Am) !== Cn && (Zu(this, Am, Cn),
        this.onFocus())
    }
    onFocus() {
        const Cn = this.isFocused();
        this.listeners.forEach(as => {
            as(Cn)
        }
        )
    }
    isFocused() {
        var Cn;
        return typeof du(this, Am) == "boolean" ? du(this, Am) : ((Cn = globalThis.document) == null ? void 0 : Cn.visibilityState) !== "hidden"
    }
}
,
Am = new WeakMap,
bm = new WeakMap,
Vm = new WeakMap,
O1), focusManager = new FocusManager, Um, wm, Wm, D1, OnlineManager = (D1 = class extends Subscribable {
    constructor() {
        super();
        ip(this, Um, !0);
        ip(this, wm);
        ip(this, Wm);
        Zu(this, Wm, Cn => {
            if (!isServer && window.addEventListener) {
                const as = () => Cn(!0)
                  , cs = () => Cn(!1);
                return window.addEventListener("online", as, !1),
                window.addEventListener("offline", cs, !1),
                () => {
                    window.removeEventListener("online", as),
                    window.removeEventListener("offline", cs)
                }
            }
        }
        )
    }
    onSubscribe() {
        du(this, wm) || this.setEventListener(du(this, Wm))
    }
    onUnsubscribe() {
        var Cn;
        this.hasListeners() || ((Cn = du(this, wm)) == null || Cn.call(this),
        Zu(this, wm, void 0))
    }
    setEventListener(Cn) {
        var as;
        Zu(this, Wm, Cn),
        (as = du(this, wm)) == null || as.call(this),
        Zu(this, wm, Cn(this.setOnline.bind(this)))
    }
    setOnline(Cn) {
        du(this, Um) !== Cn && (Zu(this, Um, Cn),
        this.listeners.forEach(cs => {
            cs(Cn)
        }
        ))
    }
    isOnline() {
        return du(this, Um)
    }
}
,
Um = new WeakMap,
wm = new WeakMap,
Wm = new WeakMap,
D1), onlineManager = new OnlineManager;
function pendingThenable() {
    let xt, Cn;
    const as = new Promise( (Cs, Ls) => {
        xt = Cs,
        Cn = Ls
    }
    );
    as.status = "pending",
    as.catch( () => {}
    );
    function cs(Cs) {
        Object.assign(as, Cs),
        delete as.resolve,
        delete as.reject
    }
    return as.resolve = Cs => {
        cs({
            status: "fulfilled",
            value: Cs
        }),
        xt(Cs)
    }
    ,
    as.reject = Cs => {
        cs({
            status: "rejected",
            reason: Cs
        }),
        Cn(Cs)
    }
    ,
    as
}
function defaultRetryDelay(xt) {
    return Math.min(1e3 * 2 ** xt, 3e4)
}
function canFetch(xt) {
    return (xt ?? "online") === "online" ? onlineManager.isOnline() : !0
}
var CancelledError = class extends Error {
    constructor(xt) {
        super("CancelledError"),
        this.revert = xt == null ? void 0 : xt.revert,
        this.silent = xt == null ? void 0 : xt.silent
    }
}
;
function isCancelledError(xt) {
    return xt instanceof CancelledError
}
function createRetryer(xt) {
    let Cn = !1, as = 0, cs = !1, Cs;
    const Ls = pendingThenable()
      , Vs = El => {
        var Cl;
        cs || (xl(new CancelledError(El)),
        (Cl = xt.abort) == null || Cl.call(xt))
    }
      , Ws = () => {
        Cn = !0
    }
      , Xs = () => {
        Cn = !1
    }
      , ga = () => focusManager.isFocused() && (xt.networkMode === "always" || onlineManager.isOnline()) && xt.canRun()
      , ba = () => canFetch(xt.networkMode) && xt.canRun()
      , yl = El => {
        var Cl;
        cs || (cs = !0,
        (Cl = xt.onSuccess) == null || Cl.call(xt, El),
        Cs == null || Cs(),
        Ls.resolve(El))
    }
      , xl = El => {
        var Cl;
        cs || (cs = !0,
        (Cl = xt.onError) == null || Cl.call(xt, El),
        Cs == null || Cs(),
        Ls.reject(El))
    }
      , wl = () => new Promise(El => {
        var Cl;
        Cs = $l => {
            (cs || ga()) && El($l)
        }
        ,
        (Cl = xt.onPause) == null || Cl.call(xt)
    }
    ).then( () => {
        var El;
        Cs = void 0,
        cs || (El = xt.onContinue) == null || El.call(xt)
    }
    )
      , _l = () => {
        if (cs)
            return;
        let El;
        const Cl = as === 0 ? xt.initialPromise : void 0;
        try {
            El = Cl ?? xt.fn()
        } catch ($l) {
            El = Promise.reject($l)
        }
        Promise.resolve(El).then(yl).catch($l => {
            var Ml;
            if (cs)
                return;
            const Sl = xt.retry ?? (isServer ? 0 : 3)
              , Tl = xt.retryDelay ?? defaultRetryDelay
              , Rl = typeof Tl == "function" ? Tl(as, $l) : Tl
              , Il = Sl === !0 || typeof Sl == "number" && as < Sl || typeof Sl == "function" && Sl(as, $l);
            if (Cn || !Il) {
                xl($l);
                return
            }
            as++,
            (Ml = xt.onFail) == null || Ml.call(xt, as, $l),
            sleep(Rl).then( () => ga() ? void 0 : wl()).then( () => {
                Cn ? xl($l) : _l()
            }
            )
        }
        )
    }
    ;
    return {
        promise: Ls,
        cancel: Vs,
        continue: () => (Cs == null || Cs(),
        Ls),
        cancelRetry: Ws,
        continueRetry: Xs,
        canStart: ba,
        start: () => (ba() ? _l() : wl().then(_l),
        Ls)
    }
}
var defaultScheduler = xt => setTimeout(xt, 0);
function createNotifyManager() {
    let xt = []
      , Cn = 0
      , as = Ws => {
        Ws()
    }
      , cs = Ws => {
        Ws()
    }
      , Cs = defaultScheduler;
    const Ls = Ws => {
        Cn ? xt.push(Ws) : Cs( () => {
            as(Ws)
        }
        )
    }
      , Vs = () => {
        const Ws = xt;
        xt = [],
        Ws.length && Cs( () => {
            cs( () => {
                Ws.forEach(Xs => {
                    as(Xs)
                }
                )
            }
            )
        }
        )
    }
    ;
    return {
        batch: Ws => {
            let Xs;
            Cn++;
            try {
                Xs = Ws()
            } finally {
                Cn--,
                Cn || Vs()
            }
            return Xs
        }
        ,
        batchCalls: Ws => (...Xs) => {
            Ls( () => {
                Ws(...Xs)
            }
            )
        }
        ,
        schedule: Ls,
        setNotifyFunction: Ws => {
            as = Ws
        }
        ,
        setBatchNotifyFunction: Ws => {
            cs = Ws
        }
        ,
        setScheduler: Ws => {
            Cs = Ws
        }
    }
}
var notifyManager = createNotifyManager(), Mm, V1, Removable = (V1 = class {
    constructor() {
        ip(this, Mm)
    }
    destroy() {
        this.clearGcTimeout()
    }
    scheduleGc() {
        this.clearGcTimeout(),
        isValidTimeout(this.gcTime) && Zu(this, Mm, setTimeout( () => {
            this.optionalRemove()
        }
        , this.gcTime))
    }
    updateGcTime(xt) {
        this.gcTime = Math.max(this.gcTime || 0, xt ?? (isServer ? 1 / 0 : 5 * 60 * 1e3))
    }
    clearGcTimeout() {
        du(this, Mm) && (clearTimeout(du(this, Mm)),
        Zu(this, Mm, void 0))
    }
}
,
Mm = new WeakMap,
V1), Hm, Gm, im, Lm, Xp, s1, jm, am, fm, U1, Query = (U1 = class extends Removable {
    constructor(Cn) {
        super();
        ip(this, am);
        ip(this, Hm);
        ip(this, Gm);
        ip(this, im);
        ip(this, Lm);
        ip(this, Xp);
        ip(this, s1);
        ip(this, jm);
        Zu(this, jm, !1),
        Zu(this, s1, Cn.defaultOptions),
        this.setOptions(Cn.options),
        this.observers = [],
        Zu(this, Lm, Cn.client),
        Zu(this, im, du(this, Lm).getQueryCache()),
        this.queryKey = Cn.queryKey,
        this.queryHash = Cn.queryHash,
        Zu(this, Hm, getDefaultState$1(this.options)),
        this.state = Cn.state ?? du(this, Hm),
        this.scheduleGc()
    }
    get meta() {
        return this.options.meta
    }
    get promise() {
        var Cn;
        return (Cn = du(this, Xp)) == null ? void 0 : Cn.promise
    }
    setOptions(Cn) {
        this.options = {
            ...du(this, s1),
            ...Cn
        },
        this.updateGcTime(this.options.gcTime)
    }
    optionalRemove() {
        !this.observers.length && this.state.fetchStatus === "idle" && du(this, im).remove(this)
    }
    setData(Cn, as) {
        const cs = replaceData(this.state.data, Cn, this.options);
        return up(this, am, fm).call(this, {
            data: cs,
            type: "success",
            dataUpdatedAt: as == null ? void 0 : as.updatedAt,
            manual: as == null ? void 0 : as.manual
        }),
        cs
    }
    setState(Cn, as) {
        up(this, am, fm).call(this, {
            type: "setState",
            state: Cn,
            setStateOptions: as
        })
    }
    cancel(Cn) {
        var cs, Cs;
        const as = (cs = du(this, Xp)) == null ? void 0 : cs.promise;
        return (Cs = du(this, Xp)) == null || Cs.cancel(Cn),
        as ? as.then(noop$2).catch(noop$2) : Promise.resolve()
    }
    destroy() {
        super.destroy(),
        this.cancel({
            silent: !0
        })
    }
    reset() {
        this.destroy(),
        this.setState(du(this, Hm))
    }
    isActive() {
        return this.observers.some(Cn => resolveEnabled(Cn.options.enabled, this) !== !1)
    }
    isDisabled() {
        return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0
    }
    isStale() {
        return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some(Cn => Cn.getCurrentResult().isStale) : this.state.data === void 0
    }
    isStaleByTime(Cn=0) {
        return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, Cn)
    }
    onFocus() {
        var as;
        const Cn = this.observers.find(cs => cs.shouldFetchOnWindowFocus());
        Cn == null || Cn.refetch({
            cancelRefetch: !1
        }),
        (as = du(this, Xp)) == null || as.continue()
    }
    onOnline() {
        var as;
        const Cn = this.observers.find(cs => cs.shouldFetchOnReconnect());
        Cn == null || Cn.refetch({
            cancelRefetch: !1
        }),
        (as = du(this, Xp)) == null || as.continue()
    }
    addObserver(Cn) {
        this.observers.includes(Cn) || (this.observers.push(Cn),
        this.clearGcTimeout(),
        du(this, im).notify({
            type: "observerAdded",
            query: this,
            observer: Cn
        }))
    }
    removeObserver(Cn) {
        this.observers.includes(Cn) && (this.observers = this.observers.filter(as => as !== Cn),
        this.observers.length || (du(this, Xp) && (du(this, jm) ? du(this, Xp).cancel({
            revert: !0
        }) : du(this, Xp).cancelRetry()),
        this.scheduleGc()),
        du(this, im).notify({
            type: "observerRemoved",
            query: this,
            observer: Cn
        }))
    }
    getObserversCount() {
        return this.observers.length
    }
    invalidate() {
        this.state.isInvalidated || up(this, am, fm).call(this, {
            type: "invalidate"
        })
    }
    fetch(Cn, as) {
        var Xs, ga, ba;
        if (this.state.fetchStatus !== "idle") {
            if (this.state.data !== void 0 && (as != null && as.cancelRefetch))
                this.cancel({
                    silent: !0
                });
            else if (du(this, Xp))
                return du(this, Xp).continueRetry(),
                du(this, Xp).promise
        }
        if (Cn && this.setOptions(Cn),
        !this.options.queryFn) {
            const yl = this.observers.find(xl => xl.options.queryFn);
            yl && this.setOptions(yl.options)
        }
        const cs = new AbortController
          , Cs = yl => {
            Object.defineProperty(yl, "signal", {
                enumerable: !0,
                get: () => (Zu(this, jm, !0),
                cs.signal)
            })
        }
          , Ls = () => {
            const yl = ensureQueryFn(this.options, as)
              , xl = {
                client: du(this, Lm),
                queryKey: this.queryKey,
                meta: this.meta
            };
            return Cs(xl),
            Zu(this, jm, !1),
            this.options.persister ? this.options.persister(yl, xl, this) : yl(xl)
        }
          , Vs = {
            fetchOptions: as,
            options: this.options,
            queryKey: this.queryKey,
            client: du(this, Lm),
            state: this.state,
            fetchFn: Ls
        };
        Cs(Vs),
        (Xs = this.options.behavior) == null || Xs.onFetch(Vs, this),
        Zu(this, Gm, this.state),
        (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((ga = Vs.fetchOptions) == null ? void 0 : ga.meta)) && up(this, am, fm).call(this, {
            type: "fetch",
            meta: (ba = Vs.fetchOptions) == null ? void 0 : ba.meta
        });
        const Ws = yl => {
            var xl, wl, _l, El;
            isCancelledError(yl) && yl.silent || up(this, am, fm).call(this, {
                type: "error",
                error: yl
            }),
            isCancelledError(yl) || ((wl = (xl = du(this, im).config).onError) == null || wl.call(xl, yl, this),
            (El = (_l = du(this, im).config).onSettled) == null || El.call(_l, this.state.data, yl, this)),
            this.scheduleGc()
        }
        ;
        return Zu(this, Xp, createRetryer({
            initialPromise: as == null ? void 0 : as.initialPromise,
            fn: Vs.fetchFn,
            abort: cs.abort.bind(cs),
            onSuccess: yl => {
                var xl, wl, _l, El;
                if (yl === void 0) {
                    Ws(new Error(`${this.queryHash} data is undefined`));
                    return
                }
                try {
                    this.setData(yl)
                } catch (Cl) {
                    Ws(Cl);
                    return
                }
                (wl = (xl = du(this, im).config).onSuccess) == null || wl.call(xl, yl, this),
                (El = (_l = du(this, im).config).onSettled) == null || El.call(_l, yl, this.state.error, this),
                this.scheduleGc()
            }
            ,
            onError: Ws,
            onFail: (yl, xl) => {
                up(this, am, fm).call(this, {
                    type: "failed",
                    failureCount: yl,
                    error: xl
                })
            }
            ,
            onPause: () => {
                up(this, am, fm).call(this, {
                    type: "pause"
                })
            }
            ,
            onContinue: () => {
                up(this, am, fm).call(this, {
                    type: "continue"
                })
            }
            ,
            retry: Vs.options.retry,
            retryDelay: Vs.options.retryDelay,
            networkMode: Vs.options.networkMode,
            canRun: () => !0
        })),
        du(this, Xp).start()
    }
}
,
Hm = new WeakMap,
Gm = new WeakMap,
im = new WeakMap,
Lm = new WeakMap,
Xp = new WeakMap,
s1 = new WeakMap,
jm = new WeakMap,
am = new WeakSet,
fm = function(Cn) {
    const as = cs => {
        switch (Cn.type) {
        case "failed":
            return {
                ...cs,
                fetchFailureCount: Cn.failureCount,
                fetchFailureReason: Cn.error
            };
        case "pause":
            return {
                ...cs,
                fetchStatus: "paused"
            };
        case "continue":
            return {
                ...cs,
                fetchStatus: "fetching"
            };
        case "fetch":
            return {
                ...cs,
                ...fetchState(cs.data, this.options),
                fetchMeta: Cn.meta ?? null
            };
        case "success":
            return {
                ...cs,
                data: Cn.data,
                dataUpdateCount: cs.dataUpdateCount + 1,
                dataUpdatedAt: Cn.dataUpdatedAt ?? Date.now(),
                error: null,
                isInvalidated: !1,
                status: "success",
                ...!Cn.manual && {
                    fetchStatus: "idle",
                    fetchFailureCount: 0,
                    fetchFailureReason: null
                }
            };
        case "error":
            const Cs = Cn.error;
            return isCancelledError(Cs) && Cs.revert && du(this, Gm) ? {
                ...du(this, Gm),
                fetchStatus: "idle"
            } : {
                ...cs,
                error: Cs,
                errorUpdateCount: cs.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: cs.fetchFailureCount + 1,
                fetchFailureReason: Cs,
                fetchStatus: "idle",
                status: "error"
            };
        case "invalidate":
            return {
                ...cs,
                isInvalidated: !0
            };
        case "setState":
            return {
                ...cs,
                ...Cn.state
            }
        }
    }
    ;
    this.state = as(this.state),
    notifyManager.batch( () => {
        this.observers.forEach(cs => {
            cs.onQueryUpdate()
        }
        ),
        du(this, im).notify({
            query: this,
            type: "updated",
            action: Cn
        })
    }
    )
}
,
U1);
function fetchState(xt, Cn) {
    return {
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchStatus: canFetch(Cn.networkMode) ? "fetching" : "paused",
        ...xt === void 0 && {
            error: null,
            status: "pending"
        }
    }
}
function getDefaultState$1(xt) {
    const Cn = typeof xt.initialData == "function" ? xt.initialData() : xt.initialData
      , as = Cn !== void 0
      , cs = as ? typeof xt.initialDataUpdatedAt == "function" ? xt.initialDataUpdatedAt() : xt.initialDataUpdatedAt : 0;
    return {
        data: Cn,
        dataUpdateCount: 0,
        dataUpdatedAt: as ? cs ?? Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: !1,
        status: as ? "success" : "pending",
        fetchStatus: "idle"
    }
}
var cm, W1, QueryCache = (W1 = class extends Subscribable {
    constructor(Cn={}) {
        super();
        ip(this, cm);
        this.config = Cn,
        Zu(this, cm, new Map)
    }
    build(Cn, as, cs) {
        const Cs = as.queryKey
          , Ls = as.queryHash ?? hashQueryKeyByOptions(Cs, as);
        let Vs = this.get(Ls);
        return Vs || (Vs = new Query({
            client: Cn,
            queryKey: Cs,
            queryHash: Ls,
            options: Cn.defaultQueryOptions(as),
            state: cs,
            defaultOptions: Cn.getQueryDefaults(Cs)
        }),
        this.add(Vs)),
        Vs
    }
    add(Cn) {
        du(this, cm).has(Cn.queryHash) || (du(this, cm).set(Cn.queryHash, Cn),
        this.notify({
            type: "added",
            query: Cn
        }))
    }
    remove(Cn) {
        const as = du(this, cm).get(Cn.queryHash);
        as && (Cn.destroy(),
        as === Cn && du(this, cm).delete(Cn.queryHash),
        this.notify({
            type: "removed",
            query: Cn
        }))
    }
    clear() {
        notifyManager.batch( () => {
            this.getAll().forEach(Cn => {
                this.remove(Cn)
            }
            )
        }
        )
    }
    get(Cn) {
        return du(this, cm).get(Cn)
    }
    getAll() {
        return [...du(this, cm).values()]
    }
    find(Cn) {
        const as = {
            exact: !0,
            ...Cn
        };
        return this.getAll().find(cs => matchQuery(as, cs))
    }
    findAll(Cn={}) {
        const as = this.getAll();
        return Object.keys(Cn).length > 0 ? as.filter(cs => matchQuery(Cn, cs)) : as
    }
    notify(Cn) {
        notifyManager.batch( () => {
            this.listeners.forEach(as => {
                as(Cn)
            }
            )
        }
        )
    }
    onFocus() {
        notifyManager.batch( () => {
            this.getAll().forEach(Cn => {
                Cn.onFocus()
            }
            )
        }
        )
    }
    onOnline() {
        notifyManager.batch( () => {
            this.getAll().forEach(Cn => {
                Cn.onOnline()
            }
            )
        }
        )
    }
}
,
cm = new WeakMap,
W1), um, em, Nm, dm, vm, G1, Mutation = (G1 = class extends Removable {
    constructor(Cn) {
        super();
        ip(this, dm);
        ip(this, um);
        ip(this, em);
        ip(this, Nm);
        this.mutationId = Cn.mutationId,
        Zu(this, em, Cn.mutationCache),
        Zu(this, um, []),
        this.state = Cn.state || getDefaultState(),
        this.setOptions(Cn.options),
        this.scheduleGc()
    }
    setOptions(Cn) {
        this.options = Cn,
        this.updateGcTime(this.options.gcTime)
    }
    get meta() {
        return this.options.meta
    }
    addObserver(Cn) {
        du(this, um).includes(Cn) || (du(this, um).push(Cn),
        this.clearGcTimeout(),
        du(this, em).notify({
            type: "observerAdded",
            mutation: this,
            observer: Cn
        }))
    }
    removeObserver(Cn) {
        Zu(this, um, du(this, um).filter(as => as !== Cn)),
        this.scheduleGc(),
        du(this, em).notify({
            type: "observerRemoved",
            mutation: this,
            observer: Cn
        })
    }
    optionalRemove() {
        du(this, um).length || (this.state.status === "pending" ? this.scheduleGc() : du(this, em).remove(this))
    }
    continue() {
        var Cn;
        return ((Cn = du(this, Nm)) == null ? void 0 : Cn.continue()) ?? this.execute(this.state.variables)
    }
    async execute(Cn) {
        var Ls, Vs, Ws, Xs, ga, ba, yl, xl, wl, _l, El, Cl, $l, Sl, Tl, Rl, Il, Ml, Nl, Ll;
        const as = () => {
            up(this, dm, vm).call(this, {
                type: "continue"
            })
        }
        ;
        Zu(this, Nm, createRetryer({
            fn: () => this.options.mutationFn ? this.options.mutationFn(Cn) : Promise.reject(new Error("No mutationFn found")),
            onFail: (Fl, Ul) => {
                up(this, dm, vm).call(this, {
                    type: "failed",
                    failureCount: Fl,
                    error: Ul
                })
            }
            ,
            onPause: () => {
                up(this, dm, vm).call(this, {
                    type: "pause"
                })
            }
            ,
            onContinue: as,
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: () => du(this, em).canRun(this)
        }));
        const cs = this.state.status === "pending"
          , Cs = !du(this, Nm).canStart();
        try {
            if (cs)
                as();
            else {
                up(this, dm, vm).call(this, {
                    type: "pending",
                    variables: Cn,
                    isPaused: Cs
                }),
                await ((Vs = (Ls = du(this, em).config).onMutate) == null ? void 0 : Vs.call(Ls, Cn, this));
                const Ul = await ((Xs = (Ws = this.options).onMutate) == null ? void 0 : Xs.call(Ws, Cn));
                Ul !== this.state.context && up(this, dm, vm).call(this, {
                    type: "pending",
                    context: Ul,
                    variables: Cn,
                    isPaused: Cs
                })
            }
            const Fl = await du(this, Nm).start();
            return await ((ba = (ga = du(this, em).config).onSuccess) == null ? void 0 : ba.call(ga, Fl, Cn, this.state.context, this)),
            await ((xl = (yl = this.options).onSuccess) == null ? void 0 : xl.call(yl, Fl, Cn, this.state.context)),
            await ((_l = (wl = du(this, em).config).onSettled) == null ? void 0 : _l.call(wl, Fl, null, this.state.variables, this.state.context, this)),
            await ((Cl = (El = this.options).onSettled) == null ? void 0 : Cl.call(El, Fl, null, Cn, this.state.context)),
            up(this, dm, vm).call(this, {
                type: "success",
                data: Fl
            }),
            Fl
        } catch (Fl) {
            try {
                throw await ((Sl = ($l = du(this, em).config).onError) == null ? void 0 : Sl.call($l, Fl, Cn, this.state.context, this)),
                await ((Rl = (Tl = this.options).onError) == null ? void 0 : Rl.call(Tl, Fl, Cn, this.state.context)),
                await ((Ml = (Il = du(this, em).config).onSettled) == null ? void 0 : Ml.call(Il, void 0, Fl, this.state.variables, this.state.context, this)),
                await ((Ll = (Nl = this.options).onSettled) == null ? void 0 : Ll.call(Nl, void 0, Fl, Cn, this.state.context)),
                Fl
            } finally {
                up(this, dm, vm).call(this, {
                    type: "error",
                    error: Fl
                })
            }
        } finally {
            du(this, em).runNext(this)
        }
    }
}
,
um = new WeakMap,
em = new WeakMap,
Nm = new WeakMap,
dm = new WeakSet,
vm = function(Cn) {
    const as = cs => {
        switch (Cn.type) {
        case "failed":
            return {
                ...cs,
                failureCount: Cn.failureCount,
                failureReason: Cn.error
            };
        case "pause":
            return {
                ...cs,
                isPaused: !0
            };
        case "continue":
            return {
                ...cs,
                isPaused: !1
            };
        case "pending":
            return {
                ...cs,
                context: Cn.context,
                data: void 0,
                failureCount: 0,
                failureReason: null,
                error: null,
                isPaused: Cn.isPaused,
                status: "pending",
                variables: Cn.variables,
                submittedAt: Date.now()
            };
        case "success":
            return {
                ...cs,
                data: Cn.data,
                failureCount: 0,
                failureReason: null,
                error: null,
                status: "success",
                isPaused: !1
            };
        case "error":
            return {
                ...cs,
                data: void 0,
                error: Cn.error,
                failureCount: cs.failureCount + 1,
                failureReason: Cn.error,
                isPaused: !1,
                status: "error"
            }
        }
    }
    ;
    this.state = as(this.state),
    notifyManager.batch( () => {
        du(this, um).forEach(cs => {
            cs.onMutationUpdate(Cn)
        }
        ),
        du(this, em).notify({
            mutation: this,
            type: "updated",
            action: Cn
        })
    }
    )
}
,
G1);
function getDefaultState() {
    return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: !1,
        status: "idle",
        variables: void 0,
        submittedAt: 0
    }
}
var hm, lm, o1, z1, MutationCache = (z1 = class extends Subscribable {
    constructor(Cn={}) {
        super();
        ip(this, hm);
        ip(this, lm);
        ip(this, o1);
        this.config = Cn,
        Zu(this, hm, new Set),
        Zu(this, lm, new Map),
        Zu(this, o1, 0)
    }
    build(Cn, as, cs) {
        const Cs = new Mutation({
            mutationCache: this,
            mutationId: ++f1(this, o1)._,
            options: Cn.defaultMutationOptions(as),
            state: cs
        });
        return this.add(Cs),
        Cs
    }
    add(Cn) {
        du(this, hm).add(Cn);
        const as = scopeFor(Cn);
        if (typeof as == "string") {
            const cs = du(this, lm).get(as);
            cs ? cs.push(Cn) : du(this, lm).set(as, [Cn])
        }
        this.notify({
            type: "added",
            mutation: Cn
        })
    }
    remove(Cn) {
        if (du(this, hm).delete(Cn)) {
            const as = scopeFor(Cn);
            if (typeof as == "string") {
                const cs = du(this, lm).get(as);
                if (cs)
                    if (cs.length > 1) {
                        const Cs = cs.indexOf(Cn);
                        Cs !== -1 && cs.splice(Cs, 1)
                    } else
                        cs[0] === Cn && du(this, lm).delete(as)
            }
        }
        this.notify({
            type: "removed",
            mutation: Cn
        })
    }
    canRun(Cn) {
        const as = scopeFor(Cn);
        if (typeof as == "string") {
            const cs = du(this, lm).get(as)
              , Cs = cs == null ? void 0 : cs.find(Ls => Ls.state.status === "pending");
            return !Cs || Cs === Cn
        } else
            return !0
    }
    runNext(Cn) {
        var cs;
        const as = scopeFor(Cn);
        if (typeof as == "string") {
            const Cs = (cs = du(this, lm).get(as)) == null ? void 0 : cs.find(Ls => Ls !== Cn && Ls.state.isPaused);
            return (Cs == null ? void 0 : Cs.continue()) ?? Promise.resolve()
        } else
            return Promise.resolve()
    }
    clear() {
        notifyManager.batch( () => {
            du(this, hm).forEach(Cn => {
                this.notify({
                    type: "removed",
                    mutation: Cn
                })
            }
            ),
            du(this, hm).clear(),
            du(this, lm).clear()
        }
        )
    }
    getAll() {
        return Array.from(du(this, hm))
    }
    find(Cn) {
        const as = {
            exact: !0,
            ...Cn
        };
        return this.getAll().find(cs => matchMutation(as, cs))
    }
    findAll(Cn={}) {
        return this.getAll().filter(as => matchMutation(Cn, as))
    }
    notify(Cn) {
        notifyManager.batch( () => {
            this.listeners.forEach(as => {
                as(Cn)
            }
            )
        }
        )
    }
    resumePausedMutations() {
        const Cn = this.getAll().filter(as => as.state.isPaused);
        return notifyManager.batch( () => Promise.all(Cn.map(as => as.continue().catch(noop$2))))
    }
}
,
hm = new WeakMap,
lm = new WeakMap,
o1 = new WeakMap,
z1);
function scopeFor(xt) {
    var Cn;
    return (Cn = xt.options.scope) == null ? void 0 : Cn.id
}
function infiniteQueryBehavior(xt) {
    return {
        onFetch: (Cn, as) => {
            var ba, yl, xl, wl, _l;
            const cs = Cn.options
              , Cs = (xl = (yl = (ba = Cn.fetchOptions) == null ? void 0 : ba.meta) == null ? void 0 : yl.fetchMore) == null ? void 0 : xl.direction
              , Ls = ((wl = Cn.state.data) == null ? void 0 : wl.pages) || []
              , Vs = ((_l = Cn.state.data) == null ? void 0 : _l.pageParams) || [];
            let Ws = {
                pages: [],
                pageParams: []
            }
              , Xs = 0;
            const ga = async () => {
                let El = !1;
                const Cl = Tl => {
                    Object.defineProperty(Tl, "signal", {
                        enumerable: !0,
                        get: () => (Cn.signal.aborted ? El = !0 : Cn.signal.addEventListener("abort", () => {
                            El = !0
                        }
                        ),
                        Cn.signal)
                    })
                }
                  , $l = ensureQueryFn(Cn.options, Cn.fetchOptions)
                  , Sl = async (Tl, Rl, Il) => {
                    if (El)
                        return Promise.reject();
                    if (Rl == null && Tl.pages.length)
                        return Promise.resolve(Tl);
                    const Ml = {
                        client: Cn.client,
                        queryKey: Cn.queryKey,
                        pageParam: Rl,
                        direction: Il ? "backward" : "forward",
                        meta: Cn.options.meta
                    };
                    Cl(Ml);
                    const Nl = await $l(Ml)
                      , {maxPages: Ll} = Cn.options
                      , Fl = Il ? addToStart : addToEnd;
                    return {
                        pages: Fl(Tl.pages, Nl, Ll),
                        pageParams: Fl(Tl.pageParams, Rl, Ll)
                    }
                }
                ;
                if (Cs && Ls.length) {
                    const Tl = Cs === "backward"
                      , Rl = Tl ? getPreviousPageParam : getNextPageParam
                      , Il = {
                        pages: Ls,
                        pageParams: Vs
                    }
                      , Ml = Rl(cs, Il);
                    Ws = await Sl(Il, Ml, Tl)
                } else {
                    const Tl = xt ?? Ls.length;
                    do {
                        const Rl = Xs === 0 ? Vs[0] ?? cs.initialPageParam : getNextPageParam(cs, Ws);
                        if (Xs > 0 && Rl == null)
                            break;
                        Ws = await Sl(Ws, Rl),
                        Xs++
                    } while (Xs < Tl)
                }
                return Ws
            }
            ;
            Cn.options.persister ? Cn.fetchFn = () => {
                var El, Cl;
                return (Cl = (El = Cn.options).persister) == null ? void 0 : Cl.call(El, ga, {
                    client: Cn.client,
                    queryKey: Cn.queryKey,
                    meta: Cn.options.meta,
                    signal: Cn.signal
                }, as)
            }
            : Cn.fetchFn = ga
        }
    }
}
function getNextPageParam(xt, {pages: Cn, pageParams: as}) {
    const cs = Cn.length - 1;
    return Cn.length > 0 ? xt.getNextPageParam(Cn[cs], Cn, as[cs], as) : void 0
}
function getPreviousPageParam(xt, {pages: Cn, pageParams: as}) {
    var cs;
    return Cn.length > 0 ? (cs = xt.getPreviousPageParam) == null ? void 0 : cs.call(xt, Cn[0], Cn, as[0], as) : void 0
}
function hasNextPage(xt, Cn) {
    return Cn ? getNextPageParam(xt, Cn) != null : !1
}
function hasPreviousPage(xt, Cn) {
    return !Cn || !xt.getPreviousPageParam ? !1 : getPreviousPageParam(xt, Cn) != null
}
var Up, Em, _m, zm, Zm, Cm, Km, qm, Z1, QueryClient = (Z1 = class {
    constructor(xt={}) {
        ip(this, Up);
        ip(this, Em);
        ip(this, _m);
        ip(this, zm);
        ip(this, Zm);
        ip(this, Cm);
        ip(this, Km);
        ip(this, qm);
        Zu(this, Up, xt.queryCache || new QueryCache),
        Zu(this, Em, xt.mutationCache || new MutationCache),
        Zu(this, _m, xt.defaultOptions || {}),
        Zu(this, zm, new Map),
        Zu(this, Zm, new Map),
        Zu(this, Cm, 0)
    }
    mount() {
        f1(this, Cm)._++,
        du(this, Cm) === 1 && (Zu(this, Km, focusManager.subscribe(async xt => {
            xt && (await this.resumePausedMutations(),
            du(this, Up).onFocus())
        }
        )),
        Zu(this, qm, onlineManager.subscribe(async xt => {
            xt && (await this.resumePausedMutations(),
            du(this, Up).onOnline())
        }
        )))
    }
    unmount() {
        var xt, Cn;
        f1(this, Cm)._--,
        du(this, Cm) === 0 && ((xt = du(this, Km)) == null || xt.call(this),
        Zu(this, Km, void 0),
        (Cn = du(this, qm)) == null || Cn.call(this),
        Zu(this, qm, void 0))
    }
    isFetching(xt) {
        return du(this, Up).findAll({
            ...xt,
            fetchStatus: "fetching"
        }).length
    }
    isMutating(xt) {
        return du(this, Em).findAll({
            ...xt,
            status: "pending"
        }).length
    }
    getQueryData(xt) {
        var as;
        const Cn = this.defaultQueryOptions({
            queryKey: xt
        });
        return (as = du(this, Up).get(Cn.queryHash)) == null ? void 0 : as.state.data
    }
    ensureQueryData(xt) {
        const Cn = this.defaultQueryOptions(xt)
          , as = du(this, Up).build(this, Cn)
          , cs = as.state.data;
        return cs === void 0 ? this.fetchQuery(xt) : (xt.revalidateIfStale && as.isStaleByTime(resolveStaleTime(Cn.staleTime, as)) && this.prefetchQuery(Cn),
        Promise.resolve(cs))
    }
    getQueriesData(xt) {
        return du(this, Up).findAll(xt).map( ({queryKey: Cn, state: as}) => {
            const cs = as.data;
            return [Cn, cs]
        }
        )
    }
    setQueryData(xt, Cn, as) {
        const cs = this.defaultQueryOptions({
            queryKey: xt
        })
          , Cs = du(this, Up).get(cs.queryHash)
          , Ls = Cs == null ? void 0 : Cs.state.data
          , Vs = functionalUpdate(Cn, Ls);
        if (Vs !== void 0)
            return du(this, Up).build(this, cs).setData(Vs, {
                ...as,
                manual: !0
            })
    }
    setQueriesData(xt, Cn, as) {
        return notifyManager.batch( () => du(this, Up).findAll(xt).map( ({queryKey: cs}) => [cs, this.setQueryData(cs, Cn, as)]))
    }
    getQueryState(xt) {
        var as;
        const Cn = this.defaultQueryOptions({
            queryKey: xt
        });
        return (as = du(this, Up).get(Cn.queryHash)) == null ? void 0 : as.state
    }
    removeQueries(xt) {
        const Cn = du(this, Up);
        notifyManager.batch( () => {
            Cn.findAll(xt).forEach(as => {
                Cn.remove(as)
            }
            )
        }
        )
    }
    resetQueries(xt, Cn) {
        const as = du(this, Up);
        return notifyManager.batch( () => (as.findAll(xt).forEach(cs => {
            cs.reset()
        }
        ),
        this.refetchQueries({
            type: "active",
            ...xt
        }, Cn)))
    }
    cancelQueries(xt, Cn={}) {
        const as = {
            revert: !0,
            ...Cn
        }
          , cs = notifyManager.batch( () => du(this, Up).findAll(xt).map(Cs => Cs.cancel(as)));
        return Promise.all(cs).then(noop$2).catch(noop$2)
    }
    invalidateQueries(xt, Cn={}) {
        return notifyManager.batch( () => (du(this, Up).findAll(xt).forEach(as => {
            as.invalidate()
        }
        ),
        (xt == null ? void 0 : xt.refetchType) === "none" ? Promise.resolve() : this.refetchQueries({
            ...xt,
            type: (xt == null ? void 0 : xt.refetchType) ?? (xt == null ? void 0 : xt.type) ?? "active"
        }, Cn)))
    }
    refetchQueries(xt, Cn={}) {
        const as = {
            ...Cn,
            cancelRefetch: Cn.cancelRefetch ?? !0
        }
          , cs = notifyManager.batch( () => du(this, Up).findAll(xt).filter(Cs => !Cs.isDisabled()).map(Cs => {
            let Ls = Cs.fetch(void 0, as);
            return as.throwOnError || (Ls = Ls.catch(noop$2)),
            Cs.state.fetchStatus === "paused" ? Promise.resolve() : Ls
        }
        ));
        return Promise.all(cs).then(noop$2)
    }
    fetchQuery(xt) {
        const Cn = this.defaultQueryOptions(xt);
        Cn.retry === void 0 && (Cn.retry = !1);
        const as = du(this, Up).build(this, Cn);
        return as.isStaleByTime(resolveStaleTime(Cn.staleTime, as)) ? as.fetch(Cn) : Promise.resolve(as.state.data)
    }
    prefetchQuery(xt) {
        return this.fetchQuery(xt).then(noop$2).catch(noop$2)
    }
    fetchInfiniteQuery(xt) {
        return xt.behavior = infiniteQueryBehavior(xt.pages),
        this.fetchQuery(xt)
    }
    prefetchInfiniteQuery(xt) {
        return this.fetchInfiniteQuery(xt).then(noop$2).catch(noop$2)
    }
    ensureInfiniteQueryData(xt) {
        return xt.behavior = infiniteQueryBehavior(xt.pages),
        this.ensureQueryData(xt)
    }
    resumePausedMutations() {
        return onlineManager.isOnline() ? du(this, Em).resumePausedMutations() : Promise.resolve()
    }
    getQueryCache() {
        return du(this, Up)
    }
    getMutationCache() {
        return du(this, Em)
    }
    getDefaultOptions() {
        return du(this, _m)
    }
    setDefaultOptions(xt) {
        Zu(this, _m, xt)
    }
    setQueryDefaults(xt, Cn) {
        du(this, zm).set(hashKey(xt), {
            queryKey: xt,
            defaultOptions: Cn
        })
    }
    getQueryDefaults(xt) {
        const Cn = [...du(this, zm).values()]
          , as = {};
        return Cn.forEach(cs => {
            partialMatchKey(xt, cs.queryKey) && Object.assign(as, cs.defaultOptions)
        }
        ),
        as
    }
    setMutationDefaults(xt, Cn) {
        du(this, Zm).set(hashKey(xt), {
            mutationKey: xt,
            defaultOptions: Cn
        })
    }
    getMutationDefaults(xt) {
        const Cn = [...du(this, Zm).values()]
          , as = {};
        return Cn.forEach(cs => {
            partialMatchKey(xt, cs.mutationKey) && Object.assign(as, cs.defaultOptions)
        }
        ),
        as
    }
    defaultQueryOptions(xt) {
        if (xt._defaulted)
            return xt;
        const Cn = {
            ...du(this, _m).queries,
            ...this.getQueryDefaults(xt.queryKey),
            ...xt,
            _defaulted: !0
        };
        return Cn.queryHash || (Cn.queryHash = hashQueryKeyByOptions(Cn.queryKey, Cn)),
        Cn.refetchOnReconnect === void 0 && (Cn.refetchOnReconnect = Cn.networkMode !== "always"),
        Cn.throwOnError === void 0 && (Cn.throwOnError = !!Cn.suspense),
        !Cn.networkMode && Cn.persister && (Cn.networkMode = "offlineFirst"),
        Cn.queryFn === skipToken && (Cn.enabled = !1),
        Cn
    }
    defaultMutationOptions(xt) {
        return xt != null && xt._defaulted ? xt : {
            ...du(this, _m).mutations,
            ...(xt == null ? void 0 : xt.mutationKey) && this.getMutationDefaults(xt.mutationKey),
            ...xt,
            _defaulted: !0
        }
    }
    clear() {
        du(this, Up).clear(),
        du(this, Em).clear()
    }
}
,
Up = new WeakMap,
Em = new WeakMap,
_m = new WeakMap,
zm = new WeakMap,
Zm = new WeakMap,
Cm = new WeakMap,
Km = new WeakMap,
qm = new WeakMap,
Z1), nm, kp, a1, tm, Bm, Ym, $m, Sm, l1, Qm, Xm, Om, Fm, Tm, Jm, Np, i1, v1, x1, b1, w1, E1, _1, $1, e0, K1, QueryObserver = (K1 = class extends Subscribable {
    constructor(Cn, as) {
        super();
        ip(this, Np);
        ip(this, nm);
        ip(this, kp);
        ip(this, a1);
        ip(this, tm);
        ip(this, Bm);
        ip(this, Ym);
        ip(this, $m);
        ip(this, Sm);
        ip(this, l1);
        ip(this, Qm);
        ip(this, Xm);
        ip(this, Om);
        ip(this, Fm);
        ip(this, Tm);
        ip(this, Jm, new Set);
        this.options = as,
        Zu(this, nm, Cn),
        Zu(this, Sm, null),
        Zu(this, $m, pendingThenable()),
        this.options.experimental_prefetchInRender || du(this, $m).reject(new Error("experimental_prefetchInRender feature flag is not enabled")),
        this.bindMethods(),
        this.setOptions(as)
    }
    bindMethods() {
        this.refetch = this.refetch.bind(this)
    }
    onSubscribe() {
        this.listeners.size === 1 && (du(this, kp).addObserver(this),
        shouldFetchOnMount(du(this, kp), this.options) ? up(this, Np, i1).call(this) : this.updateResult(),
        up(this, Np, w1).call(this))
    }
    onUnsubscribe() {
        this.hasListeners() || this.destroy()
    }
    shouldFetchOnReconnect() {
        return shouldFetchOn(du(this, kp), this.options, this.options.refetchOnReconnect)
    }
    shouldFetchOnWindowFocus() {
        return shouldFetchOn(du(this, kp), this.options, this.options.refetchOnWindowFocus)
    }
    destroy() {
        this.listeners = new Set,
        up(this, Np, E1).call(this),
        up(this, Np, _1).call(this),
        du(this, kp).removeObserver(this)
    }
    setOptions(Cn) {
        const as = this.options
          , cs = du(this, kp);
        if (this.options = du(this, nm).defaultQueryOptions(Cn),
        this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof resolveEnabled(this.options.enabled, du(this, kp)) != "boolean")
            throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");
        up(this, Np, $1).call(this),
        du(this, kp).setOptions(this.options),
        as._defaulted && !shallowEqualObjects(this.options, as) && du(this, nm).getQueryCache().notify({
            type: "observerOptionsUpdated",
            query: du(this, kp),
            observer: this
        });
        const Cs = this.hasListeners();
        Cs && shouldFetchOptionally(du(this, kp), cs, this.options, as) && up(this, Np, i1).call(this),
        this.updateResult(),
        Cs && (du(this, kp) !== cs || resolveEnabled(this.options.enabled, du(this, kp)) !== resolveEnabled(as.enabled, du(this, kp)) || resolveStaleTime(this.options.staleTime, du(this, kp)) !== resolveStaleTime(as.staleTime, du(this, kp))) && up(this, Np, v1).call(this);
        const Ls = up(this, Np, x1).call(this);
        Cs && (du(this, kp) !== cs || resolveEnabled(this.options.enabled, du(this, kp)) !== resolveEnabled(as.enabled, du(this, kp)) || Ls !== du(this, Tm)) && up(this, Np, b1).call(this, Ls)
    }
    getOptimisticResult(Cn) {
        const as = du(this, nm).getQueryCache().build(du(this, nm), Cn)
          , cs = this.createResult(as, Cn);
        return shouldAssignObserverCurrentProperties(this, cs) && (Zu(this, tm, cs),
        Zu(this, Ym, this.options),
        Zu(this, Bm, du(this, kp).state)),
        cs
    }
    getCurrentResult() {
        return du(this, tm)
    }
    trackResult(Cn, as) {
        const cs = {};
        return Object.keys(Cn).forEach(Cs => {
            Object.defineProperty(cs, Cs, {
                configurable: !1,
                enumerable: !0,
                get: () => (this.trackProp(Cs),
                as == null || as(Cs),
                Cn[Cs])
            })
        }
        ),
        cs
    }
    trackProp(Cn) {
        du(this, Jm).add(Cn)
    }
    getCurrentQuery() {
        return du(this, kp)
    }
    refetch({...Cn}={}) {
        return this.fetch({
            ...Cn
        })
    }
    fetchOptimistic(Cn) {
        const as = du(this, nm).defaultQueryOptions(Cn)
          , cs = du(this, nm).getQueryCache().build(du(this, nm), as);
        return cs.fetch().then( () => this.createResult(cs, as))
    }
    fetch(Cn) {
        return up(this, Np, i1).call(this, {
            ...Cn,
            cancelRefetch: Cn.cancelRefetch ?? !0
        }).then( () => (this.updateResult(),
        du(this, tm)))
    }
    createResult(Cn, as) {
        var Fl;
        const cs = du(this, kp)
          , Cs = this.options
          , Ls = du(this, tm)
          , Vs = du(this, Bm)
          , Ws = du(this, Ym)
          , ga = Cn !== cs ? Cn.state : du(this, a1)
          , {state: ba} = Cn;
        let yl = {
            ...ba
        }, xl = !1, wl;
        if (as._optimisticResults) {
            const Ul = this.hasListeners()
              , Dl = !Ul && shouldFetchOnMount(Cn, as)
              , Zl = Ul && shouldFetchOptionally(Cn, cs, as, Cs);
            (Dl || Zl) && (yl = {
                ...yl,
                ...fetchState(ba.data, Cn.options)
            }),
            as._optimisticResults === "isRestoring" && (yl.fetchStatus = "idle")
        }
        let {error: _l, errorUpdatedAt: El, status: Cl} = yl;
        wl = yl.data;
        let $l = !1;
        if (as.placeholderData !== void 0 && wl === void 0 && Cl === "pending") {
            let Ul;
            Ls != null && Ls.isPlaceholderData && as.placeholderData === (Ws == null ? void 0 : Ws.placeholderData) ? (Ul = Ls.data,
            $l = !0) : Ul = typeof as.placeholderData == "function" ? as.placeholderData((Fl = du(this, Xm)) == null ? void 0 : Fl.state.data, du(this, Xm)) : as.placeholderData,
            Ul !== void 0 && (Cl = "success",
            wl = replaceData(Ls == null ? void 0 : Ls.data, Ul, as),
            xl = !0)
        }
        if (as.select && wl !== void 0 && !$l)
            if (Ls && wl === (Vs == null ? void 0 : Vs.data) && as.select === du(this, l1))
                wl = du(this, Qm);
            else
                try {
                    Zu(this, l1, as.select),
                    wl = as.select(wl),
                    wl = replaceData(Ls == null ? void 0 : Ls.data, wl, as),
                    Zu(this, Qm, wl),
                    Zu(this, Sm, null)
                } catch (Ul) {
                    Zu(this, Sm, Ul)
                }
        du(this, Sm) && (_l = du(this, Sm),
        wl = du(this, Qm),
        El = Date.now(),
        Cl = "error");
        const Sl = yl.fetchStatus === "fetching"
          , Tl = Cl === "pending"
          , Rl = Cl === "error"
          , Il = Tl && Sl
          , Ml = wl !== void 0
          , Ll = {
            status: Cl,
            fetchStatus: yl.fetchStatus,
            isPending: Tl,
            isSuccess: Cl === "success",
            isError: Rl,
            isInitialLoading: Il,
            isLoading: Il,
            data: wl,
            dataUpdatedAt: yl.dataUpdatedAt,
            error: _l,
            errorUpdatedAt: El,
            failureCount: yl.fetchFailureCount,
            failureReason: yl.fetchFailureReason,
            errorUpdateCount: yl.errorUpdateCount,
            isFetched: yl.dataUpdateCount > 0 || yl.errorUpdateCount > 0,
            isFetchedAfterMount: yl.dataUpdateCount > ga.dataUpdateCount || yl.errorUpdateCount > ga.errorUpdateCount,
            isFetching: Sl,
            isRefetching: Sl && !Tl,
            isLoadingError: Rl && !Ml,
            isPaused: yl.fetchStatus === "paused",
            isPlaceholderData: xl,
            isRefetchError: Rl && Ml,
            isStale: isStale(Cn, as),
            refetch: this.refetch,
            promise: du(this, $m)
        };
        if (this.options.experimental_prefetchInRender) {
            const Ul = Gl => {
                Ll.status === "error" ? Gl.reject(Ll.error) : Ll.data !== void 0 && Gl.resolve(Ll.data)
            }
              , Dl = () => {
                const Gl = Zu(this, $m, Ll.promise = pendingThenable());
                Ul(Gl)
            }
              , Zl = du(this, $m);
            switch (Zl.status) {
            case "pending":
                Cn.queryHash === cs.queryHash && Ul(Zl);
                break;
            case "fulfilled":
                (Ll.status === "error" || Ll.data !== Zl.value) && Dl();
                break;
            case "rejected":
                (Ll.status !== "error" || Ll.error !== Zl.reason) && Dl();
                break
            }
        }
        return Ll
    }
    updateResult() {
        const Cn = du(this, tm)
          , as = this.createResult(du(this, kp), this.options);
        if (Zu(this, Bm, du(this, kp).state),
        Zu(this, Ym, this.options),
        du(this, Bm).data !== void 0 && Zu(this, Xm, du(this, kp)),
        shallowEqualObjects(as, Cn))
            return;
        Zu(this, tm, as);
        const cs = () => {
            if (!Cn)
                return !0;
            const {notifyOnChangeProps: Cs} = this.options
              , Ls = typeof Cs == "function" ? Cs() : Cs;
            if (Ls === "all" || !Ls && !du(this, Jm).size)
                return !0;
            const Vs = new Set(Ls ?? du(this, Jm));
            return this.options.throwOnError && Vs.add("error"),
            Object.keys(du(this, tm)).some(Ws => {
                const Xs = Ws;
                return du(this, tm)[Xs] !== Cn[Xs] && Vs.has(Xs)
            }
            )
        }
        ;
        up(this, Np, e0).call(this, {
            listeners: cs()
        })
    }
    onQueryUpdate() {
        this.updateResult(),
        this.hasListeners() && up(this, Np, w1).call(this)
    }
}
,
nm = new WeakMap,
kp = new WeakMap,
a1 = new WeakMap,
tm = new WeakMap,
Bm = new WeakMap,
Ym = new WeakMap,
$m = new WeakMap,
Sm = new WeakMap,
l1 = new WeakMap,
Qm = new WeakMap,
Xm = new WeakMap,
Om = new WeakMap,
Fm = new WeakMap,
Tm = new WeakMap,
Jm = new WeakMap,
Np = new WeakSet,
i1 = function(Cn) {
    up(this, Np, $1).call(this);
    let as = du(this, kp).fetch(this.options, Cn);
    return Cn != null && Cn.throwOnError || (as = as.catch(noop$2)),
    as
}
,
v1 = function() {
    up(this, Np, E1).call(this);
    const Cn = resolveStaleTime(this.options.staleTime, du(this, kp));
    if (isServer || du(this, tm).isStale || !isValidTimeout(Cn))
        return;
    const cs = timeUntilStale(du(this, tm).dataUpdatedAt, Cn) + 1;
    Zu(this, Om, setTimeout( () => {
        du(this, tm).isStale || this.updateResult()
    }
    , cs))
}
,
x1 = function() {
    return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(du(this, kp)) : this.options.refetchInterval) ?? !1
}
,
b1 = function(Cn) {
    up(this, Np, _1).call(this),
    Zu(this, Tm, Cn),
    !(isServer || resolveEnabled(this.options.enabled, du(this, kp)) === !1 || !isValidTimeout(du(this, Tm)) || du(this, Tm) === 0) && Zu(this, Fm, setInterval( () => {
        (this.options.refetchIntervalInBackground || focusManager.isFocused()) && up(this, Np, i1).call(this)
    }
    , du(this, Tm)))
}
,
w1 = function() {
    up(this, Np, v1).call(this),
    up(this, Np, b1).call(this, up(this, Np, x1).call(this))
}
,
E1 = function() {
    du(this, Om) && (clearTimeout(du(this, Om)),
    Zu(this, Om, void 0))
}
,
_1 = function() {
    du(this, Fm) && (clearInterval(du(this, Fm)),
    Zu(this, Fm, void 0))
}
,
$1 = function() {
    const Cn = du(this, nm).getQueryCache().build(du(this, nm), this.options);
    if (Cn === du(this, kp))
        return;
    const as = du(this, kp);
    Zu(this, kp, Cn),
    Zu(this, a1, Cn.state),
    this.hasListeners() && (as == null || as.removeObserver(this),
    Cn.addObserver(this))
}
,
e0 = function(Cn) {
    notifyManager.batch( () => {
        Cn.listeners && this.listeners.forEach(as => {
            as(du(this, tm))
        }
        ),
        du(this, nm).getQueryCache().notify({
            query: du(this, kp),
            type: "observerResultsUpdated"
        })
    }
    )
}
,
K1);
function shouldLoadOnMount(xt, Cn) {
    return resolveEnabled(Cn.enabled, xt) !== !1 && xt.state.data === void 0 && !(xt.state.status === "error" && Cn.retryOnMount === !1)
}
function shouldFetchOnMount(xt, Cn) {
    return shouldLoadOnMount(xt, Cn) || xt.state.data !== void 0 && shouldFetchOn(xt, Cn, Cn.refetchOnMount)
}
function shouldFetchOn(xt, Cn, as) {
    if (resolveEnabled(Cn.enabled, xt) !== !1) {
        const cs = typeof as == "function" ? as(xt) : as;
        return cs === "always" || cs !== !1 && isStale(xt, Cn)
    }
    return !1
}
function shouldFetchOptionally(xt, Cn, as, cs) {
    return (xt !== Cn || resolveEnabled(cs.enabled, xt) === !1) && (!as.suspense || xt.state.status !== "error") && isStale(xt, as)
}
function isStale(xt, Cn) {
    return resolveEnabled(Cn.enabled, xt) !== !1 && xt.isStaleByTime(resolveStaleTime(Cn.staleTime, xt))
}
function shouldAssignObserverCurrentProperties(xt, Cn) {
    return !shallowEqualObjects(xt.getCurrentResult(), Cn)
}
function difference(xt, Cn) {
    return xt.filter(as => !Cn.includes(as))
}
function replaceAt(xt, Cn, as) {
    const cs = xt.slice(0);
    return cs[Cn] = as,
    cs
}
var e1, sm, t1, n1, om, km, c1, u1, d1, Kp, S1, T1, k1, R1, P1, q1, QueriesObserver = (q1 = class extends Subscribable {
    constructor(Cn, as, cs) {
        super();
        ip(this, Kp);
        ip(this, e1);
        ip(this, sm);
        ip(this, t1);
        ip(this, n1);
        ip(this, om);
        ip(this, km);
        ip(this, c1);
        ip(this, u1);
        ip(this, d1, []);
        Zu(this, e1, Cn),
        Zu(this, n1, cs),
        Zu(this, t1, []),
        Zu(this, om, []),
        Zu(this, sm, []),
        this.setQueries(as)
    }
    onSubscribe() {
        this.listeners.size === 1 && du(this, om).forEach(Cn => {
            Cn.subscribe(as => {
                up(this, Kp, R1).call(this, Cn, as)
            }
            )
        }
        )
    }
    onUnsubscribe() {
        this.listeners.size || this.destroy()
    }
    destroy() {
        this.listeners = new Set,
        du(this, om).forEach(Cn => {
            Cn.destroy()
        }
        )
    }
    setQueries(Cn, as) {
        Zu(this, t1, Cn),
        Zu(this, n1, as),
        notifyManager.batch( () => {
            const cs = du(this, om)
              , Cs = up(this, Kp, k1).call(this, du(this, t1));
            Zu(this, d1, Cs),
            Cs.forEach(Xs => Xs.observer.setOptions(Xs.defaultedQueryOptions));
            const Ls = Cs.map(Xs => Xs.observer)
              , Vs = Ls.map(Xs => Xs.getCurrentResult())
              , Ws = Ls.some( (Xs, ga) => Xs !== cs[ga]);
            cs.length === Ls.length && !Ws || (Zu(this, om, Ls),
            Zu(this, sm, Vs),
            this.hasListeners() && (difference(cs, Ls).forEach(Xs => {
                Xs.destroy()
            }
            ),
            difference(Ls, cs).forEach(Xs => {
                Xs.subscribe(ga => {
                    up(this, Kp, R1).call(this, Xs, ga)
                }
                )
            }
            ),
            up(this, Kp, P1).call(this)))
        }
        )
    }
    getCurrentResult() {
        return du(this, sm)
    }
    getQueries() {
        return du(this, om).map(Cn => Cn.getCurrentQuery())
    }
    getObservers() {
        return du(this, om)
    }
    getOptimisticResult(Cn, as) {
        const cs = up(this, Kp, k1).call(this, Cn)
          , Cs = cs.map(Ls => Ls.observer.getOptimisticResult(Ls.defaultedQueryOptions));
        return [Cs, Ls => up(this, Kp, T1).call(this, Ls ?? Cs, as), () => up(this, Kp, S1).call(this, Cs, cs)]
    }
}
,
e1 = new WeakMap,
sm = new WeakMap,
t1 = new WeakMap,
n1 = new WeakMap,
om = new WeakMap,
km = new WeakMap,
c1 = new WeakMap,
u1 = new WeakMap,
d1 = new WeakMap,
Kp = new WeakSet,
S1 = function(Cn, as) {
    return as.map( (cs, Cs) => {
        const Ls = Cn[Cs];
        return cs.defaultedQueryOptions.notifyOnChangeProps ? Ls : cs.observer.trackResult(Ls, Vs => {
            as.forEach(Ws => {
                Ws.observer.trackProp(Vs)
            }
            )
        }
        )
    }
    )
}
,
T1 = function(Cn, as) {
    return as ? ((!du(this, km) || du(this, sm) !== du(this, u1) || as !== du(this, c1)) && (Zu(this, c1, as),
    Zu(this, u1, du(this, sm)),
    Zu(this, km, replaceEqualDeep(du(this, km), as(Cn)))),
    du(this, km)) : Cn
}
,
k1 = function(Cn) {
    const as = new Map(du(this, om).map(Cs => [Cs.options.queryHash, Cs]))
      , cs = [];
    return Cn.forEach(Cs => {
        const Ls = du(this, e1).defaultQueryOptions(Cs)
          , Vs = as.get(Ls.queryHash);
        Vs ? cs.push({
            defaultedQueryOptions: Ls,
            observer: Vs
        }) : cs.push({
            defaultedQueryOptions: Ls,
            observer: new QueryObserver(du(this, e1),Ls)
        })
    }
    ),
    cs
}
,
R1 = function(Cn, as) {
    const cs = du(this, om).indexOf(Cn);
    cs !== -1 && (Zu(this, sm, replaceAt(du(this, sm), cs, as)),
    up(this, Kp, P1).call(this))
}
,
P1 = function() {
    var Cn;
    if (this.hasListeners()) {
        const as = du(this, km)
          , cs = up(this, Kp, S1).call(this, du(this, sm), du(this, d1))
          , Cs = up(this, Kp, T1).call(this, cs, (Cn = du(this, n1)) == null ? void 0 : Cn.combine);
        as !== Cs && notifyManager.batch( () => {
            this.listeners.forEach(Ls => {
                Ls(du(this, sm))
            }
            )
        }
        )
    }
}
,
q1), InfiniteQueryObserver = class extends QueryObserver {
    constructor(xt, Cn) {
        super(xt, Cn)
    }
    bindMethods() {
        super.bindMethods(),
        this.fetchNextPage = this.fetchNextPage.bind(this),
        this.fetchPreviousPage = this.fetchPreviousPage.bind(this)
    }
    setOptions(xt) {
        super.setOptions({
            ...xt,
            behavior: infiniteQueryBehavior()
        })
    }
    getOptimisticResult(xt) {
        return xt.behavior = infiniteQueryBehavior(),
        super.getOptimisticResult(xt)
    }
    fetchNextPage(xt) {
        return this.fetch({
            ...xt,
            meta: {
                fetchMore: {
                    direction: "forward"
                }
            }
        })
    }
    fetchPreviousPage(xt) {
        return this.fetch({
            ...xt,
            meta: {
                fetchMore: {
                    direction: "backward"
                }
            }
        })
    }
    createResult(xt, Cn) {
        var _l, El;
        const {state: as} = xt
          , cs = super.createResult(xt, Cn)
          , {isFetching: Cs, isRefetching: Ls, isError: Vs, isRefetchError: Ws} = cs
          , Xs = (El = (_l = as.fetchMeta) == null ? void 0 : _l.fetchMore) == null ? void 0 : El.direction
          , ga = Vs && Xs === "forward"
          , ba = Cs && Xs === "forward"
          , yl = Vs && Xs === "backward"
          , xl = Cs && Xs === "backward";
        return {
            ...cs,
            fetchNextPage: this.fetchNextPage,
            fetchPreviousPage: this.fetchPreviousPage,
            hasNextPage: hasNextPage(Cn, as.data),
            hasPreviousPage: hasPreviousPage(Cn, as.data),
            isFetchNextPageError: ga,
            isFetchingNextPage: ba,
            isFetchPreviousPageError: yl,
            isFetchingPreviousPage: xl,
            isRefetchError: Ws && !ga && !yl,
            isRefetching: Ls && !ba && !xl
        }
    }
}
, Rm, Pm, rm, pm, mm, m1, I1, Y1, MutationObserver$1 = (Y1 = class extends Subscribable {
    constructor(as, cs) {
        super();
        ip(this, mm);
        ip(this, Rm);
        ip(this, Pm);
        ip(this, rm);
        ip(this, pm);
        Zu(this, Rm, as),
        this.setOptions(cs),
        this.bindMethods(),
        up(this, mm, m1).call(this)
    }
    bindMethods() {
        this.mutate = this.mutate.bind(this),
        this.reset = this.reset.bind(this)
    }
    setOptions(as) {
        var Cs;
        const cs = this.options;
        this.options = du(this, Rm).defaultMutationOptions(as),
        shallowEqualObjects(this.options, cs) || du(this, Rm).getMutationCache().notify({
            type: "observerOptionsUpdated",
            mutation: du(this, rm),
            observer: this
        }),
        cs != null && cs.mutationKey && this.options.mutationKey && hashKey(cs.mutationKey) !== hashKey(this.options.mutationKey) ? this.reset() : ((Cs = du(this, rm)) == null ? void 0 : Cs.state.status) === "pending" && du(this, rm).setOptions(this.options)
    }
    onUnsubscribe() {
        var as;
        this.hasListeners() || (as = du(this, rm)) == null || as.removeObserver(this)
    }
    onMutationUpdate(as) {
        up(this, mm, m1).call(this),
        up(this, mm, I1).call(this, as)
    }
    getCurrentResult() {
        return du(this, Pm)
    }
    reset() {
        var as;
        (as = du(this, rm)) == null || as.removeObserver(this),
        Zu(this, rm, void 0),
        up(this, mm, m1).call(this),
        up(this, mm, I1).call(this)
    }
    mutate(as, cs) {
        var Cs;
        return Zu(this, pm, cs),
        (Cs = du(this, rm)) == null || Cs.removeObserver(this),
        Zu(this, rm, du(this, Rm).getMutationCache().build(du(this, Rm), this.options)),
        du(this, rm).addObserver(this),
        du(this, rm).execute(as)
    }
}
,
Rm = new WeakMap,
Pm = new WeakMap,
rm = new WeakMap,
pm = new WeakMap,
mm = new WeakSet,
m1 = function() {
    var cs;
    const as = ((cs = du(this, rm)) == null ? void 0 : cs.state) ?? getDefaultState();
    Zu(this, Pm, {
        ...as,
        isPending: as.status === "pending",
        isSuccess: as.status === "success",
        isError: as.status === "error",
        isIdle: as.status === "idle",
        mutate: this.mutate,
        reset: this.reset
    })
}
,
I1 = function(as) {
    notifyManager.batch( () => {
        var cs, Cs, Ls, Vs, Ws, Xs, ga, ba;
        if (du(this, pm) && this.hasListeners()) {
            const yl = du(this, Pm).variables
              , xl = du(this, Pm).context;
            (as == null ? void 0 : as.type) === "success" ? ((Cs = (cs = du(this, pm)).onSuccess) == null || Cs.call(cs, as.data, yl, xl),
            (Vs = (Ls = du(this, pm)).onSettled) == null || Vs.call(Ls, as.data, null, yl, xl)) : (as == null ? void 0 : as.type) === "error" && ((Xs = (Ws = du(this, pm)).onError) == null || Xs.call(Ws, as.error, yl, xl),
            (ba = (ga = du(this, pm)).onSettled) == null || ba.call(ga, void 0, as.error, yl, xl))
        }
        this.listeners.forEach(yl => {
            yl(du(this, Pm))
        }
        )
    }
    )
}
,
Y1), QueryClientContext = reactExports.createContext(void 0), useQueryClient = xt => {
    const Cn = reactExports.useContext(QueryClientContext);
    if (!Cn)
        throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return Cn
}
, QueryClientProvider = ({client: xt, children: Cn}) => (reactExports.useEffect( () => (xt.mount(),
() => {
    xt.unmount()
}
), [xt]),
jsxRuntimeExports.jsx(QueryClientContext.Provider, {
    value: xt,
    children: Cn
})), IsRestoringContext = reactExports.createContext(!1), useIsRestoring = () => reactExports.useContext(IsRestoringContext);
IsRestoringContext.Provider;
function createValue() {
    let xt = !1;
    return {
        clearReset: () => {
            xt = !1
        }
        ,
        reset: () => {
            xt = !0
        }
        ,
        isReset: () => xt
    }
}
var QueryErrorResetBoundaryContext = reactExports.createContext(createValue())
  , useQueryErrorResetBoundary = () => reactExports.useContext(QueryErrorResetBoundaryContext);
function shouldThrowError(xt, Cn) {
    return typeof xt == "function" ? xt(...Cn) : !!xt
}
function noop$1() {}
var ensurePreventErrorBoundaryRetry = (xt, Cn) => {
    (xt.suspense || xt.throwOnError || xt.experimental_prefetchInRender) && (Cn.isReset() || (xt.retryOnMount = !1))
}
  , useClearResetErrorBoundary = xt => {
    reactExports.useEffect( () => {
        xt.clearReset()
    }
    , [xt])
}
  , getHasError = ({result: xt, errorResetBoundary: Cn, throwOnError: as, query: cs, suspense: Cs}) => xt.isError && !Cn.isReset() && !xt.isFetching && cs && (Cs && xt.data === void 0 || shouldThrowError(as, [xt.error, cs]))
  , defaultThrowOnError = (xt, Cn) => Cn.state.data === void 0
  , ensureSuspenseTimers = xt => {
    const Cn = xt.staleTime;
    xt.suspense && (xt.staleTime = typeof Cn == "function" ? (...as) => Math.max(Cn(...as), 1e3) : Math.max(Cn ?? 1e3, 1e3),
    typeof xt.gcTime == "number" && (xt.gcTime = Math.max(xt.gcTime, 1e3)))
}
  , willFetch = (xt, Cn) => xt.isLoading && xt.isFetching && !Cn
  , shouldSuspend = (xt, Cn) => (xt == null ? void 0 : xt.suspense) && Cn.isPending
  , fetchOptimistic = (xt, Cn, as) => Cn.fetchOptimistic(xt).catch( () => {
    as.clearReset()
}
);
function useQueries({queries: xt, ...Cn}, as) {
    const cs = useQueryClient()
      , Cs = useIsRestoring()
      , Ls = useQueryErrorResetBoundary()
      , Vs = reactExports.useMemo( () => xt.map(El => {
        const Cl = cs.defaultQueryOptions(El);
        return Cl._optimisticResults = Cs ? "isRestoring" : "optimistic",
        Cl
    }
    ), [xt, cs, Cs]);
    Vs.forEach(El => {
        ensureSuspenseTimers(El),
        ensurePreventErrorBoundaryRetry(El, Ls)
    }
    ),
    useClearResetErrorBoundary(Ls);
    const [Ws] = reactExports.useState( () => new QueriesObserver(cs,Vs,Cn))
      , [Xs,ga,ba] = Ws.getOptimisticResult(Vs, Cn.combine)
      , yl = !Cs && Cn.subscribed !== !1;
    reactExports.useSyncExternalStore(reactExports.useCallback(El => yl ? Ws.subscribe(notifyManager.batchCalls(El)) : noop$1, [Ws, yl]), () => Ws.getCurrentResult(), () => Ws.getCurrentResult()),
    reactExports.useEffect( () => {
        Ws.setQueries(Vs, Cn)
    }
    , [Vs, Cn, Ws]);
    const wl = Xs.some( (El, Cl) => shouldSuspend(Vs[Cl], El)) ? Xs.flatMap( (El, Cl) => {
        const $l = Vs[Cl];
        if ($l) {
            const Sl = new QueryObserver(cs,$l);
            if (shouldSuspend($l, El))
                return fetchOptimistic($l, Sl, Ls);
            willFetch(El, Cs) && fetchOptimistic($l, Sl, Ls)
        }
        return []
    }
    ) : [];
    if (wl.length > 0)
        throw Promise.all(wl);
    const _l = Xs.find( (El, Cl) => {
        const $l = Vs[Cl];
        return $l && getHasError({
            result: El,
            errorResetBoundary: Ls,
            throwOnError: $l.throwOnError,
            query: cs.getQueryCache().get($l.queryHash),
            suspense: $l.suspense
        })
    }
    );
    if (_l != null && _l.error)
        throw _l.error;
    return ga(ba())
}
function useBaseQuery(xt, Cn, as) {
    var yl, xl, wl, _l, El;
    const cs = useQueryClient()
      , Cs = useIsRestoring()
      , Ls = useQueryErrorResetBoundary()
      , Vs = cs.defaultQueryOptions(xt);
    (xl = (yl = cs.getDefaultOptions().queries) == null ? void 0 : yl._experimental_beforeQuery) == null || xl.call(yl, Vs),
    Vs._optimisticResults = Cs ? "isRestoring" : "optimistic",
    ensureSuspenseTimers(Vs),
    ensurePreventErrorBoundaryRetry(Vs, Ls),
    useClearResetErrorBoundary(Ls);
    const Ws = !cs.getQueryCache().get(Vs.queryHash)
      , [Xs] = reactExports.useState( () => new Cn(cs,Vs))
      , ga = Xs.getOptimisticResult(Vs)
      , ba = !Cs && xt.subscribed !== !1;
    if (reactExports.useSyncExternalStore(reactExports.useCallback(Cl => {
        const $l = ba ? Xs.subscribe(notifyManager.batchCalls(Cl)) : noop$1;
        return Xs.updateResult(),
        $l
    }
    , [Xs, ba]), () => Xs.getCurrentResult(), () => Xs.getCurrentResult()),
    reactExports.useEffect( () => {
        Xs.setOptions(Vs)
    }
    , [Vs, Xs]),
    shouldSuspend(Vs, ga))
        throw fetchOptimistic(Vs, Xs, Ls);
    if (getHasError({
        result: ga,
        errorResetBoundary: Ls,
        throwOnError: Vs.throwOnError,
        query: cs.getQueryCache().get(Vs.queryHash),
        suspense: Vs.suspense
    }))
        throw ga.error;
    if ((_l = (wl = cs.getDefaultOptions().queries) == null ? void 0 : wl._experimental_afterQuery) == null || _l.call(wl, Vs, ga),
    Vs.experimental_prefetchInRender && !isServer && willFetch(ga, Cs)) {
        const Cl = Ws ? fetchOptimistic(Vs, Xs, Ls) : (El = cs.getQueryCache().get(Vs.queryHash)) == null ? void 0 : El.promise;
        Cl == null || Cl.catch(noop$1).finally( () => {
            Xs.updateResult()
        }
        )
    }
    return Vs.notifyOnChangeProps ? ga : Xs.trackResult(ga)
}
function useQuery(xt, Cn) {
    return useBaseQuery(xt, QueryObserver)
}
function useSuspenseQueries(xt, Cn) {
    return useQueries({
        ...xt,
        queries: xt.queries.map(as => ({
            ...as,
            suspense: !0,
            throwOnError: defaultThrowOnError,
            enabled: !0,
            placeholderData: void 0
        }))
    })
}
function queryOptions(xt) {
    return xt
}
function infiniteQueryOptions(xt) {
    return xt
}
function useIsFetching(xt, Cn) {
    const as = useQueryClient()
      , cs = as.getQueryCache();
    return reactExports.useSyncExternalStore(reactExports.useCallback(Cs => cs.subscribe(notifyManager.batchCalls(Cs)), [cs]), () => as.isFetching(xt), () => as.isFetching(xt))
}
function useMutation(xt, Cn) {
    const as = useQueryClient()
      , [cs] = reactExports.useState( () => new MutationObserver$1(as,xt));
    reactExports.useEffect( () => {
        cs.setOptions(xt)
    }
    , [cs, xt]);
    const Cs = reactExports.useSyncExternalStore(reactExports.useCallback(Vs => cs.subscribe(notifyManager.batchCalls(Vs)), [cs]), () => cs.getCurrentResult(), () => cs.getCurrentResult())
      , Ls = reactExports.useCallback( (Vs, Ws) => {
        cs.mutate(Vs, Ws).catch(noop$1)
    }
    , [cs]);
    if (Cs.error && shouldThrowError(cs.options.throwOnError, [Cs.error]))
        throw Cs.error;
    return {
        ...Cs,
        mutate: Ls,
        mutateAsync: Cs.mutate
    }
}
function useInfiniteQuery(xt, Cn) {
    return useBaseQuery(xt, InfiniteQueryObserver)
}
const queryClient = new QueryClient({
    defaultOptions: {
        queries: {
            retry: !1,
            refetchOnMount: !0,
            refetchOnWindowFocus: !0
        }
    }
})
  , getQueryData = xt => queryClient.getQueryData(xt)
  , QueryProvider = ({children: xt}) => jsxRuntimeExports.jsx(QueryClientProvider, {
    client: queryClient,
    children: xt
})
  , MIN_ITEMS_FOR_LAYOUT = 4
  , promotionsSlice = createSlice( (xt, Cn) => ({
    prefetchedPromotions: [],
    isResizeListenerSetup: !1,
    resizeHandler: null,
    calculatePromotedFirst: as => {
        if (as.length <= MIN_ITEMS_FOR_LAYOUT) {
            Cn().filters.setPromotedFirst(!0);
            return
        }
        const Cs = window.innerWidth
          , Ls = Math.floor(Cs / 92)
          , Vs = !!Ls && as.length > Ls;
        Cn().filters.setPromotedFirst(!Vs)
    }
    ,
    setupResizeListener: () => {
        const as = Cn().promotions.resizeHandler;
        as && window.removeEventListener("resize", as);
        const cs = Cs => {
            var Xs;
            const Ls = Cn().filters
              , Vs = getQueryData([QueryKeys.promotions, Ls])
              , Ws = ((Xs = Vs == null ? void 0 : Vs.pages) == null ? void 0 : Xs.flatMap(ga => ga)) || Cn().promotions.prefetchedPromotions;
            Cn().promotions.calculatePromotedFirst(Ws)
        }
        ;
        xt(Cs => ({
            promotions: {
                ...Cs.promotions,
                resizeHandler: cs,
                isResizeListenerSetup: !0
            }
        })),
        window.addEventListener("resize", cs),
        cs(new UIEvent("resize"))
    }
    ,
    prefetchPromotionsPromise: async () => {
        try {
            const as = await prefetchInitialPromotions();
            xt(Ls => ({
                promotions: {
                    ...Ls.promotions,
                    prefetchedPromotions: as
                }
            })),
            Cn().promotions.calculatePromotedFirst(as);
            const {promotedFirst: cs} = Cn().filters
              , Cs = await prefetchInitialGifts(cs);
            xt(Ls => ({
                gifts: {
                    ...Ls.gifts,
                    prefetchedGifts: Cs
                }
            }))
        } catch (as) {
            console.error("Error while fetching initial promotions", as)
        }
    }
}))
  , leaderboardSlice = createSlice( (xt, Cn) => ({
    leaderboard: null,
    fetchLeaderboard: async (as=!1) => {
        var Ls;
        as || [...((Ls = Cn().leaderboards.leaderboard) == null ? void 0 : Ls.users) || []];
        const Cs = await (await fetch(getApiUrl(`/api/v1/gifts-leaderboards/${Cn().app.leaderboardId}`))).json();
        xt(Vs => ({
            leaderboards: {
                ...Vs.leaderboards,
                leaderboard: {
                    ...Vs.leaderboards.leaderboard,
                    ...Cs
                }
            }
        }))
    }
}))
  , stickersSlice = createSlice( (xt, Cn) => ({
    showTooltip: !1,
    setShowTooltip: as => {
        xt(cs => ({
            stickers: {
                ...cs.stickers,
                showTooltip: as
            }
        }))
    }
}))
  , feedSlice = (xt, Cn) => ({
    eventForOverview: null,
    setEventForOverview: as => xt(cs => ({
        feed: {
            ...cs.feed,
            eventForOverview: as
        }
    })),
    openFeedEvent: async as => {
        const cs = Cn();
        switch (as.type) {
        default:
            return cs.gifts.setSelectedGiftForOverview(as.gift),
            cs.modal.addModal(ModalNames.GIFT_OVERVIEW)
        }
    }
    ,
    getAndOpenFeedEvent: async as => {
        const cs = await fetch(getApiUrl(`/api/v1/feed/${as}`));
        Cn().feed.openFeedEvent(await cs.json())
    }
    ,
    shareEvent: (as, cs) => {
        const Ls = Cn().app.inGameLink;
        Oc(`https://t.me/share/url?url=${Ls}feed${as.id.replace(/-/g, "")}&text=${cs("Look!")}`)
    }
})
  , isInternalApi = xt => {
    try {
        return typeof xt != "string" ? !1 : window.API_URL && xt.includes(window.API_URL) ? !0 : xt.startsWith("/") || xt.includes("api.mrkt.io")
    } catch {
        return !1
    }
}
  , store = create()( (xt, Cn) => {
    const as = window.fetch;
    return window.fetch = async (...cs) => {
        const [Cs,Ls] = cs
          , Vs = {
            ...Ls || {},
            headers: {
                ...Ls ? Ls.headers : {},
                ...isInternalApi(Cs) && Cn().auth.accessToken ? {
                    authorization: Cn().auth.accessToken
                } : {}
            }
        };
        try {
            const Ws = await as(Cs, {
                ...Vs
            });
            return Ws.ok || console.log("RESPONSE", Ws),
            !Ws.ok && Ws.status === 502 && xt(Xs => ({
                app: {
                    ...Xs.app,
                    maintenance: !0,
                    state: APP_STATE.ERROR
                }
            })),
            Ws
        } catch (Ws) {
            throw console.log("ERROR", Ws),
            Ws
        }
    }
    ,
    {
        app: appSlice(xt, Cn),
        auth: authSlice(xt, Cn),
        wallet: walletSlice(xt, Cn),
        locales: localesSlice(xt, Cn),
        profile: profileSlice(xt, Cn),
        backButton: backButtonSlice(xt, Cn),
        modal: modalSlice(xt, Cn),
        timers: timersSlice(xt, Cn),
        navigation: navigationSlice(xt, Cn),
        myGifts: myGiftsSlice(xt, Cn),
        giftDisplay: giftDisplaySlice(xt),
        gifts: giftsSlice(xt, Cn),
        referrals: referralsSlice(xt, Cn),
        cart: cartSlice(xt, Cn),
        transaction: transactionsSlice(xt, Cn),
        withdraw: withdrawSlice(xt, Cn),
        filters: filtersSlice(xt),
        history: historySlice(xt, Cn),
        giveaways: giveawaysSlice(xt, Cn),
        promotions: promotionsSlice(xt, Cn),
        leaderboards: leaderboardSlice(xt, Cn),
        stickers: stickersSlice(xt, Cn),
        feed: feedSlice(xt, Cn)
    }
}
)
  , useStorage = xt => store(useShallow(xt));
var LIBVERSION = "2.0.3"
  , UA_MAX_LENGTH = 500
  , USER_AGENT = "user-agent"
  , EMPTY = ""
  , UNKNOWN = "?"
  , FUNC_TYPE = "function"
  , UNDEF_TYPE = "undefined"
  , OBJ_TYPE = "object"
  , STR_TYPE = "string"
  , UA_BROWSER = "browser"
  , UA_CPU = "cpu"
  , UA_DEVICE = "device"
  , UA_ENGINE = "engine"
  , UA_OS = "os"
  , UA_RESULT = "result"
  , NAME = "name"
  , TYPE = "type"
  , VENDOR = "vendor"
  , VERSION = "version"
  , ARCHITECTURE = "architecture"
  , MAJOR = "major"
  , MODEL = "model"
  , CONSOLE = "console"
  , MOBILE = "mobile"
  , TABLET = "tablet"
  , SMARTTV = "smarttv"
  , WEARABLE = "wearable"
  , XR = "xr"
  , EMBEDDED = "embedded"
  , INAPP = "inapp"
  , BRANDS = "brands"
  , FORMFACTORS = "formFactors"
  , FULLVERLIST = "fullVersionList"
  , PLATFORM = "platform"
  , PLATFORMVER = "platformVersion"
  , BITNESS = "bitness"
  , CH_HEADER = "sec-ch-ua"
  , CH_HEADER_FULL_VER_LIST = CH_HEADER + "-full-version-list"
  , CH_HEADER_ARCH = CH_HEADER + "-arch"
  , CH_HEADER_BITNESS = CH_HEADER + "-" + BITNESS
  , CH_HEADER_FORM_FACTORS = CH_HEADER + "-form-factors"
  , CH_HEADER_MOBILE = CH_HEADER + "-" + MOBILE
  , CH_HEADER_MODEL = CH_HEADER + "-" + MODEL
  , CH_HEADER_PLATFORM = CH_HEADER + "-" + PLATFORM
  , CH_HEADER_PLATFORM_VER = CH_HEADER_PLATFORM + "-version"
  , CH_ALL_VALUES = [BRANDS, FULLVERLIST, MOBILE, MODEL, PLATFORM, PLATFORMVER, ARCHITECTURE, FORMFACTORS, BITNESS]
  , AMAZON = "Amazon"
  , APPLE = "Apple"
  , ASUS = "ASUS"
  , BLACKBERRY = "BlackBerry"
  , GOOGLE = "Google"
  , HUAWEI = "Huawei"
  , LENOVO = "Lenovo"
  , HONOR = "Honor"
  , LG = "LG"
  , MICROSOFT = "Microsoft"
  , MOTOROLA = "Motorola"
  , NVIDIA = "Nvidia"
  , ONEPLUS = "OnePlus"
  , OPPO = "OPPO"
  , SAMSUNG = "Samsung"
  , SHARP = "Sharp"
  , SONY = "Sony"
  , XIAOMI = "Xiaomi"
  , ZEBRA = "Zebra"
  , CHROME = "Chrome"
  , CHROMIUM = "Chromium"
  , CHROMECAST = "Chromecast"
  , EDGE = "Edge"
  , FIREFOX = "Firefox"
  , OPERA = "Opera"
  , FACEBOOK = "Facebook"
  , SOGOU = "Sogou"
  , PREFIX_MOBILE = "Mobile "
  , SUFFIX_BROWSER = " Browser"
  , WINDOWS = "Windows"
  , isWindow = typeof window !== UNDEF_TYPE
  , NAVIGATOR = isWindow && window.navigator ? window.navigator : void 0
  , NAVIGATOR_UADATA = NAVIGATOR && NAVIGATOR.userAgentData ? NAVIGATOR.userAgentData : void 0
  , extend = function(xt, Cn) {
    var as = {}
      , cs = Cn;
    if (!isExtensions(Cn)) {
        cs = {};
        for (var Cs in Cn)
            for (var Ls in Cn[Cs])
                cs[Ls] = Cn[Cs][Ls].concat(cs[Ls] ? cs[Ls] : [])
    }
    for (var Vs in xt)
        as[Vs] = cs[Vs] && cs[Vs].length % 2 === 0 ? cs[Vs].concat(xt[Vs]) : xt[Vs];
    return as
}
  , enumerize = function(xt) {
    for (var Cn = {}, as = 0; as < xt.length; as++)
        Cn[xt[as].toUpperCase()] = xt[as];
    return Cn
}
  , has = function(xt, Cn) {
    if (typeof xt === OBJ_TYPE && xt.length > 0) {
        for (var as in xt)
            if (lowerize(xt[as]) == lowerize(Cn))
                return !0;
        return !1
    }
    return isString$1(xt) ? lowerize(Cn).indexOf(lowerize(xt)) !== -1 : !1
}
  , isExtensions = function(xt, Cn) {
    for (var as in xt)
        return /^(browser|cpu|device|engine|os)$/.test(as) || (Cn ? isExtensions(xt[as]) : !1)
}
  , isString$1 = function(xt) {
    return typeof xt === STR_TYPE
}
  , itemListToArray = function(xt) {
    if (xt) {
        for (var Cn = [], as = strip(/\\?\"/g, xt).split(","), cs = 0; cs < as.length; cs++)
            if (as[cs].indexOf(";") > -1) {
                var Cs = trim(as[cs]).split(";v=");
                Cn[cs] = {
                    brand: Cs[0],
                    version: Cs[1]
                }
            } else
                Cn[cs] = trim(as[cs]);
        return Cn
    }
}
  , lowerize = function(xt) {
    return isString$1(xt) ? xt.toLowerCase() : xt
}
  , majorize = function(xt) {
    return isString$1(xt) ? strip(/[^\d\.]/g, xt).split(".")[0] : void 0
}
  , setProps = function(xt) {
    for (var Cn in xt) {
        var as = xt[Cn];
        typeof as == OBJ_TYPE && as.length == 2 ? this[as[0]] = as[1] : this[as] = void 0
    }
    return this
}
  , strip = function(xt, Cn) {
    return isString$1(Cn) ? Cn.replace(xt, EMPTY) : Cn
}
  , stripQuotes = function(xt) {
    return strip(/\\?\"/g, xt)
}
  , trim = function(xt, Cn) {
    if (isString$1(xt))
        return xt = strip(/^\s\s*/, xt),
        typeof Cn === UNDEF_TYPE ? xt : xt.substring(0, UA_MAX_LENGTH)
}
  , rgxMapper = function(xt, Cn) {
    if (!(!xt || !Cn))
        for (var as = 0, cs, Cs, Ls, Vs, Ws, Xs; as < Cn.length && !Ws; ) {
            var ga = Cn[as]
              , ba = Cn[as + 1];
            for (cs = Cs = 0; cs < ga.length && !Ws && ga[cs]; )
                if (Ws = ga[cs++].exec(xt),
                Ws)
                    for (Ls = 0; Ls < ba.length; Ls++)
                        Xs = Ws[++Cs],
                        Vs = ba[Ls],
                        typeof Vs === OBJ_TYPE && Vs.length > 0 ? Vs.length === 2 ? typeof Vs[1] == FUNC_TYPE ? this[Vs[0]] = Vs[1].call(this, Xs) : this[Vs[0]] = Vs[1] : Vs.length === 3 ? typeof Vs[1] === FUNC_TYPE && !(Vs[1].exec && Vs[1].test) ? this[Vs[0]] = Xs ? Vs[1].call(this, Xs, Vs[2]) : void 0 : this[Vs[0]] = Xs ? Xs.replace(Vs[1], Vs[2]) : void 0 : Vs.length === 4 && (this[Vs[0]] = Xs ? Vs[3].call(this, Xs.replace(Vs[1], Vs[2])) : void 0) : this[Vs] = Xs || void 0;
            as += 2
        }
}
  , strMapper = function(xt, Cn) {
    for (var as in Cn)
        if (typeof Cn[as] === OBJ_TYPE && Cn[as].length > 0) {
            for (var cs = 0; cs < Cn[as].length; cs++)
                if (has(Cn[as][cs], xt))
                    return as === UNKNOWN ? void 0 : as
        } else if (has(Cn[as], xt))
            return as === UNKNOWN ? void 0 : as;
    return Cn.hasOwnProperty("*") ? Cn["*"] : xt
}
  , windowsVersionMap = {
    ME: "4.90",
    "NT 3.11": "NT3.51",
    "NT 4.0": "NT4.0",
    2e3: "NT 5.0",
    XP: ["NT 5.1", "NT 5.2"],
    Vista: "NT 6.0",
    7: "NT 6.1",
    8: "NT 6.2",
    "8.1": "NT 6.3",
    10: ["NT 6.4", "NT 10.0"],
    RT: "ARM"
}
  , formFactorsMap = {
    embedded: "Automotive",
    mobile: "Mobile",
    tablet: ["Tablet", "EInk"],
    smarttv: "TV",
    wearable: "Watch",
    xr: ["VR", "XR"],
    "?": ["Desktop", "Unknown"],
    "*": void 0
}
  , defaultRegexes = {
    browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [VERSION, [NAME, PREFIX_MOBILE + "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [VERSION, [NAME, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [NAME, VERSION], [/opios[\/ ]+([\w\.]+)/i], [VERSION, [NAME, OPERA + " Mini"]], [/\bop(?:rg)?x\/([\w\.]+)/i], [VERSION, [NAME, OPERA + " GX"]], [/\bopr\/([\w\.]+)/i], [VERSION, [NAME, OPERA]], [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i], [VERSION, [NAME, "Baidu"]], [/\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i], [VERSION, [NAME, "Maxthon"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i, /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon|otter|dooble|(?:lg |qute)browser)\/([-\w\.]+)/i, /(heytap|ovi|115|surf)browser\/([\d\.]+)/i, /(ecosia|weibo)(?:__| \w+@)([\d\.]+)/i], [NAME, VERSION], [/quark(?:pc)?\/([-\w\.]+)/i], [VERSION, [NAME, "Quark"]], [/\bddg\/([\w\.]+)/i], [VERSION, [NAME, "DuckDuckGo"]], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [VERSION, [NAME, "UCBrowser"]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i], [VERSION, [NAME, "WeChat"]], [/konqueror\/([\w\.]+)/i], [VERSION, [NAME, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [VERSION, [NAME, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [VERSION, [NAME, "Yandex"]], [/slbrowser\/([\w\.]+)/i], [VERSION, [NAME, "Smart " + LENOVO + SUFFIX_BROWSER]], [/(avast|avg)\/([\w\.]+)/i], [[NAME, /(.+)/, "$1 Secure" + SUFFIX_BROWSER], VERSION], [/\bfocus\/([\w\.]+)/i], [VERSION, [NAME, FIREFOX + " Focus"]], [/\bopt\/([\w\.]+)/i], [VERSION, [NAME, OPERA + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [VERSION, [NAME, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [VERSION, [NAME, "Dolphin"]], [/coast\/([\w\.]+)/i], [VERSION, [NAME, OPERA + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [VERSION, [NAME, "MIUI" + SUFFIX_BROWSER]], [/fxios\/([\w\.-]+)/i], [VERSION, [NAME, PREFIX_MOBILE + FIREFOX]], [/\bqihoobrowser\/?([\w\.]*)/i], [VERSION, [NAME, "360"]], [/\b(qq)\/([\w\.]+)/i], [[NAME, /(.+)/, "$1Browser"], VERSION], [/(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i], [[NAME, /(.+)/, "$1" + SUFFIX_BROWSER], VERSION], [/samsungbrowser\/([\w\.]+)/i], [VERSION, [NAME, SAMSUNG + " Internet"]], [/metasr[\/ ]?([\d\.]+)/i], [VERSION, [NAME, SOGOU + " Explorer"]], [/(sogou)mo\w+\/([\d\.]+)/i], [[NAME, SOGOU + " Mobile"], VERSION], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i], [NAME, VERSION], [/(lbbrowser|rekonq)/i], [NAME], [/ome\/([\w\.]+) \w* ?(iron) saf/i, /ome\/([\w\.]+).+qihu (360)[es]e/i], [VERSION, NAME], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[NAME, FACEBOOK], VERSION, [TYPE, INAPP]], [/(Klarna)\/([\w\.]+)/i, /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /(daum)apps[\/ ]([\w\.]+)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(alipay)client\/([\w\.]+)/i, /(twitter)(?:and| f.+e\/([\w\.]+))/i, /(instagram|snapchat)[\/ ]([-\w\.]+)/i], [NAME, VERSION, [TYPE, INAPP]], [/\bgsa\/([\w\.]+) .*safari\//i], [VERSION, [NAME, "GSA"], [TYPE, INAPP]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [VERSION, [NAME, "TikTok"], [TYPE, INAPP]], [/\[(linkedin)app\]/i], [NAME, [TYPE, INAPP]], [/(chromium)[\/ ]([-\w\.]+)/i], [NAME, VERSION], [/headlesschrome(?:\/([\w\.]+)| )/i], [VERSION, [NAME, CHROME + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[NAME, CHROME + " WebView"], VERSION], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [VERSION, [NAME, "Android" + SUFFIX_BROWSER]], [/chrome\/([\w\.]+) mobile/i], [VERSION, [NAME, PREFIX_MOBILE + "Chrome"]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [NAME, VERSION], [/version\/([\w\.\,]+) .*mobile(?:\/\w+ | ?)safari/i], [VERSION, [NAME, PREFIX_MOBILE + "Safari"]], [/iphone .*mobile(?:\/\w+ | ?)safari/i], [[NAME, PREFIX_MOBILE + "Safari"]], [/version\/([\w\.\,]+) .*(safari)/i], [VERSION, NAME], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [NAME, [VERSION, "1"]], [/(webkit|khtml)\/([\w\.]+)/i], [NAME, VERSION], [/(?:mobile|tablet);.*(firefox)\/([\w\.-]+)/i], [[NAME, PREFIX_MOBILE + FIREFOX], VERSION], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[NAME, "Netscape"], VERSION], [/(wolvic|librewolf)\/([\w\.]+)/i], [NAME, VERSION], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [VERSION, [NAME, FIREFOX + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(amaya|dillo|doris|icab|ladybird|lynx|mosaic|netsurf|obigo|polaris|w3m|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /\b(links) \(([\w\.]+)/i], [NAME, [VERSION, /_/g, "."]], [/(cobalt)\/([\w\.]+)/i], [NAME, [VERSION, /[^\d\.]+./, EMPTY]]],
    cpu: [[/\b((amd|x|x86[-_]?|wow|win)64)\b/i], [[ARCHITECTURE, "amd64"]], [/(ia32(?=;))/i, /\b((i[346]|x)86)(pc)?\b/i], [[ARCHITECTURE, "ia32"]], [/\b(aarch64|arm(v?[89]e?l?|_?64))\b/i], [[ARCHITECTURE, "arm64"]], [/\b(arm(v[67])?ht?n?[fl]p?)\b/i], [[ARCHITECTURE, "armhf"]], [/( (ce|mobile); ppc;|\/[\w\.]+arm\b)/i], [[ARCHITECTURE, "arm"]], [/((ppc|powerpc)(64)?)( mac|;|\))/i], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [/ sun4\w[;\)]/i], [[ARCHITECTURE, "sparc"]], [/\b(avr32|ia64(?=;)|68k(?=\))|\barm(?=v([1-7]|[5-7]1)l?|;|eabi)|(irix|mips|sparc)(64)?\b|pa-risc)/i], [[ARCHITECTURE, lowerize]]],
    device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [/\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]((?!sm-[lr])[-\w]+)/i, /sec-(sgh\w+)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [/(macintosh);/i], [MODEL, [VENDOR, APPLE]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]], [/\b((?:brt|eln|hey2?|gdi|jdn)-a?[lnw]09|(?:ag[rm]3?|jdn2|kob2)-a?[lw]0[09]hn)(?: bui|\)|;)/i], [MODEL, [VENDOR, HONOR], [TYPE, TABLET]], [/honor([-\w ]+)[;\)]/i], [MODEL, [VENDOR, HONOR], [TYPE, MOBILE]], [/\b((?:ag[rs][2356]?k?|bah[234]?|bg[2o]|bt[kv]|cmr|cpn|db[ry]2?|jdn2|got|kob2?k?|mon|pce|scm|sht?|[tw]gr|vrd)-[ad]?[lw][0125][09]b?|605hw|bg2-u03|(?:gem|fdr|m2|ple|t1)-[7a]0[1-4][lu]|t1-a2[13][lw]|mediapad[\w\. ]*(?= bui|\)))\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [/(?:huawei)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [/oid[^\)]+; (2[\dbc]{4}(182|283|rp\w{2})[cgl]|m2105k81a?c)(?: bui|\))/i, /\b((?:red)?mi[-_ ]?pad[\w- ]*)(?: bui|\))/i], [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i, / ([\w ]+) miui\/v?\d/i], [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [MODEL, [VENDOR, OPPO], [TYPE, MOBILE]], [/\b(opd2(\d{3}a?))(?: bui|\))/i], [MODEL, [VENDOR, strMapper, {
        OnePlus: ["304", "403", "203"],
        "*": OPPO
    }], [TYPE, TABLET]], [/(vivo (5r?|6|8l?|go|one|s|x[il]?[2-4]?)[\w\+ ]*)(?: bui|\))/i], [MODEL, [VENDOR, "BLU"], [TYPE, MOBILE]], [/; vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]], [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto(?! 360)[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+(?!.*(?:browser|netcast|android tv|watch))(\w+)/i, /\blg-?([\d\w]+) bui/i], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [/(ideatab[-\w ]+|602lv|d-42a|a101lv|a2109a|a3500-hv|s[56]000|pb-6505[my]|tb-?x?\d{3,4}(?:f[cu]|xu|[av])|yt\d?-[jx]?\d+[lfmx])( bui|;|\)|\/)/i, /lenovo ?(b[68]0[08]0-?[hf]?|tab(?:[\w- ]+?)|tb[\w-]{6,7})( bui|;|\)|\/)/i], [MODEL, [VENDOR, LENOVO], [TYPE, TABLET]], [/(nokia) (t[12][01])/i], [VENDOR, MODEL, [TYPE, TABLET]], [/(?:maemo|nokia).*(n900|lumia \d+|rm-\d+)/i, /nokia[-_ ]?(([-\w\. ]*))/i], [[MODEL, /_/g, " "], [TYPE, MOBILE], [VENDOR, "Nokia"]], [/(pixel (c|tablet))\b/i], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [/droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [MODEL, [VENDOR, ONEPLUS], [TYPE, MOBILE]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]], [/(playbook);[-\w\),; ]+(rim)/i], [MODEL, VENDOR, [TYPE, TABLET]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [/(nexus 9)/i], [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]], [/tcl (xess p17aa)/i, /droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])(_\w(\w|\w\w))?(\)| bui)/i], [MODEL, [VENDOR, "TCL"], [TYPE, TABLET]], [/droid [\w\.]+; (418(?:7d|8v)|5087z|5102l|61(?:02[dh]|25[adfh]|27[ai]|56[dh]|59k|65[ah])|a509dl|t(?:43(?:0w|1[adepqu])|50(?:6d|7[adju])|6(?:09dl|10k|12b|71[efho]|76[hjk])|7(?:66[ahju]|67[hw]|7[045][bh]|71[hk]|73o|76[ho]|79w|81[hks]?|82h|90[bhsy]|99b)|810[hs]))(_\w(\w|\w\w))?(\)| bui)/i], [MODEL, [VENDOR, "TCL"], [TYPE, MOBILE]], [/(itel) ((\w+))/i], [[VENDOR, lowerize], MODEL, [TYPE, strMapper, {
        tablet: ["p10001l", "w7001"],
        "*": "mobile"
    }]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]], [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [MODEL, [VENDOR, "Ulefone"], [TYPE, MOBILE]], [/; (energy ?\w+)(?: bui|\))/i, /; energizer ([\w ]+)(?: bui|\))/i], [MODEL, [VENDOR, "Energizer"], [TYPE, MOBILE]], [/; cat (b35);/i, /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i], [MODEL, [VENDOR, "Cat"], [TYPE, MOBILE]], [/((?:new )?andromax[\w- ]+)(?: bui|\))/i], [MODEL, [VENDOR, "Smartfren"], [TYPE, MOBILE]], [/droid.+; (a(?:015|06[35]|142p?))/i], [MODEL, [VENDOR, "Nothing"], [TYPE, MOBILE]], [/; (x67 5g|tikeasy \w+|ac[1789]\d\w+)( b|\))/i, /archos ?(5|gamepad2?|([\w ]*[t1789]|hello) ?\d+[\w ]*)( b|\))/i], [MODEL, [VENDOR, "Archos"], [TYPE, TABLET]], [/archos ([\w ]+)( b|\))/i, /; (ac[3-6]\d\w{2,8})( b|\))/i], [MODEL, [VENDOR, "Archos"], [TYPE, MOBILE]], [/(imo) (tab \w+)/i, /(infinix) (x1101b?)/i], [VENDOR, MODEL, [TYPE, TABLET]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus(?! zenw)|dell|jolla|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\w]*)/i, /; (blu|hmd|imo|tcl)[_ ]([\w\+ ]+?)(?: bui|\)|; r)/i, /(hp) ([\w ]+\w)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w ]+?)(?: bui|\)|\/)/i, /(oppo) ?([\w ]+) bui/i], [VENDOR, MODEL, [TYPE, MOBILE]], [/(kobo)\s(ereader|touch)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i], [VENDOR, MODEL, [TYPE, TABLET]], [/(surface duo)/i], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]], [/((?:tegranote|shield t(?!.+d tv))[\w- ]*?)(?: b|\))/i], [MODEL, [VENDOR, NVIDIA], [TYPE, TABLET]], [/(sprint) (\w+)/i], [VENDOR, MODEL, [TYPE, MOBILE]], [/(kin\.[onetw]{3})/i], [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [/droid.+; ([c6]+|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [/smart-tv.+(samsung)/i], [VENDOR, [TYPE, SMARTTV]], [/hbbtv.+maple;(\d+)/i], [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [/tcast.+(lg)e?. ([-\w]+)/i], [VENDOR, MODEL, [TYPE, SMARTTV]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[VENDOR, LG], [TYPE, SMARTTV]], [/(apple) ?tv/i], [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]], [/crkey.*devicetype\/chromecast/i], [[MODEL, CHROMECAST + " Third Generation"], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [/crkey.*devicetype\/([^/]*)/i], [[MODEL, /^/, "Chromecast "], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [/fuchsia.*crkey/i], [[MODEL, CHROMECAST + " Nest Hub"], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [/crkey/i], [[MODEL, CHROMECAST], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [/(portaltv)/i], [MODEL, [VENDOR, FACEBOOK], [TYPE, SMARTTV]], [/droid.+aft(\w+)( bui|\))/i], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [/(shield \w+ tv)/i], [MODEL, [VENDOR, NVIDIA], [TYPE, SMARTTV]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]], [/(bravia[\w ]+)( bui|\))/i], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [/(mi(tv|box)-?\w+) bui/i], [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]], [/Hbbtv.*(technisat) (.*);/i], [VENDOR, MODEL, [TYPE, SMARTTV]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]], [/droid.+; ([\w- ]+) (?:android tv|smart[- ]?tv)/i], [MODEL, [TYPE, SMARTTV]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[TYPE, SMARTTV]], [/(ouya)/i, /(nintendo) (\w+)/i], [VENDOR, MODEL, [TYPE, CONSOLE]], [/droid.+; (shield)( bui|\))/i], [MODEL, [VENDOR, NVIDIA], [TYPE, CONSOLE]], [/(playstation \w+)/i], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [/\b(sm-[lr]\d\d[0156][fnuw]?s?|gear live)\b/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, WEARABLE]], [/((pebble))app/i, /(asus|google|lg|oppo) ((pixel |zen)?watch[\w ]*)( bui|\))/i], [VENDOR, MODEL, [TYPE, WEARABLE]], [/(ow(?:19|20)?we?[1-3]{1,3})/i], [MODEL, [VENDOR, OPPO], [TYPE, WEARABLE]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]], [/(opwwe\d{3})/i], [MODEL, [VENDOR, ONEPLUS], [TYPE, WEARABLE]], [/(moto 360)/i], [MODEL, [VENDOR, MOTOROLA], [TYPE, WEARABLE]], [/(smartwatch 3)/i], [MODEL, [VENDOR, SONY], [TYPE, WEARABLE]], [/(g watch r)/i], [MODEL, [VENDOR, LG], [TYPE, WEARABLE]], [/droid.+; (wt63?0{2,3})\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [/droid.+; (glass) \d/i], [MODEL, [VENDOR, GOOGLE], [TYPE, XR]], [/(pico) (4|neo3(?: link|pro)?)/i], [VENDOR, MODEL, [TYPE, XR]], [/(quest( \d| pro)?s?).+vr/i], [MODEL, [VENDOR, FACEBOOK], [TYPE, XR]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [VENDOR, [TYPE, EMBEDDED]], [/(aeobc)\b/i], [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]], [/(homepod).+mac os/i], [MODEL, [VENDOR, APPLE], [TYPE, EMBEDDED]], [/windows iot/i], [[TYPE, EMBEDDED]], [/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+?(mobile|vr|\d) safari/i], [MODEL, [TYPE, strMapper, {
        mobile: "Mobile",
        xr: "VR",
        "*": TABLET
    }]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[TYPE, TABLET]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[TYPE, MOBILE]], [/droid .+?; ([\w\. -]+)( bui|\))/i], [MODEL, [VENDOR, "Generic"]]],
    engine: [[/windows.+ edge\/([\w\.]+)/i], [VERSION, [NAME, EDGE + "HTML"]], [/(arkweb)\/([\w\.]+)/i], [NAME, VERSION], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [VERSION, [NAME, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [NAME, VERSION], [/ladybird\//i], [[NAME, "LibWeb"]], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [VERSION, NAME]],
    os: [[/microsoft (windows) (vista|xp)/i], [NAME, VERSION], [/(windows (?:phone(?: os)?|mobile|iot))[\/ ]?([\d\.\w ]*)/i], [NAME, [VERSION, strMapper, windowsVersionMap]], [/windows nt 6\.2; (arm)/i, /windows[\/ ]([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[VERSION, strMapper, windowsVersionMap], [NAME, WINDOWS]], [/[adehimnop]{4,7}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[VERSION, /_/g, "."], [NAME, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[NAME, "macOS"], [VERSION, /_/g, "."]], [/android ([\d\.]+).*crkey/i], [VERSION, [NAME, CHROMECAST + " Android"]], [/fuchsia.*crkey\/([\d\.]+)/i], [VERSION, [NAME, CHROMECAST + " Fuchsia"]], [/crkey\/([\d\.]+).*devicetype\/smartspeaker/i], [VERSION, [NAME, CHROMECAST + " SmartSpeaker"]], [/linux.*crkey\/([\d\.]+)/i], [VERSION, [NAME, CHROMECAST + " Linux"]], [/crkey\/([\d\.]+)/i], [VERSION, [NAME, CHROMECAST]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [VERSION, NAME], [/(ubuntu) ([\w\.]+) like android/i], [[NAME, /(.+)/, "$1 Touch"], VERSION], [/(android|bada|blackberry|kaios|maemo|meego|openharmony|qnx|rim tablet os|sailfish|series40|symbian|tizen|webos)\w*[-\/\.; ]?([\d\.]*)/i], [NAME, VERSION], [/\(bb(10);/i], [VERSION, [NAME, BLACKBERRY]], [/(?:symbian ?os|symbos|s60(?=;)|series ?60)[-\/ ]?([\w\.]*)/i], [VERSION, [NAME, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [VERSION, [NAME, FIREFOX + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [VERSION, [NAME, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [VERSION, [NAME, "watchOS"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[NAME, "Chrome OS"], VERSION], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) (\w+)/i, /(xbox); +xbox ([^\);]+)/i, /(pico) .+os([\w\.]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux)(?: arm\w*| x86\w*| ?)([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [NAME, VERSION], [/(sunos) ?([\w\.\d]*)/i], [[NAME, "Solaris"], VERSION], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [NAME, VERSION]]
}
  , defaultProps = function() {
    var xt = {
        init: {},
        isIgnore: {},
        isIgnoreRgx: {},
        toString: {}
    };
    return setProps.call(xt.init, [[UA_BROWSER, [NAME, VERSION, MAJOR, TYPE]], [UA_CPU, [ARCHITECTURE]], [UA_DEVICE, [TYPE, MODEL, VENDOR]], [UA_ENGINE, [NAME, VERSION]], [UA_OS, [NAME, VERSION]]]),
    setProps.call(xt.isIgnore, [[UA_BROWSER, [VERSION, MAJOR]], [UA_ENGINE, [VERSION]], [UA_OS, [VERSION]]]),
    setProps.call(xt.isIgnoreRgx, [[UA_BROWSER, / ?browser$/i], [UA_OS, / ?os$/i]]),
    setProps.call(xt.toString, [[UA_BROWSER, [NAME, VERSION]], [UA_CPU, [ARCHITECTURE]], [UA_DEVICE, [VENDOR, MODEL]], [UA_ENGINE, [NAME, VERSION]], [UA_OS, [NAME, VERSION]]]),
    xt
}()
  , createIData = function(xt, Cn) {
    var as = defaultProps.init[Cn]
      , cs = defaultProps.isIgnore[Cn] || 0
      , Cs = defaultProps.isIgnoreRgx[Cn] || 0
      , Ls = defaultProps.toString[Cn] || 0;
    function Vs() {
        setProps.call(this, as)
    }
    return Vs.prototype.getItem = function() {
        return xt
    }
    ,
    Vs.prototype.withClientHints = function() {
        return NAVIGATOR_UADATA ? NAVIGATOR_UADATA.getHighEntropyValues(CH_ALL_VALUES).then(function(Ws) {
            return xt.setCH(new UACHData(Ws,!1)).parseCH().get()
        }) : xt.parseCH().get()
    }
    ,
    Vs.prototype.withFeatureCheck = function() {
        return xt.detectFeature().get()
    }
    ,
    Cn != UA_RESULT && (Vs.prototype.is = function(Ws) {
        var Xs = !1;
        for (var ga in this)
            if (this.hasOwnProperty(ga) && !has(cs, ga) && lowerize(Cs ? strip(Cs, this[ga]) : this[ga]) == lowerize(Cs ? strip(Cs, Ws) : Ws)) {
                if (Xs = !0,
                Ws != UNDEF_TYPE)
                    break
            } else if (Ws == UNDEF_TYPE && Xs) {
                Xs = !Xs;
                break
            }
        return Xs
    }
    ,
    Vs.prototype.toString = function() {
        var Ws = EMPTY;
        for (var Xs in Ls)
            typeof this[Ls[Xs]] !== UNDEF_TYPE && (Ws += (Ws ? " " : EMPTY) + this[Ls[Xs]]);
        return Ws || UNDEF_TYPE
    }
    ),
    NAVIGATOR_UADATA || (Vs.prototype.then = function(Ws) {
        var Xs = this
          , ga = function() {
            for (var yl in Xs)
                Xs.hasOwnProperty(yl) && (this[yl] = Xs[yl])
        };
        ga.prototype = {
            is: Vs.prototype.is,
            toString: Vs.prototype.toString
        };
        var ba = new ga;
        return Ws(ba),
        ba
    }
    ),
    new Vs
};
function UACHData(xt, Cn) {
    if (xt = xt || {},
    setProps.call(this, CH_ALL_VALUES),
    Cn)
        setProps.call(this, [[BRANDS, itemListToArray(xt[CH_HEADER])], [FULLVERLIST, itemListToArray(xt[CH_HEADER_FULL_VER_LIST])], [MOBILE, /\?1/.test(xt[CH_HEADER_MOBILE])], [MODEL, stripQuotes(xt[CH_HEADER_MODEL])], [PLATFORM, stripQuotes(xt[CH_HEADER_PLATFORM])], [PLATFORMVER, stripQuotes(xt[CH_HEADER_PLATFORM_VER])], [ARCHITECTURE, stripQuotes(xt[CH_HEADER_ARCH])], [FORMFACTORS, itemListToArray(xt[CH_HEADER_FORM_FACTORS])], [BITNESS, stripQuotes(xt[CH_HEADER_BITNESS])]]);
    else
        for (var as in xt)
            this.hasOwnProperty(as) && typeof xt[as] !== UNDEF_TYPE && (this[as] = xt[as])
}
function UAItem(xt, Cn, as, cs) {
    return this.get = function(Cs) {
        return Cs ? this.data.hasOwnProperty(Cs) ? this.data[Cs] : void 0 : this.data
    }
    ,
    this.set = function(Cs, Ls) {
        return this.data[Cs] = Ls,
        this
    }
    ,
    this.setCH = function(Cs) {
        return this.uaCH = Cs,
        this
    }
    ,
    this.detectFeature = function() {
        if (NAVIGATOR && NAVIGATOR.userAgent == this.ua)
            switch (this.itemType) {
            case UA_BROWSER:
                NAVIGATOR.brave && typeof NAVIGATOR.brave.isBrave == FUNC_TYPE && this.set(NAME, "Brave");
                break;
            case UA_DEVICE:
                !this.get(TYPE) && NAVIGATOR_UADATA && NAVIGATOR_UADATA[MOBILE] && this.set(TYPE, MOBILE),
                this.get(MODEL) == "Macintosh" && NAVIGATOR && typeof NAVIGATOR.standalone !== UNDEF_TYPE && NAVIGATOR.maxTouchPoints && NAVIGATOR.maxTouchPoints > 2 && this.set(MODEL, "iPad").set(TYPE, TABLET);
                break;
            case UA_OS:
                !this.get(NAME) && NAVIGATOR_UADATA && NAVIGATOR_UADATA[PLATFORM] && this.set(NAME, NAVIGATOR_UADATA[PLATFORM]);
                break;
            case UA_RESULT:
                var Cs = this.data
                  , Ls = function(Vs) {
                    return Cs[Vs].getItem().detectFeature().get()
                };
                this.set(UA_BROWSER, Ls(UA_BROWSER)).set(UA_CPU, Ls(UA_CPU)).set(UA_DEVICE, Ls(UA_DEVICE)).set(UA_ENGINE, Ls(UA_ENGINE)).set(UA_OS, Ls(UA_OS))
            }
        return this
    }
    ,
    this.parseUA = function() {
        return this.itemType != UA_RESULT && rgxMapper.call(this.data, this.ua, this.rgxMap),
        this.itemType == UA_BROWSER && this.set(MAJOR, majorize(this.get(VERSION))),
        this
    }
    ,
    this.parseCH = function() {
        var Cs = this.uaCH
          , Ls = this.rgxMap;
        switch (this.itemType) {
        case UA_BROWSER:
        case UA_ENGINE:
            var Vs = Cs[FULLVERLIST] || Cs[BRANDS], Ws;
            if (Vs)
                for (var Xs in Vs) {
                    var ga = Vs[Xs].brand || Vs[Xs]
                      , ba = Vs[Xs].version;
                    this.itemType == UA_BROWSER && !/not.a.brand/i.test(ga) && (!Ws || /chrom/i.test(Ws) && ga != CHROMIUM) && (ga = strMapper(ga, {
                        Chrome: "Google Chrome",
                        Edge: "Microsoft Edge",
                        "Chrome WebView": "Android WebView",
                        "Chrome Headless": "HeadlessChrome",
                        "Huawei Browser": "HuaweiBrowser",
                        "MIUI Browser": "Miui Browser",
                        "Opera Mobi": "OperaMobile",
                        Yandex: "YaBrowser"
                    }),
                    this.set(NAME, ga).set(VERSION, ba).set(MAJOR, majorize(ba)),
                    Ws = ga),
                    this.itemType == UA_ENGINE && ga == CHROMIUM && this.set(VERSION, ba)
                }
            break;
        case UA_CPU:
            var yl = Cs[ARCHITECTURE];
            yl && (yl && Cs[BITNESS] == "64" && (yl += "64"),
            rgxMapper.call(this.data, yl + ";", Ls));
            break;
        case UA_DEVICE:
            if (Cs[MOBILE] && this.set(TYPE, MOBILE),
            Cs[MODEL] && (this.set(MODEL, Cs[MODEL]),
            !this.get(TYPE) || !this.get(VENDOR))) {
                var xl = {};
                rgxMapper.call(xl, "droid 9; " + Cs[MODEL] + ")", Ls),
                !this.get(TYPE) && xl.type && this.set(TYPE, xl.type),
                !this.get(VENDOR) && xl.vendor && this.set(VENDOR, xl.vendor)
            }
            if (Cs[FORMFACTORS]) {
                var wl;
                if (typeof Cs[FORMFACTORS] != "string")
                    for (var _l = 0; !wl && _l < Cs[FORMFACTORS].length; )
                        wl = strMapper(Cs[FORMFACTORS][_l++], formFactorsMap);
                else
                    wl = strMapper(Cs[FORMFACTORS], formFactorsMap);
                this.set(TYPE, wl)
            }
            break;
        case UA_OS:
            var El = Cs[PLATFORM];
            if (El) {
                var Cl = Cs[PLATFORMVER];
                El == WINDOWS && (Cl = parseInt(majorize(Cl), 10) >= 13 ? "11" : "10"),
                this.set(NAME, El).set(VERSION, Cl)
            }
            this.get(NAME) == WINDOWS && Cs[MODEL] == "Xbox" && this.set(NAME, "Xbox").set(VERSION, void 0);
            break;
        case UA_RESULT:
            var $l = this.data
              , Sl = function(Tl) {
                return $l[Tl].getItem().setCH(Cs).parseCH().get()
            };
            this.set(UA_BROWSER, Sl(UA_BROWSER)).set(UA_CPU, Sl(UA_CPU)).set(UA_DEVICE, Sl(UA_DEVICE)).set(UA_ENGINE, Sl(UA_ENGINE)).set(UA_OS, Sl(UA_OS))
        }
        return this
    }
    ,
    setProps.call(this, [["itemType", xt], ["ua", Cn], ["uaCH", cs], ["rgxMap", as], ["data", createIData(this, xt)]]),
    this
}
function UAParser(xt, Cn, as) {
    if (typeof xt === OBJ_TYPE ? (isExtensions(xt, !0) ? (typeof Cn === OBJ_TYPE && (as = Cn),
    Cn = xt) : (as = xt,
    Cn = void 0),
    xt = void 0) : typeof xt === STR_TYPE && !isExtensions(Cn, !0) && (as = Cn,
    Cn = void 0),
    as && typeof as.append === FUNC_TYPE) {
        var cs = {};
        as.forEach(function(Xs, ga) {
            cs[ga] = Xs
        }),
        as = cs
    }
    if (!(this instanceof UAParser))
        return new UAParser(xt,Cn,as).getResult();
    var Cs = typeof xt === STR_TYPE ? xt : as && as[USER_AGENT] ? as[USER_AGENT] : NAVIGATOR && NAVIGATOR.userAgent ? NAVIGATOR.userAgent : EMPTY
      , Ls = new UACHData(as,!0)
      , Vs = Cn ? extend(defaultRegexes, Cn) : defaultRegexes
      , Ws = function(Xs) {
        return Xs == UA_RESULT ? function() {
            return new UAItem(Xs,Cs,Vs,Ls).set("ua", Cs).set(UA_BROWSER, this.getBrowser()).set(UA_CPU, this.getCPU()).set(UA_DEVICE, this.getDevice()).set(UA_ENGINE, this.getEngine()).set(UA_OS, this.getOS()).get()
        }
        : function() {
            return new UAItem(Xs,Cs,Vs[Xs],Ls).parseUA().get()
        }
    };
    return setProps.call(this, [["getBrowser", Ws(UA_BROWSER)], ["getCPU", Ws(UA_CPU)], ["getDevice", Ws(UA_DEVICE)], ["getEngine", Ws(UA_ENGINE)], ["getOS", Ws(UA_OS)], ["getResult", Ws(UA_RESULT)], ["getUA", function() {
        return Cs
    }
    ], ["setUA", function(Xs) {
        return isString$1(Xs) && (Cs = Xs.length > UA_MAX_LENGTH ? trim(Xs, UA_MAX_LENGTH) : Xs),
        this
    }
    ]]).setUA(Cs),
    this
}
UAParser.VERSION = LIBVERSION;
UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR, TYPE]);
UAParser.CPU = enumerize([ARCHITECTURE]);
UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);
const parser = new UAParser(navigator.userAgent)
  , isMobile = () => parser.getDevice().type === "mobile"
  , isIphone = () => parser.getOS().name === "iOS"
  , header$4 = "_header_e05uz_1"
  , headerLeft = "_headerLeft_e05uz_8"
  , headerAvatar = "_headerAvatar_e05uz_13"
  , headerAvatarWrapper = "_headerAvatarWrapper_e05uz_25"
  , headerBalance = "_headerBalance_e05uz_28"
  , headerBalanceIcon = "_headerBalanceIcon_e05uz_34"
  , headerBalanceAmount = "_headerBalanceAmount_e05uz_38"
  , headerRight = "_headerRight_e05uz_42"
  , headerIcon = "_headerIcon_e05uz_47"
  , headerIconMedium = "_headerIconMedium_e05uz_53"
  , headerWalletTooltipWrapper = "_headerWalletTooltipWrapper_e05uz_62"
  , profilePhoto = "_profilePhoto_e05uz_69"
  , profileInitials = "_profileInitials_e05uz_74"
  , profileIcon = "_profileIcon_e05uz_90"
  , styles$1r = {
    header: header$4,
    headerLeft,
    headerAvatar,
    headerAvatarWrapper,
    headerBalance,
    headerBalanceIcon,
    headerBalanceAmount,
    headerRight,
    headerIcon,
    headerIconMedium,
    headerWalletTooltipWrapper,
    profilePhoto,
    profileInitials,
    profileIcon
}
  , SvgTonIcon = xt => reactExports.createElement("svg", {
    width: 22,
    height: 22,
    viewBox: "0 0 22 22",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M19.4687 6.33953L11.7971 18.52C11.7037 18.6671 11.5745 18.7882 11.4216 18.8721C11.2686 18.956 11.0969 19 10.9223 19C10.7464 19.0003 10.5732 18.956 10.4193 18.8711C10.2653 18.7862 10.1356 18.6636 10.0423 18.5148L2.5209 6.33437C2.31019 5.99296 2.19906 5.59977 2.19996 5.1989C2.2095 4.60707 2.45412 4.04319 2.88016 3.63099C3.30619 3.21879 3.87883 2.99194 4.47243 3.00022H17.5378C18.7854 3.00022 19.8 3.98085 19.8 5.19374C19.8 5.59631 19.6861 5.99373 19.4687 6.33953ZM4.3689 5.93179L9.96466 14.5355V5.06471H4.95384C4.37407 5.06471 4.11525 5.44664 4.3689 5.93179ZM12.0352 14.5355L17.631 5.93179C17.8898 5.44664 17.6258 5.06471 17.0461 5.06471H12.0352V14.5355Z",
    fill: "#7E7E82"
}))
  , SvgAddWallet = xt => reactExports.createElement("svg", {
    width: 23,
    height: 23,
    viewBox: "0 0 23 23",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("rect", {
    x: 4.5,
    y: 3.5,
    width: 15,
    height: 15,
    rx: 3.5,
    stroke: "#0A84FF",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M13.3889 11C13.3889 9.80336 14.359 8.83331 15.5556 8.83331H19.5V13.1666H15.5556C14.359 13.1666 13.3889 12.1966 13.3889 11Z",
    stroke: "#0A84FF",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("circle", {
    cx: 16,
    cy: 11,
    r: .5,
    stroke: "#0A84FF",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M12 16.5C12 17.5312 11.7112 18.5075 11.2025 19.3325C10.9137 19.8275 10.5425 20.2675 10.1162 20.625C9.15375 21.4913 7.88875 22 6.5 22C4.4925 22 2.74625 20.9275 1.7975 19.3325C1.28875 18.5075 1 17.5312 1 16.5C1 14.7675 1.7975 13.2138 3.0625 12.21C4.01125 11.4538 5.2075 11 6.5 11C9.53875 11 12 13.4612 12 16.5Z",
    fill: "#1D2733",
    stroke: "#0A84FF",
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M8.55111 16.4718H4.45361",
    stroke: "#0A84FF",
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M6.5 14.4644V18.5756",
    stroke: "#0A84FF",
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))
  , SvgCart = xt => reactExports.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M16.3776 10.6153H6.30998L5.07922 4.46143H17.3869C17.4769 4.46176 17.5657 4.48183 17.6471 4.52022C17.7285 4.55861 17.8005 4.6144 17.858 4.68364C17.9155 4.75288 17.9571 4.83389 17.9799 4.92096C18.0027 5.00803 18.0061 5.09904 17.9899 5.18758L16.9807 10.1106C16.9572 10.253 16.8834 10.3822 16.7727 10.4748C16.6621 10.5673 16.5219 10.6172 16.3776 10.6153V10.6153Z",
    stroke: "#0A84FF",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M5.0791 4.46154L4.56218 2.49231C4.53381 2.35331 4.45828 2.22838 4.34838 2.13867C4.23849 2.04896 4.10097 1.99997 3.95911 2H2.00219",
    stroke: "#0A84FF",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M6.31042 10.6155L6.82734 13.2001C6.85572 13.3391 6.93124 13.464 7.04114 13.5537C7.15104 13.6434 7.28855 13.6924 7.43042 13.6924H14.9258",
    stroke: "#0A84FF",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M14.3104 18.5001C13.6944 18.5001 13.195 18.0007 13.195 17.3847C13.195 16.7687 13.6944 16.2693 14.3104 16.2693C14.9264 16.2693 15.4258 16.7687 15.4258 17.3847C15.4258 18.0007 14.9264 18.5001 14.3104 18.5001Z",
    stroke: "#0A84FF",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M8.1561 18.5001C7.54009 18.5001 7.04072 18.0007 7.04072 17.3847C7.04072 16.7687 7.54009 16.2693 8.1561 16.2693C8.77211 16.2693 9.27148 16.7687 9.27148 17.3847C9.27148 18.0007 8.77211 18.5001 8.1561 18.5001Z",
    stroke: "#0A84FF",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))
  , SvgSupport = xt => reactExports.createElement("svg", {
    width: 18,
    height: 18,
    viewBox: "0 0 18 18",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("g", {
    clipPath: "url(#clip0_1112_6045)"
}, reactExports.createElement("path", {
    d: "M1.92854 7.71429H3.21425C3.38475 7.71429 3.54826 7.78202 3.66882 7.90258C3.78938 8.02314 3.85711 8.18666 3.85711 8.35715V11.5714C3.85711 11.7419 3.78938 11.9054 3.66882 12.026C3.54826 12.1466 3.38475 12.2143 3.21425 12.2143H1.92854C1.58754 12.2143 1.26052 12.0788 1.0194 11.8377C0.778281 11.5966 0.642822 11.2696 0.642822 10.9286V9.00001C0.642822 8.65902 0.778281 8.33199 1.0194 8.09087C1.26052 7.84975 1.58754 7.71429 1.92854 7.71429V7.71429Z",
    stroke: "#0A84FF",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M16.0713 12.2143H14.7856C14.6151 12.2143 14.4516 12.1466 14.3311 12.026C14.2105 11.9054 14.1428 11.7419 14.1428 11.5714V8.35715C14.1428 8.18666 14.2105 8.02314 14.3311 7.90258C14.4516 7.78202 14.6151 7.71429 14.7856 7.71429H16.0713C16.4123 7.71429 16.7394 7.84975 16.9805 8.09087C17.2216 8.33199 17.3571 8.65902 17.3571 9.00001V10.9286C17.3571 11.2696 17.2216 11.5966 16.9805 11.8377C16.7394 12.0788 16.4123 12.2143 16.0713 12.2143V12.2143Z",
    stroke: "#0A84FF",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M12.2142 15.75C12.8962 15.75 13.5503 15.4791 14.0325 14.9969C14.5147 14.5146 14.7857 13.8606 14.7857 13.1786V12.2143",
    stroke: "#0A84FF",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M10.6071 14.1429C11.0334 14.1429 11.4421 14.3122 11.7435 14.6136C12.0449 14.915 12.2143 15.3238 12.2143 15.75C12.2143 16.1763 12.0449 16.585 11.7435 16.8864C11.4421 17.1878 11.0334 17.3572 10.6071 17.3572H8.67855C8.25231 17.3572 7.84353 17.1878 7.54213 16.8864C7.24073 16.585 7.07141 16.1763 7.07141 15.75C7.07141 15.3238 7.24073 14.915 7.54213 14.6136C7.84353 14.3122 8.25231 14.1429 8.67855 14.1429H10.6071Z",
    stroke: "#0A84FF",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M3.21423 7.71431V6.4286C3.21423 4.89413 3.8238 3.42251 4.90883 2.33748C5.99386 1.25245 7.46548 0.642883 8.99995 0.642883C10.5344 0.642883 12.006 1.25245 13.0911 2.33748C14.1761 3.42251 14.7857 4.89413 14.7857 6.4286V7.71431",
    stroke: "#0A84FF",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M7.07141 5.14288V7.07145",
    stroke: "#0A84FF",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M10.9286 5.14288V7.07145",
    stroke: "#0A84FF",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M7.07141 9.64288C7.07141 11.3529 10.9286 11.3529 10.9286 9.64288",
    stroke: "#0A84FF",
    strokeLinecap: "round",
    strokeLinejoin: "round"
})), reactExports.createElement("defs", null, reactExports.createElement("clipPath", {
    id: "clip0_1112_6045"
}, reactExports.createElement("rect", {
    width: 18,
    height: 18,
    fill: "white"
}))))
  , SvgInfoCircleBlue = xt => reactExports.createElement("svg", {
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("g", {
    id: "info-circle"
}, reactExports.createElement("rect", {
    width: 16,
    height: 16,
    rx: 8,
    fill: "#1D2733"
}), reactExports.createElement("g", {
    id: "vuesax/linear/info-circle"
}, reactExports.createElement("g", {
    id: "info-circle_2"
}, reactExports.createElement("path", {
    id: "Vector",
    d: "M8 3C10.75 3 13 5.25 13 8C13 10.75 10.75 13 8 13C5.25 13 3 10.75 3 8C3 5.25 5.25 3 8 3Z",
    stroke: "#0A84FF",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_2",
    d: "M8 10V7.5",
    stroke: "#0A84FF",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_3",
    d: "M7.99725 6H8.00174",
    stroke: "#0A84FF",
    strokeLinecap: "round",
    strokeLinejoin: "round"
})))))
  , button$4 = "_button_14yx4_1"
  , success$1 = "_success_14yx4_17"
  , error$1 = "_error_14yx4_21"
  , primary$1 = "_primary_14yx4_25"
  , loading = "_loading_14yx4_29"
  , secondary$1 = "_secondary_14yx4_33"
  , warning$1 = "_warning_14yx4_40"
  , white = "_white_14yx4_44"
  , small$2 = "_small_14yx4_51"
  , loadingIcon = "_loadingIcon_14yx4_55"
  , iconButton = "_iconButton_14yx4_59"
  , medium$1 = "_medium_14yx4_63"
  , spin$1 = "_spin_14yx4_1"
  , styles$1q = {
    button: button$4,
    success: success$1,
    error: error$1,
    primary: primary$1,
    loading,
    secondary: secondary$1,
    warning: warning$1,
    white,
    small: small$2,
    loadingIcon,
    iconButton,
    medium: medium$1,
    spin: spin$1
}
  , SvgSpinner = xt => reactExports.createElement("svg", {
    width: 21,
    height: 20,
    viewBox: "0 0 21 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M20.5 10C20.5 15.5228 16.0228 20 10.5 20C4.97715 20 0.5 15.5228 0.5 10C0.5 4.47715 4.97715 0 10.5 0C16.0228 0 20.5 4.47715 20.5 10ZM2.7 10C2.7 14.3078 6.19218 17.8 10.5 17.8C14.8078 17.8 18.3 14.3078 18.3 10C18.3 5.69218 14.8078 2.2 10.5 2.2C6.19218 2.2 2.7 5.69218 2.7 10Z",
    fill: "white",
    fillOpacity: .5
}), reactExports.createElement("path", {
    d: "M10.5 1.1C10.5 0.492487 10.006 -0.006254 9.4022 0.0604392C8.24858 0.187854 7.12307 0.515464 6.07711 1.03127C4.70142 1.70969 3.50023 2.69548 2.56647 3.91239C1.6327 5.12929 0.991391 6.54469 0.692147 8.0491C0.464628 9.19291 0.439485 10.3649 0.61499 11.5122C0.706855 12.1127 1.31645 12.4607 1.90326 12.3035C2.49007 12.1463 2.83001 11.5428 2.75682 10.9397C2.65755 10.1218 2.68823 9.29094 2.84987 8.4783C3.08329 7.30486 3.58351 6.20085 4.31184 5.25166C5.04018 4.30247 5.97711 3.53356 7.05015 3.00439C7.79327 2.63793 8.58787 2.39325 9.40363 2.27744C10.0051 2.19204 10.5 1.70751 10.5 1.1Z",
    fill: "white"
}))
  , Button = ({onClick: xt, children: Cn, disabled: as, loading: cs, className: Cs, variant: Ls="secondary", size: Vs="medium", iconButton: Ws=!1}) => jsxRuntimeExports.jsx("button", {
    className: classNames$1({
        [styles$1q.iconButton]: Ws,
        [styles$1q.loading]: cs
    }, [styles$1q.button], styles$1q[Ls], styles$1q[Vs], Cs),
    onClick: xt,
    disabled: as || cs,
    children: cs ? jsxRuntimeExports.jsx(SvgSpinner, {
        className: styles$1q.loadingIcon
    }) : Cn
});
var dist$1 = {}
  , Address$1 = {};
const SymbolInspect = Symbol.for("nodejs.util.inspect.custom");
var symbol_inspect = SymbolInspect
  , crc16$2 = {};
Object.defineProperty(crc16$2, "__esModule", {
    value: !0
});
crc16$2.crc16 = void 0;
function crc16$1(xt) {
    let as = 0;
    const cs = Buffer.alloc(xt.length + 2);
    cs.set(xt);
    for (let Cs of cs) {
        let Ls = 128;
        for (; Ls > 0; )
            as <<= 1,
            Cs & Ls && (as += 1),
            Ls >>= 1,
            as > 65535 && (as &= 65535,
            as ^= 4129)
    }
    return Buffer.from([Math.floor(as / 256), as % 256])
}
crc16$2.crc16 = crc16$1;
var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(xt) {
    return xt && xt.__esModule ? xt : {
        default: xt
    }
}
, _a$2;
Object.defineProperty(Address$1, "__esModule", {
    value: !0
});
Address$1.address = Address$1.Address = void 0;
const symbol_inspect_1$2 = __importDefault$7(symbol_inspect)
  , crc16_1$1 = crc16$2
  , bounceable_tag = 17
  , non_bounceable_tag = 81
  , test_flag = 128;
function parseFriendlyAddress(xt) {
    if (typeof xt == "string" && !Address.isFriendly(xt))
        throw new Error("Unknown address type");
    const Cn = Buffer.isBuffer(xt) ? xt : Buffer.from(xt, "base64");
    if (Cn.length !== 36)
        throw new Error("Unknown address type: byte length is not equal to 36");
    const as = Cn.subarray(0, 34)
      , cs = Cn.subarray(34, 36)
      , Cs = (0,
    crc16_1$1.crc16)(as);
    if (!(Cs[0] === cs[0] && Cs[1] === cs[1]))
        throw new Error("Invalid checksum: " + xt);
    let Ls = as[0]
      , Vs = !1
      , Ws = !1;
    if (Ls & test_flag && (Vs = !0,
    Ls = Ls ^ test_flag),
    Ls !== bounceable_tag && Ls !== non_bounceable_tag)
        throw "Unknown address tag";
    Ws = Ls === bounceable_tag;
    let Xs = null;
    as[1] === 255 ? Xs = -1 : Xs = as[1];
    const ga = as.subarray(2, 34);
    return {
        isTestOnly: Vs,
        isBounceable: Ws,
        workchain: Xs,
        hashPart: ga
    }
}
class Address {
    static isAddress(Cn) {
        return Cn instanceof Address
    }
    static isFriendly(Cn) {
        return !(Cn.length !== 48 || !/[A-Za-z0-9+/_-]+/.test(Cn))
    }
    static isRaw(Cn) {
        if (Cn.indexOf(":") === -1)
            return !1;
        let[as,cs] = Cn.split(":");
        return !(!Number.isInteger(parseFloat(as)) || !/[a-f0-9]+/.test(cs.toLowerCase()) || cs.length !== 64)
    }
    static normalize(Cn) {
        return typeof Cn == "string" ? Address.parse(Cn).toString() : Cn.toString()
    }
    static parse(Cn) {
        if (Address.isFriendly(Cn))
            return this.parseFriendly(Cn).address;
        if (Address.isRaw(Cn))
            return this.parseRaw(Cn);
        throw new Error("Unknown address type: " + Cn)
    }
    static parseRaw(Cn) {
        let as = parseInt(Cn.split(":")[0])
          , cs = Buffer.from(Cn.split(":")[1], "hex");
        return new Address(as,cs)
    }
    static parseFriendly(Cn) {
        if (Buffer.isBuffer(Cn)) {
            let as = parseFriendlyAddress(Cn);
            return {
                isBounceable: as.isBounceable,
                isTestOnly: as.isTestOnly,
                address: new Address(as.workchain,as.hashPart)
            }
        } else {
            let as = Cn.replace(/\-/g, "+").replace(/_/g, "/")
              , cs = parseFriendlyAddress(as);
            return {
                isBounceable: cs.isBounceable,
                isTestOnly: cs.isTestOnly,
                address: new Address(cs.workchain,cs.hashPart)
            }
        }
    }
    constructor(Cn, as) {
        if (this.toRawString = () => this.workChain + ":" + this.hash.toString("hex"),
        this.toRaw = () => {
            const cs = Buffer.alloc(36);
            return cs.set(this.hash),
            cs.set([this.workChain, this.workChain, this.workChain, this.workChain], 32),
            cs
        }
        ,
        this.toStringBuffer = cs => {
            let Cs = cs && cs.testOnly !== void 0 ? cs.testOnly : !1
              , Vs = (cs && cs.bounceable !== void 0 ? cs.bounceable : !0) ? bounceable_tag : non_bounceable_tag;
            Cs && (Vs |= test_flag);
            const Ws = Buffer.alloc(34);
            Ws[0] = Vs,
            Ws[1] = this.workChain,
            Ws.set(this.hash, 2);
            const Xs = Buffer.alloc(36);
            return Xs.set(Ws),
            Xs.set((0,
            crc16_1$1.crc16)(Ws), 34),
            Xs
        }
        ,
        this.toString = cs => {
            let Cs = cs && cs.urlSafe !== void 0 ? cs.urlSafe : !0
              , Ls = this.toStringBuffer(cs);
            return Cs ? Ls.toString("base64").replace(/\+/g, "-").replace(/\//g, "_") : Ls.toString("base64")
        }
        ,
        this[_a$2] = () => this.toString(),
        as.length !== 32)
            throw new Error("Invalid address hash length: " + as.length);
        this.workChain = Cn,
        this.hash = as,
        Object.freeze(this)
    }
    equals(Cn) {
        return Cn.workChain !== this.workChain ? !1 : Cn.hash.equals(this.hash)
    }
}
Address$1.Address = Address;
_a$2 = symbol_inspect_1$2.default;
function address(xt) {
    return Address.parse(xt)
}
Address$1.address = address;
var ExternalAddress$1 = {}, __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(xt) {
    return xt && xt.__esModule ? xt : {
        default: xt
    }
}
, _a$1;
Object.defineProperty(ExternalAddress$1, "__esModule", {
    value: !0
});
ExternalAddress$1.ExternalAddress = void 0;
const symbol_inspect_1$1 = __importDefault$6(symbol_inspect);
class ExternalAddress {
    static isAddress(Cn) {
        return Cn instanceof ExternalAddress
    }
    constructor(Cn, as) {
        this[_a$1] = () => this.toString(),
        this.value = Cn,
        this.bits = as
    }
    toString() {
        return `External<${this.bits}:${this.value}>`
    }
}
ExternalAddress$1.ExternalAddress = ExternalAddress;
_a$1 = symbol_inspect_1$1.default;
var ADNLAddress$1 = {}
  , base32 = {};
Object.defineProperty(base32, "__esModule", {
    value: !0
});
base32.base32Decode = base32.base32Encode = void 0;
const alphabet = "abcdefghijklmnopqrstuvwxyz234567";
function base32Encode(xt) {
    const Cn = xt.byteLength;
    let as = 0
      , cs = 0
      , Cs = "";
    for (let Ls = 0; Ls < Cn; Ls++)
        for (cs = cs << 8 | xt[Ls],
        as += 8; as >= 5; )
            Cs += alphabet[cs >>> as - 5 & 31],
            as -= 5;
    return as > 0 && (Cs += alphabet[cs << 5 - as & 31]),
    Cs
}
base32.base32Encode = base32Encode;
function readChar(xt, Cn) {
    const as = xt.indexOf(Cn);
    if (as === -1)
        throw new Error("Invalid character found: " + Cn);
    return as
}
function base32Decode(xt) {
    let Cn;
    Cn = xt.toLowerCase();
    const {length: as} = Cn;
    let cs = 0
      , Cs = 0
      , Ls = 0;
    const Vs = Buffer.alloc(as * 5 / 8 | 0);
    for (let Ws = 0; Ws < as; Ws++)
        Cs = Cs << 5 | readChar(alphabet, Cn[Ws]),
        cs += 5,
        cs >= 8 && (Vs[Ls++] = Cs >>> cs - 8 & 255,
        cs -= 8);
    return Vs
}
base32.base32Decode = base32Decode;
var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(xt) {
    return xt && xt.__esModule ? xt : {
        default: xt
    }
}
, _a;
Object.defineProperty(ADNLAddress$1, "__esModule", {
    value: !0
});
ADNLAddress$1.ADNLAddress = void 0;
const symbol_inspect_1 = __importDefault$5(symbol_inspect)
  , base32_1 = base32
  , crc16_1 = crc16$2;
class ADNLAddress {
    static parseFriendly(Cn) {
        if (Cn.length !== 55)
            throw Error("Invalid address");
        Cn = "f" + Cn;
        let as = (0,
        base32_1.base32Decode)(Cn);
        if (as[0] !== 45)
            throw Error("Invalid address");
        let cs = as.slice(33);
        if (!(0,
        crc16_1.crc16)(as.slice(0, 33)).equals(cs))
            throw Error("Invalid address");
        return new ADNLAddress(as.slice(1, 33))
    }
    static parseRaw(Cn) {
        const as = Buffer.from(Cn, "base64");
        return new ADNLAddress(as)
    }
    constructor(Cn) {
        if (this.toRaw = () => this.address.toString("hex").toUpperCase(),
        this.toString = () => {
            let as = Buffer.concat([Buffer.from([45]), this.address])
              , cs = (0,
            crc16_1.crc16)(as);
            return as = Buffer.concat([as, cs]),
            (0,
            base32_1.base32Encode)(as).slice(1)
        }
        ,
        this[_a] = () => this.toString(),
        Cn.length !== 32)
            throw Error("Invalid address");
        this.address = Cn
    }
    equals(Cn) {
        return this.address.equals(Cn.address)
    }
}
ADNLAddress$1.ADNLAddress = ADNLAddress;
_a = symbol_inspect_1.default;
var contractAddress$1 = {}, Builder = {}, BitBuilder = {}, BitString = {}, paddedBits = {}, hasRequiredPaddedBits;
function requirePaddedBits() {
    if (hasRequiredPaddedBits)
        return paddedBits;
    hasRequiredPaddedBits = 1,
    Object.defineProperty(paddedBits, "__esModule", {
        value: !0
    }),
    paddedBits.paddedBufferToBits = paddedBits.bitsToPaddedBuffer = void 0;
    const xt = requireBitBuilder()
      , Cn = requireBitString();
    function as(Cs) {
        let Ls = new xt.BitBuilder(Math.ceil(Cs.length / 8) * 8);
        Ls.writeBits(Cs);
        let Vs = Math.ceil(Cs.length / 8) * 8 - Cs.length;
        for (let Ws = 0; Ws < Vs; Ws++)
            Ws === 0 ? Ls.writeBit(1) : Ls.writeBit(0);
        return Ls.buffer()
    }
    paddedBits.bitsToPaddedBuffer = as;
    function cs(Cs) {
        let Ls = 0;
        for (let Vs = Cs.length - 1; Vs >= 0; Vs--)
            if (Cs[Vs] !== 0) {
                const Ws = Cs[Vs];
                let Xs = Ws & -Ws;
                Xs & 1 || (Xs = Math.log2(Xs) + 1),
                Vs > 0 && (Ls = Vs << 3),
                Ls += 8 - Xs;
                break
            }
        return new Cn.BitString(Cs,0,Ls)
    }
    return paddedBits.paddedBufferToBits = cs,
    paddedBits
}
var hasRequiredBitString;
function requireBitString() {
    if (hasRequiredBitString)
        return BitString;
    hasRequiredBitString = 1;
    var xt = commonjsGlobal && commonjsGlobal.__importDefault || function(Ls) {
        return Ls && Ls.__esModule ? Ls : {
            default: Ls
        }
    }
    , Cn;
    Object.defineProperty(BitString, "__esModule", {
        value: !0
    }),
    BitString.BitString = void 0;
    const as = requirePaddedBits()
      , cs = xt(symbol_inspect);
    let Cs = class g1 {
        static isBitString(Vs) {
            return Vs instanceof g1
        }
        constructor(Vs, Ws, Xs) {
            if (this[Cn] = () => this.toString(),
            Xs < 0)
                throw new Error(`Length ${Xs} is out of bounds`);
            this._length = Xs,
            this._data = Vs,
            this._offset = Ws
        }
        get length() {
            return this._length
        }
        at(Vs) {
            if (Vs >= this._length)
                throw new Error(`Index ${Vs} > ${this._length} is out of bounds`);
            if (Vs < 0)
                throw new Error(`Index ${Vs} < 0 is out of bounds`);
            let Ws = this._offset + Vs >> 3
              , Xs = 7 - (this._offset + Vs) % 8;
            return (this._data[Ws] & 1 << Xs) !== 0
        }
        substring(Vs, Ws) {
            if (Vs > this._length)
                throw new Error(`Offset(${Vs}) > ${this._length} is out of bounds`);
            if (Vs < 0)
                throw new Error(`Offset(${Vs}) < 0 is out of bounds`);
            if (Ws === 0)
                return g1.EMPTY;
            if (Vs + Ws > this._length)
                throw new Error(`Offset ${Vs} + Length ${Ws} > ${this._length} is out of bounds`);
            return new g1(this._data,this._offset + Vs,Ws)
        }
        subbuffer(Vs, Ws) {
            if (Vs > this._length)
                throw new Error(`Offset ${Vs} is out of bounds`);
            if (Vs < 0)
                throw new Error(`Offset ${Vs} is out of bounds`);
            if (Vs + Ws > this._length)
                throw new Error(`Offset + Lenght = ${Vs + Ws} is out of bounds`);
            if (Ws % 8 !== 0 || (this._offset + Vs) % 8 !== 0)
                return null;
            let Xs = this._offset + Vs >> 3
              , ga = Xs + (Ws >> 3);
            return this._data.subarray(Xs, ga)
        }
        equals(Vs) {
            if (this._length !== Vs._length)
                return !1;
            for (let Ws = 0; Ws < this._length; Ws++)
                if (this.at(Ws) !== Vs.at(Ws))
                    return !1;
            return !0
        }
        toString() {
            const Vs = (0,
            as.bitsToPaddedBuffer)(this);
            if (this._length % 4 === 0) {
                const Ws = Vs.subarray(0, Math.ceil(this._length / 8)).toString("hex").toUpperCase();
                return this._length % 8 === 0 ? Ws : Ws.substring(0, Ws.length - 1)
            } else {
                const Ws = Vs.toString("hex").toUpperCase();
                return this._length % 8 <= 4 ? Ws.substring(0, Ws.length - 1) + "_" : Ws + "_"
            }
        }
    }
    ;
    return BitString.BitString = Cs,
    Cn = cs.default,
    Cs.EMPTY = new Cs(Buffer.alloc(0),0,0),
    BitString
}
var hasRequiredBitBuilder;
function requireBitBuilder() {
    if (hasRequiredBitBuilder)
        return BitBuilder;
    hasRequiredBitBuilder = 1,
    Object.defineProperty(BitBuilder, "__esModule", {
        value: !0
    }),
    BitBuilder.BitBuilder = void 0;
    const xt = Address$1
      , Cn = ExternalAddress$1
      , as = requireBitString();
    let cs = class {
        constructor(Ls=1023) {
            this._buffer = Buffer.alloc(Math.ceil(Ls / 8)),
            this._length = 0
        }
        get length() {
            return this._length
        }
        writeBit(Ls) {
            let Vs = this._length;
            if (Vs > this._buffer.length * 8)
                throw new Error("BitBuilder overflow");
            (typeof Ls == "boolean" && Ls === !0 || typeof Ls == "number" && Ls > 0) && (this._buffer[Vs / 8 | 0] |= 1 << 7 - Vs % 8),
            this._length++
        }
        writeBits(Ls) {
            for (let Vs = 0; Vs < Ls.length; Vs++)
                this.writeBit(Ls.at(Vs))
        }
        writeBuffer(Ls) {
            if (this._length % 8 === 0) {
                if (this._length + Ls.length * 8 > this._buffer.length * 8)
                    throw new Error("BitBuilder overflow");
                Ls.copy(this._buffer, this._length / 8),
                this._length += Ls.length * 8
            } else
                for (let Vs = 0; Vs < Ls.length; Vs++)
                    this.writeUint(Ls[Vs], 8)
        }
        writeUint(Ls, Vs) {
            if (Vs < 0 || !Number.isSafeInteger(Vs))
                throw Error(`invalid bit length. Got ${Vs}`);
            const Ws = BigInt(Ls);
            if (Vs === 0) {
                if (Ws !== 0n)
                    throw Error(`value is not zero for ${Vs} bits. Got ${Ls}`);
                return
            }
            const Xs = 1n << BigInt(Vs);
            if (Ws < 0 || Ws >= Xs)
                throw Error(`bitLength is too small for a value ${Ls}. Got ${Vs}`);
            if (this._length + Vs > this._buffer.length * 8)
                throw new Error("BitBuilder overflow");
            const ga = 8 - this._length % 8;
            if (ga > 0) {
                const ba = Math.floor(this._length / 8);
                if (Vs < ga) {
                    const yl = Number(Ws);
                    this._buffer[ba] |= yl << ga - Vs,
                    this._length += Vs
                } else {
                    const yl = Number(Ws >> BigInt(Vs - ga));
                    this._buffer[ba] |= yl,
                    this._length += ga
                }
            }
            for (Vs -= ga; Vs > 0; )
                Vs >= 8 ? (this._buffer[this._length / 8] = Number(Ws >> BigInt(Vs - 8) & 0xffn),
                this._length += 8,
                Vs -= 8) : (this._buffer[this._length / 8] = Number(Ws << BigInt(8 - Vs) & 0xffn),
                this._length += Vs,
                Vs = 0)
        }
        writeInt(Ls, Vs) {
            let Ws = BigInt(Ls);
            if (Vs < 0 || !Number.isSafeInteger(Vs))
                throw Error(`invalid bit length. Got ${Vs}`);
            if (Vs === 0) {
                if (Ls !== 0n)
                    throw Error(`value is not zero for ${Vs} bits. Got ${Ls}`);
                return
            }
            if (Vs === 1) {
                if (Ls !== -1n && Ls !== 0n)
                    throw Error(`value is not zero or -1 for ${Vs} bits. Got ${Ls}`);
                this.writeBit(Ls === -1n);
                return
            }
            let Xs = 1n << BigInt(Vs) - 1n;
            if (Ws < -Xs || Ws >= Xs)
                throw Error(`value is out of range for ${Vs} bits. Got ${Ls}`);
            Ws < 0 ? (this.writeBit(!0),
            Ws = Xs + Ws) : this.writeBit(!1),
            this.writeUint(Ws, Vs - 1)
        }
        writeVarUint(Ls, Vs) {
            let Ws = BigInt(Ls);
            if (Vs < 0 || !Number.isSafeInteger(Vs))
                throw Error(`invalid bit length. Got ${Vs}`);
            if (Ws < 0)
                throw Error(`value is negative. Got ${Ls}`);
            if (Ws === 0n) {
                this.writeUint(0, Vs);
                return
            }
            const Xs = Math.ceil(Ws.toString(2).length / 8)
              , ga = Xs * 8;
            this.writeUint(Xs, Vs),
            this.writeUint(Ws, ga)
        }
        writeVarInt(Ls, Vs) {
            let Ws = BigInt(Ls);
            if (Vs < 0 || !Number.isSafeInteger(Vs))
                throw Error(`invalid bit length. Got ${Vs}`);
            if (Ws === 0n) {
                this.writeUint(0, Vs);
                return
            }
            let Xs = Ws > 0 ? Ws : -Ws;
            const ga = 1 + Math.ceil(Xs.toString(2).length / 8)
              , ba = ga * 8;
            this.writeUint(ga, Vs),
            this.writeInt(Ws, ba)
        }
        writeCoins(Ls) {
            this.writeVarUint(Ls, 4)
        }
        writeAddress(Ls) {
            if (Ls == null) {
                this.writeUint(0, 2);
                return
            }
            if (xt.Address.isAddress(Ls)) {
                this.writeUint(2, 2),
                this.writeUint(0, 1),
                this.writeInt(Ls.workChain, 8),
                this.writeBuffer(Ls.hash);
                return
            }
            if (Cn.ExternalAddress.isAddress(Ls)) {
                this.writeUint(1, 2),
                this.writeUint(Ls.bits, 9),
                this.writeUint(Ls.value, Ls.bits);
                return
            }
            throw Error(`Invalid address. Got ${Ls}`)
        }
        build() {
            return new as.BitString(this._buffer,0,this._length)
        }
        buffer() {
            if (this._length % 8 !== 0)
                throw new Error("BitBuilder buffer is not byte aligned");
            return this._buffer.subarray(0, this._length / 8)
        }
    }
    ;
    return BitBuilder.BitBuilder = cs,
    BitBuilder
}
var Cell = {}
  , CellType$1 = {};
Object.defineProperty(CellType$1, "__esModule", {
    value: !0
});
CellType$1.CellType = void 0;
var CellType;
(function(xt) {
    xt[xt.Ordinary = -1] = "Ordinary",
    xt[xt.PrunedBranch = 1] = "PrunedBranch",
    xt[xt.Library = 2] = "Library",
    xt[xt.MerkleProof = 3] = "MerkleProof",
    xt[xt.MerkleUpdate = 4] = "MerkleUpdate"
}
)(CellType || (CellType$1.CellType = CellType = {}));
var Slice = {}
  , Dictionary = {}
  , generateMerkleProof = {}
  , readUnaryLength$2 = {};
Object.defineProperty(readUnaryLength$2, "__esModule", {
    value: !0
});
readUnaryLength$2.readUnaryLength = void 0;
function readUnaryLength$1(xt) {
    let Cn = 0;
    for (; xt.loadBit(); )
        Cn++;
    return Cn
}
readUnaryLength$2.readUnaryLength = readUnaryLength$1;
var exoticMerkleProof = {}
  , BitReader$1 = {};
Object.defineProperty(BitReader$1, "__esModule", {
    value: !0
});
BitReader$1.BitReader = void 0;
const Address_1$4 = Address$1
  , ExternalAddress_1 = ExternalAddress$1;
class BitReader {
    constructor(Cn, as=0) {
        this._checkpoints = [],
        this._bits = Cn,
        this._offset = as
    }
    get offset() {
        return this._offset
    }
    get remaining() {
        return this._bits.length - this._offset
    }
    skip(Cn) {
        if (Cn < 0 || this._offset + Cn > this._bits.length)
            throw new Error(`Index ${this._offset + Cn} is out of bounds`);
        this._offset += Cn
    }
    reset() {
        this._checkpoints.length > 0 ? this._offset = this._checkpoints.pop() : this._offset = 0
    }
    save() {
        this._checkpoints.push(this._offset)
    }
    loadBit() {
        let Cn = this._bits.at(this._offset);
        return this._offset++,
        Cn
    }
    preloadBit() {
        return this._bits.at(this._offset)
    }
    loadBits(Cn) {
        let as = this._bits.substring(this._offset, Cn);
        return this._offset += Cn,
        as
    }
    preloadBits(Cn) {
        return this._bits.substring(this._offset, Cn)
    }
    loadBuffer(Cn) {
        let as = this._preloadBuffer(Cn, this._offset);
        return this._offset += Cn * 8,
        as
    }
    preloadBuffer(Cn) {
        return this._preloadBuffer(Cn, this._offset)
    }
    loadUint(Cn) {
        return this._toSafeInteger(this.loadUintBig(Cn), "loadUintBig")
    }
    loadUintBig(Cn) {
        let as = this.preloadUintBig(Cn);
        return this._offset += Cn,
        as
    }
    preloadUint(Cn) {
        return this._toSafeInteger(this._preloadUint(Cn, this._offset), "preloadUintBig")
    }
    preloadUintBig(Cn) {
        return this._preloadUint(Cn, this._offset)
    }
    loadInt(Cn) {
        let as = this._preloadInt(Cn, this._offset);
        return this._offset += Cn,
        this._toSafeInteger(as, "loadUintBig")
    }
    loadIntBig(Cn) {
        let as = this._preloadInt(Cn, this._offset);
        return this._offset += Cn,
        as
    }
    preloadInt(Cn) {
        return this._toSafeInteger(this._preloadInt(Cn, this._offset), "preloadIntBig")
    }
    preloadIntBig(Cn) {
        return this._preloadInt(Cn, this._offset)
    }
    loadVarUint(Cn) {
        let as = Number(this.loadUint(Cn));
        return this._toSafeInteger(this.loadUintBig(as * 8), "loadVarUintBig")
    }
    loadVarUintBig(Cn) {
        let as = Number(this.loadUint(Cn));
        return this.loadUintBig(as * 8)
    }
    preloadVarUint(Cn) {
        let as = Number(this._preloadUint(Cn, this._offset));
        return this._toSafeInteger(this._preloadUint(as * 8, this._offset + Cn), "preloadVarUintBig")
    }
    preloadVarUintBig(Cn) {
        let as = Number(this._preloadUint(Cn, this._offset));
        return this._preloadUint(as * 8, this._offset + Cn)
    }
    loadVarInt(Cn) {
        let as = Number(this.loadUint(Cn));
        return this._toSafeInteger(this.loadIntBig(as * 8), "loadVarIntBig")
    }
    loadVarIntBig(Cn) {
        let as = Number(this.loadUint(Cn));
        return this.loadIntBig(as * 8)
    }
    preloadVarInt(Cn) {
        let as = Number(this._preloadUint(Cn, this._offset));
        return this._toSafeInteger(this._preloadInt(as * 8, this._offset + Cn), "preloadVarIntBig")
    }
    preloadVarIntBig(Cn) {
        let as = Number(this._preloadUint(Cn, this._offset));
        return this._preloadInt(as * 8, this._offset + Cn)
    }
    loadCoins() {
        return this.loadVarUintBig(4)
    }
    preloadCoins() {
        return this.preloadVarUintBig(4)
    }
    loadAddress() {
        let Cn = Number(this._preloadUint(2, this._offset));
        if (Cn === 2)
            return this._loadInternalAddress();
        throw new Error("Invalid address: " + Cn)
    }
    loadMaybeAddress() {
        let Cn = Number(this._preloadUint(2, this._offset));
        if (Cn === 0)
            return this._offset += 2,
            null;
        if (Cn === 2)
            return this._loadInternalAddress();
        throw new Error("Invalid address")
    }
    loadExternalAddress() {
        if (Number(this._preloadUint(2, this._offset)) === 1)
            return this._loadExternalAddress();
        throw new Error("Invalid address")
    }
    loadMaybeExternalAddress() {
        let Cn = Number(this._preloadUint(2, this._offset));
        if (Cn === 0)
            return this._offset += 2,
            null;
        if (Cn === 1)
            return this._loadExternalAddress();
        throw new Error("Invalid address")
    }
    loadAddressAny() {
        let Cn = Number(this._preloadUint(2, this._offset));
        if (Cn === 0)
            return this._offset += 2,
            null;
        if (Cn === 2)
            return this._loadInternalAddress();
        if (Cn === 1)
            return this._loadExternalAddress();
        throw Error(Cn === 3 ? "Unsupported" : "Unreachable")
    }
    loadPaddedBits(Cn) {
        if (Cn % 8 !== 0)
            throw new Error("Invalid number of bits");
        let as = Cn;
        for (; ; )
            if (this._bits.at(this._offset + as - 1)) {
                as--;
                break
            } else
                as--;
        let cs = this._bits.substring(this._offset, as);
        return this._offset += Cn,
        cs
    }
    clone() {
        return new BitReader(this._bits,this._offset)
    }
    _preloadInt(Cn, as) {
        if (Cn == 0)
            return 0n;
        let cs = this._bits.at(as)
          , Cs = 0n;
        for (let Ls = 0; Ls < Cn - 1; Ls++)
            this._bits.at(as + 1 + Ls) && (Cs += 1n << BigInt(Cn - Ls - 1 - 1));
        return cs && (Cs = Cs - (1n << BigInt(Cn - 1))),
        Cs
    }
    _preloadUint(Cn, as) {
        if (Cn == 0)
            return 0n;
        let cs = 0n;
        for (let Cs = 0; Cs < Cn; Cs++)
            this._bits.at(as + Cs) && (cs += 1n << BigInt(Cn - Cs - 1));
        return cs
    }
    _preloadBuffer(Cn, as) {
        let cs = this._bits.subbuffer(as, Cn * 8);
        if (cs)
            return cs;
        let Cs = Buffer.alloc(Cn);
        for (let Ls = 0; Ls < Cn; Ls++)
            Cs[Ls] = Number(this._preloadUint(8, as + Ls * 8));
        return Cs
    }
    _loadInternalAddress() {
        if (Number(this._preloadUint(2, this._offset)) !== 2 || this._preloadUint(1, this._offset + 2) !== 0n)
            throw Error("Invalid address");
        let as = Number(this._preloadInt(8, this._offset + 3))
          , cs = this._preloadBuffer(32, this._offset + 11);
        return this._offset += 267,
        new Address_1$4.Address(as,cs)
    }
    _loadExternalAddress() {
        if (Number(this._preloadUint(2, this._offset)) !== 1)
            throw Error("Invalid address");
        let as = Number(this._preloadUint(9, this._offset + 2))
          , cs = this._preloadUint(as, this._offset + 11);
        return this._offset += 11 + as,
        new ExternalAddress_1.ExternalAddress(cs,as)
    }
    _toSafeInteger(Cn, as) {
        if (BigInt(Number.MAX_SAFE_INTEGER) < Cn || Cn < BigInt(Number.MIN_SAFE_INTEGER))
            throw new TypeError(`${Cn} is out of safe integer range. Use ${as} instead`);
        return Number(Cn)
    }
}
BitReader$1.BitReader = BitReader;
var hasRequiredExoticMerkleProof;
function requireExoticMerkleProof() {
    if (hasRequiredExoticMerkleProof)
        return exoticMerkleProof;
    hasRequiredExoticMerkleProof = 1,
    Object.defineProperty(exoticMerkleProof, "__esModule", {
        value: !0
    }),
    exoticMerkleProof.convertToMerkleProof = exoticMerkleProof.exoticMerkleProof = void 0;
    const xt = BitReader$1
      , Cn = requireBuilder();
    function as(Cs, Ls) {
        const Vs = new xt.BitReader(Cs);
        if (Cs.length !== 280)
            throw new Error(`Merkle Proof cell must have exactly (8 + 256 + 16) bits, got "${Cs.length}"`);
        if (Ls.length !== 1)
            throw new Error(`Merkle Proof cell must have exactly 1 ref, got "${Ls.length}"`);
        let Xs = Vs.loadUint(8);
        if (Xs !== 3)
            throw new Error(`Merkle Proof cell must have type 3, got "${Xs}"`);
        const ga = Vs.loadBuffer(32)
          , ba = Vs.loadUint(16)
          , yl = Ls[0].hash(0)
          , xl = Ls[0].depth(0);
        if (ba !== xl)
            throw new Error(`Merkle Proof cell ref depth must be exactly "${ba}", got "${xl}"`);
        if (!ga.equals(yl))
            throw new Error(`Merkle Proof cell ref hash must be exactly "${ga.toString("hex")}", got "${yl.toString("hex")}"`);
        return {
            proofDepth: ba,
            proofHash: ga
        }
    }
    exoticMerkleProof.exoticMerkleProof = as;
    function cs(Cs) {
        return (0,
        Cn.beginCell)().storeUint(3, 8).storeBuffer(Cs.hash(0)).storeUint(Cs.depth(0), 16).storeRef(Cs).endCell({
            exotic: !0
        })
    }
    return exoticMerkleProof.convertToMerkleProof = cs,
    exoticMerkleProof
}
var hasRequiredGenerateMerkleProof;
function requireGenerateMerkleProof() {
    if (hasRequiredGenerateMerkleProof)
        return generateMerkleProof;
    hasRequiredGenerateMerkleProof = 1,
    Object.defineProperty(generateMerkleProof, "__esModule", {
        value: !0
    }),
    generateMerkleProof.generateMerkleProof = generateMerkleProof.generateMerkleProofDirect = void 0;
    const xt = requireBuilder()
      , Cn = readUnaryLength$2
      , as = requireExoticMerkleProof();
    function cs(Ws) {
        return (0,
        xt.beginCell)().storeUint(1, 8).storeUint(1, 8).storeBuffer(Ws.hash(0)).storeUint(Ws.depth(0), 16).endCell({
            exotic: !0
        })
    }
    function Cs(Ws, Xs, ga, ba) {
        const yl = Xs.asCell();
        if (ba.length == 0)
            return cs(yl);
        let xl = Xs.loadBit() ? 1 : 0
          , wl = 0
          , _l = Ws;
        if (xl === 0) {
            wl = (0,
            Cn.readUnaryLength)(Xs);
            for (let El = 0; El < wl; El++)
                _l += Xs.loadBit() ? "1" : "0"
        } else if ((Xs.loadBit() ? 1 : 0) === 0) {
            wl = Xs.loadUint(Math.ceil(Math.log2(ga + 1)));
            for (let Cl = 0; Cl < wl; Cl++)
                _l += Xs.loadBit() ? "1" : "0"
        } else {
            let Cl = Xs.loadBit() ? "1" : "0";
            wl = Xs.loadUint(Math.ceil(Math.log2(ga + 1)));
            for (let $l = 0; $l < wl; $l++)
                _l += Cl
        }
        if (ga - wl === 0)
            return yl;
        {
            let El = yl.beginParse()
              , Cl = El.loadRef()
              , $l = El.loadRef();
            if (!Cl.isExotic) {
                const Sl = ba.filter(Tl => _l + "0" === Tl.slice(0, _l.length + 1));
                Cl = Cs(_l + "0", Cl.beginParse(), ga - wl - 1, Sl)
            }
            if (!$l.isExotic) {
                const Sl = ba.filter(Tl => _l + "1" === Tl.slice(0, _l.length + 1));
                $l = Cs(_l + "1", $l.beginParse(), ga - wl - 1, Sl)
            }
            return (0,
            xt.beginCell)().storeSlice(El).storeRef(Cl).storeRef($l).endCell()
        }
    }
    function Ls(Ws, Xs, ga) {
        Xs.forEach(yl => {
            if (!Ws.has(yl))
                throw new Error(`Trying to generate merkle proof for a missing key "${yl}"`)
        }
        );
        const ba = (0,
        xt.beginCell)().storeDictDirect(Ws).asSlice();
        return Cs("", ba, ga.bits, Xs.map(yl => ga.serialize(yl).toString(2).padStart(ga.bits, "0")))
    }
    generateMerkleProof.generateMerkleProofDirect = Ls;
    function Vs(Ws, Xs, ga) {
        return (0,
        as.convertToMerkleProof)(Ls(Ws, Xs, ga))
    }
    return generateMerkleProof.generateMerkleProof = Vs,
    generateMerkleProof
}
var generateMerkleUpdate = {}, hasRequiredGenerateMerkleUpdate;
function requireGenerateMerkleUpdate() {
    if (hasRequiredGenerateMerkleUpdate)
        return generateMerkleUpdate;
    hasRequiredGenerateMerkleUpdate = 1,
    Object.defineProperty(generateMerkleUpdate, "__esModule", {
        value: !0
    }),
    generateMerkleUpdate.generateMerkleUpdate = void 0;
    const xt = requireBuilder()
      , Cn = requireGenerateMerkleProof();
    function as(Cs, Ls) {
        return (0,
        xt.beginCell)().storeUint(4, 8).storeBuffer(Cs.hash(0)).storeBuffer(Ls.hash(0)).storeUint(Cs.depth(0), 16).storeUint(Ls.depth(0), 16).storeRef(Cs).storeRef(Ls).endCell({
            exotic: !0
        })
    }
    function cs(Cs, Ls, Vs, Ws) {
        const Xs = (0,
        Cn.generateMerkleProof)(Cs, [Ls], Vs).refs[0];
        Cs.set(Ls, Ws);
        const ga = (0,
        Cn.generateMerkleProof)(Cs, [Ls], Vs).refs[0];
        return as(Xs, ga)
    }
    return generateMerkleUpdate.generateMerkleUpdate = cs,
    generateMerkleUpdate
}
var parseDict$1 = {};
Object.defineProperty(parseDict$1, "__esModule", {
    value: !0
});
parseDict$1.parseDict = void 0;
function readUnaryLength(xt) {
    let Cn = 0;
    for (; xt.loadBit(); )
        Cn++;
    return Cn
}
function doParse(xt, Cn, as, cs, Cs) {
    let Ls = Cn.loadBit() ? 1 : 0
      , Vs = 0
      , Ws = xt;
    if (Ls === 0) {
        Vs = readUnaryLength(Cn);
        for (let Xs = 0; Xs < Vs; Xs++)
            Ws += Cn.loadBit() ? "1" : "0"
    } else if ((Cn.loadBit() ? 1 : 0) === 0) {
        Vs = Cn.loadUint(Math.ceil(Math.log2(as + 1)));
        for (let ga = 0; ga < Vs; ga++)
            Ws += Cn.loadBit() ? "1" : "0"
    } else {
        let ga = Cn.loadBit() ? "1" : "0";
        Vs = Cn.loadUint(Math.ceil(Math.log2(as + 1)));
        for (let ba = 0; ba < Vs; ba++)
            Ws += ga
    }
    if (as - Vs === 0)
        cs.set(BigInt("0b" + Ws), Cs(Cn));
    else {
        let Xs = Cn.loadRef()
          , ga = Cn.loadRef();
        Xs.isExotic || doParse(Ws + "0", Xs.beginParse(), as - Vs - 1, cs, Cs),
        ga.isExotic || doParse(Ws + "1", ga.beginParse(), as - Vs - 1, cs, Cs)
    }
}
function parseDict(xt, Cn, as) {
    let cs = new Map;
    return xt && doParse("", xt, Cn, cs, as),
    cs
}
parseDict$1.parseDict = parseDict;
var serializeDict = {}
  , findCommonPrefix$1 = {};
Object.defineProperty(findCommonPrefix$1, "__esModule", {
    value: !0
});
findCommonPrefix$1.findCommonPrefix = void 0;
function findCommonPrefix(xt, Cn=0) {
    if (xt.length === 0)
        return "";
    let as = xt[0].slice(Cn);
    for (let cs = 1; cs < xt.length; cs++) {
        const Cs = xt[cs];
        for (; Cs.indexOf(as, Cn) !== Cn; )
            if (as = as.substring(0, as.length - 1),
            as === "")
                return as
    }
    return as
}
findCommonPrefix$1.findCommonPrefix = findCommonPrefix;
var hasRequiredSerializeDict;
function requireSerializeDict() {
    if (hasRequiredSerializeDict)
        return serializeDict;
    hasRequiredSerializeDict = 1,
    Object.defineProperty(serializeDict, "__esModule", {
        value: !0
    }),
    serializeDict.serializeDict = serializeDict.detectLabelType = serializeDict.writeLabelSame = serializeDict.writeLabelLong = serializeDict.writeLabelShort = serializeDict.buildTree = void 0;
    const xt = requireBuilder()
      , Cn = findCommonPrefix$1;
    function as(Tl, Rl) {
        for (; Tl.length < Rl; )
            Tl = "0" + Tl;
        return Tl
    }
    function cs(Tl, Rl) {
        if (Tl.size === 0)
            throw Error("Internal inconsistency");
        let Il = new Map
          , Ml = new Map;
        for (let[Nl,Ll] of Tl.entries())
            Nl[Rl] === "0" ? Il.set(Nl, Ll) : Ml.set(Nl, Ll);
        if (Il.size === 0)
            throw Error("Internal inconsistency. Left emtpy.");
        if (Ml.size === 0)
            throw Error("Internal inconsistency. Right emtpy.");
        return {
            left: Il,
            right: Ml
        }
    }
    function Cs(Tl, Rl) {
        if (Tl.size === 0)
            throw Error("Internal inconsistency");
        if (Tl.size === 1)
            return {
                type: "leaf",
                value: Array.from(Tl.values())[0]
            };
        let {left: Il, right: Ml} = cs(Tl, Rl);
        return {
            type: "fork",
            left: Ls(Il, Rl + 1),
            right: Ls(Ml, Rl + 1)
        }
    }
    function Ls(Tl, Rl=0) {
        if (Tl.size === 0)
            throw Error("Internal inconsistency");
        const Il = (0,
        Cn.findCommonPrefix)(Array.from(Tl.keys()), Rl);
        return {
            label: Il,
            node: Cs(Tl, Il.length + Rl)
        }
    }
    function Vs(Tl, Rl) {
        let Il = new Map;
        for (let Ml of Array.from(Tl.keys())) {
            const Nl = as(Ml.toString(2), Rl);
            Il.set(Nl, Tl.get(Ml))
        }
        return Ls(Il)
    }
    serializeDict.buildTree = Vs;
    function Ws(Tl, Rl) {
        Rl.storeBit(0);
        for (let Il = 0; Il < Tl.length; Il++)
            Rl.storeBit(1);
        return Rl.storeBit(0),
        Tl.length > 0 && Rl.storeUint(BigInt("0b" + Tl), Tl.length),
        Rl
    }
    serializeDict.writeLabelShort = Ws;
    function Xs(Tl) {
        return 1 + Tl.length + 1 + Tl.length
    }
    function ga(Tl, Rl, Il) {
        Il.storeBit(1),
        Il.storeBit(0);
        let Ml = Math.ceil(Math.log2(Rl + 1));
        return Il.storeUint(Tl.length, Ml),
        Tl.length > 0 && Il.storeUint(BigInt("0b" + Tl), Tl.length),
        Il
    }
    serializeDict.writeLabelLong = ga;
    function ba(Tl, Rl) {
        return 2 + Math.ceil(Math.log2(Rl + 1)) + Tl.length
    }
    function yl(Tl, Rl, Il, Ml) {
        Ml.storeBit(1),
        Ml.storeBit(1),
        Ml.storeBit(Tl);
        let Nl = Math.ceil(Math.log2(Il + 1));
        Ml.storeUint(Rl, Nl)
    }
    serializeDict.writeLabelSame = yl;
    function xl(Tl) {
        return 3 + Math.ceil(Math.log2(Tl + 1))
    }
    function wl(Tl) {
        if (Tl.length === 0 || Tl.length === 1)
            return !0;
        for (let Rl = 1; Rl < Tl.length; Rl++)
            if (Tl[Rl] !== Tl[0])
                return !1;
        return !0
    }
    function _l(Tl, Rl) {
        let Il = "short"
          , Ml = Xs(Tl)
          , Nl = ba(Tl, Rl);
        if (Nl < Ml && (Ml = Nl,
        Il = "long"),
        wl(Tl)) {
            let Ll = xl(Rl);
            Ll < Ml && (Ml = Ll,
            Il = "same")
        }
        return Il
    }
    serializeDict.detectLabelType = _l;
    function El(Tl, Rl, Il) {
        let Ml = _l(Tl, Rl);
        Ml === "short" ? Ws(Tl, Il) : Ml === "long" ? ga(Tl, Rl, Il) : Ml === "same" && yl(Tl[0] === "1", Tl.length, Rl, Il)
    }
    function Cl(Tl, Rl, Il, Ml) {
        if (Tl.type === "leaf" && Il(Tl.value, Ml),
        Tl.type === "fork") {
            const Nl = (0,
            xt.beginCell)()
              , Ll = (0,
            xt.beginCell)();
            $l(Tl.left, Rl - 1, Il, Nl),
            $l(Tl.right, Rl - 1, Il, Ll),
            Ml.storeRef(Nl),
            Ml.storeRef(Ll)
        }
    }
    function $l(Tl, Rl, Il, Ml) {
        El(Tl.label, Rl, Ml),
        Cl(Tl.node, Rl - Tl.label.length, Il, Ml)
    }
    function Sl(Tl, Rl, Il, Ml) {
        const Nl = Vs(Tl, Rl);
        $l(Nl, Rl, Il, Ml)
    }
    return serializeDict.serializeDict = Sl,
    serializeDict
}
var internalKeySerializer = {};
Object.defineProperty(internalKeySerializer, "__esModule", {
    value: !0
});
internalKeySerializer.deserializeInternalKey = internalKeySerializer.serializeInternalKey = void 0;
const Address_1$3 = Address$1
  , BitString_1 = requireBitString()
  , paddedBits_1$1 = requirePaddedBits();
function serializeInternalKey(xt) {
    if (typeof xt == "number") {
        if (!Number.isSafeInteger(xt))
            throw Error("Invalid key type: not a safe integer: " + xt);
        return "n:" + xt.toString(10)
    } else {
        if (typeof xt == "bigint")
            return "b:" + xt.toString(10);
        if (Address_1$3.Address.isAddress(xt))
            return "a:" + xt.toString();
        if (Buffer.isBuffer(xt))
            return "f:" + xt.toString("hex");
        if (BitString_1.BitString.isBitString(xt))
            return "B:" + xt.toString();
        throw Error("Invalid key type")
    }
}
internalKeySerializer.serializeInternalKey = serializeInternalKey;
function deserializeInternalKey(xt) {
    let Cn = xt.slice(0, 2)
      , as = xt.slice(2);
    if (Cn === "n:")
        return parseInt(as, 10);
    if (Cn === "b:")
        return BigInt(as);
    if (Cn === "a:")
        return Address_1$3.Address.parse(as);
    if (Cn === "f:")
        return Buffer.from(as, "hex");
    if (Cn === "B:") {
        const cs = as.slice(-1) == "_";
        if (cs || as.length % 2 != 0) {
            let Ls = cs ? as.length - 1 : as.length;
            const Vs = as.substr(0, Ls) + "0";
            return !cs && Ls & 1 ? new BitString_1.BitString(Buffer.from(Vs, "hex"),0,Ls << 2) : (0,
            paddedBits_1$1.paddedBufferToBits)(Buffer.from(Vs, "hex"))
        } else
            return new BitString_1.BitString(Buffer.from(as, "hex"),0,as.length << 2)
    }
    throw Error("Invalid key type: " + Cn)
}
internalKeySerializer.deserializeInternalKey = deserializeInternalKey;
var hasRequiredDictionary;
function requireDictionary() {
    if (hasRequiredDictionary)
        return Dictionary;
    hasRequiredDictionary = 1,
    Object.defineProperty(Dictionary, "__esModule", {
        value: !0
    }),
    Dictionary.Dictionary = void 0;
    const xt = Address$1
      , Cn = requireBuilder()
      , as = requireCell()
      , cs = requireBitString()
      , Cs = requireGenerateMerkleProof()
      , Ls = requireGenerateMerkleUpdate()
      , Vs = parseDict$1
      , Ws = requireSerializeDict()
      , Xs = internalKeySerializer;
    let ga = class xm {
        static empty(Wl, Ql) {
            return Wl && Ql ? new xm(new Map,Wl,Ql) : new xm(new Map,null,null)
        }
        static load(Wl, Ql, cu) {
            let pu;
            if (cu instanceof as.Cell) {
                if (cu.isExotic)
                    return xm.empty(Wl, Ql);
                pu = cu.beginParse()
            } else
                pu = cu;
            let zl = pu.loadMaybeRef();
            return zl && !zl.isExotic ? xm.loadDirect(Wl, Ql, zl.beginParse()) : xm.empty(Wl, Ql)
        }
        static loadDirect(Wl, Ql, cu) {
            if (!cu)
                return xm.empty(Wl, Ql);
            let pu;
            cu instanceof as.Cell ? pu = cu.beginParse() : pu = cu;
            let zl = (0,
            Vs.parseDict)(pu, Wl.bits, Ql.parse)
              , Yl = new Map;
            for (let[lu,mu] of zl)
                Yl.set((0,
                Xs.serializeInternalKey)(Wl.parse(lu)), mu);
            return new xm(Yl,Wl,Ql)
        }
        constructor(Wl, Ql, cu) {
            this._key = Ql,
            this._value = cu,
            this._map = Wl
        }
        get size() {
            return this._map.size
        }
        get(Wl) {
            return this._map.get((0,
            Xs.serializeInternalKey)(Wl))
        }
        has(Wl) {
            return this._map.has((0,
            Xs.serializeInternalKey)(Wl))
        }
        set(Wl, Ql) {
            return this._map.set((0,
            Xs.serializeInternalKey)(Wl), Ql),
            this
        }
        delete(Wl) {
            const Ql = (0,
            Xs.serializeInternalKey)(Wl);
            return this._map.delete(Ql)
        }
        clear() {
            this._map.clear()
        }
        *[Symbol.iterator]() {
            for (const [Wl,Ql] of this._map)
                yield[(0,
                Xs.deserializeInternalKey)(Wl), Ql]
        }
        keys() {
            return Array.from(this._map.keys()).map(Wl => (0,
            Xs.deserializeInternalKey)(Wl))
        }
        values() {
            return Array.from(this._map.values())
        }
        store(Wl, Ql, cu) {
            if (this._map.size === 0)
                Wl.storeBit(0);
            else {
                let pu = this._key;
                Ql != null && (pu = Ql);
                let zl = this._value;
                if (cu != null && (zl = cu),
                !pu)
                    throw Error("Key serializer is not defined");
                if (!zl)
                    throw Error("Value serializer is not defined");
                let Yl = new Map;
                for (const [mu,Cu] of this._map)
                    Yl.set(pu.serialize((0,
                    Xs.deserializeInternalKey)(mu)), Cu);
                Wl.storeBit(1);
                let lu = (0,
                Cn.beginCell)();
                (0,
                Ws.serializeDict)(Yl, pu.bits, zl.serialize, lu),
                Wl.storeRef(lu.endCell())
            }
        }
        storeDirect(Wl, Ql, cu) {
            if (this._map.size === 0)
                throw Error("Cannot store empty dictionary directly");
            let pu = this._key;
            Ql != null && (pu = Ql);
            let zl = this._value;
            if (cu != null && (zl = cu),
            !pu)
                throw Error("Key serializer is not defined");
            if (!zl)
                throw Error("Value serializer is not defined");
            let Yl = new Map;
            for (const [lu,mu] of this._map)
                Yl.set(pu.serialize((0,
                Xs.deserializeInternalKey)(lu)), mu);
            (0,
            Ws.serializeDict)(Yl, pu.bits, zl.serialize, Wl)
        }
        generateMerkleProof(Wl) {
            return (0,
            Cs.generateMerkleProof)(this, Wl, this._key)
        }
        generateMerkleProofDirect(Wl) {
            return (0,
            Cs.generateMerkleProofDirect)(this, Wl, this._key)
        }
        generateMerkleUpdate(Wl, Ql) {
            return (0,
            Ls.generateMerkleUpdate)(this, Wl, this._key, Ql)
        }
    }
    ;
    Dictionary.Dictionary = ga,
    ga.Keys = {
        Address: () => ba(),
        BigInt: Gl => yl(Gl),
        Int: Gl => xl(Gl),
        BigUint: Gl => wl(Gl),
        Uint: Gl => _l(Gl),
        Buffer: Gl => El(Gl),
        BitString: Gl => Cl(Gl)
    },
    ga.Values = {
        BigInt: Gl => Sl(Gl),
        Int: Gl => $l(Gl),
        BigVarInt: Gl => Tl(Gl),
        BigUint: Gl => Ml(Gl),
        Uint: Gl => Il(Gl),
        BigVarUint: Gl => Rl(Gl),
        Bool: () => Nl(),
        Address: () => Ll(),
        Cell: () => Fl(),
        Buffer: Gl => Dl(Gl),
        BitString: Gl => Zl(Gl),
        Dictionary: (Gl, Wl) => Ul(Gl, Wl)
    };
    function ba() {
        return {
            bits: 267,
            serialize: Gl => {
                if (!xt.Address.isAddress(Gl))
                    throw Error("Key is not an address");
                return (0,
                Cn.beginCell)().storeAddress(Gl).endCell().beginParse().preloadUintBig(267)
            }
            ,
            parse: Gl => (0,
            Cn.beginCell)().storeUint(Gl, 267).endCell().beginParse().loadAddress()
        }
    }
    function yl(Gl) {
        return {
            bits: Gl,
            serialize: Wl => {
                if (typeof Wl != "bigint")
                    throw Error("Key is not a bigint");
                return (0,
                Cn.beginCell)().storeInt(Wl, Gl).endCell().beginParse().loadUintBig(Gl)
            }
            ,
            parse: Wl => (0,
            Cn.beginCell)().storeUint(Wl, Gl).endCell().beginParse().loadIntBig(Gl)
        }
    }
    function xl(Gl) {
        return {
            bits: Gl,
            serialize: Wl => {
                if (typeof Wl != "number")
                    throw Error("Key is not a number");
                if (!Number.isSafeInteger(Wl))
                    throw Error("Key is not a safe integer: " + Wl);
                return (0,
                Cn.beginCell)().storeInt(Wl, Gl).endCell().beginParse().loadUintBig(Gl)
            }
            ,
            parse: Wl => (0,
            Cn.beginCell)().storeUint(Wl, Gl).endCell().beginParse().loadInt(Gl)
        }
    }
    function wl(Gl) {
        return {
            bits: Gl,
            serialize: Wl => {
                if (typeof Wl != "bigint")
                    throw Error("Key is not a bigint");
                if (Wl < 0)
                    throw Error("Key is negative: " + Wl);
                return (0,
                Cn.beginCell)().storeUint(Wl, Gl).endCell().beginParse().loadUintBig(Gl)
            }
            ,
            parse: Wl => (0,
            Cn.beginCell)().storeUint(Wl, Gl).endCell().beginParse().loadUintBig(Gl)
        }
    }
    function _l(Gl) {
        return {
            bits: Gl,
            serialize: Wl => {
                if (typeof Wl != "number")
                    throw Error("Key is not a number");
                if (!Number.isSafeInteger(Wl))
                    throw Error("Key is not a safe integer: " + Wl);
                if (Wl < 0)
                    throw Error("Key is negative: " + Wl);
                return (0,
                Cn.beginCell)().storeUint(Wl, Gl).endCell().beginParse().loadUintBig(Gl)
            }
            ,
            parse: Wl => Number((0,
            Cn.beginCell)().storeUint(Wl, Gl).endCell().beginParse().loadUint(Gl))
        }
    }
    function El(Gl) {
        return {
            bits: Gl * 8,
            serialize: Wl => {
                if (!Buffer.isBuffer(Wl))
                    throw Error("Key is not a buffer");
                return (0,
                Cn.beginCell)().storeBuffer(Wl).endCell().beginParse().loadUintBig(Gl * 8)
            }
            ,
            parse: Wl => (0,
            Cn.beginCell)().storeUint(Wl, Gl * 8).endCell().beginParse().loadBuffer(Gl)
        }
    }
    function Cl(Gl) {
        return {
            bits: Gl,
            serialize: Wl => {
                if (!cs.BitString.isBitString(Wl))
                    throw Error("Key is not a BitString");
                return (0,
                Cn.beginCell)().storeBits(Wl).endCell().beginParse().loadUintBig(Gl)
            }
            ,
            parse: Wl => (0,
            Cn.beginCell)().storeUint(Wl, Gl).endCell().beginParse().loadBits(Gl)
        }
    }
    function $l(Gl) {
        return {
            serialize: (Wl, Ql) => {
                Ql.storeInt(Wl, Gl)
            }
            ,
            parse: Wl => Wl.loadInt(Gl)
        }
    }
    function Sl(Gl) {
        return {
            serialize: (Wl, Ql) => {
                Ql.storeInt(Wl, Gl)
            }
            ,
            parse: Wl => Wl.loadIntBig(Gl)
        }
    }
    function Tl(Gl) {
        return {
            serialize: (Wl, Ql) => {
                Ql.storeVarInt(Wl, Gl)
            }
            ,
            parse: Wl => Wl.loadVarIntBig(Gl)
        }
    }
    function Rl(Gl) {
        return {
            serialize: (Wl, Ql) => {
                Ql.storeVarUint(Wl, Gl)
            }
            ,
            parse: Wl => Wl.loadVarUintBig(Gl)
        }
    }
    function Il(Gl) {
        return {
            serialize: (Wl, Ql) => {
                Ql.storeUint(Wl, Gl)
            }
            ,
            parse: Wl => Wl.loadUint(Gl)
        }
    }
    function Ml(Gl) {
        return {
            serialize: (Wl, Ql) => {
                Ql.storeUint(Wl, Gl)
            }
            ,
            parse: Wl => Wl.loadUintBig(Gl)
        }
    }
    function Nl() {
        return {
            serialize: (Gl, Wl) => {
                Wl.storeBit(Gl)
            }
            ,
            parse: Gl => Gl.loadBit()
        }
    }
    function Ll() {
        return {
            serialize: (Gl, Wl) => {
                Wl.storeAddress(Gl)
            }
            ,
            parse: Gl => Gl.loadAddress()
        }
    }
    function Fl() {
        return {
            serialize: (Gl, Wl) => {
                Wl.storeRef(Gl)
            }
            ,
            parse: Gl => Gl.loadRef()
        }
    }
    function Ul(Gl, Wl) {
        return {
            serialize: (Ql, cu) => {
                Ql.store(cu)
            }
            ,
            parse: Ql => ga.load(Gl, Wl, Ql)
        }
    }
    function Dl(Gl) {
        return {
            serialize: (Wl, Ql) => {
                if (Wl.length !== Gl)
                    throw Error("Invalid buffer size");
                Ql.storeBuffer(Wl)
            }
            ,
            parse: Wl => Wl.loadBuffer(Gl)
        }
    }
    function Zl(Gl) {
        return {
            serialize: (Wl, Ql) => {
                if (Wl.length !== Gl)
                    throw Error("Invalid BitString size");
                Ql.storeBits(Wl)
            }
            ,
            parse: Wl => Wl.loadBits(Gl)
        }
    }
    return Dictionary
}
var strings = {}, hasRequiredStrings;
function requireStrings() {
    if (hasRequiredStrings)
        return strings;
    hasRequiredStrings = 1,
    Object.defineProperty(strings, "__esModule", {
        value: !0
    }),
    strings.writeString = strings.stringToCell = strings.readString = void 0;
    const xt = requireBuilder();
    function Cn(Vs) {
        if (Vs.remainingBits % 8 !== 0)
            throw new Error(`Invalid string length: ${Vs.remainingBits}`);
        if (Vs.remainingRefs !== 0 && Vs.remainingRefs !== 1)
            throw new Error(`invalid number of refs: ${Vs.remainingRefs}`);
        let Ws;
        return Vs.remainingBits === 0 ? Ws = Buffer.alloc(0) : Ws = Vs.loadBuffer(Vs.remainingBits / 8),
        Vs.remainingRefs === 1 && (Ws = Buffer.concat([Ws, Cn(Vs.loadRef().beginParse())])),
        Ws
    }
    function as(Vs) {
        return Cn(Vs).toString()
    }
    strings.readString = as;
    function cs(Vs, Ws) {
        if (Vs.length > 0) {
            let Xs = Math.floor(Ws.availableBits / 8);
            if (Vs.length > Xs) {
                let ga = Vs.subarray(0, Xs)
                  , ba = Vs.subarray(Xs);
                Ws = Ws.storeBuffer(ga);
                let yl = (0,
                xt.beginCell)();
                cs(ba, yl),
                Ws = Ws.storeRef(yl.endCell())
            } else
                Ws = Ws.storeBuffer(Vs)
        }
    }
    function Cs(Vs) {
        let Ws = (0,
        xt.beginCell)();
        return cs(Buffer.from(Vs), Ws),
        Ws.endCell()
    }
    strings.stringToCell = Cs;
    function Ls(Vs, Ws) {
        cs(Buffer.from(Vs), Ws)
    }
    return strings.writeString = Ls,
    strings
}
var hasRequiredSlice;
function requireSlice() {
    if (hasRequiredSlice)
        return Slice;
    hasRequiredSlice = 1;
    var xt = commonjsGlobal && commonjsGlobal.__importDefault || function(Ws) {
        return Ws && Ws.__esModule ? Ws : {
            default: Ws
        }
    }
    , Cn;
    Object.defineProperty(Slice, "__esModule", {
        value: !0
    }),
    Slice.Slice = void 0;
    const as = xt(symbol_inspect)
      , cs = requireDictionary()
      , Cs = requireBuilder()
      , Ls = requireStrings();
    let Vs = class A1 {
        constructor(Xs, ga) {
            this[Cn] = () => this.toString(),
            this._reader = Xs.clone(),
            this._refs = [...ga],
            this._refsOffset = 0
        }
        get remainingBits() {
            return this._reader.remaining
        }
        get offsetBits() {
            return this._reader.offset
        }
        get remainingRefs() {
            return this._refs.length - this._refsOffset
        }
        get offsetRefs() {
            return this._refsOffset
        }
        skip(Xs) {
            return this._reader.skip(Xs),
            this
        }
        loadBit() {
            return this._reader.loadBit()
        }
        preloadBit() {
            return this._reader.preloadBit()
        }
        loadBoolean() {
            return this.loadBit()
        }
        loadMaybeBoolean() {
            return this.loadBit() ? this.loadBoolean() : null
        }
        loadBits(Xs) {
            return this._reader.loadBits(Xs)
        }
        preloadBits(Xs) {
            return this._reader.preloadBits(Xs)
        }
        loadUint(Xs) {
            return this._reader.loadUint(Xs)
        }
        loadUintBig(Xs) {
            return this._reader.loadUintBig(Xs)
        }
        preloadUint(Xs) {
            return this._reader.preloadUint(Xs)
        }
        preloadUintBig(Xs) {
            return this._reader.preloadUintBig(Xs)
        }
        loadMaybeUint(Xs) {
            return this.loadBit() ? this.loadUint(Xs) : null
        }
        loadMaybeUintBig(Xs) {
            return this.loadBit() ? this.loadUintBig(Xs) : null
        }
        loadInt(Xs) {
            return this._reader.loadInt(Xs)
        }
        loadIntBig(Xs) {
            return this._reader.loadIntBig(Xs)
        }
        preloadInt(Xs) {
            return this._reader.preloadInt(Xs)
        }
        preloadIntBig(Xs) {
            return this._reader.preloadIntBig(Xs)
        }
        loadMaybeInt(Xs) {
            return this.loadBit() ? this.loadInt(Xs) : null
        }
        loadMaybeIntBig(Xs) {
            return this.loadBit() ? this.loadIntBig(Xs) : null
        }
        loadVarUint(Xs) {
            return this._reader.loadVarUint(Xs)
        }
        loadVarUintBig(Xs) {
            return this._reader.loadVarUintBig(Xs)
        }
        preloadVarUint(Xs) {
            return this._reader.preloadVarUint(Xs)
        }
        preloadVarUintBig(Xs) {
            return this._reader.preloadVarUintBig(Xs)
        }
        loadVarInt(Xs) {
            return this._reader.loadVarInt(Xs)
        }
        loadVarIntBig(Xs) {
            return this._reader.loadVarIntBig(Xs)
        }
        preloadVarInt(Xs) {
            return this._reader.preloadVarInt(Xs)
        }
        preloadVarIntBig(Xs) {
            return this._reader.preloadVarIntBig(Xs)
        }
        loadCoins() {
            return this._reader.loadCoins()
        }
        preloadCoins() {
            return this._reader.preloadCoins()
        }
        loadMaybeCoins() {
            return this._reader.loadBit() ? this._reader.loadCoins() : null
        }
        loadAddress() {
            return this._reader.loadAddress()
        }
        loadMaybeAddress() {
            return this._reader.loadMaybeAddress()
        }
        loadExternalAddress() {
            return this._reader.loadExternalAddress()
        }
        loadMaybeExternalAddress() {
            return this._reader.loadMaybeExternalAddress()
        }
        loadAddressAny() {
            return this._reader.loadAddressAny()
        }
        loadRef() {
            if (this._refsOffset >= this._refs.length)
                throw new Error("No more references");
            return this._refs[this._refsOffset++]
        }
        preloadRef() {
            if (this._refsOffset >= this._refs.length)
                throw new Error("No more references");
            return this._refs[this._refsOffset]
        }
        loadMaybeRef() {
            return this.loadBit() ? this.loadRef() : null
        }
        preloadMaybeRef() {
            return this.preloadBit() ? this.preloadRef() : null
        }
        loadBuffer(Xs) {
            return this._reader.loadBuffer(Xs)
        }
        preloadBuffer(Xs) {
            return this._reader.preloadBuffer(Xs)
        }
        loadStringTail() {
            return (0,
            Ls.readString)(this)
        }
        loadMaybeStringTail() {
            return this.loadBit() ? (0,
            Ls.readString)(this) : null
        }
        loadStringRefTail() {
            return (0,
            Ls.readString)(this.loadRef().beginParse())
        }
        loadMaybeStringRefTail() {
            const Xs = this.loadMaybeRef();
            return Xs ? (0,
            Ls.readString)(Xs.beginParse()) : null
        }
        loadDict(Xs, ga) {
            return cs.Dictionary.load(Xs, ga, this)
        }
        loadDictDirect(Xs, ga) {
            return cs.Dictionary.loadDirect(Xs, ga, this)
        }
        endParse() {
            if (this.remainingBits > 0 || this.remainingRefs > 0)
                throw new Error("Slice is not empty")
        }
        asCell() {
            return (0,
            Cs.beginCell)().storeSlice(this).endCell()
        }
        asBuilder() {
            return (0,
            Cs.beginCell)().storeSlice(this)
        }
        clone(Xs=!1) {
            if (Xs) {
                let ga = this._reader.clone();
                return ga.reset(),
                new A1(ga,this._refs)
            } else {
                let ga = new A1(this._reader,this._refs);
                return ga._refsOffset = this._refsOffset,
                ga
            }
        }
        toString() {
            return this.asCell().toString()
        }
    }
    ;
    return Slice.Slice = Vs,
    Cn = as.default,
    Slice
}
var resolveExotic = {}
  , exoticLibrary$1 = {};
Object.defineProperty(exoticLibrary$1, "__esModule", {
    value: !0
});
exoticLibrary$1.exoticLibrary = void 0;
const BitReader_1$2 = BitReader$1;
function exoticLibrary(xt, Cn) {
    const as = new BitReader_1$2.BitReader(xt);
    if (xt.length !== 264)
        throw new Error(`Library cell must have exactly (8 + 256) bits, got "${xt.length}"`);
    let Cs = as.loadUint(8);
    if (Cs !== 2)
        throw new Error(`Library cell must have type 2, got "${Cs}"`);
    return {}
}
exoticLibrary$1.exoticLibrary = exoticLibrary;
var exoticMerkleUpdate$1 = {};
Object.defineProperty(exoticMerkleUpdate$1, "__esModule", {
    value: !0
});
exoticMerkleUpdate$1.exoticMerkleUpdate = void 0;
const BitReader_1$1 = BitReader$1;
function exoticMerkleUpdate(xt, Cn) {
    const as = new BitReader_1$1.BitReader(xt)
      , cs = 8 + 2 * 272;
    if (xt.length !== cs)
        throw new Error(`Merkle Update cell must have exactly (8 + (2 * (256 + 16))) bits, got "${xt.length}"`);
    if (Cn.length !== 2)
        throw new Error(`Merkle Update cell must have exactly 2 refs, got "${Cn.length}"`);
    let Cs = as.loadUint(8);
    if (Cs !== 4)
        throw new Error(`Merkle Update cell type must be exactly 4, got "${Cs}"`);
    const Ls = as.loadBuffer(32)
      , Vs = as.loadBuffer(32)
      , Ws = as.loadUint(16)
      , Xs = as.loadUint(16);
    if (Ws !== Cn[0].depth(0))
        throw new Error(`Merkle Update cell ref depth must be exactly "${Ws}", got "${Cn[0].depth(0)}"`);
    if (!Ls.equals(Cn[0].hash(0)))
        throw new Error(`Merkle Update cell ref hash must be exactly "${Ls.toString("hex")}", got "${Cn[0].hash(0).toString("hex")}"`);
    if (Xs !== Cn[1].depth(0))
        throw new Error(`Merkle Update cell ref depth must be exactly "${Xs}", got "${Cn[1].depth(0)}"`);
    if (!Vs.equals(Cn[1].hash(0)))
        throw new Error(`Merkle Update cell ref hash must be exactly "${Vs.toString("hex")}", got "${Cn[1].hash(0).toString("hex")}"`);
    return {
        proofDepth1: Ws,
        proofDepth2: Xs,
        proofHash1: Ls,
        proofHash2: Vs
    }
}
exoticMerkleUpdate$1.exoticMerkleUpdate = exoticMerkleUpdate;
var exoticPruned$1 = {}
  , LevelMask$1 = {};
Object.defineProperty(LevelMask$1, "__esModule", {
    value: !0
});
LevelMask$1.LevelMask = void 0;
class LevelMask {
    constructor(Cn=0) {
        this._mask = 0,
        this._mask = Cn,
        this._hashIndex = countSetBits(this._mask),
        this._hashCount = this._hashIndex + 1
    }
    get value() {
        return this._mask
    }
    get level() {
        return 32 - Math.clz32(this._mask)
    }
    get hashIndex() {
        return this._hashIndex
    }
    get hashCount() {
        return this._hashCount
    }
    apply(Cn) {
        return new LevelMask(this._mask & (1 << Cn) - 1)
    }
    isSignificant(Cn) {
        return Cn === 0 || (this._mask >> Cn - 1) % 2 !== 0
    }
}
LevelMask$1.LevelMask = LevelMask;
function countSetBits(xt) {
    return xt = xt - (xt >> 1 & 1431655765),
    xt = (xt & 858993459) + (xt >> 2 & 858993459),
    (xt + (xt >> 4) & 252645135) * 16843009 >> 24
}
Object.defineProperty(exoticPruned$1, "__esModule", {
    value: !0
});
exoticPruned$1.exoticPruned = void 0;
const BitReader_1 = BitReader$1
  , LevelMask_1 = LevelMask$1;
function exoticPruned(xt, Cn) {
    let as = new BitReader_1.BitReader(xt)
      , cs = as.loadUint(8);
    if (cs !== 1)
        throw new Error(`Pruned branch cell must have type 1, got "${cs}"`);
    if (Cn.length !== 0)
        throw new Error(`Pruned Branch cell can't has refs, got "${Cn.length}"`);
    let Cs;
    if (xt.length === 280)
        Cs = new LevelMask_1.LevelMask(1);
    else {
        if (Cs = new LevelMask_1.LevelMask(as.loadUint(8)),
        Cs.level < 1 || Cs.level > 3)
            throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got "${Cs.level}/${Cs.value}"`);
        const Xs = 16 + Cs.apply(Cs.level - 1).hashCount * 272;
        if (xt.length !== Xs)
            throw new Error(`Pruned branch cell must have exactly ${Xs} bits, got "${xt.length}"`)
    }
    let Ls = []
      , Vs = []
      , Ws = [];
    for (let Xs = 0; Xs < Cs.level; Xs++)
        Vs.push(as.loadBuffer(32));
    for (let Xs = 0; Xs < Cs.level; Xs++)
        Ws.push(as.loadUint(16));
    for (let Xs = 0; Xs < Cs.level; Xs++)
        Ls.push({
            depth: Ws[Xs],
            hash: Vs[Xs]
        });
    return {
        mask: Cs.value,
        pruned: Ls
    }
}
exoticPruned$1.exoticPruned = exoticPruned;
var hasRequiredResolveExotic;
function requireResolveExotic() {
    if (hasRequiredResolveExotic)
        return resolveExotic;
    hasRequiredResolveExotic = 1,
    Object.defineProperty(resolveExotic, "__esModule", {
        value: !0
    }),
    resolveExotic.resolveExotic = void 0;
    const xt = BitReader$1
      , Cn = CellType$1
      , as = exoticLibrary$1
      , cs = requireExoticMerkleProof()
      , Cs = exoticMerkleUpdate$1
      , Ls = exoticPruned$1
      , Vs = LevelMask$1;
    function Ws(xl, wl) {
        let _l = (0,
        Ls.exoticPruned)(xl, wl)
          , El = []
          , Cl = []
          , $l = new Vs.LevelMask(_l.mask);
        for (let Sl = 0; Sl < _l.pruned.length; Sl++)
            El.push(_l.pruned[Sl].depth),
            Cl.push(_l.pruned[Sl].hash);
        return {
            type: Cn.CellType.PrunedBranch,
            depths: El,
            hashes: Cl,
            mask: $l
        }
    }
    function Xs(xl, wl) {
        (0,
        as.exoticLibrary)(xl, wl);
        let _l = []
          , El = []
          , Cl = new Vs.LevelMask;
        return {
            type: Cn.CellType.Library,
            depths: _l,
            hashes: El,
            mask: Cl
        }
    }
    function ga(xl, wl) {
        (0,
        cs.exoticMerkleProof)(xl, wl);
        let _l = []
          , El = []
          , Cl = new Vs.LevelMask(wl[0].level() >> 1);
        return {
            type: Cn.CellType.MerkleProof,
            depths: _l,
            hashes: El,
            mask: Cl
        }
    }
    function ba(xl, wl) {
        (0,
        Cs.exoticMerkleUpdate)(xl, wl);
        let _l = []
          , El = []
          , Cl = new Vs.LevelMask((wl[0].level() | wl[1].level()) >> 1);
        return {
            type: Cn.CellType.MerkleUpdate,
            depths: _l,
            hashes: El,
            mask: Cl
        }
    }
    function yl(xl, wl) {
        let El = new xt.BitReader(xl).preloadUint(8);
        if (El === 1)
            return Ws(xl, wl);
        if (El === 2)
            return Xs(xl, wl);
        if (El === 3)
            return ga(xl, wl);
        if (El === 4)
            return ba(xl, wl);
        throw Error("Invalid exotic cell type: " + El)
    }
    return resolveExotic.resolveExotic = yl,
    resolveExotic
}
var wonderCalculator = {}
  , descriptor = {};
Object.defineProperty(descriptor, "__esModule", {
    value: !0
});
descriptor.getRepr = descriptor.getBitsDescriptor = descriptor.getRefsDescriptor = void 0;
const CellType_1 = CellType$1
  , paddedBits_1 = requirePaddedBits();
function getRefsDescriptor(xt, Cn, as) {
    return xt.length + (as !== CellType_1.CellType.Ordinary ? 1 : 0) * 8 + Cn * 32
}
descriptor.getRefsDescriptor = getRefsDescriptor;
function getBitsDescriptor(xt) {
    let Cn = xt.length;
    return Math.ceil(Cn / 8) + Math.floor(Cn / 8)
}
descriptor.getBitsDescriptor = getBitsDescriptor;
function getRepr(xt, Cn, as, cs, Cs, Ls) {
    const Vs = Math.ceil(Cn.length / 8)
      , Ws = Buffer.alloc(2 + Vs + 34 * as.length);
    let Xs = 0;
    Ws[Xs++] = getRefsDescriptor(as, Cs, Ls),
    Ws[Xs++] = getBitsDescriptor(xt),
    (0,
    paddedBits_1.bitsToPaddedBuffer)(Cn).copy(Ws, Xs),
    Xs += Vs;
    for (const ga of as) {
        let ba;
        Ls == CellType_1.CellType.MerkleProof || Ls == CellType_1.CellType.MerkleUpdate ? ba = ga.depth(cs + 1) : ba = ga.depth(cs),
        Ws[Xs++] = Math.floor(ba / 256),
        Ws[Xs++] = ba % 256
    }
    for (const ga of as) {
        let ba;
        Ls == CellType_1.CellType.MerkleProof || Ls == CellType_1.CellType.MerkleUpdate ? ba = ga.hash(cs + 1) : ba = ga.hash(cs),
        ba.copy(Ws, Xs),
        Xs += 32
    }
    return Ws
}
descriptor.getRepr = getRepr;
var dist = {}
  , sha256$3 = {}
  , sha = {
    exports: {}
};
(function(xt, Cn) {
    (function(as, cs) {
        xt.exports = cs()
    }
    )(commonjsGlobal, function() {
        var as = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        function cs(nu, Kl, Bl, Pl) {
            var Al, Vl, eu, iu = Kl || [0], ou = (Bl = Bl || 0) >>> 3, Tu = Pl === -1 ? 3 : 0;
            for (Al = 0; Al < nu.length; Al += 1)
                Vl = (eu = Al + ou) >>> 2,
                iu.length <= Vl && iu.push(0),
                iu[Vl] |= nu[Al] << 8 * (Tu + Pl * (eu % 4));
            return {
                value: iu,
                binLen: 8 * nu.length + Bl
            }
        }
        function Cs(nu, Kl, Bl) {
            switch (Kl) {
            case "UTF8":
            case "UTF16BE":
            case "UTF16LE":
                break;
            default:
                throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE")
            }
            switch (nu) {
            case "HEX":
                return function(Pl, Al, Vl) {
                    return function(eu, iu, ou, Tu) {
                        var Hu, Mu, Uu, Yu;
                        if (eu.length % 2 != 0)
                            throw new Error("String of HEX type must be in byte increments");
                        var Gu = iu || [0]
                          , Tp = (ou = ou || 0) >>> 3
                          , Sp = Tu === -1 ? 3 : 0;
                        for (Hu = 0; Hu < eu.length; Hu += 2) {
                            if (Mu = parseInt(eu.substr(Hu, 2), 16),
                            isNaN(Mu))
                                throw new Error("String of HEX type contains invalid characters");
                            for (Uu = (Yu = (Hu >>> 1) + Tp) >>> 2; Gu.length <= Uu; )
                                Gu.push(0);
                            Gu[Uu] |= Mu << 8 * (Sp + Tu * (Yu % 4))
                        }
                        return {
                            value: Gu,
                            binLen: 4 * eu.length + ou
                        }
                    }(Pl, Al, Vl, Bl)
                }
                ;
            case "TEXT":
                return function(Pl, Al, Vl) {
                    return function(eu, iu, ou, Tu, Hu) {
                        var Mu, Uu, Yu, Gu, Tp, Sp, jp, Op, Gp = 0, Wp = ou || [0], Zp = (Tu = Tu || 0) >>> 3;
                        if (iu === "UTF8")
                            for (jp = Hu === -1 ? 3 : 0,
                            Yu = 0; Yu < eu.length; Yu += 1)
                                for (Uu = [],
                                128 > (Mu = eu.charCodeAt(Yu)) ? Uu.push(Mu) : 2048 > Mu ? (Uu.push(192 | Mu >>> 6),
                                Uu.push(128 | 63 & Mu)) : 55296 > Mu || 57344 <= Mu ? Uu.push(224 | Mu >>> 12, 128 | Mu >>> 6 & 63, 128 | 63 & Mu) : (Yu += 1,
                                Mu = 65536 + ((1023 & Mu) << 10 | 1023 & eu.charCodeAt(Yu)),
                                Uu.push(240 | Mu >>> 18, 128 | Mu >>> 12 & 63, 128 | Mu >>> 6 & 63, 128 | 63 & Mu)),
                                Gu = 0; Gu < Uu.length; Gu += 1) {
                                    for (Tp = (Sp = Gp + Zp) >>> 2; Wp.length <= Tp; )
                                        Wp.push(0);
                                    Wp[Tp] |= Uu[Gu] << 8 * (jp + Hu * (Sp % 4)),
                                    Gp += 1
                                }
                        else
                            for (jp = Hu === -1 ? 2 : 0,
                            Op = iu === "UTF16LE" && Hu !== 1 || iu !== "UTF16LE" && Hu === 1,
                            Yu = 0; Yu < eu.length; Yu += 1) {
                                for (Mu = eu.charCodeAt(Yu),
                                Op === !0 && (Mu = (Gu = 255 & Mu) << 8 | Mu >>> 8),
                                Tp = (Sp = Gp + Zp) >>> 2; Wp.length <= Tp; )
                                    Wp.push(0);
                                Wp[Tp] |= Mu << 8 * (jp + Hu * (Sp % 4)),
                                Gp += 2
                            }
                        return {
                            value: Wp,
                            binLen: 8 * Gp + Tu
                        }
                    }(Pl, Kl, Al, Vl, Bl)
                }
                ;
            case "B64":
                return function(Pl, Al, Vl) {
                    return function(eu, iu, ou, Tu) {
                        var Hu, Mu, Uu, Yu, Gu, Tp, Sp = 0, jp = iu || [0], Op = (ou = ou || 0) >>> 3, Gp = Tu === -1 ? 3 : 0, Wp = eu.indexOf("=");
                        if (eu.search(/^[a-zA-Z0-9=+/]+$/) === -1)
                            throw new Error("Invalid character in base-64 string");
                        if (eu = eu.replace(/=/g, ""),
                        Wp !== -1 && Wp < eu.length)
                            throw new Error("Invalid '=' found in base-64 string");
                        for (Hu = 0; Hu < eu.length; Hu += 4) {
                            for (Yu = eu.substr(Hu, 4),
                            Uu = 0,
                            Mu = 0; Mu < Yu.length; Mu += 1)
                                Uu |= as.indexOf(Yu.charAt(Mu)) << 18 - 6 * Mu;
                            for (Mu = 0; Mu < Yu.length - 1; Mu += 1) {
                                for (Gu = (Tp = Sp + Op) >>> 2; jp.length <= Gu; )
                                    jp.push(0);
                                jp[Gu] |= (Uu >>> 16 - 8 * Mu & 255) << 8 * (Gp + Tu * (Tp % 4)),
                                Sp += 1
                            }
                        }
                        return {
                            value: jp,
                            binLen: 8 * Sp + ou
                        }
                    }(Pl, Al, Vl, Bl)
                }
                ;
            case "BYTES":
                return function(Pl, Al, Vl) {
                    return function(eu, iu, ou, Tu) {
                        var Hu, Mu, Uu, Yu, Gu = iu || [0], Tp = (ou = ou || 0) >>> 3, Sp = Tu === -1 ? 3 : 0;
                        for (Mu = 0; Mu < eu.length; Mu += 1)
                            Hu = eu.charCodeAt(Mu),
                            Uu = (Yu = Mu + Tp) >>> 2,
                            Gu.length <= Uu && Gu.push(0),
                            Gu[Uu] |= Hu << 8 * (Sp + Tu * (Yu % 4));
                        return {
                            value: Gu,
                            binLen: 8 * eu.length + ou
                        }
                    }(Pl, Al, Vl, Bl)
                }
                ;
            case "ARRAYBUFFER":
                try {
                    new ArrayBuffer(0)
                } catch {
                    throw new Error("ARRAYBUFFER not supported by this environment")
                }
                return function(Pl, Al, Vl) {
                    return function(eu, iu, ou, Tu) {
                        return cs(new Uint8Array(eu), iu, ou, Tu)
                    }(Pl, Al, Vl, Bl)
                }
                ;
            case "UINT8ARRAY":
                try {
                    new Uint8Array(0)
                } catch {
                    throw new Error("UINT8ARRAY not supported by this environment")
                }
                return function(Pl, Al, Vl) {
                    return cs(Pl, Al, Vl, Bl)
                }
                ;
            default:
                throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")
            }
        }
        function Ls(nu, Kl, Bl, Pl) {
            switch (nu) {
            case "HEX":
                return function(Al) {
                    return function(Vl, eu, iu, ou) {
                        var Tu, Hu, Mu = "", Uu = eu / 8, Yu = iu === -1 ? 3 : 0;
                        for (Tu = 0; Tu < Uu; Tu += 1)
                            Hu = Vl[Tu >>> 2] >>> 8 * (Yu + iu * (Tu % 4)),
                            Mu += "0123456789abcdef".charAt(Hu >>> 4 & 15) + "0123456789abcdef".charAt(15 & Hu);
                        return ou.outputUpper ? Mu.toUpperCase() : Mu
                    }(Al, Kl, Bl, Pl)
                }
                ;
            case "B64":
                return function(Al) {
                    return function(Vl, eu, iu, ou) {
                        var Tu, Hu, Mu, Uu, Yu, Gu = "", Tp = eu / 8, Sp = iu === -1 ? 3 : 0;
                        for (Tu = 0; Tu < Tp; Tu += 3)
                            for (Uu = Tu + 1 < Tp ? Vl[Tu + 1 >>> 2] : 0,
                            Yu = Tu + 2 < Tp ? Vl[Tu + 2 >>> 2] : 0,
                            Mu = (Vl[Tu >>> 2] >>> 8 * (Sp + iu * (Tu % 4)) & 255) << 16 | (Uu >>> 8 * (Sp + iu * ((Tu + 1) % 4)) & 255) << 8 | Yu >>> 8 * (Sp + iu * ((Tu + 2) % 4)) & 255,
                            Hu = 0; Hu < 4; Hu += 1)
                                Gu += 8 * Tu + 6 * Hu <= eu ? as.charAt(Mu >>> 6 * (3 - Hu) & 63) : ou.b64Pad;
                        return Gu
                    }(Al, Kl, Bl, Pl)
                }
                ;
            case "BYTES":
                return function(Al) {
                    return function(Vl, eu, iu) {
                        var ou, Tu, Hu = "", Mu = eu / 8, Uu = iu === -1 ? 3 : 0;
                        for (ou = 0; ou < Mu; ou += 1)
                            Tu = Vl[ou >>> 2] >>> 8 * (Uu + iu * (ou % 4)) & 255,
                            Hu += String.fromCharCode(Tu);
                        return Hu
                    }(Al, Kl, Bl)
                }
                ;
            case "ARRAYBUFFER":
                try {
                    new ArrayBuffer(0)
                } catch {
                    throw new Error("ARRAYBUFFER not supported by this environment")
                }
                return function(Al) {
                    return function(Vl, eu, iu) {
                        var ou, Tu = eu / 8, Hu = new ArrayBuffer(Tu), Mu = new Uint8Array(Hu), Uu = iu === -1 ? 3 : 0;
                        for (ou = 0; ou < Tu; ou += 1)
                            Mu[ou] = Vl[ou >>> 2] >>> 8 * (Uu + iu * (ou % 4)) & 255;
                        return Hu
                    }(Al, Kl, Bl)
                }
                ;
            case "UINT8ARRAY":
                try {
                    new Uint8Array(0)
                } catch {
                    throw new Error("UINT8ARRAY not supported by this environment")
                }
                return function(Al) {
                    return function(Vl, eu, iu) {
                        var ou, Tu = eu / 8, Hu = iu === -1 ? 3 : 0, Mu = new Uint8Array(Tu);
                        for (ou = 0; ou < Tu; ou += 1)
                            Mu[ou] = Vl[ou >>> 2] >>> 8 * (Hu + iu * (ou % 4)) & 255;
                        return Mu
                    }(Al, Kl, Bl)
                }
                ;
            default:
                throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")
            }
        }
        var Vs = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]
          , Ws = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
          , Xs = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]
          , ga = "Chosen SHA variant is not supported";
        function ba(nu, Kl) {
            var Bl, Pl, Al = nu.binLen >>> 3, Vl = Kl.binLen >>> 3, eu = Al << 3, iu = 4 - Al << 3;
            if (Al % 4 != 0) {
                for (Bl = 0; Bl < Vl; Bl += 4)
                    Pl = Al + Bl >>> 2,
                    nu.value[Pl] |= Kl.value[Bl >>> 2] << eu,
                    nu.value.push(0),
                    nu.value[Pl + 1] |= Kl.value[Bl >>> 2] >>> iu;
                return (nu.value.length << 2) - 4 >= Vl + Al && nu.value.pop(),
                {
                    value: nu.value,
                    binLen: nu.binLen + Kl.binLen
                }
            }
            return {
                value: nu.value.concat(Kl.value),
                binLen: nu.binLen + Kl.binLen
            }
        }
        function yl(nu) {
            var Kl = {
                outputUpper: !1,
                b64Pad: "=",
                outputLen: -1
            }
              , Bl = nu || {}
              , Pl = "Output length must be a multiple of 8";
            if (Kl.outputUpper = Bl.outputUpper || !1,
            Bl.b64Pad && (Kl.b64Pad = Bl.b64Pad),
            Bl.outputLen) {
                if (Bl.outputLen % 8 != 0)
                    throw new Error(Pl);
                Kl.outputLen = Bl.outputLen
            } else if (Bl.shakeLen) {
                if (Bl.shakeLen % 8 != 0)
                    throw new Error(Pl);
                Kl.outputLen = Bl.shakeLen
            }
            if (typeof Kl.outputUpper != "boolean")
                throw new Error("Invalid outputUpper formatting option");
            if (typeof Kl.b64Pad != "string")
                throw new Error("Invalid b64Pad formatting option");
            return Kl
        }
        function xl(nu, Kl, Bl, Pl) {
            var Al = nu + " must include a value and format";
            if (!Kl) {
                if (!Pl)
                    throw new Error(Al);
                return Pl
            }
            if (Kl.value === void 0 || !Kl.format)
                throw new Error(Al);
            return Cs(Kl.format, Kl.encoding || "UTF8", Bl)(Kl.value)
        }
        var wl = function() {
            function nu(Kl, Bl, Pl) {
                var Al = Pl || {};
                if (this.t = Bl,
                this.i = Al.encoding || "UTF8",
                this.numRounds = Al.numRounds || 1,
                isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds)
                    throw new Error("numRounds must a integer >= 1");
                this.o = Kl,
                this.u = [],
                this.s = 0,
                this.h = !1,
                this.v = 0,
                this.A = !1,
                this.l = [],
                this.H = []
            }
            return nu.prototype.update = function(Kl) {
                var Bl, Pl = 0, Al = this.S >>> 5, Vl = this.p(Kl, this.u, this.s), eu = Vl.binLen, iu = Vl.value, ou = eu >>> 5;
                for (Bl = 0; Bl < ou; Bl += Al)
                    Pl + this.S <= eu && (this.m = this.R(iu.slice(Bl, Bl + Al), this.m),
                    Pl += this.S);
                this.v += Pl,
                this.u = iu.slice(Pl >>> 5),
                this.s = eu % this.S,
                this.h = !0
            }
            ,
            nu.prototype.getHash = function(Kl, Bl) {
                var Pl, Al, Vl = this.U, eu = yl(Bl);
                if (this.T) {
                    if (eu.outputLen === -1)
                        throw new Error("Output length must be specified in options");
                    Vl = eu.outputLen
                }
                var iu = Ls(Kl, Vl, this.C, eu);
                if (this.A && this.F)
                    return iu(this.F(eu));
                for (Al = this.K(this.u.slice(), this.s, this.v, this.B(this.m), Vl),
                Pl = 1; Pl < this.numRounds; Pl += 1)
                    this.T && Vl % 32 != 0 && (Al[Al.length - 1] &= 16777215 >>> 24 - Vl % 32),
                    Al = this.K(Al, Vl, 0, this.L(this.o), Vl);
                return iu(Al)
            }
            ,
            nu.prototype.setHMACKey = function(Kl, Bl, Pl) {
                if (!this.g)
                    throw new Error("Variant does not support HMAC");
                if (this.h)
                    throw new Error("Cannot set MAC key after calling update");
                var Al = Cs(Bl, (Pl || {}).encoding || "UTF8", this.C);
                this.k(Al(Kl))
            }
            ,
            nu.prototype.k = function(Kl) {
                var Bl, Pl = this.S >>> 3, Al = Pl / 4 - 1;
                if (this.numRounds !== 1)
                    throw new Error("Cannot set numRounds with MAC");
                if (this.A)
                    throw new Error("MAC key already set");
                for (Pl < Kl.binLen / 8 && (Kl.value = this.K(Kl.value, Kl.binLen, 0, this.L(this.o), this.U)); Kl.value.length <= Al; )
                    Kl.value.push(0);
                for (Bl = 0; Bl <= Al; Bl += 1)
                    this.l[Bl] = 909522486 ^ Kl.value[Bl],
                    this.H[Bl] = 1549556828 ^ Kl.value[Bl];
                this.m = this.R(this.l, this.m),
                this.v = this.S,
                this.A = !0
            }
            ,
            nu.prototype.getHMAC = function(Kl, Bl) {
                var Pl = yl(Bl);
                return Ls(Kl, this.U, this.C, Pl)(this.Y())
            }
            ,
            nu.prototype.Y = function() {
                var Kl;
                if (!this.A)
                    throw new Error("Cannot call getHMAC without first setting MAC key");
                var Bl = this.K(this.u.slice(), this.s, this.v, this.B(this.m), this.U);
                return Kl = this.R(this.H, this.L(this.o)),
                Kl = this.K(Bl, this.U, this.S, Kl, this.U)
            }
            ,
            nu
        }()
          , _l = function(nu, Kl) {
            return (_l = Object.setPrototypeOf || {
                __proto__: []
            }instanceof Array && function(Bl, Pl) {
                Bl.__proto__ = Pl
            }
            || function(Bl, Pl) {
                for (var Al in Pl)
                    Object.prototype.hasOwnProperty.call(Pl, Al) && (Bl[Al] = Pl[Al])
            }
            )(nu, Kl)
        };
        function El(nu, Kl) {
            function Bl() {
                this.constructor = nu
            }
            _l(nu, Kl),
            nu.prototype = Kl === null ? Object.create(Kl) : (Bl.prototype = Kl.prototype,
            new Bl)
        }
        function Cl(nu, Kl) {
            return nu << Kl | nu >>> 32 - Kl
        }
        function $l(nu, Kl) {
            return nu >>> Kl | nu << 32 - Kl
        }
        function Sl(nu, Kl) {
            return nu >>> Kl
        }
        function Tl(nu, Kl, Bl) {
            return nu ^ Kl ^ Bl
        }
        function Rl(nu, Kl, Bl) {
            return nu & Kl ^ ~nu & Bl
        }
        function Il(nu, Kl, Bl) {
            return nu & Kl ^ nu & Bl ^ Kl & Bl
        }
        function Ml(nu) {
            return $l(nu, 2) ^ $l(nu, 13) ^ $l(nu, 22)
        }
        function Nl(nu, Kl) {
            var Bl = (65535 & nu) + (65535 & Kl);
            return (65535 & (nu >>> 16) + (Kl >>> 16) + (Bl >>> 16)) << 16 | 65535 & Bl
        }
        function Ll(nu, Kl, Bl, Pl) {
            var Al = (65535 & nu) + (65535 & Kl) + (65535 & Bl) + (65535 & Pl);
            return (65535 & (nu >>> 16) + (Kl >>> 16) + (Bl >>> 16) + (Pl >>> 16) + (Al >>> 16)) << 16 | 65535 & Al
        }
        function Fl(nu, Kl, Bl, Pl, Al) {
            var Vl = (65535 & nu) + (65535 & Kl) + (65535 & Bl) + (65535 & Pl) + (65535 & Al);
            return (65535 & (nu >>> 16) + (Kl >>> 16) + (Bl >>> 16) + (Pl >>> 16) + (Al >>> 16) + (Vl >>> 16)) << 16 | 65535 & Vl
        }
        function Ul(nu) {
            return $l(nu, 7) ^ $l(nu, 18) ^ Sl(nu, 3)
        }
        function Dl(nu) {
            return $l(nu, 6) ^ $l(nu, 11) ^ $l(nu, 25)
        }
        function Zl(nu) {
            return [1732584193, 4023233417, 2562383102, 271733878, 3285377520]
        }
        function Gl(nu, Kl) {
            var Bl, Pl, Al, Vl, eu, iu, ou, Tu = [];
            for (Bl = Kl[0],
            Pl = Kl[1],
            Al = Kl[2],
            Vl = Kl[3],
            eu = Kl[4],
            ou = 0; ou < 80; ou += 1)
                Tu[ou] = ou < 16 ? nu[ou] : Cl(Tu[ou - 3] ^ Tu[ou - 8] ^ Tu[ou - 14] ^ Tu[ou - 16], 1),
                iu = ou < 20 ? Fl(Cl(Bl, 5), Rl(Pl, Al, Vl), eu, 1518500249, Tu[ou]) : ou < 40 ? Fl(Cl(Bl, 5), Tl(Pl, Al, Vl), eu, 1859775393, Tu[ou]) : ou < 60 ? Fl(Cl(Bl, 5), Il(Pl, Al, Vl), eu, 2400959708, Tu[ou]) : Fl(Cl(Bl, 5), Tl(Pl, Al, Vl), eu, 3395469782, Tu[ou]),
                eu = Vl,
                Vl = Al,
                Al = Cl(Pl, 30),
                Pl = Bl,
                Bl = iu;
            return Kl[0] = Nl(Bl, Kl[0]),
            Kl[1] = Nl(Pl, Kl[1]),
            Kl[2] = Nl(Al, Kl[2]),
            Kl[3] = Nl(Vl, Kl[3]),
            Kl[4] = Nl(eu, Kl[4]),
            Kl
        }
        function Wl(nu, Kl, Bl, Pl) {
            for (var Al, Vl = 15 + (Kl + 65 >>> 9 << 4), eu = Kl + Bl; nu.length <= Vl; )
                nu.push(0);
            for (nu[Kl >>> 5] |= 128 << 24 - Kl % 32,
            nu[Vl] = 4294967295 & eu,
            nu[Vl - 1] = eu / 4294967296 | 0,
            Al = 0; Al < nu.length; Al += 16)
                Pl = Gl(nu.slice(Al, Al + 16), Pl);
            return Pl
        }
        var Ql = function(nu) {
            function Kl(Bl, Pl, Al) {
                var Vl = this;
                if (Bl !== "SHA-1")
                    throw new Error(ga);
                var eu = Al || {};
                return (Vl = nu.call(this, Bl, Pl, Al) || this).g = !0,
                Vl.F = Vl.Y,
                Vl.C = -1,
                Vl.p = Cs(Vl.t, Vl.i, Vl.C),
                Vl.R = Gl,
                Vl.B = function(iu) {
                    return iu.slice()
                }
                ,
                Vl.L = Zl,
                Vl.K = Wl,
                Vl.m = [1732584193, 4023233417, 2562383102, 271733878, 3285377520],
                Vl.S = 512,
                Vl.U = 160,
                Vl.T = !1,
                eu.hmacKey && Vl.k(xl("hmacKey", eu.hmacKey, Vl.C)),
                Vl
            }
            return El(Kl, nu),
            Kl
        }(wl);
        function cu(nu) {
            return nu == "SHA-224" ? Ws.slice() : Xs.slice()
        }
        function pu(nu, Kl) {
            var Bl, Pl, Al, Vl, eu, iu, ou, Tu, Hu, Mu, Uu, Yu, Gu = [];
            for (Bl = Kl[0],
            Pl = Kl[1],
            Al = Kl[2],
            Vl = Kl[3],
            eu = Kl[4],
            iu = Kl[5],
            ou = Kl[6],
            Tu = Kl[7],
            Uu = 0; Uu < 64; Uu += 1)
                Gu[Uu] = Uu < 16 ? nu[Uu] : Ll($l(Yu = Gu[Uu - 2], 17) ^ $l(Yu, 19) ^ Sl(Yu, 10), Gu[Uu - 7], Ul(Gu[Uu - 15]), Gu[Uu - 16]),
                Hu = Fl(Tu, Dl(eu), Rl(eu, iu, ou), Vs[Uu], Gu[Uu]),
                Mu = Nl(Ml(Bl), Il(Bl, Pl, Al)),
                Tu = ou,
                ou = iu,
                iu = eu,
                eu = Nl(Vl, Hu),
                Vl = Al,
                Al = Pl,
                Pl = Bl,
                Bl = Nl(Hu, Mu);
            return Kl[0] = Nl(Bl, Kl[0]),
            Kl[1] = Nl(Pl, Kl[1]),
            Kl[2] = Nl(Al, Kl[2]),
            Kl[3] = Nl(Vl, Kl[3]),
            Kl[4] = Nl(eu, Kl[4]),
            Kl[5] = Nl(iu, Kl[5]),
            Kl[6] = Nl(ou, Kl[6]),
            Kl[7] = Nl(Tu, Kl[7]),
            Kl
        }
        var zl = function(nu) {
            function Kl(Bl, Pl, Al) {
                var Vl = this;
                if (Bl !== "SHA-224" && Bl !== "SHA-256")
                    throw new Error(ga);
                var eu = Al || {};
                return (Vl = nu.call(this, Bl, Pl, Al) || this).F = Vl.Y,
                Vl.g = !0,
                Vl.C = -1,
                Vl.p = Cs(Vl.t, Vl.i, Vl.C),
                Vl.R = pu,
                Vl.B = function(iu) {
                    return iu.slice()
                }
                ,
                Vl.L = cu,
                Vl.K = function(iu, ou, Tu, Hu) {
                    return function(Mu, Uu, Yu, Gu, Tp) {
                        for (var Sp, jp = 15 + (Uu + 65 >>> 9 << 4), Op = Uu + Yu; Mu.length <= jp; )
                            Mu.push(0);
                        for (Mu[Uu >>> 5] |= 128 << 24 - Uu % 32,
                        Mu[jp] = 4294967295 & Op,
                        Mu[jp - 1] = Op / 4294967296 | 0,
                        Sp = 0; Sp < Mu.length; Sp += 16)
                            Gu = pu(Mu.slice(Sp, Sp + 16), Gu);
                        return Tp === "SHA-224" ? [Gu[0], Gu[1], Gu[2], Gu[3], Gu[4], Gu[5], Gu[6]] : Gu
                    }(iu, ou, Tu, Hu, Bl)
                }
                ,
                Vl.m = cu(Bl),
                Vl.S = 512,
                Vl.U = Bl === "SHA-224" ? 224 : 256,
                Vl.T = !1,
                eu.hmacKey && Vl.k(xl("hmacKey", eu.hmacKey, Vl.C)),
                Vl
            }
            return El(Kl, nu),
            Kl
        }(wl)
          , Yl = function(nu, Kl) {
            this.N = nu,
            this.I = Kl
        };
        function lu(nu, Kl) {
            var Bl;
            return Kl > 32 ? (Bl = 64 - Kl,
            new Yl(nu.I << Kl | nu.N >>> Bl,nu.N << Kl | nu.I >>> Bl)) : Kl !== 0 ? (Bl = 32 - Kl,
            new Yl(nu.N << Kl | nu.I >>> Bl,nu.I << Kl | nu.N >>> Bl)) : nu
        }
        function mu(nu, Kl) {
            var Bl;
            return Kl < 32 ? (Bl = 32 - Kl,
            new Yl(nu.N >>> Kl | nu.I << Bl,nu.I >>> Kl | nu.N << Bl)) : (Bl = 64 - Kl,
            new Yl(nu.I >>> Kl | nu.N << Bl,nu.N >>> Kl | nu.I << Bl))
        }
        function Cu(nu, Kl) {
            return new Yl(nu.N >>> Kl,nu.I >>> Kl | nu.N << 32 - Kl)
        }
        function ju(nu, Kl, Bl) {
            return new Yl(nu.N & Kl.N ^ ~nu.N & Bl.N,nu.I & Kl.I ^ ~nu.I & Bl.I)
        }
        function Lu(nu, Kl, Bl) {
            return new Yl(nu.N & Kl.N ^ nu.N & Bl.N ^ Kl.N & Bl.N,nu.I & Kl.I ^ nu.I & Bl.I ^ Kl.I & Bl.I)
        }
        function Au(nu) {
            var Kl = mu(nu, 28)
              , Bl = mu(nu, 34)
              , Pl = mu(nu, 39);
            return new Yl(Kl.N ^ Bl.N ^ Pl.N,Kl.I ^ Bl.I ^ Pl.I)
        }
        function Du(nu, Kl) {
            var Bl, Pl;
            Bl = (65535 & nu.I) + (65535 & Kl.I);
            var Al = (65535 & (Pl = (nu.I >>> 16) + (Kl.I >>> 16) + (Bl >>> 16))) << 16 | 65535 & Bl;
            return Bl = (65535 & nu.N) + (65535 & Kl.N) + (Pl >>> 16),
            Pl = (nu.N >>> 16) + (Kl.N >>> 16) + (Bl >>> 16),
            new Yl((65535 & Pl) << 16 | 65535 & Bl,Al)
        }
        function Qu(nu, Kl, Bl, Pl) {
            var Al, Vl;
            Al = (65535 & nu.I) + (65535 & Kl.I) + (65535 & Bl.I) + (65535 & Pl.I);
            var eu = (65535 & (Vl = (nu.I >>> 16) + (Kl.I >>> 16) + (Bl.I >>> 16) + (Pl.I >>> 16) + (Al >>> 16))) << 16 | 65535 & Al;
            return Al = (65535 & nu.N) + (65535 & Kl.N) + (65535 & Bl.N) + (65535 & Pl.N) + (Vl >>> 16),
            Vl = (nu.N >>> 16) + (Kl.N >>> 16) + (Bl.N >>> 16) + (Pl.N >>> 16) + (Al >>> 16),
            new Yl((65535 & Vl) << 16 | 65535 & Al,eu)
        }
        function fu(nu, Kl, Bl, Pl, Al) {
            var Vl, eu;
            Vl = (65535 & nu.I) + (65535 & Kl.I) + (65535 & Bl.I) + (65535 & Pl.I) + (65535 & Al.I);
            var iu = (65535 & (eu = (nu.I >>> 16) + (Kl.I >>> 16) + (Bl.I >>> 16) + (Pl.I >>> 16) + (Al.I >>> 16) + (Vl >>> 16))) << 16 | 65535 & Vl;
            return Vl = (65535 & nu.N) + (65535 & Kl.N) + (65535 & Bl.N) + (65535 & Pl.N) + (65535 & Al.N) + (eu >>> 16),
            eu = (nu.N >>> 16) + (Kl.N >>> 16) + (Bl.N >>> 16) + (Pl.N >>> 16) + (Al.N >>> 16) + (Vl >>> 16),
            new Yl((65535 & eu) << 16 | 65535 & Vl,iu)
        }
        function yu(nu, Kl) {
            return new Yl(nu.N ^ Kl.N,nu.I ^ Kl.I)
        }
        function vu(nu) {
            var Kl = mu(nu, 1)
              , Bl = mu(nu, 8)
              , Pl = Cu(nu, 7);
            return new Yl(Kl.N ^ Bl.N ^ Pl.N,Kl.I ^ Bl.I ^ Pl.I)
        }
        function _u(nu) {
            var Kl = mu(nu, 14)
              , Bl = mu(nu, 18)
              , Pl = mu(nu, 41);
            return new Yl(Kl.N ^ Bl.N ^ Pl.N,Kl.I ^ Bl.I ^ Pl.I)
        }
        var xu = [new Yl(Vs[0],3609767458), new Yl(Vs[1],602891725), new Yl(Vs[2],3964484399), new Yl(Vs[3],2173295548), new Yl(Vs[4],4081628472), new Yl(Vs[5],3053834265), new Yl(Vs[6],2937671579), new Yl(Vs[7],3664609560), new Yl(Vs[8],2734883394), new Yl(Vs[9],1164996542), new Yl(Vs[10],1323610764), new Yl(Vs[11],3590304994), new Yl(Vs[12],4068182383), new Yl(Vs[13],991336113), new Yl(Vs[14],633803317), new Yl(Vs[15],3479774868), new Yl(Vs[16],2666613458), new Yl(Vs[17],944711139), new Yl(Vs[18],2341262773), new Yl(Vs[19],2007800933), new Yl(Vs[20],1495990901), new Yl(Vs[21],1856431235), new Yl(Vs[22],3175218132), new Yl(Vs[23],2198950837), new Yl(Vs[24],3999719339), new Yl(Vs[25],766784016), new Yl(Vs[26],2566594879), new Yl(Vs[27],3203337956), new Yl(Vs[28],1034457026), new Yl(Vs[29],2466948901), new Yl(Vs[30],3758326383), new Yl(Vs[31],168717936), new Yl(Vs[32],1188179964), new Yl(Vs[33],1546045734), new Yl(Vs[34],1522805485), new Yl(Vs[35],2643833823), new Yl(Vs[36],2343527390), new Yl(Vs[37],1014477480), new Yl(Vs[38],1206759142), new Yl(Vs[39],344077627), new Yl(Vs[40],1290863460), new Yl(Vs[41],3158454273), new Yl(Vs[42],3505952657), new Yl(Vs[43],106217008), new Yl(Vs[44],3606008344), new Yl(Vs[45],1432725776), new Yl(Vs[46],1467031594), new Yl(Vs[47],851169720), new Yl(Vs[48],3100823752), new Yl(Vs[49],1363258195), new Yl(Vs[50],3750685593), new Yl(Vs[51],3785050280), new Yl(Vs[52],3318307427), new Yl(Vs[53],3812723403), new Yl(Vs[54],2003034995), new Yl(Vs[55],3602036899), new Yl(Vs[56],1575990012), new Yl(Vs[57],1125592928), new Yl(Vs[58],2716904306), new Yl(Vs[59],442776044), new Yl(Vs[60],593698344), new Yl(Vs[61],3733110249), new Yl(Vs[62],2999351573), new Yl(Vs[63],3815920427), new Yl(3391569614,3928383900), new Yl(3515267271,566280711), new Yl(3940187606,3454069534), new Yl(4118630271,4000239992), new Yl(116418474,1914138554), new Yl(174292421,2731055270), new Yl(289380356,3203993006), new Yl(460393269,320620315), new Yl(685471733,587496836), new Yl(852142971,1086792851), new Yl(1017036298,365543100), new Yl(1126000580,2618297676), new Yl(1288033470,3409855158), new Yl(1501505948,4234509866), new Yl(1607167915,987167468), new Yl(1816402316,1246189591)];
        function Ru(nu) {
            return nu === "SHA-384" ? [new Yl(3418070365,Ws[0]), new Yl(1654270250,Ws[1]), new Yl(2438529370,Ws[2]), new Yl(355462360,Ws[3]), new Yl(1731405415,Ws[4]), new Yl(41048885895,Ws[5]), new Yl(3675008525,Ws[6]), new Yl(1203062813,Ws[7])] : [new Yl(Xs[0],4089235720), new Yl(Xs[1],2227873595), new Yl(Xs[2],4271175723), new Yl(Xs[3],1595750129), new Yl(Xs[4],2917565137), new Yl(Xs[5],725511199), new Yl(Xs[6],4215389547), new Yl(Xs[7],327033209)]
        }
        function Iu(nu, Kl) {
            var Bl, Pl, Al, Vl, eu, iu, ou, Tu, Hu, Mu, Uu, Yu, Gu, Tp, Sp, jp, Op = [];
            for (Bl = Kl[0],
            Pl = Kl[1],
            Al = Kl[2],
            Vl = Kl[3],
            eu = Kl[4],
            iu = Kl[5],
            ou = Kl[6],
            Tu = Kl[7],
            Uu = 0; Uu < 80; Uu += 1)
                Uu < 16 ? (Yu = 2 * Uu,
                Op[Uu] = new Yl(nu[Yu],nu[Yu + 1])) : Op[Uu] = Qu((Gu = Op[Uu - 2],
                Tp = void 0,
                Sp = void 0,
                jp = void 0,
                Tp = mu(Gu, 19),
                Sp = mu(Gu, 61),
                jp = Cu(Gu, 6),
                new Yl(Tp.N ^ Sp.N ^ jp.N,Tp.I ^ Sp.I ^ jp.I)), Op[Uu - 7], vu(Op[Uu - 15]), Op[Uu - 16]),
                Hu = fu(Tu, _u(eu), ju(eu, iu, ou), xu[Uu], Op[Uu]),
                Mu = Du(Au(Bl), Lu(Bl, Pl, Al)),
                Tu = ou,
                ou = iu,
                iu = eu,
                eu = Du(Vl, Hu),
                Vl = Al,
                Al = Pl,
                Pl = Bl,
                Bl = Du(Hu, Mu);
            return Kl[0] = Du(Bl, Kl[0]),
            Kl[1] = Du(Pl, Kl[1]),
            Kl[2] = Du(Al, Kl[2]),
            Kl[3] = Du(Vl, Kl[3]),
            Kl[4] = Du(eu, Kl[4]),
            Kl[5] = Du(iu, Kl[5]),
            Kl[6] = Du(ou, Kl[6]),
            Kl[7] = Du(Tu, Kl[7]),
            Kl
        }
        var Ku = function(nu) {
            function Kl(Bl, Pl, Al) {
                var Vl = this;
                if (Bl !== "SHA-384" && Bl !== "SHA-512")
                    throw new Error(ga);
                var eu = Al || {};
                return (Vl = nu.call(this, Bl, Pl, Al) || this).F = Vl.Y,
                Vl.g = !0,
                Vl.C = -1,
                Vl.p = Cs(Vl.t, Vl.i, Vl.C),
                Vl.R = Iu,
                Vl.B = function(iu) {
                    return iu.slice()
                }
                ,
                Vl.L = Ru,
                Vl.K = function(iu, ou, Tu, Hu) {
                    return function(Mu, Uu, Yu, Gu, Tp) {
                        for (var Sp, jp = 31 + (Uu + 129 >>> 10 << 5), Op = Uu + Yu; Mu.length <= jp; )
                            Mu.push(0);
                        for (Mu[Uu >>> 5] |= 128 << 24 - Uu % 32,
                        Mu[jp] = 4294967295 & Op,
                        Mu[jp - 1] = Op / 4294967296 | 0,
                        Sp = 0; Sp < Mu.length; Sp += 32)
                            Gu = Iu(Mu.slice(Sp, Sp + 32), Gu);
                        return Tp === "SHA-384" ? [(Gu = Gu)[0].N, Gu[0].I, Gu[1].N, Gu[1].I, Gu[2].N, Gu[2].I, Gu[3].N, Gu[3].I, Gu[4].N, Gu[4].I, Gu[5].N, Gu[5].I] : [Gu[0].N, Gu[0].I, Gu[1].N, Gu[1].I, Gu[2].N, Gu[2].I, Gu[3].N, Gu[3].I, Gu[4].N, Gu[4].I, Gu[5].N, Gu[5].I, Gu[6].N, Gu[6].I, Gu[7].N, Gu[7].I]
                    }(iu, ou, Tu, Hu, Bl)
                }
                ,
                Vl.m = Ru(Bl),
                Vl.S = 1024,
                Vl.U = Bl === "SHA-384" ? 384 : 512,
                Vl.T = !1,
                eu.hmacKey && Vl.k(xl("hmacKey", eu.hmacKey, Vl.C)),
                Vl
            }
            return El(Kl, nu),
            Kl
        }(wl)
          , dp = [new Yl(0,1), new Yl(0,32898), new Yl(2147483648,32906), new Yl(2147483648,2147516416), new Yl(0,32907), new Yl(0,2147483649), new Yl(2147483648,2147516545), new Yl(2147483648,32777), new Yl(0,138), new Yl(0,136), new Yl(0,2147516425), new Yl(0,2147483658), new Yl(0,2147516555), new Yl(2147483648,139), new Yl(2147483648,32905), new Yl(2147483648,32771), new Yl(2147483648,32770), new Yl(2147483648,128), new Yl(0,32778), new Yl(2147483648,2147483658), new Yl(2147483648,2147516545), new Yl(2147483648,32896), new Yl(0,2147483649), new Yl(2147483648,2147516424)]
          , lp = [[0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61], [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]];
        function qu(nu) {
            var Kl, Bl = [];
            for (Kl = 0; Kl < 5; Kl += 1)
                Bl[Kl] = [new Yl(0,0), new Yl(0,0), new Yl(0,0), new Yl(0,0), new Yl(0,0)];
            return Bl
        }
        function hp(nu) {
            var Kl, Bl = [];
            for (Kl = 0; Kl < 5; Kl += 1)
                Bl[Kl] = nu[Kl].slice();
            return Bl
        }
        function fp(nu, Kl) {
            var Bl, Pl, Al, Vl, eu, iu, ou, Tu, Hu, Mu = [], Uu = [];
            if (nu !== null)
                for (Pl = 0; Pl < nu.length; Pl += 2)
                    Kl[(Pl >>> 1) % 5][(Pl >>> 1) / 5 | 0] = yu(Kl[(Pl >>> 1) % 5][(Pl >>> 1) / 5 | 0], new Yl(nu[Pl + 1],nu[Pl]));
            for (Bl = 0; Bl < 24; Bl += 1) {
                for (Vl = qu(),
                Pl = 0; Pl < 5; Pl += 1)
                    Mu[Pl] = (eu = Kl[Pl][0],
                    iu = Kl[Pl][1],
                    ou = Kl[Pl][2],
                    Tu = Kl[Pl][3],
                    Hu = Kl[Pl][4],
                    new Yl(eu.N ^ iu.N ^ ou.N ^ Tu.N ^ Hu.N,eu.I ^ iu.I ^ ou.I ^ Tu.I ^ Hu.I));
                for (Pl = 0; Pl < 5; Pl += 1)
                    Uu[Pl] = yu(Mu[(Pl + 4) % 5], lu(Mu[(Pl + 1) % 5], 1));
                for (Pl = 0; Pl < 5; Pl += 1)
                    for (Al = 0; Al < 5; Al += 1)
                        Kl[Pl][Al] = yu(Kl[Pl][Al], Uu[Pl]);
                for (Pl = 0; Pl < 5; Pl += 1)
                    for (Al = 0; Al < 5; Al += 1)
                        Vl[Al][(2 * Pl + 3 * Al) % 5] = lu(Kl[Pl][Al], lp[Pl][Al]);
                for (Pl = 0; Pl < 5; Pl += 1)
                    for (Al = 0; Al < 5; Al += 1)
                        Kl[Pl][Al] = yu(Vl[Pl][Al], new Yl(~Vl[(Pl + 1) % 5][Al].N & Vl[(Pl + 2) % 5][Al].N,~Vl[(Pl + 1) % 5][Al].I & Vl[(Pl + 2) % 5][Al].I));
                Kl[0][0] = yu(Kl[0][0], dp[Bl])
            }
            return Kl
        }
        function Lp(nu) {
            var Kl, Bl, Pl = 0, Al = [0, 0], Vl = [4294967295 & nu, nu / 4294967296 & 2097151];
            for (Kl = 6; Kl >= 0; Kl--)
                (Bl = Vl[Kl >> 2] >>> 8 * Kl & 255) === 0 && Pl === 0 || (Al[Pl + 1 >> 2] |= Bl << 8 * (Pl + 1),
                Pl += 1);
            return Pl = Pl !== 0 ? Pl : 1,
            Al[0] |= Pl,
            {
                value: Pl + 1 > 4 ? Al : [Al[0]],
                binLen: 8 + 8 * Pl
            }
        }
        function uu(nu) {
            return ba(Lp(nu.binLen), nu)
        }
        function gu(nu, Kl) {
            var Bl, Pl = Lp(Kl), Al = Kl >>> 2, Vl = (Al - (Pl = ba(Pl, nu)).value.length % Al) % Al;
            for (Bl = 0; Bl < Vl; Bl++)
                Pl.value.push(0);
            return Pl.value
        }
        var Eu = function(nu) {
            function Kl(Bl, Pl, Al) {
                var Vl = this
                  , eu = 6
                  , iu = 0
                  , ou = Al || {};
                if ((Vl = nu.call(this, Bl, Pl, Al) || this).numRounds !== 1) {
                    if (ou.kmacKey || ou.hmacKey)
                        throw new Error("Cannot set numRounds with MAC");
                    if (Vl.o === "CSHAKE128" || Vl.o === "CSHAKE256")
                        throw new Error("Cannot set numRounds for CSHAKE variants")
                }
                switch (Vl.C = 1,
                Vl.p = Cs(Vl.t, Vl.i, Vl.C),
                Vl.R = fp,
                Vl.B = hp,
                Vl.L = qu,
                Vl.m = qu(),
                Vl.T = !1,
                Bl) {
                case "SHA3-224":
                    Vl.S = iu = 1152,
                    Vl.U = 224,
                    Vl.g = !0,
                    Vl.F = Vl.Y;
                    break;
                case "SHA3-256":
                    Vl.S = iu = 1088,
                    Vl.U = 256,
                    Vl.g = !0,
                    Vl.F = Vl.Y;
                    break;
                case "SHA3-384":
                    Vl.S = iu = 832,
                    Vl.U = 384,
                    Vl.g = !0,
                    Vl.F = Vl.Y;
                    break;
                case "SHA3-512":
                    Vl.S = iu = 576,
                    Vl.U = 512,
                    Vl.g = !0,
                    Vl.F = Vl.Y;
                    break;
                case "SHAKE128":
                    eu = 31,
                    Vl.S = iu = 1344,
                    Vl.U = -1,
                    Vl.T = !0,
                    Vl.g = !1,
                    Vl.F = null;
                    break;
                case "SHAKE256":
                    eu = 31,
                    Vl.S = iu = 1088,
                    Vl.U = -1,
                    Vl.T = !0,
                    Vl.g = !1,
                    Vl.F = null;
                    break;
                case "KMAC128":
                    eu = 4,
                    Vl.S = iu = 1344,
                    Vl.M(Al),
                    Vl.U = -1,
                    Vl.T = !0,
                    Vl.g = !1,
                    Vl.F = Vl.X;
                    break;
                case "KMAC256":
                    eu = 4,
                    Vl.S = iu = 1088,
                    Vl.M(Al),
                    Vl.U = -1,
                    Vl.T = !0,
                    Vl.g = !1,
                    Vl.F = Vl.X;
                    break;
                case "CSHAKE128":
                    Vl.S = iu = 1344,
                    eu = Vl.O(Al),
                    Vl.U = -1,
                    Vl.T = !0,
                    Vl.g = !1,
                    Vl.F = null;
                    break;
                case "CSHAKE256":
                    Vl.S = iu = 1088,
                    eu = Vl.O(Al),
                    Vl.U = -1,
                    Vl.T = !0,
                    Vl.g = !1,
                    Vl.F = null;
                    break;
                default:
                    throw new Error(ga)
                }
                return Vl.K = function(Tu, Hu, Mu, Uu, Yu) {
                    return function(Gu, Tp, Sp, jp, Op, Gp, Wp) {
                        var Zp, Im, gm = 0, ym = [], Dm = Op >>> 5, Jp = Tp >>> 5;
                        for (Zp = 0; Zp < Jp && Tp >= Op; Zp += Dm)
                            jp = fp(Gu.slice(Zp, Zp + Dm), jp),
                            Tp -= Op;
                        for (Gu = Gu.slice(Zp),
                        Tp %= Op; Gu.length < Dm; )
                            Gu.push(0);
                        for (Gu[(Zp = Tp >>> 3) >> 2] ^= Gp << Zp % 4 * 8,
                        Gu[Dm - 1] ^= 2147483648,
                        jp = fp(Gu, jp); 32 * ym.length < Wp && (Im = jp[gm % 5][gm / 5 | 0],
                        ym.push(Im.I),
                        !(32 * ym.length >= Wp)); )
                            ym.push(Im.N),
                            64 * (gm += 1) % Op == 0 && (fp(null, jp),
                            gm = 0);
                        return ym
                    }(Tu, Hu, 0, Uu, iu, eu, Yu)
                }
                ,
                ou.hmacKey && Vl.k(xl("hmacKey", ou.hmacKey, Vl.C)),
                Vl
            }
            return El(Kl, nu),
            Kl.prototype.O = function(Bl, Pl) {
                var Al = function(ou) {
                    var Tu = ou || {};
                    return {
                        funcName: xl("funcName", Tu.funcName, 1, {
                            value: [],
                            binLen: 0
                        }),
                        customization: xl("Customization", Tu.customization, 1, {
                            value: [],
                            binLen: 0
                        })
                    }
                }(Bl || {});
                Pl && (Al.funcName = Pl);
                var Vl = ba(uu(Al.funcName), uu(Al.customization));
                if (Al.customization.binLen !== 0 || Al.funcName.binLen !== 0) {
                    for (var eu = gu(Vl, this.S >>> 3), iu = 0; iu < eu.length; iu += this.S >>> 5)
                        this.m = this.R(eu.slice(iu, iu + (this.S >>> 5)), this.m),
                        this.v += this.S;
                    return 4
                }
                return 31
            }
            ,
            Kl.prototype.M = function(Bl) {
                var Pl = function(eu) {
                    var iu = eu || {};
                    return {
                        kmacKey: xl("kmacKey", iu.kmacKey, 1),
                        funcName: {
                            value: [1128353099],
                            binLen: 32
                        },
                        customization: xl("Customization", iu.customization, 1, {
                            value: [],
                            binLen: 0
                        })
                    }
                }(Bl || {});
                this.O(Bl, Pl.funcName);
                for (var Al = gu(uu(Pl.kmacKey), this.S >>> 3), Vl = 0; Vl < Al.length; Vl += this.S >>> 5)
                    this.m = this.R(Al.slice(Vl, Vl + (this.S >>> 5)), this.m),
                    this.v += this.S;
                this.A = !0
            }
            ,
            Kl.prototype.X = function(Bl) {
                var Pl = ba({
                    value: this.u.slice(),
                    binLen: this.s
                }, function(Al) {
                    var Vl, eu, iu = 0, ou = [0, 0], Tu = [4294967295 & Al, Al / 4294967296 & 2097151];
                    for (Vl = 6; Vl >= 0; Vl--)
                        (eu = Tu[Vl >> 2] >>> 8 * Vl & 255) == 0 && iu === 0 || (ou[iu >> 2] |= eu << 8 * iu,
                        iu += 1);
                    return ou[(iu = iu !== 0 ? iu : 1) >> 2] |= iu << 8 * iu,
                    {
                        value: iu + 1 > 4 ? ou : [ou[0]],
                        binLen: 8 + 8 * iu
                    }
                }(Bl.outputLen));
                return this.K(Pl.value, Pl.binLen, this.v, this.B(this.m), Bl.outputLen)
            }
            ,
            Kl
        }(wl);
        return function() {
            function nu(Kl, Bl, Pl) {
                if (Kl == "SHA-1")
                    this.j = new Ql(Kl,Bl,Pl);
                else if (Kl == "SHA-224" || Kl == "SHA-256")
                    this.j = new zl(Kl,Bl,Pl);
                else if (Kl == "SHA-384" || Kl == "SHA-512")
                    this.j = new Ku(Kl,Bl,Pl);
                else {
                    if (Kl != "SHA3-224" && Kl != "SHA3-256" && Kl != "SHA3-384" && Kl != "SHA3-512" && Kl != "SHAKE128" && Kl != "SHAKE256" && Kl != "CSHAKE128" && Kl != "CSHAKE256" && Kl != "KMAC128" && Kl != "KMAC256")
                        throw new Error(ga);
                    this.j = new Eu(Kl,Bl,Pl)
                }
            }
            return nu.prototype.update = function(Kl) {
                this.j.update(Kl)
            }
            ,
            nu.prototype.getHash = function(Kl, Bl) {
                return this.j.getHash(Kl, Bl)
            }
            ,
            nu.prototype.setHMACKey = function(Kl, Bl, Pl) {
                this.j.setHMACKey(Kl, Bl, Pl)
            }
            ,
            nu.prototype.getHMAC = function(Kl, Bl) {
                return this.j.getHMAC(Kl, Bl)
            }
            ,
            nu
        }()
    })
}
)(sha);
var shaExports = sha.exports
  , browser = {}
  , getSecureRandom$1 = {};
Object.defineProperty(getSecureRandom$1, "__esModule", {
    value: !0
});
getSecureRandom$1.getSecureRandomWords = getSecureRandom$1.getSecureRandomBytes = void 0;
function getSecureRandomBytes$1(xt) {
    return Buffer.from(window.crypto.getRandomValues(new Uint8Array(xt)))
}
getSecureRandom$1.getSecureRandomBytes = getSecureRandomBytes$1;
function getSecureRandomWords$1(xt) {
    return window.crypto.getRandomValues(new Uint16Array(xt))
}
getSecureRandom$1.getSecureRandomWords = getSecureRandomWords$1;
var hmac_sha512$3 = {};
Object.defineProperty(hmac_sha512$3, "__esModule", {
    value: !0
});
hmac_sha512$3.hmac_sha512 = void 0;
async function hmac_sha512$2(xt, Cn) {
    let as = typeof xt == "string" ? Buffer.from(xt, "utf-8") : xt
      , cs = typeof Cn == "string" ? Buffer.from(Cn, "utf-8") : Cn;
    const Cs = {
        name: "HMAC",
        hash: "SHA-512"
    }
      , Ls = await window.crypto.subtle.importKey("raw", as, Cs, !1, ["sign"]);
    return Buffer.from(await crypto.subtle.sign(Cs, Ls, cs))
}
hmac_sha512$3.hmac_sha512 = hmac_sha512$2;
var pbkdf2_sha512$3 = {};
Object.defineProperty(pbkdf2_sha512$3, "__esModule", {
    value: !0
});
pbkdf2_sha512$3.pbkdf2_sha512 = void 0;
async function pbkdf2_sha512$2(xt, Cn, as, cs) {
    const Cs = typeof xt == "string" ? Buffer.from(xt, "utf-8") : xt
      , Ls = typeof Cn == "string" ? Buffer.from(Cn, "utf-8") : Cn
      , Vs = await window.crypto.subtle.importKey("raw", Cs, {
        name: "PBKDF2"
    }, !1, ["deriveBits"])
      , Ws = await window.crypto.subtle.deriveBits({
        name: "PBKDF2",
        hash: "SHA-512",
        salt: Ls,
        iterations: as
    }, Vs, cs * 8);
    return Buffer.from(Ws)
}
pbkdf2_sha512$3.pbkdf2_sha512 = pbkdf2_sha512$2;
var sha256$2 = {};
Object.defineProperty(sha256$2, "__esModule", {
    value: !0
});
sha256$2.sha256 = void 0;
async function sha256$1(xt) {
    return typeof xt == "string" ? Buffer.from(await crypto.subtle.digest("SHA-256", Buffer.from(xt, "utf-8"))) : Buffer.from(await crypto.subtle.digest("SHA-256", xt))
}
sha256$2.sha256 = sha256$1;
var sha512$3 = {};
Object.defineProperty(sha512$3, "__esModule", {
    value: !0
});
sha512$3.sha512 = void 0;
async function sha512$2(xt) {
    return typeof xt == "string" ? Buffer.from(await crypto.subtle.digest("SHA-512", Buffer.from(xt, "utf-8"))) : Buffer.from(await crypto.subtle.digest("SHA-512", xt))
}
sha512$3.sha512 = sha512$2;
(function(xt) {
    Object.defineProperty(xt, "__esModule", {
        value: !0
    }),
    xt.sha512 = xt.sha256 = xt.pbkdf2_sha512 = xt.hmac_sha512 = xt.getSecureRandomWords = xt.getSecureRandomBytes = void 0;
    var Cn = getSecureRandom$1;
    Object.defineProperty(xt, "getSecureRandomBytes", {
        enumerable: !0,
        get: function() {
            return Cn.getSecureRandomBytes
        }
    }),
    Object.defineProperty(xt, "getSecureRandomWords", {
        enumerable: !0,
        get: function() {
            return Cn.getSecureRandomWords
        }
    });
    var as = hmac_sha512$3;
    Object.defineProperty(xt, "hmac_sha512", {
        enumerable: !0,
        get: function() {
            return as.hmac_sha512
        }
    });
    var cs = pbkdf2_sha512$3;
    Object.defineProperty(xt, "pbkdf2_sha512", {
        enumerable: !0,
        get: function() {
            return cs.pbkdf2_sha512
        }
    });
    var Cs = sha256$2;
    Object.defineProperty(xt, "sha256", {
        enumerable: !0,
        get: function() {
            return Cs.sha256
        }
    });
    var Ls = sha512$3;
    Object.defineProperty(xt, "sha512", {
        enumerable: !0,
        get: function() {
            return Ls.sha512
        }
    })
}
)(browser);
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(xt) {
    return xt && xt.__esModule ? xt : {
        default: xt
    }
}
;
Object.defineProperty(sha256$3, "__esModule", {
    value: !0
});
sha256$3.sha256 = sha256$3.sha256_fallback = sha256$3.sha256_sync = void 0;
const jssha_1$2 = __importDefault$4(shaExports)
  , crypto_primitives_1$4 = browser;
function sha256_sync(xt) {
    let Cn;
    typeof xt == "string" ? Cn = Buffer.from(xt, "utf-8").toString("hex") : Cn = xt.toString("hex");
    let as = new jssha_1$2.default("SHA-256","HEX");
    as.update(Cn);
    let cs = as.getHash("HEX");
    return Buffer.from(cs, "hex")
}
sha256$3.sha256_sync = sha256_sync;
async function sha256_fallback(xt) {
    return sha256_sync(xt)
}
sha256$3.sha256_fallback = sha256_fallback;
function sha256(xt) {
    return (0,
    crypto_primitives_1$4.sha256)(xt)
}
sha256$3.sha256 = sha256;
var sha512$1 = {}
  , __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(xt) {
    return xt && xt.__esModule ? xt : {
        default: xt
    }
}
;
Object.defineProperty(sha512$1, "__esModule", {
    value: !0
});
sha512$1.sha512 = sha512$1.sha512_fallback = sha512$1.sha512_sync = void 0;
const jssha_1$1 = __importDefault$3(shaExports)
  , crypto_primitives_1$3 = browser;
function sha512_sync(xt) {
    let Cn;
    typeof xt == "string" ? Cn = Buffer.from(xt, "utf-8").toString("hex") : Cn = xt.toString("hex");
    let as = new jssha_1$1.default("SHA-512","HEX");
    as.update(Cn);
    let cs = as.getHash("HEX");
    return Buffer.from(cs, "hex")
}
sha512$1.sha512_sync = sha512_sync;
async function sha512_fallback(xt) {
    return sha512_sync(xt)
}
sha512$1.sha512_fallback = sha512_fallback;
async function sha512(xt) {
    return (0,
    crypto_primitives_1$3.sha512)(xt)
}
sha512$1.sha512 = sha512;
var pbkdf2_sha512$1 = {};
Object.defineProperty(pbkdf2_sha512$1, "__esModule", {
    value: !0
});
pbkdf2_sha512$1.pbkdf2_sha512 = void 0;
const crypto_primitives_1$2 = browser;
function pbkdf2_sha512(xt, Cn, as, cs) {
    return (0,
    crypto_primitives_1$2.pbkdf2_sha512)(xt, Cn, as, cs)
}
pbkdf2_sha512$1.pbkdf2_sha512 = pbkdf2_sha512;
var hmac_sha512$1 = {}
  , __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(xt) {
    return xt && xt.__esModule ? xt : {
        default: xt
    }
}
;
Object.defineProperty(hmac_sha512$1, "__esModule", {
    value: !0
});
hmac_sha512$1.hmac_sha512 = hmac_sha512$1.hmac_sha512_fallback = void 0;
const jssha_1 = __importDefault$2(shaExports)
  , crypto_primitives_1$1 = browser;
async function hmac_sha512_fallback(xt, Cn) {
    let as = typeof xt == "string" ? Buffer.from(xt, "utf-8") : xt
      , cs = typeof Cn == "string" ? Buffer.from(Cn, "utf-8") : Cn;
    const Cs = new jssha_1.default("SHA-512","HEX",{
        hmacKey: {
            value: as.toString("hex"),
            format: "HEX"
        }
    });
    Cs.update(cs.toString("hex"));
    const Ls = Cs.getHash("HEX");
    return Buffer.from(Ls, "hex")
}
hmac_sha512$1.hmac_sha512_fallback = hmac_sha512_fallback;
function hmac_sha512(xt, Cn) {
    return (0,
    crypto_primitives_1$1.hmac_sha512)(xt, Cn)
}
hmac_sha512$1.hmac_sha512 = hmac_sha512;
var getSecureRandom = {};
Object.defineProperty(getSecureRandom, "__esModule", {
    value: !0
});
getSecureRandom.getSecureRandomNumber = getSecureRandom.getSecureRandomWords = getSecureRandom.getSecureRandomBytes = void 0;
const crypto_primitives_1 = browser;
async function getSecureRandomBytes(xt) {
    return (0,
    crypto_primitives_1.getSecureRandomBytes)(xt)
}
getSecureRandom.getSecureRandomBytes = getSecureRandomBytes;
async function getSecureRandomWords(xt) {
    return getSecureRandomWords()
}
getSecureRandom.getSecureRandomWords = getSecureRandomWords;
async function getSecureRandomNumber(xt, Cn) {
    let as = Cn - xt;
    var cs = Math.ceil(Math.log2(as));
    if (cs > 53)
        throw new Error("Range is too large");
    for (var Cs = Math.ceil(cs / 8), Ls = Math.pow(2, cs) - 1; ; ) {
        let Ws = await getSecureRandomBytes(cs)
          , Xs = (Cs - 1) * 8
          , ga = 0;
        for (var Vs = 0; Vs < Cs; Vs++)
            ga += Ws[Vs] * Math.pow(2, Xs),
            Xs -= 8;
        if (ga = ga & Ls,
        !(ga >= as))
            return xt + ga
    }
}
getSecureRandom.getSecureRandomNumber = getSecureRandomNumber;
var newSecureWords$1 = {}
  , wordlist$1 = {};
Object.defineProperty(wordlist$1, "__esModule", {
    value: !0
});
wordlist$1.wordlist = void 0;
wordlist$1.wordlist = ["abacus", "abdomen", "abdominal", "abide", "abiding", "ability", "ablaze", "able", "abnormal", "abrasion", "abrasive", "abreast", "abridge", "abroad", "abruptly", "absence", "absentee", "absently", "absinthe", "absolute", "absolve", "abstain", "abstract", "absurd", "accent", "acclaim", "acclimate", "accompany", "account", "accuracy", "accurate", "accustom", "acetone", "achiness", "aching", "acid", "acorn", "acquaint", "acquire", "acre", "acrobat", "acronym", "acting", "action", "activate", "activator", "active", "activism", "activist", "activity", "actress", "acts", "acutely", "acuteness", "aeration", "aerobics", "aerosol", "aerospace", "afar", "affair", "affected", "affecting", "affection", "affidavit", "affiliate", "affirm", "affix", "afflicted", "affluent", "afford", "affront", "aflame", "afloat", "aflutter", "afoot", "afraid", "afterglow", "afterlife", "aftermath", "aftermost", "afternoon", "aged", "ageless", "agency", "agenda", "agent", "aggregate", "aghast", "agile", "agility", "aging", "agnostic", "agonize", "agonizing", "agony", "agreeable", "agreeably", "agreed", "agreeing", "agreement", "aground", "ahead", "ahoy", "aide", "aids", "aim", "ajar", "alabaster", "alarm", "albatross", "album", "alfalfa", "algebra", "algorithm", "alias", "alibi", "alienable", "alienate", "aliens", "alike", "alive", "alkaline", "alkalize", "almanac", "almighty", "almost", "aloe", "aloft", "aloha", "alone", "alongside", "aloof", "alphabet", "alright", "although", "altitude", "alto", "aluminum", "alumni", "always", "amaretto", "amaze", "amazingly", "amber", "ambiance", "ambiguity", "ambiguous", "ambition", "ambitious", "ambulance", "ambush", "amendable", "amendment", "amends", "amenity", "amiable", "amicably", "amid", "amigo", "amino", "amiss", "ammonia", "ammonium", "amnesty", "amniotic", "among", "amount", "amperage", "ample", "amplifier", "amplify", "amply", "amuck", "amulet", "amusable", "amused", "amusement", "amuser", "amusing", "anaconda", "anaerobic", "anagram", "anatomist", "anatomy", "anchor", "anchovy", "ancient", "android", "anemia", "anemic", "aneurism", "anew", "angelfish", "angelic", "anger", "angled", "angler", "angles", "angling", "angrily", "angriness", "anguished", "angular", "animal", "animate", "animating", "animation", "animator", "anime", "animosity", "ankle", "annex", "annotate", "announcer", "annoying", "annually", "annuity", "anointer", "another", "answering", "antacid", "antarctic", "anteater", "antelope", "antennae", "anthem", "anthill", "anthology", "antibody", "antics", "antidote", "antihero", "antiquely", "antiques", "antiquity", "antirust", "antitoxic", "antitrust", "antiviral", "antivirus", "antler", "antonym", "antsy", "anvil", "anybody", "anyhow", "anymore", "anyone", "anyplace", "anything", "anytime", "anyway", "anywhere", "aorta", "apache", "apostle", "appealing", "appear", "appease", "appeasing", "appendage", "appendix", "appetite", "appetizer", "applaud", "applause", "apple", "appliance", "applicant", "applied", "apply", "appointee", "appraisal", "appraiser", "apprehend", "approach", "approval", "approve", "apricot", "april", "apron", "aptitude", "aptly", "aqua", "aqueduct", "arbitrary", "arbitrate", "ardently", "area", "arena", "arguable", "arguably", "argue", "arise", "armadillo", "armband", "armchair", "armed", "armful", "armhole", "arming", "armless", "armoire", "armored", "armory", "armrest", "army", "aroma", "arose", "around", "arousal", "arrange", "array", "arrest", "arrival", "arrive", "arrogance", "arrogant", "arson", "art", "ascend", "ascension", "ascent", "ascertain", "ashamed", "ashen", "ashes", "ashy", "aside", "askew", "asleep", "asparagus", "aspect", "aspirate", "aspire", "aspirin", "astonish", "astound", "astride", "astrology", "astronaut", "astronomy", "astute", "atlantic", "atlas", "atom", "atonable", "atop", "atrium", "atrocious", "atrophy", "attach", "attain", "attempt", "attendant", "attendee", "attention", "attentive", "attest", "attic", "attire", "attitude", "attractor", "attribute", "atypical", "auction", "audacious", "audacity", "audible", "audibly", "audience", "audio", "audition", "augmented", "august", "authentic", "author", "autism", "autistic", "autograph", "automaker", "automated", "automatic", "autopilot", "available", "avalanche", "avatar", "avenge", "avenging", "avenue", "average", "aversion", "avert", "aviation", "aviator", "avid", "avoid", "await", "awaken", "award", "aware", "awhile", "awkward", "awning", "awoke", "awry", "axis", "babble", "babbling", "babied", "baboon", "backache", "backboard", "backboned", "backdrop", "backed", "backer", "backfield", "backfire", "backhand", "backing", "backlands", "backlash", "backless", "backlight", "backlit", "backlog", "backpack", "backpedal", "backrest", "backroom", "backshift", "backside", "backslid", "backspace", "backspin", "backstab", "backstage", "backtalk", "backtrack", "backup", "backward", "backwash", "backwater", "backyard", "bacon", "bacteria", "bacterium", "badass", "badge", "badland", "badly", "badness", "baffle", "baffling", "bagel", "bagful", "baggage", "bagged", "baggie", "bagginess", "bagging", "baggy", "bagpipe", "baguette", "baked", "bakery", "bakeshop", "baking", "balance", "balancing", "balcony", "balmy", "balsamic", "bamboo", "banana", "banish", "banister", "banjo", "bankable", "bankbook", "banked", "banker", "banking", "banknote", "bankroll", "banner", "bannister", "banshee", "banter", "barbecue", "barbed", "barbell", "barber", "barcode", "barge", "bargraph", "barista", "baritone", "barley", "barmaid", "barman", "barn", "barometer", "barrack", "barracuda", "barrel", "barrette", "barricade", "barrier", "barstool", "bartender", "barterer", "bash", "basically", "basics", "basil", "basin", "basis", "basket", "batboy", "batch", "bath", "baton", "bats", "battalion", "battered", "battering", "battery", "batting", "battle", "bauble", "bazooka", "blabber", "bladder", "blade", "blah", "blame", "blaming", "blanching", "blandness", "blank", "blaspheme", "blasphemy", "blast", "blatancy", "blatantly", "blazer", "blazing", "bleach", "bleak", "bleep", "blemish", "blend", "bless", "blighted", "blimp", "bling", "blinked", "blinker", "blinking", "blinks", "blip", "blissful", "blitz", "blizzard", "bloated", "bloating", "blob", "blog", "bloomers", "blooming", "blooper", "blot", "blouse", "blubber", "bluff", "bluish", "blunderer", "blunt", "blurb", "blurred", "blurry", "blurt", "blush", "blustery", "boaster", "boastful", "boasting", "boat", "bobbed", "bobbing", "bobble", "bobcat", "bobsled", "bobtail", "bodacious", "body", "bogged", "boggle", "bogus", "boil", "bok", "bolster", "bolt", "bonanza", "bonded", "bonding", "bondless", "boned", "bonehead", "boneless", "bonelike", "boney", "bonfire", "bonnet", "bonsai", "bonus", "bony", "boogeyman", "boogieman", "book", "boondocks", "booted", "booth", "bootie", "booting", "bootlace", "bootleg", "boots", "boozy", "borax", "boring", "borough", "borrower", "borrowing", "boss", "botanical", "botanist", "botany", "botch", "both", "bottle", "bottling", "bottom", "bounce", "bouncing", "bouncy", "bounding", "boundless", "bountiful", "bovine", "boxcar", "boxer", "boxing", "boxlike", "boxy", "breach", "breath", "breeches", "breeching", "breeder", "breeding", "breeze", "breezy", "brethren", "brewery", "brewing", "briar", "bribe", "brick", "bride", "bridged", "brigade", "bright", "brilliant", "brim", "bring", "brink", "brisket", "briskly", "briskness", "bristle", "brittle", "broadband", "broadcast", "broaden", "broadly", "broadness", "broadside", "broadways", "broiler", "broiling", "broken", "broker", "bronchial", "bronco", "bronze", "bronzing", "brook", "broom", "brought", "browbeat", "brownnose", "browse", "browsing", "bruising", "brunch", "brunette", "brunt", "brush", "brussels", "brute", "brutishly", "bubble", "bubbling", "bubbly", "buccaneer", "bucked", "bucket", "buckle", "buckshot", "buckskin", "bucktooth", "buckwheat", "buddhism", "buddhist", "budding", "buddy", "budget", "buffalo", "buffed", "buffer", "buffing", "buffoon", "buggy", "bulb", "bulge", "bulginess", "bulgur", "bulk", "bulldog", "bulldozer", "bullfight", "bullfrog", "bullhorn", "bullion", "bullish", "bullpen", "bullring", "bullseye", "bullwhip", "bully", "bunch", "bundle", "bungee", "bunion", "bunkbed", "bunkhouse", "bunkmate", "bunny", "bunt", "busboy", "bush", "busily", "busload", "bust", "busybody", "buzz", "cabana", "cabbage", "cabbie", "cabdriver", "cable", "caboose", "cache", "cackle", "cacti", "cactus", "caddie", "caddy", "cadet", "cadillac", "cadmium", "cage", "cahoots", "cake", "calamari", "calamity", "calcium", "calculate", "calculus", "caliber", "calibrate", "calm", "caloric", "calorie", "calzone", "camcorder", "cameo", "camera", "camisole", "camper", "campfire", "camping", "campsite", "campus", "canal", "canary", "cancel", "candied", "candle", "candy", "cane", "canine", "canister", "cannabis", "canned", "canning", "cannon", "cannot", "canola", "canon", "canopener", "canopy", "canteen", "canyon", "capable", "capably", "capacity", "cape", "capillary", "capital", "capitol", "capped", "capricorn", "capsize", "capsule", "caption", "captivate", "captive", "captivity", "capture", "caramel", "carat", "caravan", "carbon", "cardboard", "carded", "cardiac", "cardigan", "cardinal", "cardstock", "carefully", "caregiver", "careless", "caress", "caretaker", "cargo", "caring", "carless", "carload", "carmaker", "carnage", "carnation", "carnival", "carnivore", "carol", "carpenter", "carpentry", "carpool", "carport", "carried", "carrot", "carrousel", "carry", "cartel", "cartload", "carton", "cartoon", "cartridge", "cartwheel", "carve", "carving", "carwash", "cascade", "case", "cash", "casing", "casino", "casket", "cassette", "casually", "casualty", "catacomb", "catalog", "catalyst", "catalyze", "catapult", "cataract", "catatonic", "catcall", "catchable", "catcher", "catching", "catchy", "caterer", "catering", "catfight", "catfish", "cathedral", "cathouse", "catlike", "catnap", "catnip", "catsup", "cattail", "cattishly", "cattle", "catty", "catwalk", "caucasian", "caucus", "causal", "causation", "cause", "causing", "cauterize", "caution", "cautious", "cavalier", "cavalry", "caviar", "cavity", "cedar", "celery", "celestial", "celibacy", "celibate", "celtic", "cement", "census", "ceramics", "ceremony", "certainly", "certainty", "certified", "certify", "cesarean", "cesspool", "chafe", "chaffing", "chain", "chair", "chalice", "challenge", "chamber", "chamomile", "champion", "chance", "change", "channel", "chant", "chaos", "chaperone", "chaplain", "chapped", "chaps", "chapter", "character", "charbroil", "charcoal", "charger", "charging", "chariot", "charity", "charm", "charred", "charter", "charting", "chase", "chasing", "chaste", "chastise", "chastity", "chatroom", "chatter", "chatting", "chatty", "cheating", "cheddar", "cheek", "cheer", "cheese", "cheesy", "chef", "chemicals", "chemist", "chemo", "cherisher", "cherub", "chess", "chest", "chevron", "chevy", "chewable", "chewer", "chewing", "chewy", "chief", "chihuahua", "childcare", "childhood", "childish", "childless", "childlike", "chili", "chill", "chimp", "chip", "chirping", "chirpy", "chitchat", "chivalry", "chive", "chloride", "chlorine", "choice", "chokehold", "choking", "chomp", "chooser", "choosing", "choosy", "chop", "chosen", "chowder", "chowtime", "chrome", "chubby", "chuck", "chug", "chummy", "chump", "chunk", "churn", "chute", "cider", "cilantro", "cinch", "cinema", "cinnamon", "circle", "circling", "circular", "circulate", "circus", "citable", "citadel", "citation", "citizen", "citric", "citrus", "city", "civic", "civil", "clad", "claim", "clambake", "clammy", "clamor", "clamp", "clamshell", "clang", "clanking", "clapped", "clapper", "clapping", "clarify", "clarinet", "clarity", "clash", "clasp", "class", "clatter", "clause", "clavicle", "claw", "clay", "clean", "clear", "cleat", "cleaver", "cleft", "clench", "clergyman", "clerical", "clerk", "clever", "clicker", "client", "climate", "climatic", "cling", "clinic", "clinking", "clip", "clique", "cloak", "clobber", "clock", "clone", "cloning", "closable", "closure", "clothes", "clothing", "cloud", "clover", "clubbed", "clubbing", "clubhouse", "clump", "clumsily", "clumsy", "clunky", "clustered", "clutch", "clutter", "coach", "coagulant", "coastal", "coaster", "coasting", "coastland", "coastline", "coat", "coauthor", "cobalt", "cobbler", "cobweb", "cocoa", "coconut", "cod", "coeditor", "coerce", "coexist", "coffee", "cofounder", "cognition", "cognitive", "cogwheel", "coherence", "coherent", "cohesive", "coil", "coke", "cola", "cold", "coleslaw", "coliseum", "collage", "collapse", "collar", "collected", "collector", "collide", "collie", "collision", "colonial", "colonist", "colonize", "colony", "colossal", "colt", "coma", "come", "comfort", "comfy", "comic", "coming", "comma", "commence", "commend", "comment", "commerce", "commode", "commodity", "commodore", "common", "commotion", "commute", "commuting", "compacted", "compacter", "compactly", "compactor", "companion", "company", "compare", "compel", "compile", "comply", "component", "composed", "composer", "composite", "compost", "composure", "compound", "compress", "comprised", "computer", "computing", "comrade", "concave", "conceal", "conceded", "concept", "concerned", "concert", "conch", "concierge", "concise", "conclude", "concrete", "concur", "condense", "condiment", "condition", "condone", "conducive", "conductor", "conduit", "cone", "confess", "confetti", "confidant", "confident", "confider", "confiding", "configure", "confined", "confining", "confirm", "conflict", "conform", "confound", "confront", "confused", "confusing", "confusion", "congenial", "congested", "congrats", "congress", "conical", "conjoined", "conjure", "conjuror", "connected", "connector", "consensus", "consent", "console", "consoling", "consonant", "constable", "constant", "constrain", "constrict", "construct", "consult", "consumer", "consuming", "contact", "container", "contempt", "contend", "contented", "contently", "contents", "contest", "context", "contort", "contour", "contrite", "control", "contusion", "convene", "convent", "copartner", "cope", "copied", "copier", "copilot", "coping", "copious", "copper", "copy", "coral", "cork", "cornball", "cornbread", "corncob", "cornea", "corned", "corner", "cornfield", "cornflake", "cornhusk", "cornmeal", "cornstalk", "corny", "coronary", "coroner", "corporal", "corporate", "corral", "correct", "corridor", "corrode", "corroding", "corrosive", "corsage", "corset", "cortex", "cosigner", "cosmetics", "cosmic", "cosmos", "cosponsor", "cost", "cottage", "cotton", "couch", "cough", "could", "countable", "countdown", "counting", "countless", "country", "county", "courier", "covenant", "cover", "coveted", "coveting", "coyness", "cozily", "coziness", "cozy", "crabbing", "crabgrass", "crablike", "crabmeat", "cradle", "cradling", "crafter", "craftily", "craftsman", "craftwork", "crafty", "cramp", "cranberry", "crane", "cranial", "cranium", "crank", "crate", "crave", "craving", "crawfish", "crawlers", "crawling", "crayfish", "crayon", "crazed", "crazily", "craziness", "crazy", "creamed", "creamer", "creamlike", "crease", "creasing", "creatable", "create", "creation", "creative", "creature", "credible", "credibly", "credit", "creed", "creme", "creole", "crepe", "crept", "crescent", "crested", "cresting", "crestless", "crevice", "crewless", "crewman", "crewmate", "crib", "cricket", "cried", "crier", "crimp", "crimson", "cringe", "cringing", "crinkle", "crinkly", "crisped", "crisping", "crisply", "crispness", "crispy", "criteria", "critter", "croak", "crock", "crook", "croon", "crop", "cross", "crouch", "crouton", "crowbar", "crowd", "crown", "crucial", "crudely", "crudeness", "cruelly", "cruelness", "cruelty", "crumb", "crummiest", "crummy", "crumpet", "crumpled", "cruncher", "crunching", "crunchy", "crusader", "crushable", "crushed", "crusher", "crushing", "crust", "crux", "crying", "cryptic", "crystal", "cubbyhole", "cube", "cubical", "cubicle", "cucumber", "cuddle", "cuddly", "cufflink", "culinary", "culminate", "culpable", "culprit", "cultivate", "cultural", "culture", "cupbearer", "cupcake", "cupid", "cupped", "cupping", "curable", "curator", "curdle", "cure", "curfew", "curing", "curled", "curler", "curliness", "curling", "curly", "curry", "curse", "cursive", "cursor", "curtain", "curtly", "curtsy", "curvature", "curve", "curvy", "cushy", "cusp", "cussed", "custard", "custodian", "custody", "customary", "customer", "customize", "customs", "cut", "cycle", "cyclic", "cycling", "cyclist", "cylinder", "cymbal", "cytoplasm", "cytoplast", "dab", "dad", "daffodil", "dagger", "daily", "daintily", "dainty", "dairy", "daisy", "dallying", "dance", "dancing", "dandelion", "dander", "dandruff", "dandy", "danger", "dangle", "dangling", "daredevil", "dares", "daringly", "darkened", "darkening", "darkish", "darkness", "darkroom", "darling", "darn", "dart", "darwinism", "dash", "dastardly", "data", "datebook", "dating", "daughter", "daunting", "dawdler", "dawn", "daybed", "daybreak", "daycare", "daydream", "daylight", "daylong", "dayroom", "daytime", "dazzler", "dazzling", "deacon", "deafening", "deafness", "dealer", "dealing", "dealmaker", "dealt", "dean", "debatable", "debate", "debating", "debit", "debrief", "debtless", "debtor", "debug", "debunk", "decade", "decaf", "decal", "decathlon", "decay", "deceased", "deceit", "deceiver", "deceiving", "december", "decency", "decent", "deception", "deceptive", "decibel", "decidable", "decimal", "decimeter", "decipher", "deck", "declared", "decline", "decode", "decompose", "decorated", "decorator", "decoy", "decrease", "decree", "dedicate", "dedicator", "deduce", "deduct", "deed", "deem", "deepen", "deeply", "deepness", "deface", "defacing", "defame", "default", "defeat", "defection", "defective", "defendant", "defender", "defense", "defensive", "deferral", "deferred", "defiance", "defiant", "defile", "defiling", "define", "definite", "deflate", "deflation", "deflator", "deflected", "deflector", "defog", "deforest", "defraud", "defrost", "deftly", "defuse", "defy", "degraded", "degrading", "degrease", "degree", "dehydrate", "deity", "dejected", "delay", "delegate", "delegator", "delete", "deletion", "delicacy", "delicate", "delicious", "delighted", "delirious", "delirium", "deliverer", "delivery", "delouse", "delta", "deluge", "delusion", "deluxe", "demanding", "demeaning", "demeanor", "demise", "democracy", "democrat", "demote", "demotion", "demystify", "denatured", "deniable", "denial", "denim", "denote", "dense", "density", "dental", "dentist", "denture", "deny", "deodorant", "deodorize", "departed", "departure", "depict", "deplete", "depletion", "deplored", "deploy", "deport", "depose", "depraved", "depravity", "deprecate", "depress", "deprive", "depth", "deputize", "deputy", "derail", "deranged", "derby", "derived", "desecrate", "deserve", "deserving", "designate", "designed", "designer", "designing", "deskbound", "desktop", "deskwork", "desolate", "despair", "despise", "despite", "destiny", "destitute", "destruct", "detached", "detail", "detection", "detective", "detector", "detention", "detergent", "detest", "detonate", "detonator", "detoxify", "detract", "deuce", "devalue", "deviancy", "deviant", "deviate", "deviation", "deviator", "device", "devious", "devotedly", "devotee", "devotion", "devourer", "devouring", "devoutly", "dexterity", "dexterous", "diabetes", "diabetic", "diabolic", "diagnoses", "diagnosis", "diagram", "dial", "diameter", "diaper", "diaphragm", "diary", "dice", "dicing", "dictate", "dictation", "dictator", "difficult", "diffused", "diffuser", "diffusion", "diffusive", "dig", "dilation", "diligence", "diligent", "dill", "dilute", "dime", "diminish", "dimly", "dimmed", "dimmer", "dimness", "dimple", "diner", "dingbat", "dinghy", "dinginess", "dingo", "dingy", "dining", "dinner", "diocese", "dioxide", "diploma", "dipped", "dipper", "dipping", "directed", "direction", "directive", "directly", "directory", "direness", "dirtiness", "disabled", "disagree", "disallow", "disarm", "disarray", "disaster", "disband", "disbelief", "disburse", "discard", "discern", "discharge", "disclose", "discolor", "discount", "discourse", "discover", "discuss", "disdain", "disengage", "disfigure", "disgrace", "dish", "disinfect", "disjoin", "disk", "dislike", "disliking", "dislocate", "dislodge", "disloyal", "dismantle", "dismay", "dismiss", "dismount", "disobey", "disorder", "disown", "disparate", "disparity", "dispatch", "dispense", "dispersal", "dispersed", "disperser", "displace", "display", "displease", "disposal", "dispose", "disprove", "dispute", "disregard", "disrupt", "dissuade", "distance", "distant", "distaste", "distill", "distinct", "distort", "distract", "distress", "district", "distrust", "ditch", "ditto", "ditzy", "dividable", "divided", "dividend", "dividers", "dividing", "divinely", "diving", "divinity", "divisible", "divisibly", "division", "divisive", "divorcee", "dizziness", "dizzy", "doable", "docile", "dock", "doctrine", "document", "dodge", "dodgy", "doily", "doing", "dole", "dollar", "dollhouse", "dollop", "dolly", "dolphin", "domain", "domelike", "domestic", "dominion", "dominoes", "donated", "donation", "donator", "donor", "donut", "doodle", "doorbell", "doorframe", "doorknob", "doorman", "doormat", "doornail", "doorpost", "doorstep", "doorstop", "doorway", "doozy", "dork", "dormitory", "dorsal", "dosage", "dose", "dotted", "doubling", "douche", "dove", "down", "dowry", "doze", "drab", "dragging", "dragonfly", "dragonish", "dragster", "drainable", "drainage", "drained", "drainer", "drainpipe", "dramatic", "dramatize", "drank", "drapery", "drastic", "draw", "dreaded", "dreadful", "dreadlock", "dreamboat", "dreamily", "dreamland", "dreamless", "dreamlike", "dreamt", "dreamy", "drearily", "dreary", "drench", "dress", "drew", "dribble", "dried", "drier", "drift", "driller", "drilling", "drinkable", "drinking", "dripping", "drippy", "drivable", "driven", "driver", "driveway", "driving", "drizzle", "drizzly", "drone", "drool", "droop", "drop-down", "dropbox", "dropkick", "droplet", "dropout", "dropper", "drove", "drown", "drowsily", "drudge", "drum", "dry", "dubbed", "dubiously", "duchess", "duckbill", "ducking", "duckling", "ducktail", "ducky", "duct", "dude", "duffel", "dugout", "duh", "duke", "duller", "dullness", "duly", "dumping", "dumpling", "dumpster", "duo", "dupe", "duplex", "duplicate", "duplicity", "durable", "durably", "duration", "duress", "during", "dusk", "dust", "dutiful", "duty", "duvet", "dwarf", "dweeb", "dwelled", "dweller", "dwelling", "dwindle", "dwindling", "dynamic", "dynamite", "dynasty", "dyslexia", "dyslexic", "each", "eagle", "earache", "eardrum", "earflap", "earful", "earlobe", "early", "earmark", "earmuff", "earphone", "earpiece", "earplugs", "earring", "earshot", "earthen", "earthlike", "earthling", "earthly", "earthworm", "earthy", "earwig", "easeful", "easel", "easiest", "easily", "easiness", "easing", "eastbound", "eastcoast", "easter", "eastward", "eatable", "eaten", "eatery", "eating", "eats", "ebay", "ebony", "ebook", "ecard", "eccentric", "echo", "eclair", "eclipse", "ecologist", "ecology", "economic", "economist", "economy", "ecosphere", "ecosystem", "edge", "edginess", "edging", "edgy", "edition", "editor", "educated", "education", "educator", "eel", "effective", "effects", "efficient", "effort", "eggbeater", "egging", "eggnog", "eggplant", "eggshell", "egomaniac", "egotism", "egotistic", "either", "eject", "elaborate", "elastic", "elated", "elbow", "eldercare", "elderly", "eldest", "electable", "election", "elective", "elephant", "elevate", "elevating", "elevation", "elevator", "eleven", "elf", "eligible", "eligibly", "eliminate", "elite", "elitism", "elixir", "elk", "ellipse", "elliptic", "elm", "elongated", "elope", "eloquence", "eloquent", "elsewhere", "elude", "elusive", "elves", "email", "embargo", "embark", "embassy", "embattled", "embellish", "ember", "embezzle", "emblaze", "emblem", "embody", "embolism", "emboss", "embroider", "emcee", "emerald", "emergency", "emission", "emit", "emote", "emoticon", "emotion", "empathic", "empathy", "emperor", "emphases", "emphasis", "emphasize", "emphatic", "empirical", "employed", "employee", "employer", "emporium", "empower", "emptier", "emptiness", "empty", "emu", "enable", "enactment", "enamel", "enchanted", "enchilada", "encircle", "enclose", "enclosure", "encode", "encore", "encounter", "encourage", "encroach", "encrust", "encrypt", "endanger", "endeared", "endearing", "ended", "ending", "endless", "endnote", "endocrine", "endorphin", "endorse", "endowment", "endpoint", "endurable", "endurance", "enduring", "energetic", "energize", "energy", "enforced", "enforcer", "engaged", "engaging", "engine", "engorge", "engraved", "engraver", "engraving", "engross", "engulf", "enhance", "enigmatic", "enjoyable", "enjoyably", "enjoyer", "enjoying", "enjoyment", "enlarged", "enlarging", "enlighten", "enlisted", "enquirer", "enrage", "enrich", "enroll", "enslave", "ensnare", "ensure", "entail", "entangled", "entering", "entertain", "enticing", "entire", "entitle", "entity", "entomb", "entourage", "entrap", "entree", "entrench", "entrust", "entryway", "entwine", "enunciate", "envelope", "enviable", "enviably", "envious", "envision", "envoy", "envy", "enzyme", "epic", "epidemic", "epidermal", "epidermis", "epidural", "epilepsy", "epileptic", "epilogue", "epiphany", "episode", "equal", "equate", "equation", "equator", "equinox", "equipment", "equity", "equivocal", "eradicate", "erasable", "erased", "eraser", "erasure", "ergonomic", "errand", "errant", "erratic", "error", "erupt", "escalate", "escalator", "escapable", "escapade", "escapist", "escargot", "eskimo", "esophagus", "espionage", "espresso", "esquire", "essay", "essence", "essential", "establish", "estate", "esteemed", "estimate", "estimator", "estranged", "estrogen", "etching", "eternal", "eternity", "ethanol", "ether", "ethically", "ethics", "euphemism", "evacuate", "evacuee", "evade", "evaluate", "evaluator", "evaporate", "evasion", "evasive", "even", "everglade", "evergreen", "everybody", "everyday", "everyone", "evict", "evidence", "evident", "evil", "evoke", "evolution", "evolve", "exact", "exalted", "example", "excavate", "excavator", "exceeding", "exception", "excess", "exchange", "excitable", "exciting", "exclaim", "exclude", "excluding", "exclusion", "exclusive", "excretion", "excretory", "excursion", "excusable", "excusably", "excuse", "exemplary", "exemplify", "exemption", "exerciser", "exert", "exes", "exfoliate", "exhale", "exhaust", "exhume", "exile", "existing", "exit", "exodus", "exonerate", "exorcism", "exorcist", "expand", "expanse", "expansion", "expansive", "expectant", "expedited", "expediter", "expel", "expend", "expenses", "expensive", "expert", "expire", "expiring", "explain", "expletive", "explicit", "explode", "exploit", "explore", "exploring", "exponent", "exporter", "exposable", "expose", "exposure", "express", "expulsion", "exquisite", "extended", "extending", "extent", "extenuate", "exterior", "external", "extinct", "extortion", "extradite", "extras", "extrovert", "extrude", "extruding", "exuberant", "fable", "fabric", "fabulous", "facebook", "facecloth", "facedown", "faceless", "facelift", "faceplate", "faceted", "facial", "facility", "facing", "facsimile", "faction", "factoid", "factor", "factsheet", "factual", "faculty", "fade", "fading", "failing", "falcon", "fall", "false", "falsify", "fame", "familiar", "family", "famine", "famished", "fanatic", "fancied", "fanciness", "fancy", "fanfare", "fang", "fanning", "fantasize", "fantastic", "fantasy", "fascism", "fastball", "faster", "fasting", "fastness", "faucet", "favorable", "favorably", "favored", "favoring", "favorite", "fax", "feast", "federal", "fedora", "feeble", "feed", "feel", "feisty", "feline", "felt-tip", "feminine", "feminism", "feminist", "feminize", "femur", "fence", "fencing", "fender", "ferment", "fernlike", "ferocious", "ferocity", "ferret", "ferris", "ferry", "fervor", "fester", "festival", "festive", "festivity", "fetal", "fetch", "fever", "fiber", "fiction", "fiddle", "fiddling", "fidelity", "fidgeting", "fidgety", "fifteen", "fifth", "fiftieth", "fifty", "figment", "figure", "figurine", "filing", "filled", "filler", "filling", "film", "filter", "filth", "filtrate", "finale", "finalist", "finalize", "finally", "finance", "financial", "finch", "fineness", "finer", "finicky", "finished", "finisher", "finishing", "finite", "finless", "finlike", "fiscally", "fit", "five", "flaccid", "flagman", "flagpole", "flagship", "flagstick", "flagstone", "flail", "flakily", "flaky", "flame", "flammable", "flanked", "flanking", "flannels", "flap", "flaring", "flashback", "flashbulb", "flashcard", "flashily", "flashing", "flashy", "flask", "flatbed", "flatfoot", "flatly", "flatness", "flatten", "flattered", "flatterer", "flattery", "flattop", "flatware", "flatworm", "flavored", "flavorful", "flavoring", "flaxseed", "fled", "fleshed", "fleshy", "flick", "flier", "flight", "flinch", "fling", "flint", "flip", "flirt", "float", "flock", "flogging", "flop", "floral", "florist", "floss", "flounder", "flyable", "flyaway", "flyer", "flying", "flyover", "flypaper", "foam", "foe", "fog", "foil", "folic", "folk", "follicle", "follow", "fondling", "fondly", "fondness", "fondue", "font", "food", "fool", "footage", "football", "footbath", "footboard", "footer", "footgear", "foothill", "foothold", "footing", "footless", "footman", "footnote", "footpad", "footpath", "footprint", "footrest", "footsie", "footsore", "footwear", "footwork", "fossil", "foster", "founder", "founding", "fountain", "fox", "foyer", "fraction", "fracture", "fragile", "fragility", "fragment", "fragrance", "fragrant", "frail", "frame", "framing", "frantic", "fraternal", "frayed", "fraying", "frays", "freckled", "freckles", "freebase", "freebee", "freebie", "freedom", "freefall", "freehand", "freeing", "freeload", "freely", "freemason", "freeness", "freestyle", "freeware", "freeway", "freewill", "freezable", "freezing", "freight", "french", "frenzied", "frenzy", "frequency", "frequent", "fresh", "fretful", "fretted", "friction", "friday", "fridge", "fried", "friend", "frighten", "frightful", "frigidity", "frigidly", "frill", "fringe", "frisbee", "frisk", "fritter", "frivolous", "frolic", "from", "front", "frostbite", "frosted", "frostily", "frosting", "frostlike", "frosty", "froth", "frown", "frozen", "fructose", "frugality", "frugally", "fruit", "frustrate", "frying", "gab", "gaffe", "gag", "gainfully", "gaining", "gains", "gala", "gallantly", "galleria", "gallery", "galley", "gallon", "gallows", "gallstone", "galore", "galvanize", "gambling", "game", "gaming", "gamma", "gander", "gangly", "gangrene", "gangway", "gap", "garage", "garbage", "garden", "gargle", "garland", "garlic", "garment", "garnet", "garnish", "garter", "gas", "gatherer", "gathering", "gating", "gauging", "gauntlet", "gauze", "gave", "gawk", "gazing", "gear", "gecko", "geek", "geiger", "gem", "gender", "generic", "generous", "genetics", "genre", "gentile", "gentleman", "gently", "gents", "geography", "geologic", "geologist", "geology", "geometric", "geometry", "geranium", "gerbil", "geriatric", "germicide", "germinate", "germless", "germproof", "gestate", "gestation", "gesture", "getaway", "getting", "getup", "giant", "gibberish", "giblet", "giddily", "giddiness", "giddy", "gift", "gigabyte", "gigahertz", "gigantic", "giggle", "giggling", "giggly", "gigolo", "gilled", "gills", "gimmick", "girdle", "giveaway", "given", "giver", "giving", "gizmo", "gizzard", "glacial", "glacier", "glade", "gladiator", "gladly", "glamorous", "glamour", "glance", "glancing", "glandular", "glare", "glaring", "glass", "glaucoma", "glazing", "gleaming", "gleeful", "glider", "gliding", "glimmer", "glimpse", "glisten", "glitch", "glitter", "glitzy", "gloater", "gloating", "gloomily", "gloomy", "glorified", "glorifier", "glorify", "glorious", "glory", "gloss", "glove", "glowing", "glowworm", "glucose", "glue", "gluten", "glutinous", "glutton", "gnarly", "gnat", "goal", "goatskin", "goes", "goggles", "going", "goldfish", "goldmine", "goldsmith", "golf", "goliath", "gonad", "gondola", "gone", "gong", "good", "gooey", "goofball", "goofiness", "goofy", "google", "goon", "gopher", "gore", "gorged", "gorgeous", "gory", "gosling", "gossip", "gothic", "gotten", "gout", "gown", "grab", "graceful", "graceless", "gracious", "gradation", "graded", "grader", "gradient", "grading", "gradually", "graduate", "graffiti", "grafted", "grafting", "grain", "granddad", "grandkid", "grandly", "grandma", "grandpa", "grandson", "granite", "granny", "granola", "grant", "granular", "grape", "graph", "grapple", "grappling", "grasp", "grass", "gratified", "gratify", "grating", "gratitude", "gratuity", "gravel", "graveness", "graves", "graveyard", "gravitate", "gravity", "gravy", "gray", "grazing", "greasily", "greedily", "greedless", "greedy", "green", "greeter", "greeting", "grew", "greyhound", "grid", "grief", "grievance", "grieving", "grievous", "grill", "grimace", "grimacing", "grime", "griminess", "grimy", "grinch", "grinning", "grip", "gristle", "grit", "groggily", "groggy", "groin", "groom", "groove", "grooving", "groovy", "grope", "ground", "grouped", "grout", "grove", "grower", "growing", "growl", "grub", "grudge", "grudging", "grueling", "gruffly", "grumble", "grumbling", "grumbly", "grumpily", "grunge", "grunt", "guacamole", "guidable", "guidance", "guide", "guiding", "guileless", "guise", "gulf", "gullible", "gully", "gulp", "gumball", "gumdrop", "gumminess", "gumming", "gummy", "gurgle", "gurgling", "guru", "gush", "gusto", "gusty", "gutless", "guts", "gutter", "guy", "guzzler", "gyration", "habitable", "habitant", "habitat", "habitual", "hacked", "hacker", "hacking", "hacksaw", "had", "haggler", "haiku", "half", "halogen", "halt", "halved", "halves", "hamburger", "hamlet", "hammock", "hamper", "hamster", "hamstring", "handbag", "handball", "handbook", "handbrake", "handcart", "handclap", "handclasp", "handcraft", "handcuff", "handed", "handful", "handgrip", "handgun", "handheld", "handiness", "handiwork", "handlebar", "handled", "handler", "handling", "handmade", "handoff", "handpick", "handprint", "handrail", "handsaw", "handset", "handsfree", "handshake", "handstand", "handwash", "handwork", "handwoven", "handwrite", "handyman", "hangnail", "hangout", "hangover", "hangup", "hankering", "hankie", "hanky", "haphazard", "happening", "happier", "happiest", "happily", "happiness", "happy", "harbor", "hardcopy", "hardcore", "hardcover", "harddisk", "hardened", "hardener", "hardening", "hardhat", "hardhead", "hardiness", "hardly", "hardness", "hardship", "hardware", "hardwired", "hardwood", "hardy", "harmful", "harmless", "harmonica", "harmonics", "harmonize", "harmony", "harness", "harpist", "harsh", "harvest", "hash", "hassle", "haste", "hastily", "hastiness", "hasty", "hatbox", "hatchback", "hatchery", "hatchet", "hatching", "hatchling", "hate", "hatless", "hatred", "haunt", "haven", "hazard", "hazelnut", "hazily", "haziness", "hazing", "hazy", "headache", "headband", "headboard", "headcount", "headdress", "headed", "header", "headfirst", "headgear", "heading", "headlamp", "headless", "headlock", "headphone", "headpiece", "headrest", "headroom", "headscarf", "headset", "headsman", "headstand", "headstone", "headway", "headwear", "heap", "heat", "heave", "heavily", "heaviness", "heaving", "hedge", "hedging", "heftiness", "hefty", "helium", "helmet", "helper", "helpful", "helping", "helpless", "helpline", "hemlock", "hemstitch", "hence", "henchman", "henna", "herald", "herbal", "herbicide", "herbs", "heritage", "hermit", "heroics", "heroism", "herring", "herself", "hertz", "hesitancy", "hesitant", "hesitate", "hexagon", "hexagram", "hubcap", "huddle", "huddling", "huff", "hug", "hula", "hulk", "hull", "human", "humble", "humbling", "humbly", "humid", "humiliate", "humility", "humming", "hummus", "humongous", "humorist", "humorless", "humorous", "humpback", "humped", "humvee", "hunchback", "hundredth", "hunger", "hungrily", "hungry", "hunk", "hunter", "hunting", "huntress", "huntsman", "hurdle", "hurled", "hurler", "hurling", "hurray", "hurricane", "hurried", "hurry", "hurt", "husband", "hush", "husked", "huskiness", "hut", "hybrid", "hydrant", "hydrated", "hydration", "hydrogen", "hydroxide", "hyperlink", "hypertext", "hyphen", "hypnoses", "hypnosis", "hypnotic", "hypnotism", "hypnotist", "hypnotize", "hypocrisy", "hypocrite", "ibuprofen", "ice", "iciness", "icing", "icky", "icon", "icy", "idealism", "idealist", "idealize", "ideally", "idealness", "identical", "identify", "identity", "ideology", "idiocy", "idiom", "idly", "igloo", "ignition", "ignore", "iguana", "illicitly", "illusion", "illusive", "image", "imaginary", "imagines", "imaging", "imbecile", "imitate", "imitation", "immature", "immerse", "immersion", "imminent", "immobile", "immodest", "immorally", "immortal", "immovable", "immovably", "immunity", "immunize", "impaired", "impale", "impart", "impatient", "impeach", "impeding", "impending", "imperfect", "imperial", "impish", "implant", "implement", "implicate", "implicit", "implode", "implosion", "implosive", "imply", "impolite", "important", "importer", "impose", "imposing", "impotence", "impotency", "impotent", "impound", "imprecise", "imprint", "imprison", "impromptu", "improper", "improve", "improving", "improvise", "imprudent", "impulse", "impulsive", "impure", "impurity", "iodine", "iodize", "ion", "ipad", "iphone", "ipod", "irate", "irk", "iron", "irregular", "irrigate", "irritable", "irritably", "irritant", "irritate", "islamic", "islamist", "isolated", "isolating", "isolation", "isotope", "issue", "issuing", "italicize", "italics", "item", "itinerary", "itunes", "ivory", "ivy", "jab", "jackal", "jacket", "jackknife", "jackpot", "jailbird", "jailbreak", "jailer", "jailhouse", "jalapeno", "jam", "janitor", "january", "jargon", "jarring", "jasmine", "jaundice", "jaunt", "java", "jawed", "jawless", "jawline", "jaws", "jaybird", "jaywalker", "jazz", "jeep", "jeeringly", "jellied", "jelly", "jersey", "jester", "jet", "jiffy", "jigsaw", "jimmy", "jingle", "jingling", "jinx", "jitters", "jittery", "job", "jockey", "jockstrap", "jogger", "jogging", "john", "joining", "jokester", "jokingly", "jolliness", "jolly", "jolt", "jot", "jovial", "joyfully", "joylessly", "joyous", "joyride", "joystick", "jubilance", "jubilant", "judge", "judgingly", "judicial", "judiciary", "judo", "juggle", "juggling", "jugular", "juice", "juiciness", "juicy", "jujitsu", "jukebox", "july", "jumble", "jumbo", "jump", "junction", "juncture", "june", "junior", "juniper", "junkie", "junkman", "junkyard", "jurist", "juror", "jury", "justice", "justifier", "justify", "justly", "justness", "juvenile", "kabob", "kangaroo", "karaoke", "karate", "karma", "kebab", "keenly", "keenness", "keep", "keg", "kelp", "kennel", "kept", "kerchief", "kerosene", "kettle", "kick", "kiln", "kilobyte", "kilogram", "kilometer", "kilowatt", "kilt", "kimono", "kindle", "kindling", "kindly", "kindness", "kindred", "kinetic", "kinfolk", "king", "kinship", "kinsman", "kinswoman", "kissable", "kisser", "kissing", "kitchen", "kite", "kitten", "kitty", "kiwi", "kleenex", "knapsack", "knee", "knelt", "knickers", "knoll", "koala", "kooky", "kosher", "krypton", "kudos", "kung", "labored", "laborer", "laboring", "laborious", "labrador", "ladder", "ladies", "ladle", "ladybug", "ladylike", "lagged", "lagging", "lagoon", "lair", "lake", "lance", "landed", "landfall", "landfill", "landing", "landlady", "landless", "landline", "landlord", "landmark", "landmass", "landmine", "landowner", "landscape", "landside", "landslide", "language", "lankiness", "lanky", "lantern", "lapdog", "lapel", "lapped", "lapping", "laptop", "lard", "large", "lark", "lash", "lasso", "last", "latch", "late", "lather", "latitude", "latrine", "latter", "latticed", "launch", "launder", "laundry", "laurel", "lavender", "lavish", "laxative", "lazily", "laziness", "lazy", "lecturer", "left", "legacy", "legal", "legend", "legged", "leggings", "legible", "legibly", "legislate", "lego", "legroom", "legume", "legwarmer", "legwork", "lemon", "lend", "length", "lens", "lent", "leotard", "lesser", "letdown", "lethargic", "lethargy", "letter", "lettuce", "level", "leverage", "levers", "levitate", "levitator", "liability", "liable", "liberty", "librarian", "library", "licking", "licorice", "lid", "life", "lifter", "lifting", "liftoff", "ligament", "likely", "likeness", "likewise", "liking", "lilac", "lilly", "lily", "limb", "limeade", "limelight", "limes", "limit", "limping", "limpness", "line", "lingo", "linguini", "linguist", "lining", "linked", "linoleum", "linseed", "lint", "lion", "lip", "liquefy", "liqueur", "liquid", "lisp", "list", "litigate", "litigator", "litmus", "litter", "little", "livable", "lived", "lively", "liver", "livestock", "lividly", "living", "lizard", "lubricant", "lubricate", "lucid", "luckily", "luckiness", "luckless", "lucrative", "ludicrous", "lugged", "lukewarm", "lullaby", "lumber", "luminance", "luminous", "lumpiness", "lumping", "lumpish", "lunacy", "lunar", "lunchbox", "luncheon", "lunchroom", "lunchtime", "lung", "lurch", "lure", "luridness", "lurk", "lushly", "lushness", "luster", "lustfully", "lustily", "lustiness", "lustrous", "lusty", "luxurious", "luxury", "lying", "lyrically", "lyricism", "lyricist", "lyrics", "macarena", "macaroni", "macaw", "mace", "machine", "machinist", "magazine", "magenta", "maggot", "magical", "magician", "magma", "magnesium", "magnetic", "magnetism", "magnetize", "magnifier", "magnify", "magnitude", "magnolia", "mahogany", "maimed", "majestic", "majesty", "majorette", "majority", "makeover", "maker", "makeshift", "making", "malformed", "malt", "mama", "mammal", "mammary", "mammogram", "manager", "managing", "manatee", "mandarin", "mandate", "mandatory", "mandolin", "manger", "mangle", "mango", "mangy", "manhandle", "manhole", "manhood", "manhunt", "manicotti", "manicure", "manifesto", "manila", "mankind", "manlike", "manliness", "manly", "manmade", "manned", "mannish", "manor", "manpower", "mantis", "mantra", "manual", "many", "map", "marathon", "marauding", "marbled", "marbles", "marbling", "march", "mardi", "margarine", "margarita", "margin", "marigold", "marina", "marine", "marital", "maritime", "marlin", "marmalade", "maroon", "married", "marrow", "marry", "marshland", "marshy", "marsupial", "marvelous", "marxism", "mascot", "masculine", "mashed", "mashing", "massager", "masses", "massive", "mastiff", "matador", "matchbook", "matchbox", "matcher", "matching", "matchless", "material", "maternal", "maternity", "math", "mating", "matriarch", "matrimony", "matrix", "matron", "matted", "matter", "maturely", "maturing", "maturity", "mauve", "maverick", "maximize", "maximum", "maybe", "mayday", "mayflower", "moaner", "moaning", "mobile", "mobility", "mobilize", "mobster", "mocha", "mocker", "mockup", "modified", "modify", "modular", "modulator", "module", "moisten", "moistness", "moisture", "molar", "molasses", "mold", "molecular", "molecule", "molehill", "mollusk", "mom", "monastery", "monday", "monetary", "monetize", "moneybags", "moneyless", "moneywise", "mongoose", "mongrel", "monitor", "monkhood", "monogamy", "monogram", "monologue", "monopoly", "monorail", "monotone", "monotype", "monoxide", "monsieur", "monsoon", "monstrous", "monthly", "monument", "moocher", "moodiness", "moody", "mooing", "moonbeam", "mooned", "moonlight", "moonlike", "moonlit", "moonrise", "moonscape", "moonshine", "moonstone", "moonwalk", "mop", "morale", "morality", "morally", "morbidity", "morbidly", "morphine", "morphing", "morse", "mortality", "mortally", "mortician", "mortified", "mortify", "mortuary", "mosaic", "mossy", "most", "mothball", "mothproof", "motion", "motivate", "motivator", "motive", "motocross", "motor", "motto", "mountable", "mountain", "mounted", "mounting", "mourner", "mournful", "mouse", "mousiness", "moustache", "mousy", "mouth", "movable", "move", "movie", "moving", "mower", "mowing", "much", "muck", "mud", "mug", "mulberry", "mulch", "mule", "mulled", "mullets", "multiple", "multiply", "multitask", "multitude", "mumble", "mumbling", "mumbo", "mummified", "mummify", "mummy", "mumps", "munchkin", "mundane", "municipal", "muppet", "mural", "murkiness", "murky", "murmuring", "muscular", "museum", "mushily", "mushiness", "mushroom", "mushy", "music", "musket", "muskiness", "musky", "mustang", "mustard", "muster", "mustiness", "musty", "mutable", "mutate", "mutation", "mute", "mutilated", "mutilator", "mutiny", "mutt", "mutual", "muzzle", "myself", "myspace", "mystified", "mystify", "myth", "nacho", "nag", "nail", "name", "naming", "nanny", "nanometer", "nape", "napkin", "napped", "napping", "nappy", "narrow", "nastily", "nastiness", "national", "native", "nativity", "natural", "nature", "naturist", "nautical", "navigate", "navigator", "navy", "nearby", "nearest", "nearly", "nearness", "neatly", "neatness", "nebula", "nebulizer", "nectar", "negate", "negation", "negative", "neglector", "negligee", "negligent", "negotiate", "nemeses", "nemesis", "neon", "nephew", "nerd", "nervous", "nervy", "nest", "net", "neurology", "neuron", "neurosis", "neurotic", "neuter", "neutron", "never", "next", "nibble", "nickname", "nicotine", "niece", "nifty", "nimble", "nimbly", "nineteen", "ninetieth", "ninja", "nintendo", "ninth", "nuclear", "nuclei", "nucleus", "nugget", "nullify", "number", "numbing", "numbly", "numbness", "numeral", "numerate", "numerator", "numeric", "numerous", "nuptials", "nursery", "nursing", "nurture", "nutcase", "nutlike", "nutmeg", "nutrient", "nutshell", "nuttiness", "nutty", "nuzzle", "nylon", "oaf", "oak", "oasis", "oat", "obedience", "obedient", "obituary", "object", "obligate", "obliged", "oblivion", "oblivious", "oblong", "obnoxious", "oboe", "obscure", "obscurity", "observant", "observer", "observing", "obsessed", "obsession", "obsessive", "obsolete", "obstacle", "obstinate", "obstruct", "obtain", "obtrusive", "obtuse", "obvious", "occultist", "occupancy", "occupant", "occupier", "occupy", "ocean", "ocelot", "octagon", "octane", "october", "octopus", "ogle", "oil", "oink", "ointment", "okay", "old", "olive", "olympics", "omega", "omen", "ominous", "omission", "omit", "omnivore", "onboard", "oncoming", "ongoing", "onion", "online", "onlooker", "only", "onscreen", "onset", "onshore", "onslaught", "onstage", "onto", "onward", "onyx", "oops", "ooze", "oozy", "opacity", "opal", "open", "operable", "operate", "operating", "operation", "operative", "operator", "opium", "opossum", "opponent", "oppose", "opposing", "opposite", "oppressed", "oppressor", "opt", "opulently", "osmosis", "other", "otter", "ouch", "ought", "ounce", "outage", "outback", "outbid", "outboard", "outbound", "outbreak", "outburst", "outcast", "outclass", "outcome", "outdated", "outdoors", "outer", "outfield", "outfit", "outflank", "outgoing", "outgrow", "outhouse", "outing", "outlast", "outlet", "outline", "outlook", "outlying", "outmatch", "outmost", "outnumber", "outplayed", "outpost", "outpour", "output", "outrage", "outrank", "outreach", "outright", "outscore", "outsell", "outshine", "outshoot", "outsider", "outskirts", "outsmart", "outsource", "outspoken", "outtakes", "outthink", "outward", "outweigh", "outwit", "oval", "ovary", "oven", "overact", "overall", "overarch", "overbid", "overbill", "overbite", "overblown", "overboard", "overbook", "overbuilt", "overcast", "overcoat", "overcome", "overcook", "overcrowd", "overdraft", "overdrawn", "overdress", "overdrive", "overdue", "overeager", "overeater", "overexert", "overfed", "overfeed", "overfill", "overflow", "overfull", "overgrown", "overhand", "overhang", "overhaul", "overhead", "overhear", "overheat", "overhung", "overjoyed", "overkill", "overlabor", "overlaid", "overlap", "overlay", "overload", "overlook", "overlord", "overlying", "overnight", "overpass", "overpay", "overplant", "overplay", "overpower", "overprice", "overrate", "overreach", "overreact", "override", "overripe", "overrule", "overrun", "overshoot", "overshot", "oversight", "oversized", "oversleep", "oversold", "overspend", "overstate", "overstay", "overstep", "overstock", "overstuff", "oversweet", "overtake", "overthrow", "overtime", "overtly", "overtone", "overture", "overturn", "overuse", "overvalue", "overview", "overwrite", "owl", "oxford", "oxidant", "oxidation", "oxidize", "oxidizing", "oxygen", "oxymoron", "oyster", "ozone", "paced", "pacemaker", "pacific", "pacifier", "pacifism", "pacifist", "pacify", "padded", "padding", "paddle", "paddling", "padlock", "pagan", "pager", "paging", "pajamas", "palace", "palatable", "palm", "palpable", "palpitate", "paltry", "pampered", "pamperer", "pampers", "pamphlet", "panama", "pancake", "pancreas", "panda", "pandemic", "pang", "panhandle", "panic", "panning", "panorama", "panoramic", "panther", "pantomime", "pantry", "pants", "pantyhose", "paparazzi", "papaya", "paper", "paprika", "papyrus", "parabola", "parachute", "parade", "paradox", "paragraph", "parakeet", "paralegal", "paralyses", "paralysis", "paralyze", "paramedic", "parameter", "paramount", "parasail", "parasite", "parasitic", "parcel", "parched", "parchment", "pardon", "parish", "parka", "parking", "parkway", "parlor", "parmesan", "parole", "parrot", "parsley", "parsnip", "partake", "parted", "parting", "partition", "partly", "partner", "partridge", "party", "passable", "passably", "passage", "passcode", "passenger", "passerby", "passing", "passion", "passive", "passivism", "passover", "passport", "password", "pasta", "pasted", "pastel", "pastime", "pastor", "pastrami", "pasture", "pasty", "patchwork", "patchy", "paternal", "paternity", "path", "patience", "patient", "patio", "patriarch", "patriot", "patrol", "patronage", "patronize", "pauper", "pavement", "paver", "pavestone", "pavilion", "paving", "pawing", "payable", "payback", "paycheck", "payday", "payee", "payer", "paying", "payment", "payphone", "payroll", "pebble", "pebbly", "pecan", "pectin", "peculiar", "peddling", "pediatric", "pedicure", "pedigree", "pedometer", "pegboard", "pelican", "pellet", "pelt", "pelvis", "penalize", "penalty", "pencil", "pendant", "pending", "penholder", "penknife", "pennant", "penniless", "penny", "penpal", "pension", "pentagon", "pentagram", "pep", "perceive", "percent", "perch", "percolate", "perennial", "perfected", "perfectly", "perfume", "periscope", "perish", "perjurer", "perjury", "perkiness", "perky", "perm", "peroxide", "perpetual", "perplexed", "persecute", "persevere", "persuaded", "persuader", "pesky", "peso", "pessimism", "pessimist", "pester", "pesticide", "petal", "petite", "petition", "petri", "petroleum", "petted", "petticoat", "pettiness", "petty", "petunia", "phantom", "phobia", "phoenix", "phonebook", "phoney", "phonics", "phoniness", "phony", "phosphate", "photo", "phrase", "phrasing", "placard", "placate", "placidly", "plank", "planner", "plant", "plasma", "plaster", "plastic", "plated", "platform", "plating", "platinum", "platonic", "platter", "platypus", "plausible", "plausibly", "playable", "playback", "player", "playful", "playgroup", "playhouse", "playing", "playlist", "playmaker", "playmate", "playoff", "playpen", "playroom", "playset", "plaything", "playtime", "plaza", "pleading", "pleat", "pledge", "plentiful", "plenty", "plethora", "plexiglas", "pliable", "plod", "plop", "plot", "plow", "ploy", "pluck", "plug", "plunder", "plunging", "plural", "plus", "plutonium", "plywood", "poach", "pod", "poem", "poet", "pogo", "pointed", "pointer", "pointing", "pointless", "pointy", "poise", "poison", "poker", "poking", "polar", "police", "policy", "polio", "polish", "politely", "polka", "polo", "polyester", "polygon", "polygraph", "polymer", "poncho", "pond", "pony", "popcorn", "pope", "poplar", "popper", "poppy", "popsicle", "populace", "popular", "populate", "porcupine", "pork", "porous", "porridge", "portable", "portal", "portfolio", "porthole", "portion", "portly", "portside", "poser", "posh", "posing", "possible", "possibly", "possum", "postage", "postal", "postbox", "postcard", "posted", "poster", "posting", "postnasal", "posture", "postwar", "pouch", "pounce", "pouncing", "pound", "pouring", "pout", "powdered", "powdering", "powdery", "power", "powwow", "pox", "praising", "prance", "prancing", "pranker", "prankish", "prankster", "prayer", "praying", "preacher", "preaching", "preachy", "preamble", "precinct", "precise", "precision", "precook", "precut", "predator", "predefine", "predict", "preface", "prefix", "preflight", "preformed", "pregame", "pregnancy", "pregnant", "preheated", "prelaunch", "prelaw", "prelude", "premiere", "premises", "premium", "prenatal", "preoccupy", "preorder", "prepaid", "prepay", "preplan", "preppy", "preschool", "prescribe", "preseason", "preset", "preshow", "president", "presoak", "press", "presume", "presuming", "preteen", "pretended", "pretender", "pretense", "pretext", "pretty", "pretzel", "prevail", "prevalent", "prevent", "preview", "previous", "prewar", "prewashed", "prideful", "pried", "primal", "primarily", "primary", "primate", "primer", "primp", "princess", "print", "prior", "prism", "prison", "prissy", "pristine", "privacy", "private", "privatize", "prize", "proactive", "probable", "probably", "probation", "probe", "probing", "probiotic", "problem", "procedure", "process", "proclaim", "procreate", "procurer", "prodigal", "prodigy", "produce", "product", "profane", "profanity", "professed", "professor", "profile", "profound", "profusely", "progeny", "prognosis", "program", "progress", "projector", "prologue", "prolonged", "promenade", "prominent", "promoter", "promotion", "prompter", "promptly", "prone", "prong", "pronounce", "pronto", "proofing", "proofread", "proofs", "propeller", "properly", "property", "proponent", "proposal", "propose", "props", "prorate", "protector", "protegee", "proton", "prototype", "protozoan", "protract", "protrude", "proud", "provable", "proved", "proven", "provided", "provider", "providing", "province", "proving", "provoke", "provoking", "provolone", "prowess", "prowler", "prowling", "proximity", "proxy", "prozac", "prude", "prudishly", "prune", "pruning", "pry", "psychic", "public", "publisher", "pucker", "pueblo", "pug", "pull", "pulmonary", "pulp", "pulsate", "pulse", "pulverize", "puma", "pumice", "pummel", "punch", "punctual", "punctuate", "punctured", "pungent", "punisher", "punk", "pupil", "puppet", "puppy", "purchase", "pureblood", "purebred", "purely", "pureness", "purgatory", "purge", "purging", "purifier", "purify", "purist", "puritan", "purity", "purple", "purplish", "purposely", "purr", "purse", "pursuable", "pursuant", "pursuit", "purveyor", "pushcart", "pushchair", "pusher", "pushiness", "pushing", "pushover", "pushpin", "pushup", "pushy", "putdown", "putt", "puzzle", "puzzling", "pyramid", "pyromania", "python", "quack", "quadrant", "quail", "quaintly", "quake", "quaking", "qualified", "qualifier", "qualify", "quality", "qualm", "quantum", "quarrel", "quarry", "quartered", "quarterly", "quarters", "quartet", "quench", "query", "quicken", "quickly", "quickness", "quicksand", "quickstep", "quiet", "quill", "quilt", "quintet", "quintuple", "quirk", "quit", "quiver", "quizzical", "quotable", "quotation", "quote", "rabid", "race", "racing", "racism", "rack", "racoon", "radar", "radial", "radiance", "radiantly", "radiated", "radiation", "radiator", "radio", "radish", "raffle", "raft", "rage", "ragged", "raging", "ragweed", "raider", "railcar", "railing", "railroad", "railway", "raisin", "rake", "raking", "rally", "ramble", "rambling", "ramp", "ramrod", "ranch", "rancidity", "random", "ranged", "ranger", "ranging", "ranked", "ranking", "ransack", "ranting", "rants", "rare", "rarity", "rascal", "rash", "rasping", "ravage", "raven", "ravine", "raving", "ravioli", "ravishing", "reabsorb", "reach", "reacquire", "reaction", "reactive", "reactor", "reaffirm", "ream", "reanalyze", "reappear", "reapply", "reappoint", "reapprove", "rearrange", "rearview", "reason", "reassign", "reassure", "reattach", "reawake", "rebalance", "rebate", "rebel", "rebirth", "reboot", "reborn", "rebound", "rebuff", "rebuild", "rebuilt", "reburial", "rebuttal", "recall", "recant", "recapture", "recast", "recede", "recent", "recess", "recharger", "recipient", "recital", "recite", "reckless", "reclaim", "recliner", "reclining", "recluse", "reclusive", "recognize", "recoil", "recollect", "recolor", "reconcile", "reconfirm", "reconvene", "recopy", "record", "recount", "recoup", "recovery", "recreate", "rectal", "rectangle", "rectified", "rectify", "recycled", "recycler", "recycling", "reemerge", "reenact", "reenter", "reentry", "reexamine", "referable", "referee", "reference", "refill", "refinance", "refined", "refinery", "refining", "refinish", "reflected", "reflector", "reflex", "reflux", "refocus", "refold", "reforest", "reformat", "reformed", "reformer", "reformist", "refract", "refrain", "refreeze", "refresh", "refried", "refueling", "refund", "refurbish", "refurnish", "refusal", "refuse", "refusing", "refutable", "refute", "regain", "regalia", "regally", "reggae", "regime", "region", "register", "registrar", "registry", "regress", "regretful", "regroup", "regular", "regulate", "regulator", "rehab", "reheat", "rehire", "rehydrate", "reimburse", "reissue", "reiterate", "rejoice", "rejoicing", "rejoin", "rekindle", "relapse", "relapsing", "relatable", "related", "relation", "relative", "relax", "relay", "relearn", "release", "relenting", "reliable", "reliably", "reliance", "reliant", "relic", "relieve", "relieving", "relight", "relish", "relive", "reload", "relocate", "relock", "reluctant", "rely", "remake", "remark", "remarry", "rematch", "remedial", "remedy", "remember", "reminder", "remindful", "remission", "remix", "remnant", "remodeler", "remold", "remorse", "remote", "removable", "removal", "removed", "remover", "removing", "rename", "renderer", "rendering", "rendition", "renegade", "renewable", "renewably", "renewal", "renewed", "renounce", "renovate", "renovator", "rentable", "rental", "rented", "renter", "reoccupy", "reoccur", "reopen", "reorder", "repackage", "repacking", "repaint", "repair", "repave", "repaying", "repayment", "repeal", "repeated", "repeater", "repent", "rephrase", "replace", "replay", "replica", "reply", "reporter", "repose", "repossess", "repost", "repressed", "reprimand", "reprint", "reprise", "reproach", "reprocess", "reproduce", "reprogram", "reps", "reptile", "reptilian", "repugnant", "repulsion", "repulsive", "repurpose", "reputable", "reputably", "request", "require", "requisite", "reroute", "rerun", "resale", "resample", "rescuer", "reseal", "research", "reselect", "reseller", "resemble", "resend", "resent", "reset", "reshape", "reshoot", "reshuffle", "residence", "residency", "resident", "residual", "residue", "resigned", "resilient", "resistant", "resisting", "resize", "resolute", "resolved", "resonant", "resonate", "resort", "resource", "respect", "resubmit", "result", "resume", "resupply", "resurface", "resurrect", "retail", "retainer", "retaining", "retake", "retaliate", "retention", "rethink", "retinal", "retired", "retiree", "retiring", "retold", "retool", "retorted", "retouch", "retrace", "retract", "retrain", "retread", "retreat", "retrial", "retrieval", "retriever", "retry", "return", "retying", "retype", "reunion", "reunite", "reusable", "reuse", "reveal", "reveler", "revenge", "revenue", "reverb", "revered", "reverence", "reverend", "reversal", "reverse", "reversing", "reversion", "revert", "revisable", "revise", "revision", "revisit", "revivable", "revival", "reviver", "reviving", "revocable", "revoke", "revolt", "revolver", "revolving", "reward", "rewash", "rewind", "rewire", "reword", "rework", "rewrap", "rewrite", "rhyme", "ribbon", "ribcage", "rice", "riches", "richly", "richness", "rickety", "ricotta", "riddance", "ridden", "ride", "riding", "rifling", "rift", "rigging", "rigid", "rigor", "rimless", "rimmed", "rind", "rink", "rinse", "rinsing", "riot", "ripcord", "ripeness", "ripening", "ripping", "ripple", "rippling", "riptide", "rise", "rising", "risk", "risotto", "ritalin", "ritzy", "rival", "riverbank", "riverbed", "riverboat", "riverside", "riveter", "riveting", "roamer", "roaming", "roast", "robbing", "robe", "robin", "robotics", "robust", "rockband", "rocker", "rocket", "rockfish", "rockiness", "rocking", "rocklike", "rockslide", "rockstar", "rocky", "rogue", "roman", "romp", "rope", "roping", "roster", "rosy", "rotten", "rotting", "rotunda", "roulette", "rounding", "roundish", "roundness", "roundup", "roundworm", "routine", "routing", "rover", "roving", "royal", "rubbed", "rubber", "rubbing", "rubble", "rubdown", "ruby", "ruckus", "rudder", "rug", "ruined", "rule", "rumble", "rumbling", "rummage", "rumor", "runaround", "rundown", "runner", "running", "runny", "runt", "runway", "rupture", "rural", "ruse", "rush", "rust", "rut", "sabbath", "sabotage", "sacrament", "sacred", "sacrifice", "sadden", "saddlebag", "saddled", "saddling", "sadly", "sadness", "safari", "safeguard", "safehouse", "safely", "safeness", "saffron", "saga", "sage", "sagging", "saggy", "said", "saint", "sake", "salad", "salami", "salaried", "salary", "saline", "salon", "saloon", "salsa", "salt", "salutary", "salute", "salvage", "salvaging", "salvation", "same", "sample", "sampling", "sanction", "sanctity", "sanctuary", "sandal", "sandbag", "sandbank", "sandbar", "sandblast", "sandbox", "sanded", "sandfish", "sanding", "sandlot", "sandpaper", "sandpit", "sandstone", "sandstorm", "sandworm", "sandy", "sanitary", "sanitizer", "sank", "santa", "sapling", "sappiness", "sappy", "sarcasm", "sarcastic", "sardine", "sash", "sasquatch", "sassy", "satchel", "satiable", "satin", "satirical", "satisfied", "satisfy", "saturate", "saturday", "sauciness", "saucy", "sauna", "savage", "savanna", "saved", "savings", "savior", "savor", "saxophone", "say", "scabbed", "scabby", "scalded", "scalding", "scale", "scaling", "scallion", "scallop", "scalping", "scam", "scandal", "scanner", "scanning", "scant", "scapegoat", "scarce", "scarcity", "scarecrow", "scared", "scarf", "scarily", "scariness", "scarring", "scary", "scavenger", "scenic", "schedule", "schematic", "scheme", "scheming", "schilling", "schnapps", "scholar", "science", "scientist", "scion", "scoff", "scolding", "scone", "scoop", "scooter", "scope", "scorch", "scorebook", "scorecard", "scored", "scoreless", "scorer", "scoring", "scorn", "scorpion", "scotch", "scoundrel", "scoured", "scouring", "scouting", "scouts", "scowling", "scrabble", "scraggly", "scrambled", "scrambler", "scrap", "scratch", "scrawny", "screen", "scribble", "scribe", "scribing", "scrimmage", "script", "scroll", "scrooge", "scrounger", "scrubbed", "scrubber", "scruffy", "scrunch", "scrutiny", "scuba", "scuff", "sculptor", "sculpture", "scurvy", "scuttle", "secluded", "secluding", "seclusion", "second", "secrecy", "secret", "sectional", "sector", "secular", "securely", "security", "sedan", "sedate", "sedation", "sedative", "sediment", "seduce", "seducing", "segment", "seismic", "seizing", "seldom", "selected", "selection", "selective", "selector", "self", "seltzer", "semantic", "semester", "semicolon", "semifinal", "seminar", "semisoft", "semisweet", "senate", "senator", "send", "senior", "senorita", "sensation", "sensitive", "sensitize", "sensually", "sensuous", "sepia", "september", "septic", "septum", "sequel", "sequence", "sequester", "series", "sermon", "serotonin", "serpent", "serrated", "serve", "service", "serving", "sesame", "sessions", "setback", "setting", "settle", "settling", "setup", "sevenfold", "seventeen", "seventh", "seventy", "severity", "shabby", "shack", "shaded", "shadily", "shadiness", "shading", "shadow", "shady", "shaft", "shakable", "shakily", "shakiness", "shaking", "shaky", "shale", "shallot", "shallow", "shame", "shampoo", "shamrock", "shank", "shanty", "shape", "shaping", "share", "sharpener", "sharper", "sharpie", "sharply", "sharpness", "shawl", "sheath", "shed", "sheep", "sheet", "shelf", "shell", "shelter", "shelve", "shelving", "sherry", "shield", "shifter", "shifting", "shiftless", "shifty", "shimmer", "shimmy", "shindig", "shine", "shingle", "shininess", "shining", "shiny", "ship", "shirt", "shivering", "shock", "shone", "shoplift", "shopper", "shopping", "shoptalk", "shore", "shortage", "shortcake", "shortcut", "shorten", "shorter", "shorthand", "shortlist", "shortly", "shortness", "shorts", "shortwave", "shorty", "shout", "shove", "showbiz", "showcase", "showdown", "shower", "showgirl", "showing", "showman", "shown", "showoff", "showpiece", "showplace", "showroom", "showy", "shrank", "shrapnel", "shredder", "shredding", "shrewdly", "shriek", "shrill", "shrimp", "shrine", "shrink", "shrivel", "shrouded", "shrubbery", "shrubs", "shrug", "shrunk", "shucking", "shudder", "shuffle", "shuffling", "shun", "shush", "shut", "shy", "siamese", "siberian", "sibling", "siding", "sierra", "siesta", "sift", "sighing", "silenced", "silencer", "silent", "silica", "silicon", "silk", "silliness", "silly", "silo", "silt", "silver", "similarly", "simile", "simmering", "simple", "simplify", "simply", "sincere", "sincerity", "singer", "singing", "single", "singular", "sinister", "sinless", "sinner", "sinuous", "sip", "siren", "sister", "sitcom", "sitter", "sitting", "situated", "situation", "sixfold", "sixteen", "sixth", "sixties", "sixtieth", "sixtyfold", "sizable", "sizably", "size", "sizing", "sizzle", "sizzling", "skater", "skating", "skedaddle", "skeletal", "skeleton", "skeptic", "sketch", "skewed", "skewer", "skid", "skied", "skier", "skies", "skiing", "skilled", "skillet", "skillful", "skimmed", "skimmer", "skimming", "skimpily", "skincare", "skinhead", "skinless", "skinning", "skinny", "skintight", "skipper", "skipping", "skirmish", "skirt", "skittle", "skydiver", "skylight", "skyline", "skype", "skyrocket", "skyward", "slab", "slacked", "slacker", "slacking", "slackness", "slacks", "slain", "slam", "slander", "slang", "slapping", "slapstick", "slashed", "slashing", "slate", "slather", "slaw", "sled", "sleek", "sleep", "sleet", "sleeve", "slept", "sliceable", "sliced", "slicer", "slicing", "slick", "slider", "slideshow", "sliding", "slighted", "slighting", "slightly", "slimness", "slimy", "slinging", "slingshot", "slinky", "slip", "slit", "sliver", "slobbery", "slogan", "sloped", "sloping", "sloppily", "sloppy", "slot", "slouching", "slouchy", "sludge", "slug", "slum", "slurp", "slush", "sly", "small", "smartly", "smartness", "smasher", "smashing", "smashup", "smell", "smelting", "smile", "smilingly", "smirk", "smite", "smith", "smitten", "smock", "smog", "smoked", "smokeless", "smokiness", "smoking", "smoky", "smolder", "smooth", "smother", "smudge", "smudgy", "smuggler", "smuggling", "smugly", "smugness", "snack", "snagged", "snaking", "snap", "snare", "snarl", "snazzy", "sneak", "sneer", "sneeze", "sneezing", "snide", "sniff", "snippet", "snipping", "snitch", "snooper", "snooze", "snore", "snoring", "snorkel", "snort", "snout", "snowbird", "snowboard", "snowbound", "snowcap", "snowdrift", "snowdrop", "snowfall", "snowfield", "snowflake", "snowiness", "snowless", "snowman", "snowplow", "snowshoe", "snowstorm", "snowsuit", "snowy", "snub", "snuff", "snuggle", "snugly", "snugness", "speak", "spearfish", "spearhead", "spearman", "spearmint", "species", "specimen", "specked", "speckled", "specks", "spectacle", "spectator", "spectrum", "speculate", "speech", "speed", "spellbind", "speller", "spelling", "spendable", "spender", "spending", "spent", "spew", "sphere", "spherical", "sphinx", "spider", "spied", "spiffy", "spill", "spilt", "spinach", "spinal", "spindle", "spinner", "spinning", "spinout", "spinster", "spiny", "spiral", "spirited", "spiritism", "spirits", "spiritual", "splashed", "splashing", "splashy", "splatter", "spleen", "splendid", "splendor", "splice", "splicing", "splinter", "splotchy", "splurge", "spoilage", "spoiled", "spoiler", "spoiling", "spoils", "spoken", "spokesman", "sponge", "spongy", "sponsor", "spoof", "spookily", "spooky", "spool", "spoon", "spore", "sporting", "sports", "sporty", "spotless", "spotlight", "spotted", "spotter", "spotting", "spotty", "spousal", "spouse", "spout", "sprain", "sprang", "sprawl", "spray", "spree", "sprig", "spring", "sprinkled", "sprinkler", "sprint", "sprite", "sprout", "spruce", "sprung", "spry", "spud", "spur", "sputter", "spyglass", "squabble", "squad", "squall", "squander", "squash", "squatted", "squatter", "squatting", "squeak", "squealer", "squealing", "squeamish", "squeegee", "squeeze", "squeezing", "squid", "squiggle", "squiggly", "squint", "squire", "squirt", "squishier", "squishy", "stability", "stabilize", "stable", "stack", "stadium", "staff", "stage", "staging", "stagnant", "stagnate", "stainable", "stained", "staining", "stainless", "stalemate", "staleness", "stalling", "stallion", "stamina", "stammer", "stamp", "stand", "stank", "staple", "stapling", "starboard", "starch", "stardom", "stardust", "starfish", "stargazer", "staring", "stark", "starless", "starlet", "starlight", "starlit", "starring", "starry", "starship", "starter", "starting", "startle", "startling", "startup", "starved", "starving", "stash", "state", "static", "statistic", "statue", "stature", "status", "statute", "statutory", "staunch", "stays", "steadfast", "steadier", "steadily", "steadying", "steam", "steed", "steep", "steerable", "steering", "steersman", "stegosaur", "stellar", "stem", "stench", "stencil", "step", "stereo", "sterile", "sterility", "sterilize", "sterling", "sternness", "sternum", "stew", "stick", "stiffen", "stiffly", "stiffness", "stifle", "stifling", "stillness", "stilt", "stimulant", "stimulate", "stimuli", "stimulus", "stinger", "stingily", "stinging", "stingray", "stingy", "stinking", "stinky", "stipend", "stipulate", "stir", "stitch", "stock", "stoic", "stoke", "stole", "stomp", "stonewall", "stoneware", "stonework", "stoning", "stony", "stood", "stooge", "stool", "stoop", "stoplight", "stoppable", "stoppage", "stopped", "stopper", "stopping", "stopwatch", "storable", "storage", "storeroom", "storewide", "storm", "stout", "stove", "stowaway", "stowing", "straddle", "straggler", "strained", "strainer", "straining", "strangely", "stranger", "strangle", "strategic", "strategy", "stratus", "straw", "stray", "streak", "stream", "street", "strength", "strenuous", "strep", "stress", "stretch", "strewn", "stricken", "strict", "stride", "strife", "strike", "striking", "strive", "striving", "strobe", "strode", "stroller", "strongbox", "strongly", "strongman", "struck", "structure", "strudel", "struggle", "strum", "strung", "strut", "stubbed", "stubble", "stubbly", "stubborn", "stucco", "stuck", "student", "studied", "studio", "study", "stuffed", "stuffing", "stuffy", "stumble", "stumbling", "stump", "stung", "stunned", "stunner", "stunning", "stunt", "stupor", "sturdily", "sturdy", "styling", "stylishly", "stylist", "stylized", "stylus", "suave", "subarctic", "subatomic", "subdivide", "subdued", "subduing", "subfloor", "subgroup", "subheader", "subject", "sublease", "sublet", "sublevel", "sublime", "submarine", "submerge", "submersed", "submitter", "subpanel", "subpar", "subplot", "subprime", "subscribe", "subscript", "subsector", "subside", "subsiding", "subsidize", "subsidy", "subsoil", "subsonic", "substance", "subsystem", "subtext", "subtitle", "subtly", "subtotal", "subtract", "subtype", "suburb", "subway", "subwoofer", "subzero", "succulent", "such", "suction", "sudden", "sudoku", "suds", "sufferer", "suffering", "suffice", "suffix", "suffocate", "suffrage", "sugar", "suggest", "suing", "suitable", "suitably", "suitcase", "suitor", "sulfate", "sulfide", "sulfite", "sulfur", "sulk", "sullen", "sulphate", "sulphuric", "sultry", "superbowl", "superglue", "superhero", "superior", "superjet", "superman", "supermom", "supernova", "supervise", "supper", "supplier", "supply", "support", "supremacy", "supreme", "surcharge", "surely", "sureness", "surface", "surfacing", "surfboard", "surfer", "surgery", "surgical", "surging", "surname", "surpass", "surplus", "surprise", "surreal", "surrender", "surrogate", "surround", "survey", "survival", "survive", "surviving", "survivor", "sushi", "suspect", "suspend", "suspense", "sustained", "sustainer", "swab", "swaddling", "swagger", "swampland", "swan", "swapping", "swarm", "sway", "swear", "sweat", "sweep", "swell", "swept", "swerve", "swifter", "swiftly", "swiftness", "swimmable", "swimmer", "swimming", "swimsuit", "swimwear", "swinger", "swinging", "swipe", "swirl", "switch", "swivel", "swizzle", "swooned", "swoop", "swoosh", "swore", "sworn", "swung", "sycamore", "sympathy", "symphonic", "symphony", "symptom", "synapse", "syndrome", "synergy", "synopses", "synopsis", "synthesis", "synthetic", "syrup", "system", "t-shirt", "tabasco", "tabby", "tableful", "tables", "tablet", "tableware", "tabloid", "tackiness", "tacking", "tackle", "tackling", "tacky", "taco", "tactful", "tactical", "tactics", "tactile", "tactless", "tadpole", "taekwondo", "tag", "tainted", "take", "taking", "talcum", "talisman", "tall", "talon", "tamale", "tameness", "tamer", "tamper", "tank", "tanned", "tannery", "tanning", "tantrum", "tapeless", "tapered", "tapering", "tapestry", "tapioca", "tapping", "taps", "tarantula", "target", "tarmac", "tarnish", "tarot", "tartar", "tartly", "tartness", "task", "tassel", "taste", "tastiness", "tasting", "tasty", "tattered", "tattle", "tattling", "tattoo", "taunt", "tavern", "thank", "that", "thaw", "theater", "theatrics", "thee", "theft", "theme", "theology", "theorize", "thermal", "thermos", "thesaurus", "these", "thesis", "thespian", "thicken", "thicket", "thickness", "thieving", "thievish", "thigh", "thimble", "thing", "think", "thinly", "thinner", "thinness", "thinning", "thirstily", "thirsting", "thirsty", "thirteen", "thirty", "thong", "thorn", "those", "thousand", "thrash", "thread", "threaten", "threefold", "thrift", "thrill", "thrive", "thriving", "throat", "throbbing", "throng", "throttle", "throwaway", "throwback", "thrower", "throwing", "thud", "thumb", "thumping", "thursday", "thus", "thwarting", "thyself", "tiara", "tibia", "tidal", "tidbit", "tidiness", "tidings", "tidy", "tiger", "tighten", "tightly", "tightness", "tightrope", "tightwad", "tigress", "tile", "tiling", "till", "tilt", "timid", "timing", "timothy", "tinderbox", "tinfoil", "tingle", "tingling", "tingly", "tinker", "tinkling", "tinsel", "tinsmith", "tint", "tinwork", "tiny", "tipoff", "tipped", "tipper", "tipping", "tiptoeing", "tiptop", "tiring", "tissue", "trace", "tracing", "track", "traction", "tractor", "trade", "trading", "tradition", "traffic", "tragedy", "trailing", "trailside", "train", "traitor", "trance", "tranquil", "transfer", "transform", "translate", "transpire", "transport", "transpose", "trapdoor", "trapeze", "trapezoid", "trapped", "trapper", "trapping", "traps", "trash", "travel", "traverse", "travesty", "tray", "treachery", "treading", "treadmill", "treason", "treat", "treble", "tree", "trekker", "tremble", "trembling", "tremor", "trench", "trend", "trespass", "triage", "trial", "triangle", "tribesman", "tribunal", "tribune", "tributary", "tribute", "triceps", "trickery", "trickily", "tricking", "trickle", "trickster", "tricky", "tricolor", "tricycle", "trident", "tried", "trifle", "trifocals", "trillion", "trilogy", "trimester", "trimmer", "trimming", "trimness", "trinity", "trio", "tripod", "tripping", "triumph", "trivial", "trodden", "trolling", "trombone", "trophy", "tropical", "tropics", "trouble", "troubling", "trough", "trousers", "trout", "trowel", "truce", "truck", "truffle", "trump", "trunks", "trustable", "trustee", "trustful", "trusting", "trustless", "truth", "try", "tubby", "tubeless", "tubular", "tucking", "tuesday", "tug", "tuition", "tulip", "tumble", "tumbling", "tummy", "turban", "turbine", "turbofan", "turbojet", "turbulent", "turf", "turkey", "turmoil", "turret", "turtle", "tusk", "tutor", "tutu", "tux", "tweak", "tweed", "tweet", "tweezers", "twelve", "twentieth", "twenty", "twerp", "twice", "twiddle", "twiddling", "twig", "twilight", "twine", "twins", "twirl", "twistable", "twisted", "twister", "twisting", "twisty", "twitch", "twitter", "tycoon", "tying", "tyke", "udder", "ultimate", "ultimatum", "ultra", "umbilical", "umbrella", "umpire", "unabashed", "unable", "unadorned", "unadvised", "unafraid", "unaired", "unaligned", "unaltered", "unarmored", "unashamed", "unaudited", "unawake", "unaware", "unbaked", "unbalance", "unbeaten", "unbend", "unbent", "unbiased", "unbitten", "unblended", "unblessed", "unblock", "unbolted", "unbounded", "unboxed", "unbraided", "unbridle", "unbroken", "unbuckled", "unbundle", "unburned", "unbutton", "uncanny", "uncapped", "uncaring", "uncertain", "unchain", "unchanged", "uncharted", "uncheck", "uncivil", "unclad", "unclaimed", "unclamped", "unclasp", "uncle", "unclip", "uncloak", "unclog", "unclothed", "uncoated", "uncoiled", "uncolored", "uncombed", "uncommon", "uncooked", "uncork", "uncorrupt", "uncounted", "uncouple", "uncouth", "uncover", "uncross", "uncrown", "uncrushed", "uncured", "uncurious", "uncurled", "uncut", "undamaged", "undated", "undaunted", "undead", "undecided", "undefined", "underage", "underarm", "undercoat", "undercook", "undercut", "underdog", "underdone", "underfed", "underfeed", "underfoot", "undergo", "undergrad", "underhand", "underline", "underling", "undermine", "undermost", "underpaid", "underpass", "underpay", "underrate", "undertake", "undertone", "undertook", "undertow", "underuse", "underwear", "underwent", "underwire", "undesired", "undiluted", "undivided", "undocked", "undoing", "undone", "undrafted", "undress", "undrilled", "undusted", "undying", "unearned", "unearth", "unease", "uneasily", "uneasy", "uneatable", "uneaten", "unedited", "unelected", "unending", "unengaged", "unenvied", "unequal", "unethical", "uneven", "unexpired", "unexposed", "unfailing", "unfair", "unfasten", "unfazed", "unfeeling", "unfiled", "unfilled", "unfitted", "unfitting", "unfixable", "unfixed", "unflawed", "unfocused", "unfold", "unfounded", "unframed", "unfreeze", "unfrosted", "unfrozen", "unfunded", "unglazed", "ungloved", "unglue", "ungodly", "ungraded", "ungreased", "unguarded", "unguided", "unhappily", "unhappy", "unharmed", "unhealthy", "unheard", "unhearing", "unheated", "unhelpful", "unhidden", "unhinge", "unhitched", "unholy", "unhook", "unicorn", "unicycle", "unified", "unifier", "uniformed", "uniformly", "unify", "unimpeded", "uninjured", "uninstall", "uninsured", "uninvited", "union", "uniquely", "unisexual", "unison", "unissued", "unit", "universal", "universe", "unjustly", "unkempt", "unkind", "unknotted", "unknowing", "unknown", "unlaced", "unlatch", "unlawful", "unleaded", "unlearned", "unleash", "unless", "unleveled", "unlighted", "unlikable", "unlimited", "unlined", "unlinked", "unlisted", "unlit", "unlivable", "unloaded", "unloader", "unlocked", "unlocking", "unlovable", "unloved", "unlovely", "unloving", "unluckily", "unlucky", "unmade", "unmanaged", "unmanned", "unmapped", "unmarked", "unmasked", "unmasking", "unmatched", "unmindful", "unmixable", "unmixed", "unmolded", "unmoral", "unmovable", "unmoved", "unmoving", "unnamable", "unnamed", "unnatural", "unneeded", "unnerve", "unnerving", "unnoticed", "unopened", "unopposed", "unpack", "unpadded", "unpaid", "unpainted", "unpaired", "unpaved", "unpeeled", "unpicked", "unpiloted", "unpinned", "unplanned", "unplanted", "unpleased", "unpledged", "unplowed", "unplug", "unpopular", "unproven", "unquote", "unranked", "unrated", "unraveled", "unreached", "unread", "unreal", "unreeling", "unrefined", "unrelated", "unrented", "unrest", "unretired", "unrevised", "unrigged", "unripe", "unrivaled", "unroasted", "unrobed", "unroll", "unruffled", "unruly", "unrushed", "unsaddle", "unsafe", "unsaid", "unsalted", "unsaved", "unsavory", "unscathed", "unscented", "unscrew", "unsealed", "unseated", "unsecured", "unseeing", "unseemly", "unseen", "unselect", "unselfish", "unsent", "unsettled", "unshackle", "unshaken", "unshaved", "unshaven", "unsheathe", "unshipped", "unsightly", "unsigned", "unskilled", "unsliced", "unsmooth", "unsnap", "unsocial", "unsoiled", "unsold", "unsolved", "unsorted", "unspoiled", "unspoken", "unstable", "unstaffed", "unstamped", "unsteady", "unsterile", "unstirred", "unstitch", "unstopped", "unstuck", "unstuffed", "unstylish", "unsubtle", "unsubtly", "unsuited", "unsure", "unsworn", "untagged", "untainted", "untaken", "untamed", "untangled", "untapped", "untaxed", "unthawed", "unthread", "untidy", "untie", "until", "untimed", "untimely", "untitled", "untoasted", "untold", "untouched", "untracked", "untrained", "untreated", "untried", "untrimmed", "untrue", "untruth", "unturned", "untwist", "untying", "unusable", "unused", "unusual", "unvalued", "unvaried", "unvarying", "unveiled", "unveiling", "unvented", "unviable", "unvisited", "unvocal", "unwanted", "unwarlike", "unwary", "unwashed", "unwatched", "unweave", "unwed", "unwelcome", "unwell", "unwieldy", "unwilling", "unwind", "unwired", "unwitting", "unwomanly", "unworldly", "unworn", "unworried", "unworthy", "unwound", "unwoven", "unwrapped", "unwritten", "unzip", "upbeat", "upchuck", "upcoming", "upcountry", "update", "upfront", "upgrade", "upheaval", "upheld", "uphill", "uphold", "uplifted", "uplifting", "upload", "upon", "upper", "upright", "uprising", "upriver", "uproar", "uproot", "upscale", "upside", "upstage", "upstairs", "upstart", "upstate", "upstream", "upstroke", "upswing", "uptake", "uptight", "uptown", "upturned", "upward", "upwind", "uranium", "urban", "urchin", "urethane", "urgency", "urgent", "urging", "urologist", "urology", "usable", "usage", "useable", "used", "uselessly", "user", "usher", "usual", "utensil", "utility", "utilize", "utmost", "utopia", "utter", "vacancy", "vacant", "vacate", "vacation", "vagabond", "vagrancy", "vagrantly", "vaguely", "vagueness", "valiant", "valid", "valium", "valley", "valuables", "value", "vanilla", "vanish", "vanity", "vanquish", "vantage", "vaporizer", "variable", "variably", "varied", "variety", "various", "varmint", "varnish", "varsity", "varying", "vascular", "vaseline", "vastly", "vastness", "veal", "vegan", "veggie", "vehicular", "velcro", "velocity", "velvet", "vendetta", "vending", "vendor", "veneering", "vengeful", "venomous", "ventricle", "venture", "venue", "venus", "verbalize", "verbally", "verbose", "verdict", "verify", "verse", "version", "versus", "vertebrae", "vertical", "vertigo", "very", "vessel", "vest", "veteran", "veto", "vexingly", "viability", "viable", "vibes", "vice", "vicinity", "victory", "video", "viewable", "viewer", "viewing", "viewless", "viewpoint", "vigorous", "village", "villain", "vindicate", "vineyard", "vintage", "violate", "violation", "violator", "violet", "violin", "viper", "viral", "virtual", "virtuous", "virus", "visa", "viscosity", "viscous", "viselike", "visible", "visibly", "vision", "visiting", "visitor", "visor", "vista", "vitality", "vitalize", "vitally", "vitamins", "vivacious", "vividly", "vividness", "vixen", "vocalist", "vocalize", "vocally", "vocation", "voice", "voicing", "void", "volatile", "volley", "voltage", "volumes", "voter", "voting", "voucher", "vowed", "vowel", "voyage", "wackiness", "wad", "wafer", "waffle", "waged", "wager", "wages", "waggle", "wagon", "wake", "waking", "walk", "walmart", "walnut", "walrus", "waltz", "wand", "wannabe", "wanted", "wanting", "wasabi", "washable", "washbasin", "washboard", "washbowl", "washcloth", "washday", "washed", "washer", "washhouse", "washing", "washout", "washroom", "washstand", "washtub", "wasp", "wasting", "watch", "water", "waviness", "waving", "wavy", "whacking", "whacky", "wham", "wharf", "wheat", "whenever", "whiff", "whimsical", "whinny", "whiny", "whisking", "whoever", "whole", "whomever", "whoopee", "whooping", "whoops", "why", "wick", "widely", "widen", "widget", "widow", "width", "wieldable", "wielder", "wife", "wifi", "wikipedia", "wildcard", "wildcat", "wilder", "wildfire", "wildfowl", "wildland", "wildlife", "wildly", "wildness", "willed", "willfully", "willing", "willow", "willpower", "wilt", "wimp", "wince", "wincing", "wind", "wing", "winking", "winner", "winnings", "winter", "wipe", "wired", "wireless", "wiring", "wiry", "wisdom", "wise", "wish", "wisplike", "wispy", "wistful", "wizard", "wobble", "wobbling", "wobbly", "wok", "wolf", "wolverine", "womanhood", "womankind", "womanless", "womanlike", "womanly", "womb", "woof", "wooing", "wool", "woozy", "word", "work", "worried", "worrier", "worrisome", "worry", "worsening", "worshiper", "worst", "wound", "woven", "wow", "wrangle", "wrath", "wreath", "wreckage", "wrecker", "wrecking", "wrench", "wriggle", "wriggly", "wrinkle", "wrinkly", "wrist", "writing", "written", "wrongdoer", "wronged", "wrongful", "wrongly", "wrongness", "wrought", "xbox", "xerox", "yahoo", "yam", "yanking", "yapping", "yard", "yarn", "yeah", "yearbook", "yearling", "yearly", "yearning", "yeast", "yelling", "yelp", "yen", "yesterday", "yiddish", "yield", "yin", "yippee", "yo-yo", "yodel", "yoga", "yogurt", "yonder", "yoyo", "yummy", "zap", "zealous", "zebra", "zen", "zeppelin", "zero", "zestfully", "zesty", "zigzagged", "zipfile", "zipping", "zippy", "zips", "zit", "zodiac", "zombie", "zone", "zoning", "zookeeper", "zoologist", "zoology", "zoom"];
Object.defineProperty(newSecureWords$1, "__esModule", {
    value: !0
});
newSecureWords$1.newSecureWords = void 0;
const getSecureRandom_1$1 = getSecureRandom
  , wordlist_1$1 = wordlist$1;
async function newSecureWords(xt=6) {
    let Cn = [];
    for (let as = 0; as < xt; as++)
        Cn.push(wordlist_1$1.wordlist[await (0,
        getSecureRandom_1$1.getSecureRandomNumber)(0, wordlist_1$1.wordlist.length)]);
    return Cn
}
newSecureWords$1.newSecureWords = newSecureWords;
var newSecurePassphrase = {}, hasRequiredNewSecurePassphrase;
function requireNewSecurePassphrase() {
    if (hasRequiredNewSecurePassphrase)
        return newSecurePassphrase;
    hasRequiredNewSecurePassphrase = 1,
    Object.defineProperty(newSecurePassphrase, "__esModule", {
        value: !0
    }),
    newSecurePassphrase.newSecurePassphrase = void 0;
    const xt = requireDist();
    async function Cn(as=6) {
        return (await (0,
        xt.newSecureWords)(as)).join("-")
    }
    return newSecurePassphrase.newSecurePassphrase = Cn,
    newSecurePassphrase
}
var mnemonic = {}
  , binary = {};
Object.defineProperty(binary, "__esModule", {
    value: !0
});
binary.bitsToBytes = binary.bytesToBits = binary.lpad = void 0;
function lpad(xt, Cn, as) {
    for (; xt.length < as; )
        xt = Cn + xt;
    return xt
}
binary.lpad = lpad;
function bytesToBits(xt) {
    let Cn = "";
    for (let as = 0; as < xt.length; as++) {
        let cs = xt.at(as);
        Cn += lpad(cs.toString(2), "0", 8)
    }
    return Cn
}
binary.bytesToBits = bytesToBits;
function bitsToBytes(xt) {
    if (xt.length % 8 !== 0)
        throw Error("Uneven bits");
    let Cn = [];
    for (; xt.length > 0; )
        Cn.push(parseInt(xt.slice(0, 8), 2)),
        xt = xt.slice(8);
    return Buffer.from(Cn)
}
binary.bitsToBytes = bitsToBytes;
var wordlist = {};
Object.defineProperty(wordlist, "__esModule", {
    value: !0
});
wordlist.wordlist = void 0;
const EN = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"];
wordlist.wordlist = EN;
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(xt) {
    return xt && xt.__esModule ? xt : {
        default: xt
    }
}
;
Object.defineProperty(mnemonic, "__esModule", {
    value: !0
});
mnemonic.mnemonicFromRandomSeed = mnemonic.mnemonicIndexesToBytes = mnemonic.bytesToMnemonics = mnemonic.bytesToMnemonicIndexes = mnemonic.mnemonicNew = mnemonic.mnemonicValidate = mnemonic.mnemonicToHDSeed = mnemonic.mnemonicToWalletKey = mnemonic.mnemonicToPrivateKey = mnemonic.mnemonicToSeed = mnemonic.mnemonicToEntropy = void 0;
const tweetnacl_1$1 = __importDefault$1(naclFastExports)
  , getSecureRandom_1 = getSecureRandom
  , hmac_sha512_1$3 = hmac_sha512$1
  , pbkdf2_sha512_1 = pbkdf2_sha512$1
  , binary_1 = binary
  , wordlist_1 = wordlist
  , PBKDF_ITERATIONS = 1e5;
async function isPasswordNeeded(xt) {
    const Cn = await mnemonicToEntropy(xt);
    return await isPasswordSeed(Cn) && !await isBasicSeed(Cn)
}
function normalizeMnemonic(xt) {
    return xt.map(Cn => Cn.toLowerCase().trim())
}
async function isBasicSeed(xt) {
    return (await (0,
    pbkdf2_sha512_1.pbkdf2_sha512)(xt, "TON seed version", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), 64))[0] == 0
}
async function isPasswordSeed(xt) {
    return (await (0,
    pbkdf2_sha512_1.pbkdf2_sha512)(xt, "TON fast seed version", 1, 64))[0] == 1
}
async function mnemonicToEntropy(xt, Cn) {
    return await (0,
    hmac_sha512_1$3.hmac_sha512)(xt.join(" "), Cn && Cn.length > 0 ? Cn : "")
}
mnemonic.mnemonicToEntropy = mnemonicToEntropy;
async function mnemonicToSeed(xt, Cn, as) {
    const cs = await mnemonicToEntropy(xt, as);
    return await (0,
    pbkdf2_sha512_1.pbkdf2_sha512)(cs, Cn, PBKDF_ITERATIONS, 64)
}
mnemonic.mnemonicToSeed = mnemonicToSeed;
async function mnemonicToPrivateKey(xt, Cn) {
    xt = normalizeMnemonic(xt);
    const as = await mnemonicToSeed(xt, "TON default seed", Cn);
    let cs = tweetnacl_1$1.default.sign.keyPair.fromSeed(as.slice(0, 32));
    return {
        publicKey: Buffer.from(cs.publicKey),
        secretKey: Buffer.from(cs.secretKey)
    }
}
mnemonic.mnemonicToPrivateKey = mnemonicToPrivateKey;
async function mnemonicToWalletKey(xt, Cn) {
    let cs = (await mnemonicToPrivateKey(xt, Cn)).secretKey.slice(0, 32);
    const Cs = tweetnacl_1$1.default.sign.keyPair.fromSeed(cs);
    return {
        publicKey: Buffer.from(Cs.publicKey),
        secretKey: Buffer.from(Cs.secretKey)
    }
}
mnemonic.mnemonicToWalletKey = mnemonicToWalletKey;
async function mnemonicToHDSeed(xt, Cn) {
    return xt = normalizeMnemonic(xt),
    await mnemonicToSeed(xt, "TON HD Keys seed", Cn)
}
mnemonic.mnemonicToHDSeed = mnemonicToHDSeed;
async function mnemonicValidate(xt, Cn) {
    xt = normalizeMnemonic(xt);
    for (let as of xt)
        if (wordlist_1.wordlist.indexOf(as) < 0)
            return !1;
    return Cn && Cn.length > 0 && !await isPasswordNeeded(xt) ? !1 : await isBasicSeed(await mnemonicToEntropy(xt, Cn))
}
mnemonic.mnemonicValidate = mnemonicValidate;
async function mnemonicNew(xt=24, Cn) {
    let as = [];
    for (; ; ) {
        as = [];
        for (let cs = 0; cs < xt; cs++) {
            let Cs = await (0,
            getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length);
            as.push(wordlist_1.wordlist[Cs])
        }
        if (!(Cn && Cn.length > 0 && !await isPasswordNeeded(as)) && await isBasicSeed(await mnemonicToEntropy(as, Cn)))
            break
    }
    return as
}
mnemonic.mnemonicNew = mnemonicNew;
function bytesToMnemonicIndexes(xt, Cn) {
    let as = (0,
    binary_1.bytesToBits)(xt)
      , cs = [];
    for (let Cs = 0; Cs < Cn; Cs++) {
        let Ls = as.slice(Cs * 11, Cs * 11 + 11);
        cs.push(parseInt(Ls, 2))
    }
    return cs
}
mnemonic.bytesToMnemonicIndexes = bytesToMnemonicIndexes;
function bytesToMnemonics(xt, Cn) {
    let as = bytesToMnemonicIndexes(xt, Cn)
      , cs = [];
    for (let Cs of as)
        cs.push(wordlist_1.wordlist[Cs]);
    return cs
}
mnemonic.bytesToMnemonics = bytesToMnemonics;
function mnemonicIndexesToBytes(xt) {
    let Cn = "";
    for (let as of xt) {
        if (!Number.isSafeInteger(as) || as < 0 || as >= 2028)
            throw Error("Invalid input");
        Cn += (0,
        binary_1.lpad)(as.toString(2), "0", 11)
    }
    for (; Cn.length % 8 !== 0; )
        Cn = Cn + "0";
    return (0,
    binary_1.bitsToBytes)(Cn)
}
mnemonic.mnemonicIndexesToBytes = mnemonicIndexesToBytes;
async function mnemonicFromRandomSeed(xt, Cn=24, as) {
    const cs = Math.ceil(Cn * 11 / 8);
    let Cs = xt;
    for (; ; ) {
        let Ls = await (0,
        pbkdf2_sha512_1.pbkdf2_sha512)(Cs, "TON mnemonic seed", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), cs)
          , Vs = bytesToMnemonics(Ls, Cn);
        if (await mnemonicValidate(Vs, as))
            return Vs;
        Cs = Ls
    }
}
mnemonic.mnemonicFromRandomSeed = mnemonicFromRandomSeed;
var nacl = {}
  , __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(xt) {
    return xt && xt.__esModule ? xt : {
        default: xt
    }
}
;
Object.defineProperty(nacl, "__esModule", {
    value: !0
});
nacl.openBox = nacl.sealBox = nacl.signVerify = nacl.sign = nacl.keyPairFromSeed = nacl.keyPairFromSecretKey = void 0;
const tweetnacl_1 = __importDefault(naclFastExports);
function keyPairFromSecretKey(xt) {
    let Cn = tweetnacl_1.default.sign.keyPair.fromSecretKey(new Uint8Array(xt));
    return {
        publicKey: Buffer.from(Cn.publicKey),
        secretKey: Buffer.from(Cn.secretKey)
    }
}
nacl.keyPairFromSecretKey = keyPairFromSecretKey;
function keyPairFromSeed(xt) {
    let Cn = tweetnacl_1.default.sign.keyPair.fromSeed(new Uint8Array(xt));
    return {
        publicKey: Buffer.from(Cn.publicKey),
        secretKey: Buffer.from(Cn.secretKey)
    }
}
nacl.keyPairFromSeed = keyPairFromSeed;
function sign(xt, Cn) {
    return Buffer.from(tweetnacl_1.default.sign.detached(new Uint8Array(xt), new Uint8Array(Cn)))
}
nacl.sign = sign;
function signVerify(xt, Cn, as) {
    return tweetnacl_1.default.sign.detached.verify(new Uint8Array(xt), new Uint8Array(Cn), new Uint8Array(as))
}
nacl.signVerify = signVerify;
function sealBox(xt, Cn, as) {
    return Buffer.from(tweetnacl_1.default.secretbox(xt, Cn, as))
}
nacl.sealBox = sealBox;
function openBox(xt, Cn, as) {
    let cs = tweetnacl_1.default.secretbox.open(xt, Cn, as);
    return cs ? Buffer.from(cs) : null
}
nacl.openBox = openBox;
var ed25519 = {};
Object.defineProperty(ed25519, "__esModule", {
    value: !0
});
ed25519.deriveEd25519Path = ed25519.deriveED25519HardenedKey = ed25519.getED25519MasterKeyFromSeed = void 0;
const hmac_sha512_1$2 = hmac_sha512$1
  , ED25519_CURVE = "ed25519 seed"
  , HARDENED_OFFSET$1 = 2147483648;
async function getED25519MasterKeyFromSeed(xt) {
    const Cn = await (0,
    hmac_sha512_1$2.hmac_sha512)(ED25519_CURVE, xt)
      , as = Cn.slice(0, 32)
      , cs = Cn.slice(32);
    return {
        key: as,
        chainCode: cs
    }
}
ed25519.getED25519MasterKeyFromSeed = getED25519MasterKeyFromSeed;
async function deriveED25519HardenedKey(xt, Cn) {
    if (Cn >= HARDENED_OFFSET$1)
        throw Error("Key index must be less than offset");
    const as = Buffer.alloc(4);
    as.writeUInt32BE(Cn + HARDENED_OFFSET$1, 0);
    const cs = Buffer.concat([Buffer.alloc(1, 0), xt.key, as])
      , Cs = await (0,
    hmac_sha512_1$2.hmac_sha512)(xt.chainCode, cs)
      , Ls = Cs.slice(0, 32)
      , Vs = Cs.slice(32);
    return {
        key: Ls,
        chainCode: Vs
    }
}
ed25519.deriveED25519HardenedKey = deriveED25519HardenedKey;
async function deriveEd25519Path(xt, Cn) {
    let as = await getED25519MasterKeyFromSeed(xt)
      , cs = [...Cn];
    for (; cs.length > 0; ) {
        let Cs = cs[0];
        cs = cs.slice(1),
        as = await deriveED25519HardenedKey(as, Cs)
    }
    return as.key
}
ed25519.deriveEd25519Path = deriveEd25519Path;
var symmetric = {};
Object.defineProperty(symmetric, "__esModule", {
    value: !0
});
symmetric.deriveSymmetricPath = symmetric.deriveSymmetricHardenedKey = symmetric.getSymmetricMasterKeyFromSeed = void 0;
const hmac_sha512_1$1 = hmac_sha512$1
  , SYMMETRIC_SEED = "Symmetric key seed";
async function getSymmetricMasterKeyFromSeed(xt) {
    const Cn = await (0,
    hmac_sha512_1$1.hmac_sha512)(SYMMETRIC_SEED, xt)
      , as = Cn.slice(32)
      , cs = Cn.slice(0, 32);
    return {
        key: as,
        chainCode: cs
    }
}
symmetric.getSymmetricMasterKeyFromSeed = getSymmetricMasterKeyFromSeed;
async function deriveSymmetricHardenedKey(xt, Cn) {
    const as = Buffer.concat([Buffer.alloc(1, 0), Buffer.from(Cn)])
      , cs = await (0,
    hmac_sha512_1$1.hmac_sha512)(xt.chainCode, as)
      , Cs = cs.slice(32)
      , Ls = cs.slice(0, 32);
    return {
        key: Cs,
        chainCode: Ls
    }
}
symmetric.deriveSymmetricHardenedKey = deriveSymmetricHardenedKey;
async function deriveSymmetricPath(xt, Cn) {
    let as = await getSymmetricMasterKeyFromSeed(xt)
      , cs = [...Cn];
    for (; cs.length > 0; ) {
        let Cs = cs[0];
        cs = cs.slice(1),
        as = await deriveSymmetricHardenedKey(as, Cs)
    }
    return as.key
}
symmetric.deriveSymmetricPath = deriveSymmetricPath;
var mnemonics = {};
Object.defineProperty(mnemonics, "__esModule", {
    value: !0
});
mnemonics.deriveMnemonicsPath = mnemonics.deriveMnemonicHardenedKey = mnemonics.getMnemonicsMasterKeyFromSeed = void 0;
const mnemonic_1 = mnemonic
  , hmac_sha512_1 = hmac_sha512$1
  , HARDENED_OFFSET = 2147483648
  , MNEMONICS_SEED = "TON Mnemonics HD seed";
async function getMnemonicsMasterKeyFromSeed(xt) {
    const Cn = await (0,
    hmac_sha512_1.hmac_sha512)(MNEMONICS_SEED, xt)
      , as = Cn.slice(0, 32)
      , cs = Cn.slice(32);
    return {
        key: as,
        chainCode: cs
    }
}
mnemonics.getMnemonicsMasterKeyFromSeed = getMnemonicsMasterKeyFromSeed;
async function deriveMnemonicHardenedKey(xt, Cn) {
    if (Cn >= HARDENED_OFFSET)
        throw Error("Key index must be less than offset");
    const as = Buffer.alloc(4);
    as.writeUInt32BE(Cn + HARDENED_OFFSET, 0);
    const cs = Buffer.concat([Buffer.alloc(1, 0), xt.key, as])
      , Cs = await (0,
    hmac_sha512_1.hmac_sha512)(xt.chainCode, cs)
      , Ls = Cs.slice(0, 32)
      , Vs = Cs.slice(32);
    return {
        key: Ls,
        chainCode: Vs
    }
}
mnemonics.deriveMnemonicHardenedKey = deriveMnemonicHardenedKey;
async function deriveMnemonicsPath(xt, Cn, as=24, cs) {
    let Cs = await getMnemonicsMasterKeyFromSeed(xt)
      , Ls = [...Cn];
    for (; Ls.length > 0; ) {
        let Vs = Ls[0];
        Ls = Ls.slice(1),
        Cs = await deriveMnemonicHardenedKey(Cs, Vs)
    }
    return await (0,
    mnemonic_1.mnemonicFromRandomSeed)(Cs.key, as, cs)
}
mnemonics.deriveMnemonicsPath = deriveMnemonicsPath;
var hasRequiredDist;
function requireDist() {
    return hasRequiredDist || (hasRequiredDist = 1,
    function(xt) {
        Object.defineProperty(xt, "__esModule", {
            value: !0
        }),
        xt.getMnemonicsMasterKeyFromSeed = xt.deriveMnemonicHardenedKey = xt.deriveMnemonicsPath = xt.deriveSymmetricPath = xt.deriveSymmetricHardenedKey = xt.getSymmetricMasterKeyFromSeed = xt.deriveEd25519Path = xt.deriveED25519HardenedKey = xt.getED25519MasterKeyFromSeed = xt.signVerify = xt.sign = xt.keyPairFromSecretKey = xt.keyPairFromSeed = xt.openBox = xt.sealBox = xt.mnemonicWordList = xt.mnemonicToHDSeed = xt.mnemonicToSeed = xt.mnemonicToWalletKey = xt.mnemonicToPrivateKey = xt.mnemonicValidate = xt.mnemonicNew = xt.newSecurePassphrase = xt.newSecureWords = xt.getSecureRandomNumber = xt.getSecureRandomWords = xt.getSecureRandomBytes = xt.hmac_sha512 = xt.pbkdf2_sha512 = xt.sha512_sync = xt.sha512 = xt.sha256_sync = xt.sha256 = void 0;
        var Cn = sha256$3;
        Object.defineProperty(xt, "sha256", {
            enumerable: !0,
            get: function() {
                return Cn.sha256
            }
        }),
        Object.defineProperty(xt, "sha256_sync", {
            enumerable: !0,
            get: function() {
                return Cn.sha256_sync
            }
        });
        var as = sha512$1;
        Object.defineProperty(xt, "sha512", {
            enumerable: !0,
            get: function() {
                return as.sha512
            }
        }),
        Object.defineProperty(xt, "sha512_sync", {
            enumerable: !0,
            get: function() {
                return as.sha512_sync
            }
        });
        var cs = pbkdf2_sha512$1;
        Object.defineProperty(xt, "pbkdf2_sha512", {
            enumerable: !0,
            get: function() {
                return cs.pbkdf2_sha512
            }
        });
        var Cs = hmac_sha512$1;
        Object.defineProperty(xt, "hmac_sha512", {
            enumerable: !0,
            get: function() {
                return Cs.hmac_sha512
            }
        });
        var Ls = getSecureRandom;
        Object.defineProperty(xt, "getSecureRandomBytes", {
            enumerable: !0,
            get: function() {
                return Ls.getSecureRandomBytes
            }
        }),
        Object.defineProperty(xt, "getSecureRandomWords", {
            enumerable: !0,
            get: function() {
                return Ls.getSecureRandomWords
            }
        }),
        Object.defineProperty(xt, "getSecureRandomNumber", {
            enumerable: !0,
            get: function() {
                return Ls.getSecureRandomNumber
            }
        });
        var Vs = newSecureWords$1;
        Object.defineProperty(xt, "newSecureWords", {
            enumerable: !0,
            get: function() {
                return Vs.newSecureWords
            }
        });
        var Ws = requireNewSecurePassphrase();
        Object.defineProperty(xt, "newSecurePassphrase", {
            enumerable: !0,
            get: function() {
                return Ws.newSecurePassphrase
            }
        });
        var Xs = mnemonic;
        Object.defineProperty(xt, "mnemonicNew", {
            enumerable: !0,
            get: function() {
                return Xs.mnemonicNew
            }
        }),
        Object.defineProperty(xt, "mnemonicValidate", {
            enumerable: !0,
            get: function() {
                return Xs.mnemonicValidate
            }
        }),
        Object.defineProperty(xt, "mnemonicToPrivateKey", {
            enumerable: !0,
            get: function() {
                return Xs.mnemonicToPrivateKey
            }
        }),
        Object.defineProperty(xt, "mnemonicToWalletKey", {
            enumerable: !0,
            get: function() {
                return Xs.mnemonicToWalletKey
            }
        }),
        Object.defineProperty(xt, "mnemonicToSeed", {
            enumerable: !0,
            get: function() {
                return Xs.mnemonicToSeed
            }
        }),
        Object.defineProperty(xt, "mnemonicToHDSeed", {
            enumerable: !0,
            get: function() {
                return Xs.mnemonicToHDSeed
            }
        });
        var ga = wordlist;
        Object.defineProperty(xt, "mnemonicWordList", {
            enumerable: !0,
            get: function() {
                return ga.wordlist
            }
        });
        var ba = nacl;
        Object.defineProperty(xt, "sealBox", {
            enumerable: !0,
            get: function() {
                return ba.sealBox
            }
        }),
        Object.defineProperty(xt, "openBox", {
            enumerable: !0,
            get: function() {
                return ba.openBox
            }
        });
        var yl = nacl;
        Object.defineProperty(xt, "keyPairFromSeed", {
            enumerable: !0,
            get: function() {
                return yl.keyPairFromSeed
            }
        }),
        Object.defineProperty(xt, "keyPairFromSecretKey", {
            enumerable: !0,
            get: function() {
                return yl.keyPairFromSecretKey
            }
        }),
        Object.defineProperty(xt, "sign", {
            enumerable: !0,
            get: function() {
                return yl.sign
            }
        }),
        Object.defineProperty(xt, "signVerify", {
            enumerable: !0,
            get: function() {
                return yl.signVerify
            }
        });
        var xl = ed25519;
        Object.defineProperty(xt, "getED25519MasterKeyFromSeed", {
            enumerable: !0,
            get: function() {
                return xl.getED25519MasterKeyFromSeed
            }
        }),
        Object.defineProperty(xt, "deriveED25519HardenedKey", {
            enumerable: !0,
            get: function() {
                return xl.deriveED25519HardenedKey
            }
        }),
        Object.defineProperty(xt, "deriveEd25519Path", {
            enumerable: !0,
            get: function() {
                return xl.deriveEd25519Path
            }
        });
        var wl = symmetric;
        Object.defineProperty(xt, "getSymmetricMasterKeyFromSeed", {
            enumerable: !0,
            get: function() {
                return wl.getSymmetricMasterKeyFromSeed
            }
        }),
        Object.defineProperty(xt, "deriveSymmetricHardenedKey", {
            enumerable: !0,
            get: function() {
                return wl.deriveSymmetricHardenedKey
            }
        }),
        Object.defineProperty(xt, "deriveSymmetricPath", {
            enumerable: !0,
            get: function() {
                return wl.deriveSymmetricPath
            }
        });
        var _l = mnemonics;
        Object.defineProperty(xt, "deriveMnemonicsPath", {
            enumerable: !0,
            get: function() {
                return _l.deriveMnemonicsPath
            }
        }),
        Object.defineProperty(xt, "deriveMnemonicHardenedKey", {
            enumerable: !0,
            get: function() {
                return _l.deriveMnemonicHardenedKey
            }
        }),
        Object.defineProperty(xt, "getMnemonicsMasterKeyFromSeed", {
            enumerable: !0,
            get: function() {
                return _l.getMnemonicsMasterKeyFromSeed
            }
        })
    }(dist)),
    dist
}
var hasRequiredWonderCalculator;
function requireWonderCalculator() {
    if (hasRequiredWonderCalculator)
        return wonderCalculator;
    hasRequiredWonderCalculator = 1,
    Object.defineProperty(wonderCalculator, "__esModule", {
        value: !0
    }),
    wonderCalculator.wonderCalculator = void 0;
    const xt = requireBitString()
      , Cn = CellType$1
      , as = LevelMask$1
      , cs = exoticPruned$1
      , Cs = requireExoticMerkleProof()
      , Ls = descriptor
      , Vs = requireDist()
      , Ws = exoticMerkleUpdate$1
      , Xs = exoticLibrary$1;
    function ga(ba, yl, xl) {
        let wl, _l = null;
        if (ba === Cn.CellType.Ordinary) {
            let Ml = 0;
            for (let Nl of xl)
                Ml = Ml | Nl.mask.value;
            wl = new as.LevelMask(Ml)
        } else if (ba === Cn.CellType.PrunedBranch)
            _l = (0,
            cs.exoticPruned)(yl, xl),
            wl = new as.LevelMask(_l.mask);
        else if (ba === Cn.CellType.MerkleProof)
            (0,
            Cs.exoticMerkleProof)(yl, xl),
            wl = new as.LevelMask(xl[0].mask.value >> 1);
        else if (ba === Cn.CellType.MerkleUpdate)
            (0,
            Ws.exoticMerkleUpdate)(yl, xl),
            wl = new as.LevelMask((xl[0].mask.value | xl[1].mask.value) >> 1);
        else if (ba === Cn.CellType.Library)
            (0,
            Xs.exoticLibrary)(yl, xl),
            wl = new as.LevelMask;
        else
            throw new Error("Unsupported exotic type");
        let El = []
          , Cl = []
          , $l = ba === Cn.CellType.PrunedBranch ? 1 : wl.hashCount
          , Tl = wl.hashCount - $l;
        for (let Ml = 0, Nl = 0; Ml <= wl.level; Ml++) {
            if (!wl.isSignificant(Ml))
                continue;
            if (Nl < Tl) {
                Nl++;
                continue
            }
            let Ll;
            if (Nl === Tl) {
                if (!(Ml === 0 || ba === Cn.CellType.PrunedBranch))
                    throw Error("Invalid");
                Ll = yl
            } else {
                if (!(Ml !== 0 && ba !== Cn.CellType.PrunedBranch))
                    throw Error("Invalid: " + Ml + ", " + ba);
                Ll = new xt.BitString(Cl[Nl - Tl - 1],0,256)
            }
            let Fl = 0;
            for (let Gl of xl) {
                let Wl;
                ba == Cn.CellType.MerkleProof || ba == Cn.CellType.MerkleUpdate ? Wl = Gl.depth(Ml + 1) : Wl = Gl.depth(Ml),
                Fl = Math.max(Fl, Wl)
            }
            xl.length > 0 && Fl++;
            let Ul = (0,
            Ls.getRepr)(yl, Ll, xl, Ml, wl.apply(Ml).value, ba)
              , Dl = (0,
            Vs.sha256_sync)(Ul)
              , Zl = Nl - Tl;
            El[Zl] = Fl,
            Cl[Zl] = Dl,
            Nl++
        }
        let Rl = []
          , Il = [];
        if (_l)
            for (let Ml = 0; Ml < 4; Ml++) {
                const {hashIndex: Nl} = wl.apply(Ml)
                  , {hashIndex: Ll} = wl;
                Nl !== Ll ? (Rl.push(_l.pruned[Nl].hash),
                Il.push(_l.pruned[Nl].depth)) : (Rl.push(Cl[0]),
                Il.push(El[0]))
            }
        else
            for (let Ml = 0; Ml < 4; Ml++)
                Rl.push(Cl[wl.apply(Ml).hashIndex]),
                Il.push(El[wl.apply(Ml).hashIndex]);
        return {
            mask: wl,
            hashes: Rl,
            depths: Il
        }
    }
    return wonderCalculator.wonderCalculator = ga,
    wonderCalculator
}
var serialization = {}
  , topologicalSort$1 = {};
Object.defineProperty(topologicalSort$1, "__esModule", {
    value: !0
});
topologicalSort$1.topologicalSort = void 0;
function topologicalSort(xt) {
    let Cn = [xt]
      , as = new Map
      , cs = new Set
      , Cs = [];
    for (; Cn.length > 0; ) {
        const ga = [...Cn];
        Cn = [];
        for (let ba of ga) {
            const yl = ba.hash().toString("hex");
            if (!as.has(yl)) {
                cs.add(yl),
                as.set(yl, {
                    cell: ba,
                    refs: ba.refs.map(xl => xl.hash().toString("hex"))
                });
                for (let xl of ba.refs)
                    Cn.push(xl)
            }
        }
    }
    let Ls = new Set;
    function Vs(ga) {
        if (!cs.has(ga))
            return;
        if (Ls.has(ga))
            throw Error("Not a DAG");
        Ls.add(ga);
        let ba = as.get(ga).refs;
        for (let yl = ba.length - 1; yl >= 0; yl--)
            Vs(ba[yl]);
        Cs.push(ga),
        Ls.delete(ga),
        cs.delete(ga)
    }
    for (; cs.size > 0; ) {
        const ga = Array.from(cs)[0];
        Vs(ga)
    }
    let Ws = new Map;
    for (let ga = 0; ga < Cs.length; ga++)
        Ws.set(Cs[Cs.length - ga - 1], ga);
    let Xs = [];
    for (let ga = Cs.length - 1; ga >= 0; ga--) {
        let ba = Cs[ga];
        const yl = as.get(ba);
        Xs.push({
            cell: yl.cell,
            refs: yl.refs.map(xl => Ws.get(xl))
        })
    }
    return Xs
}
topologicalSort$1.topologicalSort = topologicalSort;
var bitsForNumber$1 = {};
Object.defineProperty(bitsForNumber$1, "__esModule", {
    value: !0
});
bitsForNumber$1.bitsForNumber = void 0;
function bitsForNumber(xt, Cn) {
    let as = BigInt(xt);
    if (Cn === "int")
        return as === 0n || as === -1n ? 1 : (as > 0 ? as : -as).toString(2).length + 1;
    if (Cn === "uint") {
        if (as < 0)
            throw Error(`value is negative. Got ${xt}`);
        return as.toString(2).length
    } else
        throw Error(`invalid mode. Got ${Cn}`)
}
bitsForNumber$1.bitsForNumber = bitsForNumber;
var crc32c$1 = {};
Object.defineProperty(crc32c$1, "__esModule", {
    value: !0
});
crc32c$1.crc32c = void 0;
const POLY = 2197175160;
function crc32c(xt) {
    let Cn = -1;
    for (let cs = 0; cs < xt.length; cs++)
        Cn ^= xt[cs],
        Cn = Cn & 1 ? Cn >>> 1 ^ POLY : Cn >>> 1,
        Cn = Cn & 1 ? Cn >>> 1 ^ POLY : Cn >>> 1,
        Cn = Cn & 1 ? Cn >>> 1 ^ POLY : Cn >>> 1,
        Cn = Cn & 1 ? Cn >>> 1 ^ POLY : Cn >>> 1,
        Cn = Cn & 1 ? Cn >>> 1 ^ POLY : Cn >>> 1,
        Cn = Cn & 1 ? Cn >>> 1 ^ POLY : Cn >>> 1,
        Cn = Cn & 1 ? Cn >>> 1 ^ POLY : Cn >>> 1,
        Cn = Cn & 1 ? Cn >>> 1 ^ POLY : Cn >>> 1;
    Cn = Cn ^ 4294967295;
    let as = Buffer.alloc(4);
    return as.writeInt32LE(Cn),
    as
}
crc32c$1.crc32c = crc32c;
var hasRequiredSerialization;
function requireSerialization() {
    if (hasRequiredSerialization)
        return serialization;
    hasRequiredSerialization = 1,
    Object.defineProperty(serialization, "__esModule", {
        value: !0
    }),
    serialization.serializeBoc = serialization.deserializeBoc = serialization.parseBoc = void 0;
    const xt = BitReader$1
      , Cn = requireBitString()
      , as = requireCell()
      , cs = topologicalSort$1
      , Cs = bitsForNumber$1
      , Ls = requireBitBuilder()
      , Vs = descriptor
      , Ws = requirePaddedBits()
      , Xs = crc32c$1;
    function ga($l) {
        return ba($l & 7)
    }
    function ba($l) {
        let Sl = 0;
        for (let Tl = 0; Tl < 3; Tl++)
            Sl += $l & 1,
            $l = $l >> 1;
        return Sl + 1
    }
    function yl($l, Sl) {
        const Tl = $l.loadUint(8)
          , Rl = Tl % 8
          , Il = !!(Tl & 8)
          , Ml = $l.loadUint(8)
          , Nl = Math.ceil(Ml / 2)
          , Ll = !!(Ml % 2)
          , Fl = Tl >> 5
          , Ul = (Tl & 16) != 0
          , Zl = Ul ? ga(Fl) * 32 : 0
          , Gl = Ul ? ga(Fl) * 2 : 0;
        $l.skip(Zl * 8),
        $l.skip(Gl * 8);
        let Wl = Cn.BitString.EMPTY;
        Nl > 0 && (Ll ? Wl = $l.loadPaddedBits(Nl * 8) : Wl = $l.loadBits(Nl * 8));
        let Ql = [];
        for (let cu = 0; cu < Rl; cu++)
            Ql.push($l.loadUint(Sl * 8));
        return {
            bits: Wl,
            refs: Ql,
            exotic: Il
        }
    }
    function xl($l, Sl) {
        return 2 + Math.ceil($l.bits.length / 8) + $l.refs.length * Sl
    }
    function wl($l) {
        let Sl = new xt.BitReader(new Cn.BitString($l,0,$l.length * 8))
          , Tl = Sl.loadUint(32);
        if (Tl === 1761568243) {
            let Rl = Sl.loadUint(8)
              , Il = Sl.loadUint(8)
              , Ml = Sl.loadUint(Rl * 8)
              , Nl = Sl.loadUint(Rl * 8)
              , Ll = Sl.loadUint(Rl * 8)
              , Fl = Sl.loadUint(Il * 8)
              , Ul = Sl.loadBuffer(Ml * Il)
              , Dl = Sl.loadBuffer(Fl);
            return {
                size: Rl,
                offBytes: Il,
                cells: Ml,
                roots: Nl,
                absent: Ll,
                totalCellSize: Fl,
                index: Ul,
                cellData: Dl,
                root: [0]
            }
        } else if (Tl === 2898503464) {
            let Rl = Sl.loadUint(8)
              , Il = Sl.loadUint(8)
              , Ml = Sl.loadUint(Rl * 8)
              , Nl = Sl.loadUint(Rl * 8)
              , Ll = Sl.loadUint(Rl * 8)
              , Fl = Sl.loadUint(Il * 8)
              , Ul = Sl.loadBuffer(Ml * Il)
              , Dl = Sl.loadBuffer(Fl)
              , Zl = Sl.loadBuffer(4);
            if (!(0,
            Xs.crc32c)($l.subarray(0, $l.length - 4)).equals(Zl))
                throw Error("Invalid CRC32C");
            return {
                size: Rl,
                offBytes: Il,
                cells: Ml,
                roots: Nl,
                absent: Ll,
                totalCellSize: Fl,
                index: Ul,
                cellData: Dl,
                root: [0]
            }
        } else if (Tl === 3052313714) {
            let Rl = Sl.loadUint(1)
              , Il = Sl.loadUint(1);
            Sl.loadUint(1),
            Sl.loadUint(2);
            let Ml = Sl.loadUint(3)
              , Nl = Sl.loadUint(8)
              , Ll = Sl.loadUint(Ml * 8)
              , Fl = Sl.loadUint(Ml * 8)
              , Ul = Sl.loadUint(Ml * 8)
              , Dl = Sl.loadUint(Nl * 8)
              , Zl = [];
            for (let Ql = 0; Ql < Fl; Ql++)
                Zl.push(Sl.loadUint(Ml * 8));
            let Gl = null;
            Rl && (Gl = Sl.loadBuffer(Ll * Nl));
            let Wl = Sl.loadBuffer(Dl);
            if (Il) {
                let Ql = Sl.loadBuffer(4);
                if (!(0,
                Xs.crc32c)($l.subarray(0, $l.length - 4)).equals(Ql))
                    throw Error("Invalid CRC32C")
            }
            return {
                size: Ml,
                offBytes: Nl,
                cells: Ll,
                roots: Fl,
                absent: Ul,
                totalCellSize: Dl,
                index: Gl,
                cellData: Wl,
                root: Zl
            }
        } else
            throw Error("Invalid magic")
    }
    serialization.parseBoc = wl;
    function _l($l) {
        let Sl = wl($l)
          , Tl = new xt.BitReader(new Cn.BitString(Sl.cellData,0,Sl.cellData.length * 8))
          , Rl = [];
        for (let Ml = 0; Ml < Sl.cells; Ml++) {
            let Nl = yl(Tl, Sl.size);
            Rl.push({
                ...Nl,
                result: null
            })
        }
        for (let Ml = Rl.length - 1; Ml >= 0; Ml--) {
            if (Rl[Ml].result)
                throw Error("Impossible");
            let Nl = [];
            for (let Ll of Rl[Ml].refs) {
                if (!Rl[Ll].result)
                    throw Error("Invalid BOC file");
                Nl.push(Rl[Ll].result)
            }
            Rl[Ml].result = new as.Cell({
                bits: Rl[Ml].bits,
                refs: Nl,
                exotic: Rl[Ml].exotic
            })
        }
        let Il = [];
        for (let Ml = 0; Ml < Sl.root.length; Ml++)
            Il.push(Rl[Sl.root[Ml]].result);
        return Il
    }
    serialization.deserializeBoc = _l;
    function El($l, Sl, Tl, Rl) {
        let Il = (0,
        Vs.getRefsDescriptor)($l.refs, $l.mask.value, $l.type)
          , Ml = (0,
        Vs.getBitsDescriptor)($l.bits);
        Rl.writeUint(Il, 8),
        Rl.writeUint(Ml, 8),
        Rl.writeBuffer((0,
        Ws.bitsToPaddedBuffer)($l.bits));
        for (let Nl of Sl)
            Rl.writeUint(Nl, Tl * 8)
    }
    function Cl($l, Sl) {
        let Tl = (0,
        cs.topologicalSort)($l)
          , Rl = Tl.length
          , Il = Sl.idx
          , Ml = Sl.crc32
          , Nl = !1
          , Ll = 0
          , Fl = Math.max(Math.ceil((0,
        Cs.bitsForNumber)(Rl, "uint") / 8), 1)
          , Ul = 0
          , Dl = [];
        for (let cu of Tl) {
            let pu = xl(cu.cell, Fl);
            Ul += pu,
            Dl.push(Ul)
        }
        let Zl = Math.max(Math.ceil((0,
        Cs.bitsForNumber)(Ul, "uint") / 8), 1)
          , Gl = (6 + 3 * Fl + Zl + 1 * Fl + (Il ? Rl * Zl : 0) + Ul + (Ml ? 4 : 0)) * 8
          , Wl = new Ls.BitBuilder(Gl);
        if (Wl.writeUint(3052313714, 32),
        Wl.writeBit(Il),
        Wl.writeBit(Ml),
        Wl.writeBit(Nl),
        Wl.writeUint(Ll, 2),
        Wl.writeUint(Fl, 3),
        Wl.writeUint(Zl, 8),
        Wl.writeUint(Rl, Fl * 8),
        Wl.writeUint(1, Fl * 8),
        Wl.writeUint(0, Fl * 8),
        Wl.writeUint(Ul, Zl * 8),
        Wl.writeUint(0, Fl * 8),
        Il)
            for (let cu = 0; cu < Rl; cu++)
                Wl.writeUint(Dl[cu], Zl * 8);
        for (let cu = 0; cu < Rl; cu++)
            El(Tl[cu].cell, Tl[cu].refs, Fl, Wl);
        if (Ml) {
            let cu = (0,
            Xs.crc32c)(Wl.buffer());
            Wl.writeBuffer(cu)
        }
        let Ql = Wl.buffer();
        if (Ql.length !== Gl / 8)
            throw Error("Internal error");
        return Ql
    }
    return serialization.serializeBoc = Cl,
    serialization
}
var hasRequiredCell;
function requireCell() {
    if (hasRequiredCell)
        return Cell;
    hasRequiredCell = 1;
    var xt = commonjsGlobal && commonjsGlobal.__importDefault || function(xl) {
        return xl && xl.__esModule ? xl : {
            default: xl
        }
    }
    , Cn;
    Object.defineProperty(Cell, "__esModule", {
        value: !0
    }),
    Cell.Cell = void 0;
    const as = xt(symbol_inspect)
      , cs = requireBitString()
      , Cs = CellType$1
      , Ls = requireSlice()
      , Vs = requireResolveExotic()
      , Ws = requireWonderCalculator()
      , Xs = requireSerialization()
      , ga = BitReader$1
      , ba = requireBuilder();
    let yl = class M1 {
        static fromBoc(wl) {
            return (0,
            Xs.deserializeBoc)(wl)
        }
        static fromBase64(wl) {
            let _l = M1.fromBoc(Buffer.from(wl, "base64"));
            if (_l.length !== 1)
                throw new Error("Deserialized more than one cell");
            return _l[0]
        }
        static fromHex(wl) {
            let _l = M1.fromBoc(Buffer.from(wl, "hex"));
            if (_l.length !== 1)
                throw new Error("Deserialized more than one cell");
            return _l[0]
        }
        constructor(wl) {
            this._hashes = [],
            this._depths = [],
            this.beginParse = (Rl=!1) => {
                if (this.isExotic && !Rl)
                    throw new Error("Exotic cells cannot be parsed");
                return new Ls.Slice(new ga.BitReader(this.bits),this.refs)
            }
            ,
            this.hash = (Rl=3) => this._hashes[Math.min(this._hashes.length - 1, Rl)],
            this.depth = (Rl=3) => this._depths[Math.min(this._depths.length - 1, Rl)],
            this.level = () => this.mask.level,
            this.equals = Rl => this.hash().equals(Rl.hash()),
            this[Cn] = () => this.toString();
            let _l = cs.BitString.EMPTY;
            wl && wl.bits && (_l = wl.bits);
            let El = [];
            wl && wl.refs && (El = [...wl.refs]);
            let Cl, $l, Sl, Tl = Cs.CellType.Ordinary;
            if (wl && wl.exotic) {
                let Rl = (0,
                Vs.resolveExotic)(_l, El)
                  , Il = (0,
                Ws.wonderCalculator)(Rl.type, _l, El);
                Sl = Il.mask,
                $l = Il.depths,
                Cl = Il.hashes,
                Tl = Rl.type
            } else {
                if (El.length > 4)
                    throw new Error("Invalid number of references");
                if (_l.length > 1023)
                    throw new Error(`Bits overflow: ${_l.length} > 1023`);
                let Rl = (0,
                Ws.wonderCalculator)(Cs.CellType.Ordinary, _l, El);
                Sl = Rl.mask,
                $l = Rl.depths,
                Cl = Rl.hashes,
                Tl = Cs.CellType.Ordinary
            }
            this.type = Tl,
            this.bits = _l,
            this.refs = El,
            this.mask = Sl,
            this._depths = $l,
            this._hashes = Cl,
            Object.freeze(this),
            Object.freeze(this.refs),
            Object.freeze(this.bits),
            Object.freeze(this.mask),
            Object.freeze(this._depths),
            Object.freeze(this._hashes)
        }
        get isExotic() {
            return this.type !== Cs.CellType.Ordinary
        }
        toBoc(wl) {
            let _l = wl && wl.idx !== null && wl.idx !== void 0 ? wl.idx : !1
              , El = wl && wl.crc32 !== null && wl.crc32 !== void 0 ? wl.crc32 : !0;
            return (0,
            Xs.serializeBoc)(this, {
                idx: _l,
                crc32: El
            })
        }
        toString(wl) {
            let _l = wl || ""
              , El = "x";
            this.isExotic && (this.type === Cs.CellType.MerkleProof ? El = "p" : this.type === Cs.CellType.MerkleUpdate ? El = "u" : this.type === Cs.CellType.PrunedBranch && (El = "p"));
            let Cl = _l + (this.isExotic ? El : "x") + "{" + this.bits.toString() + "}";
            for (let $l in this.refs) {
                const Sl = this.refs[$l];
                Cl += `
` + Sl.toString(_l + " ")
            }
            return Cl
        }
        asSlice() {
            return this.beginParse()
        }
        asBuilder() {
            return (0,
            ba.beginCell)().storeSlice(this.asSlice())
        }
    }
    ;
    return Cell.Cell = yl,
    Cn = as.default,
    yl.EMPTY = new yl,
    Cell
}
var hasRequiredBuilder;
function requireBuilder() {
    if (hasRequiredBuilder)
        return Builder;
    hasRequiredBuilder = 1,
    Object.defineProperty(Builder, "__esModule", {
        value: !0
    }),
    Builder.Builder = Builder.beginCell = void 0;
    const xt = requireBitBuilder()
      , Cn = requireCell()
      , as = requireStrings();
    function cs() {
        return new Cs
    }
    Builder.beginCell = cs;
    let Cs = class t0 {
        constructor() {
            this._bits = new xt.BitBuilder,
            this._refs = []
        }
        get bits() {
            return this._bits.length
        }
        get refs() {
            return this._refs.length
        }
        get availableBits() {
            return 1023 - this.bits
        }
        get availableRefs() {
            return 4 - this.refs
        }
        storeBit(Vs) {
            return this._bits.writeBit(Vs),
            this
        }
        storeBits(Vs) {
            return this._bits.writeBits(Vs),
            this
        }
        storeBuffer(Vs, Ws) {
            if (Ws != null && Vs.length !== Ws)
                throw Error(`Buffer length ${Vs.length} is not equal to ${Ws}`);
            return this._bits.writeBuffer(Vs),
            this
        }
        storeMaybeBuffer(Vs, Ws) {
            return Vs !== null ? (this.storeBit(1),
            this.storeBuffer(Vs, Ws)) : this.storeBit(0),
            this
        }
        storeUint(Vs, Ws) {
            return this._bits.writeUint(Vs, Ws),
            this
        }
        storeMaybeUint(Vs, Ws) {
            return Vs != null ? (this.storeBit(1),
            this.storeUint(Vs, Ws)) : this.storeBit(0),
            this
        }
        storeInt(Vs, Ws) {
            return this._bits.writeInt(Vs, Ws),
            this
        }
        storeMaybeInt(Vs, Ws) {
            return Vs != null ? (this.storeBit(1),
            this.storeInt(Vs, Ws)) : this.storeBit(0),
            this
        }
        storeVarUint(Vs, Ws) {
            return this._bits.writeVarUint(Vs, Ws),
            this
        }
        storeMaybeVarUint(Vs, Ws) {
            return Vs != null ? (this.storeBit(1),
            this.storeVarUint(Vs, Ws)) : this.storeBit(0),
            this
        }
        storeVarInt(Vs, Ws) {
            return this._bits.writeVarInt(Vs, Ws),
            this
        }
        storeMaybeVarInt(Vs, Ws) {
            return Vs != null ? (this.storeBit(1),
            this.storeVarInt(Vs, Ws)) : this.storeBit(0),
            this
        }
        storeCoins(Vs) {
            return this._bits.writeCoins(Vs),
            this
        }
        storeMaybeCoins(Vs) {
            return Vs != null ? (this.storeBit(1),
            this.storeCoins(Vs)) : this.storeBit(0),
            this
        }
        storeAddress(Vs) {
            return this._bits.writeAddress(Vs),
            this
        }
        storeRef(Vs) {
            if (this._refs.length >= 4)
                throw new Error("Too many references");
            if (Vs instanceof Cn.Cell)
                this._refs.push(Vs);
            else if (Vs instanceof t0)
                this._refs.push(Vs.endCell());
            else
                throw new Error("Invalid argument");
            return this
        }
        storeMaybeRef(Vs) {
            return Vs ? (this.storeBit(1),
            this.storeRef(Vs)) : this.storeBit(0),
            this
        }
        storeSlice(Vs) {
            let Ws = Vs.clone();
            for (Ws.remainingBits > 0 && this.storeBits(Ws.loadBits(Ws.remainingBits)); Ws.remainingRefs > 0; )
                this.storeRef(Ws.loadRef());
            return this
        }
        storeMaybeSlice(Vs) {
            return Vs ? (this.storeBit(1),
            this.storeSlice(Vs)) : this.storeBit(0),
            this
        }
        storeBuilder(Vs) {
            return this.storeSlice(Vs.endCell().beginParse())
        }
        storeMaybeBuilder(Vs) {
            return Vs ? (this.storeBit(1),
            this.storeBuilder(Vs)) : this.storeBit(0),
            this
        }
        storeWritable(Vs) {
            return typeof Vs == "object" ? Vs.writeTo(this) : Vs(this),
            this
        }
        storeMaybeWritable(Vs) {
            return Vs ? (this.storeBit(1),
            this.storeWritable(Vs)) : this.storeBit(0),
            this
        }
        store(Vs) {
            return this.storeWritable(Vs),
            this
        }
        storeStringTail(Vs) {
            return (0,
            as.writeString)(Vs, this),
            this
        }
        storeMaybeStringTail(Vs) {
            return Vs != null ? (this.storeBit(1),
            (0,
            as.writeString)(Vs, this)) : this.storeBit(0),
            this
        }
        storeStringRefTail(Vs) {
            return this.storeRef(cs().storeStringTail(Vs)),
            this
        }
        storeMaybeStringRefTail(Vs) {
            return Vs != null ? (this.storeBit(1),
            this.storeStringRefTail(Vs)) : this.storeBit(0),
            this
        }
        storeDict(Vs, Ws, Xs) {
            return Vs ? Vs.store(this, Ws, Xs) : this.storeBit(0),
            this
        }
        storeDictDirect(Vs, Ws, Xs) {
            return Vs.storeDirect(this, Ws, Xs),
            this
        }
        endCell(Vs) {
            return new Cn.Cell({
                bits: this._bits.build(),
                refs: this._refs,
                exotic: Vs == null ? void 0 : Vs.exotic
            })
        }
        asCell() {
            return this.endCell()
        }
        asSlice() {
            return this.endCell().beginParse()
        }
    }
    ;
    return Builder.Builder = Cs,
    Builder
}
var StateInit = {}
  , SimpleLibrary = {};
Object.defineProperty(SimpleLibrary, "__esModule", {
    value: !0
});
SimpleLibrary.SimpleLibraryValue = SimpleLibrary.storeSimpleLibrary = SimpleLibrary.loadSimpleLibrary = void 0;
function loadSimpleLibrary(xt) {
    return {
        public: xt.loadBit(),
        root: xt.loadRef()
    }
}
SimpleLibrary.loadSimpleLibrary = loadSimpleLibrary;
function storeSimpleLibrary(xt) {
    return Cn => {
        Cn.storeBit(xt.public),
        Cn.storeRef(xt.root)
    }
}
SimpleLibrary.storeSimpleLibrary = storeSimpleLibrary;
SimpleLibrary.SimpleLibraryValue = {
    serialize(xt, Cn) {
        storeSimpleLibrary(xt)(Cn)
    },
    parse(xt) {
        return loadSimpleLibrary(xt)
    }
};
var TickTock = {};
Object.defineProperty(TickTock, "__esModule", {
    value: !0
});
TickTock.storeTickTock = TickTock.loadTickTock = void 0;
function loadTickTock(xt) {
    return {
        tick: xt.loadBit(),
        tock: xt.loadBit()
    }
}
TickTock.loadTickTock = loadTickTock;
function storeTickTock(xt) {
    return Cn => {
        Cn.storeBit(xt.tick),
        Cn.storeBit(xt.tock)
    }
}
TickTock.storeTickTock = storeTickTock;
Object.defineProperty(StateInit, "__esModule", {
    value: !0
});
StateInit.storeStateInit = StateInit.loadStateInit = void 0;
const Dictionary_1$2 = requireDictionary()
  , SimpleLibrary_1 = SimpleLibrary
  , TickTock_1 = TickTock;
function loadStateInit(xt) {
    let Cn;
    xt.loadBit() && (Cn = xt.loadUint(5));
    let as;
    xt.loadBit() && (as = (0,
    TickTock_1.loadTickTock)(xt));
    let cs = xt.loadMaybeRef()
      , Cs = xt.loadMaybeRef()
      , Ls = xt.loadDict(Dictionary_1$2.Dictionary.Keys.BigUint(256), SimpleLibrary_1.SimpleLibraryValue);
    return Ls.size === 0 && (Ls = void 0),
    {
        splitDepth: Cn,
        special: as,
        code: cs,
        data: Cs,
        libraries: Ls
    }
}
StateInit.loadStateInit = loadStateInit;
function storeStateInit(xt) {
    return Cn => {
        xt.splitDepth !== null && xt.splitDepth !== void 0 ? (Cn.storeBit(!0),
        Cn.storeUint(xt.splitDepth, 5)) : Cn.storeBit(!1),
        xt.special !== null && xt.special !== void 0 ? (Cn.storeBit(!0),
        Cn.store((0,
        TickTock_1.storeTickTock)(xt.special))) : Cn.storeBit(!1),
        Cn.storeMaybeRef(xt.code),
        Cn.storeMaybeRef(xt.data),
        Cn.storeDict(xt.libraries)
    }
}
StateInit.storeStateInit = storeStateInit;
Object.defineProperty(contractAddress$1, "__esModule", {
    value: !0
});
contractAddress$1.contractAddress = void 0;
const Builder_1$8 = requireBuilder()
  , StateInit_1$3 = StateInit
  , Address_1$2 = Address$1;
function contractAddress(xt, Cn) {
    let as = (0,
    Builder_1$8.beginCell)().store((0,
    StateInit_1$3.storeStateInit)(Cn)).endCell().hash();
    return new Address_1$2.Address(xt,as)
}
contractAddress$1.contractAddress = contractAddress;
var tuple = {};
Object.defineProperty(tuple, "__esModule", {
    value: !0
});
tuple.parseTuple = tuple.serializeTuple = void 0;
const Builder_1$7 = requireBuilder()
  , INT64_MIN = BigInt("-9223372036854775808")
  , INT64_MAX = BigInt("9223372036854775807");
function serializeTupleItem(xt, Cn) {
    if (xt.type === "null")
        Cn.storeUint(0, 8);
    else if (xt.type === "int")
        xt.value <= INT64_MAX && xt.value >= INT64_MIN ? (Cn.storeUint(1, 8),
        Cn.storeInt(xt.value, 64)) : (Cn.storeUint(256, 15),
        Cn.storeInt(xt.value, 257));
    else if (xt.type === "nan")
        Cn.storeInt(767, 16);
    else if (xt.type === "cell")
        Cn.storeUint(3, 8),
        Cn.storeRef(xt.cell);
    else if (xt.type === "slice")
        Cn.storeUint(4, 8),
        Cn.storeUint(0, 10),
        Cn.storeUint(xt.cell.bits.length, 10),
        Cn.storeUint(0, 3),
        Cn.storeUint(xt.cell.refs.length, 3),
        Cn.storeRef(xt.cell);
    else if (xt.type === "builder")
        Cn.storeUint(5, 8),
        Cn.storeRef(xt.cell);
    else if (xt.type === "tuple") {
        let as = null
          , cs = null;
        for (let Cs = 0; Cs < xt.items.length; Cs++) {
            let Ls = as;
            as = cs,
            cs = Ls,
            Cs > 1 && (as = (0,
            Builder_1$7.beginCell)().storeRef(cs).storeRef(as).endCell());
            let Vs = (0,
            Builder_1$7.beginCell)();
            serializeTupleItem(xt.items[Cs], Vs),
            cs = Vs.endCell()
        }
        Cn.storeUint(7, 8),
        Cn.storeUint(xt.items.length, 16),
        as && Cn.storeRef(as),
        cs && Cn.storeRef(cs)
    } else
        throw Error("Invalid value")
}
function parseStackItem(xt) {
    let Cn = xt.loadUint(8);
    if (Cn === 0)
        return {
            type: "null"
        };
    if (Cn === 1)
        return {
            type: "int",
            value: xt.loadIntBig(64)
        };
    if (Cn === 2)
        return xt.loadUint(7) === 0 ? {
            type: "int",
            value: xt.loadIntBig(257)
        } : (xt.loadBit(),
        {
            type: "nan"
        });
    if (Cn === 3)
        return {
            type: "cell",
            cell: xt.loadRef()
        };
    if (Cn === 4) {
        let as = xt.loadUint(10)
          , cs = xt.loadUint(10)
          , Cs = xt.loadUint(3)
          , Ls = xt.loadUint(3)
          , Vs = xt.loadRef().beginParse();
        Vs.skip(as);
        let Ws = Vs.loadBits(cs - as)
          , Xs = (0,
        Builder_1$7.beginCell)().storeBits(Ws);
        if (Cs < Ls) {
            for (let ga = 0; ga < Cs; ga++)
                Vs.loadRef();
            for (let ga = 0; ga < Ls - Cs; ga++)
                Xs.storeRef(Vs.loadRef())
        }
        return {
            type: "slice",
            cell: Xs.endCell()
        }
    } else {
        if (Cn === 5)
            return {
                type: "builder",
                cell: xt.loadRef()
            };
        if (Cn === 7) {
            let as = xt.loadUint(16)
              , cs = [];
            if (as > 1) {
                let Cs = xt.loadRef().beginParse()
                  , Ls = xt.loadRef().beginParse();
                cs.unshift(parseStackItem(Ls));
                for (let Vs = 0; Vs < as - 2; Vs++) {
                    let Ws = Cs;
                    Cs = Ws.loadRef().beginParse(),
                    Ls = Ws.loadRef().beginParse(),
                    cs.unshift(parseStackItem(Ls))
                }
                cs.unshift(parseStackItem(Cs))
            } else
                as === 1 && cs.push(parseStackItem(xt.loadRef().beginParse()));
            return {
                type: "tuple",
                items: cs
            }
        } else
            throw Error("Unsupported stack item")
    }
}
function serializeTupleTail(xt, Cn) {
    if (xt.length > 0) {
        let as = (0,
        Builder_1$7.beginCell)();
        serializeTupleTail(xt.slice(0, xt.length - 1), as),
        Cn.storeRef(as.endCell()),
        serializeTupleItem(xt[xt.length - 1], Cn)
    }
}
function serializeTuple(xt) {
    let Cn = (0,
    Builder_1$7.beginCell)();
    Cn.storeUint(xt.length, 24);
    let as = [...xt];
    return serializeTupleTail(as, Cn),
    Cn.endCell()
}
tuple.serializeTuple = serializeTuple;
function parseTuple(xt) {
    let Cn = []
      , as = xt.beginParse()
      , cs = as.loadUint(24);
    for (let Cs = 0; Cs < cs; Cs++) {
        let Ls = as.loadRef();
        Cn.unshift(parseStackItem(as)),
        as = Ls.beginParse()
    }
    return Cn
}
tuple.parseTuple = parseTuple;
var reader = {};
Object.defineProperty(reader, "__esModule", {
    value: !0
});
reader.TupleReader = void 0;
class TupleReader {
    constructor(Cn) {
        this.items = [...Cn]
    }
    get remaining() {
        return this.items.length
    }
    peek() {
        if (this.items.length === 0)
            throw Error("EOF");
        return this.items[0]
    }
    pop() {
        if (this.items.length === 0)
            throw Error("EOF");
        let Cn = this.items[0];
        return this.items.splice(0, 1),
        Cn
    }
    skip(Cn=1) {
        for (let as = 0; as < Cn; as++)
            this.pop();
        return this
    }
    readBigNumber() {
        let Cn = this.pop();
        if (Cn.type !== "int")
            throw Error("Not a number");
        return Cn.value
    }
    readBigNumberOpt() {
        let Cn = this.pop();
        if (Cn.type === "null")
            return null;
        if (Cn.type !== "int")
            throw Error("Not a number");
        return Cn.value
    }
    readNumber() {
        return Number(this.readBigNumber())
    }
    readNumberOpt() {
        let Cn = this.readBigNumberOpt();
        return Cn !== null ? Number(Cn) : null
    }
    readBoolean() {
        return this.readNumber() !== 0
    }
    readBooleanOpt() {
        let Cn = this.readNumberOpt();
        return Cn !== null ? Cn !== 0 : null
    }
    readAddress() {
        let Cn = this.readCell().beginParse().loadAddress();
        if (Cn !== null)
            return Cn;
        throw Error("Not an address")
    }
    readAddressOpt() {
        let Cn = this.readCellOpt();
        return Cn !== null ? Cn.beginParse().loadMaybeAddress() : null
    }
    readCell() {
        let Cn = this.pop();
        if (Cn.type !== "cell" && Cn.type !== "slice" && Cn.type !== "builder")
            throw Error("Not a cell: " + Cn.type);
        return Cn.cell
    }
    readCellOpt() {
        let Cn = this.pop();
        if (Cn.type === "null")
            return null;
        if (Cn.type !== "cell" && Cn.type !== "slice" && Cn.type !== "builder")
            throw Error("Not a cell");
        return Cn.cell
    }
    readTuple() {
        let Cn = this.pop();
        if (Cn.type !== "tuple")
            throw Error("Not a tuple");
        return new TupleReader(Cn.items)
    }
    readTupleOpt() {
        let Cn = this.pop();
        if (Cn.type === "null")
            return null;
        if (Cn.type !== "tuple")
            throw Error("Not a tuple");
        return new TupleReader(Cn.items)
    }
    static readLispList(Cn) {
        const as = [];
        let cs = Cn;
        for (; cs !== null; ) {
            var Cs = cs.pop();
            if (cs.items.length === 0 || cs.items[0].type !== "tuple" && cs.items[0].type !== "null")
                throw Error("Lisp list consists only from (any, tuple) elements and ends with null");
            cs = cs.readTupleOpt(),
            as.push(Cs)
        }
        return as
    }
    readLispListDirect() {
        return this.items.length === 1 && this.items[0].type === "null" ? [] : TupleReader.readLispList(this)
    }
    readLispList() {
        return TupleReader.readLispList(this.readTupleOpt())
    }
    readBuffer() {
        let Cn = this.readCell().beginParse();
        if (Cn.remainingRefs !== 0 || Cn.remainingBits % 8 !== 0)
            throw Error("Not a buffer");
        return Cn.loadBuffer(Cn.remainingBits / 8)
    }
    readBufferOpt() {
        let Cn = this.readCellOpt();
        if (Cn !== null) {
            let as = Cn.beginParse();
            if (as.remainingRefs !== 0 || as.remainingBits % 8 !== 0)
                throw Error("Not a buffer");
            return as.loadBuffer(as.remainingBits / 8)
        } else
            return null
    }
    readString() {
        return this.readCell().beginParse().loadStringTail()
    }
    readStringOpt() {
        let Cn = this.readCellOpt();
        return Cn !== null ? Cn.beginParse().loadStringTail() : null
    }
}
reader.TupleReader = TupleReader;
var builder = {};
Object.defineProperty(builder, "__esModule", {
    value: !0
});
builder.TupleBuilder = void 0;
const Builder_1$6 = requireBuilder()
  , Cell_1$2 = requireCell()
  , Slice_1 = requireSlice();
class TupleBuilder {
    constructor() {
        this._tuple = []
    }
    writeNumber(Cn) {
        Cn == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "int",
            value: BigInt(Cn)
        })
    }
    writeBoolean(Cn) {
        Cn == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "int",
            value: Cn ? -1n : 0n
        })
    }
    writeBuffer(Cn) {
        Cn == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "slice",
            cell: (0,
            Builder_1$6.beginCell)().storeBuffer(Cn).endCell()
        })
    }
    writeString(Cn) {
        Cn == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "slice",
            cell: (0,
            Builder_1$6.beginCell)().storeStringTail(Cn).endCell()
        })
    }
    writeCell(Cn) {
        Cn == null ? this._tuple.push({
            type: "null"
        }) : Cn instanceof Cell_1$2.Cell ? this._tuple.push({
            type: "cell",
            cell: Cn
        }) : Cn instanceof Slice_1.Slice && this._tuple.push({
            type: "cell",
            cell: Cn.asCell()
        })
    }
    writeSlice(Cn) {
        Cn == null ? this._tuple.push({
            type: "null"
        }) : Cn instanceof Cell_1$2.Cell ? this._tuple.push({
            type: "slice",
            cell: Cn
        }) : Cn instanceof Slice_1.Slice && this._tuple.push({
            type: "slice",
            cell: Cn.asCell()
        })
    }
    writeBuilder(Cn) {
        Cn == null ? this._tuple.push({
            type: "null"
        }) : Cn instanceof Cell_1$2.Cell ? this._tuple.push({
            type: "builder",
            cell: Cn
        }) : Cn instanceof Slice_1.Slice && this._tuple.push({
            type: "builder",
            cell: Cn.asCell()
        })
    }
    writeTuple(Cn) {
        Cn == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "tuple",
            items: Cn
        })
    }
    writeAddress(Cn) {
        Cn == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "slice",
            cell: (0,
            Builder_1$6.beginCell)().storeAddress(Cn).endCell()
        })
    }
    build() {
        return [...this._tuple]
    }
}
builder.TupleBuilder = TupleBuilder;
var _export = {}
  , _helpers = {}
  , convert = {};
Object.defineProperty(convert, "__esModule", {
    value: !0
});
convert.fromNano = convert.toNano = void 0;
function toNano(xt) {
    if (typeof xt == "bigint")
        return xt * 1000000000n;
    {
        if (typeof xt == "number") {
            if (!Number.isFinite(xt))
                throw Error("Invalid number");
            if (Math.log10(xt) <= 6)
                xt = xt.toLocaleString("en", {
                    minimumFractionDigits: 9,
                    useGrouping: !1
                });
            else if (xt - Math.trunc(xt) === 0)
                xt = xt.toLocaleString("en", {
                    maximumFractionDigits: 0,
                    useGrouping: !1
                });
            else
                throw Error("Not enough precision for a number value. Use string value instead")
        }
        let Cn = !1;
        for (; xt.startsWith("-"); )
            Cn = !Cn,
            xt = xt.slice(1);
        if (xt === ".")
            throw Error("Invalid number");
        let as = xt.split(".");
        if (as.length > 2)
            throw Error("Invalid number");
        let cs = as[0]
          , Cs = as[1];
        if (cs || (cs = "0"),
        Cs || (Cs = "0"),
        Cs.length > 9)
            throw Error("Invalid number");
        for (; Cs.length < 9; )
            Cs += "0";
        let Ls = BigInt(cs) * 1000000000n + BigInt(Cs);
        return Cn && (Ls = -Ls),
        Ls
    }
}
convert.toNano = toNano;
function fromNano(xt) {
    let Cn = BigInt(xt)
      , as = !1;
    Cn < 0 && (as = !0,
    Cn = -Cn);
    let Cs = (Cn % 1000000000n).toString();
    for (; Cs.length < 9; )
        Cs = "0" + Cs;
    Cs = Cs.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    let Ws = `${(Cn / 1000000000n).toString()}${Cs === "0" ? "" : `.${Cs}`}`;
    return as && (Ws = "-" + Ws),
    Ws
}
convert.fromNano = fromNano;
Object.defineProperty(_helpers, "__esModule", {
    value: !0
});
_helpers.comment = _helpers.external = _helpers.internal = void 0;
const Address_1$1 = Address$1
  , Cell_1$1 = requireCell()
  , Builder_1$5 = requireBuilder()
  , convert_1 = convert;
function internal(xt) {
    let Cn = !0;
    xt.bounce !== null && xt.bounce !== void 0 && (Cn = xt.bounce);
    let as;
    if (typeof xt.to == "string")
        as = Address_1$1.Address.parse(xt.to);
    else if (Address_1$1.Address.isAddress(xt.to))
        as = xt.to;
    else
        throw new Error(`Invalid address ${xt.to}`);
    let cs;
    typeof xt.value == "string" ? cs = (0,
    convert_1.toNano)(xt.value) : cs = xt.value;
    let Cs = Cell_1$1.Cell.EMPTY;
    return typeof xt.body == "string" ? Cs = (0,
    Builder_1$5.beginCell)().storeUint(0, 32).storeStringTail(xt.body).endCell() : xt.body && (Cs = xt.body),
    {
        info: {
            type: "internal",
            dest: as,
            value: {
                coins: cs
            },
            bounce: Cn,
            ihrDisabled: !0,
            bounced: !1,
            ihrFee: 0n,
            forwardFee: 0n,
            createdAt: 0,
            createdLt: 0n
        },
        init: xt.init ?? void 0,
        body: Cs
    }
}
_helpers.internal = internal;
function external(xt) {
    let Cn;
    if (typeof xt.to == "string")
        Cn = Address_1$1.Address.parse(xt.to);
    else if (Address_1$1.Address.isAddress(xt.to))
        Cn = xt.to;
    else
        throw new Error(`Invalid address ${xt.to}`);
    return {
        info: {
            type: "external-in",
            dest: Cn,
            importFee: 0n
        },
        init: xt.init ?? void 0,
        body: xt.body || Cell_1$1.Cell.EMPTY
    }
}
_helpers.external = external;
function comment(xt) {
    return (0,
    Builder_1$5.beginCell)().storeUint(0, 32).storeStringTail(xt).endCell()
}
_helpers.comment = comment;
var Account = {}
  , AccountStorage = {}
  , AccountState = {};
Object.defineProperty(AccountState, "__esModule", {
    value: !0
});
AccountState.storeAccountState = AccountState.loadAccountState = void 0;
const StateInit_1$2 = StateInit;
function loadAccountState(xt) {
    return xt.loadBit() ? {
        type: "active",
        state: (0,
        StateInit_1$2.loadStateInit)(xt)
    } : xt.loadBit() ? {
        type: "frozen",
        stateHash: xt.loadUintBig(256)
    } : {
        type: "uninit"
    }
}
AccountState.loadAccountState = loadAccountState;
function storeAccountState(xt) {
    return Cn => {
        xt.type === "active" ? (Cn.storeBit(!0),
        Cn.store((0,
        StateInit_1$2.storeStateInit)(xt.state))) : xt.type === "frozen" ? (Cn.storeBit(!1),
        Cn.storeBit(!0),
        Cn.storeUint(xt.stateHash, 256)) : xt.type === "uninit" && (Cn.storeBit(!1),
        Cn.storeBit(!1))
    }
}
AccountState.storeAccountState = storeAccountState;
var CurrencyCollection = {};
Object.defineProperty(CurrencyCollection, "__esModule", {
    value: !0
});
CurrencyCollection.storeCurrencyCollection = CurrencyCollection.loadCurrencyCollection = void 0;
const Dictionary_1$1 = requireDictionary();
function loadCurrencyCollection(xt) {
    const Cn = xt.loadCoins()
      , as = xt.loadDict(Dictionary_1$1.Dictionary.Keys.Uint(32), Dictionary_1$1.Dictionary.Values.BigVarUint(5));
    return as.size === 0 ? {
        coins: Cn
    } : {
        other: as,
        coins: Cn
    }
}
CurrencyCollection.loadCurrencyCollection = loadCurrencyCollection;
function storeCurrencyCollection(xt) {
    return Cn => {
        Cn.storeCoins(xt.coins),
        xt.other ? Cn.storeDict(xt.other) : Cn.storeBit(0)
    }
}
CurrencyCollection.storeCurrencyCollection = storeCurrencyCollection;
Object.defineProperty(AccountStorage, "__esModule", {
    value: !0
});
AccountStorage.storeAccountStorage = AccountStorage.loadAccountStorage = void 0;
const AccountState_1 = AccountState
  , CurrencyCollection_1$6 = CurrencyCollection;
function loadAccountStorage(xt) {
    return {
        lastTransLt: xt.loadUintBig(64),
        balance: (0,
        CurrencyCollection_1$6.loadCurrencyCollection)(xt),
        state: (0,
        AccountState_1.loadAccountState)(xt)
    }
}
AccountStorage.loadAccountStorage = loadAccountStorage;
function storeAccountStorage(xt) {
    return Cn => {
        Cn.storeUint(xt.lastTransLt, 64),
        Cn.store((0,
        CurrencyCollection_1$6.storeCurrencyCollection)(xt.balance)),
        Cn.store((0,
        AccountState_1.storeAccountState)(xt.state))
    }
}
AccountStorage.storeAccountStorage = storeAccountStorage;
var StorageInto = {}
  , StorageUsed = {};
Object.defineProperty(StorageUsed, "__esModule", {
    value: !0
});
StorageUsed.storeStorageUsed = StorageUsed.loadStorageUsed = void 0;
function loadStorageUsed(xt) {
    return {
        cells: xt.loadVarUintBig(3),
        bits: xt.loadVarUintBig(3),
        publicCells: xt.loadVarUintBig(3)
    }
}
StorageUsed.loadStorageUsed = loadStorageUsed;
function storeStorageUsed(xt) {
    return Cn => {
        Cn.storeVarUint(xt.cells, 3),
        Cn.storeVarUint(xt.bits, 3),
        Cn.storeVarUint(xt.publicCells, 3)
    }
}
StorageUsed.storeStorageUsed = storeStorageUsed;
Object.defineProperty(StorageInto, "__esModule", {
    value: !0
});
StorageInto.storeStorageInfo = StorageInto.loadStorageInfo = void 0;
const StorageUsed_1 = StorageUsed;
function loadStorageInfo(xt) {
    return {
        used: (0,
        StorageUsed_1.loadStorageUsed)(xt),
        lastPaid: xt.loadUint(32),
        duePayment: xt.loadMaybeCoins()
    }
}
StorageInto.loadStorageInfo = loadStorageInfo;
function storeStorageInfo(xt) {
    return Cn => {
        Cn.store((0,
        StorageUsed_1.storeStorageUsed)(xt.used)),
        Cn.storeUint(xt.lastPaid, 32),
        Cn.storeMaybeCoins(xt.duePayment)
    }
}
StorageInto.storeStorageInfo = storeStorageInfo;
Object.defineProperty(Account, "__esModule", {
    value: !0
});
Account.storeAccount = Account.loadAccount = void 0;
const AccountStorage_1 = AccountStorage
  , StorageInto_1 = StorageInto;
function loadAccount(xt) {
    return {
        addr: xt.loadAddress(),
        storageStats: (0,
        StorageInto_1.loadStorageInfo)(xt),
        storage: (0,
        AccountStorage_1.loadAccountStorage)(xt)
    }
}
Account.loadAccount = loadAccount;
function storeAccount(xt) {
    return Cn => {
        Cn.storeAddress(xt.addr),
        Cn.store((0,
        StorageInto_1.storeStorageInfo)(xt.storageStats)),
        Cn.store((0,
        AccountStorage_1.storeAccountStorage)(xt.storage))
    }
}
Account.storeAccount = storeAccount;
var AccountStatus = {};
Object.defineProperty(AccountStatus, "__esModule", {
    value: !0
});
AccountStatus.storeAccountStatus = AccountStatus.loadAccountStatus = void 0;
function loadAccountStatus(xt) {
    const Cn = xt.loadUint(2);
    if (Cn === 0)
        return "uninitialized";
    if (Cn === 1)
        return "frozen";
    if (Cn === 2)
        return "active";
    if (Cn === 3)
        return "non-existing";
    throw Error("Invalid data")
}
AccountStatus.loadAccountStatus = loadAccountStatus;
function storeAccountStatus(xt) {
    return Cn => {
        if (xt === "uninitialized")
            Cn.storeUint(0, 2);
        else if (xt === "frozen")
            Cn.storeUint(1, 2);
        else if (xt === "active")
            Cn.storeUint(2, 2);
        else if (xt === "non-existing")
            Cn.storeUint(3, 2);
        else
            throw Error("Invalid data");
        return Cn
    }
}
AccountStatus.storeAccountStatus = storeAccountStatus;
var AccountStatusChange = {};
Object.defineProperty(AccountStatusChange, "__esModule", {
    value: !0
});
AccountStatusChange.storeAccountStatusChange = AccountStatusChange.loadAccountStatusChange = void 0;
function loadAccountStatusChange(xt) {
    return xt.loadBit() ? xt.loadBit() ? "deleted" : "frozen" : "unchanged"
}
AccountStatusChange.loadAccountStatusChange = loadAccountStatusChange;
function storeAccountStatusChange(xt) {
    return Cn => {
        if (xt == "unchanged")
            Cn.storeBit(0);
        else if (xt === "frozen")
            Cn.storeBit(1),
            Cn.storeBit(0);
        else if (xt === "deleted")
            Cn.storeBit(1),
            Cn.storeBit(1);
        else
            throw Error("Invalid account status change")
    }
}
AccountStatusChange.storeAccountStatusChange = storeAccountStatusChange;
var OutList = {}
  , MessageRelaxed = {}
  , CommonMessageInfoRelaxed = {};
Object.defineProperty(CommonMessageInfoRelaxed, "__esModule", {
    value: !0
});
CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = void 0;
const CurrencyCollection_1$5 = CurrencyCollection;
function loadCommonMessageInfoRelaxed(xt) {
    if (!xt.loadBit()) {
        const Ls = xt.loadBit()
          , Vs = xt.loadBit()
          , Ws = xt.loadBit()
          , Xs = xt.loadMaybeAddress()
          , ga = xt.loadAddress()
          , ba = (0,
        CurrencyCollection_1$5.loadCurrencyCollection)(xt)
          , yl = xt.loadCoins()
          , xl = xt.loadCoins()
          , wl = xt.loadUintBig(64)
          , _l = xt.loadUint(32);
        return {
            type: "internal",
            ihrDisabled: Ls,
            bounce: Vs,
            bounced: Ws,
            src: Xs,
            dest: ga,
            value: ba,
            ihrFee: yl,
            forwardFee: xl,
            createdLt: wl,
            createdAt: _l
        }
    }
    if (!xt.loadBit())
        throw Error("External In message is not possible for CommonMessageInfoRelaxed");
    const Cn = xt.loadMaybeAddress()
      , as = xt.loadMaybeExternalAddress()
      , cs = xt.loadUintBig(64)
      , Cs = xt.loadUint(32);
    return {
        type: "external-out",
        src: Cn,
        dest: as,
        createdLt: cs,
        createdAt: Cs
    }
}
CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = loadCommonMessageInfoRelaxed;
function storeCommonMessageInfoRelaxed(xt) {
    return Cn => {
        if (xt.type === "internal")
            Cn.storeBit(0),
            Cn.storeBit(xt.ihrDisabled),
            Cn.storeBit(xt.bounce),
            Cn.storeBit(xt.bounced),
            Cn.storeAddress(xt.src),
            Cn.storeAddress(xt.dest),
            Cn.store((0,
            CurrencyCollection_1$5.storeCurrencyCollection)(xt.value)),
            Cn.storeCoins(xt.ihrFee),
            Cn.storeCoins(xt.forwardFee),
            Cn.storeUint(xt.createdLt, 64),
            Cn.storeUint(xt.createdAt, 32);
        else if (xt.type === "external-out")
            Cn.storeBit(1),
            Cn.storeBit(1),
            Cn.storeAddress(xt.src),
            Cn.storeAddress(xt.dest),
            Cn.storeUint(xt.createdLt, 64),
            Cn.storeUint(xt.createdAt, 32);
        else
            throw new Error("Unknown CommonMessageInfo type")
    }
}
CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = storeCommonMessageInfoRelaxed;
Object.defineProperty(MessageRelaxed, "__esModule", {
    value: !0
});
MessageRelaxed.storeMessageRelaxed = MessageRelaxed.loadMessageRelaxed = void 0;
const Builder_1$4 = requireBuilder()
  , CommonMessageInfoRelaxed_1 = CommonMessageInfoRelaxed
  , StateInit_1$1 = StateInit;
function loadMessageRelaxed(xt) {
    const Cn = (0,
    CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed)(xt);
    let as = null;
    xt.loadBit() && (xt.loadBit() ? as = (0,
    StateInit_1$1.loadStateInit)(xt.loadRef().beginParse()) : as = (0,
    StateInit_1$1.loadStateInit)(xt));
    const cs = xt.loadBit() ? xt.loadRef() : xt.asCell();
    return {
        info: Cn,
        init: as,
        body: cs
    }
}
MessageRelaxed.loadMessageRelaxed = loadMessageRelaxed;
function storeMessageRelaxed(xt, Cn) {
    return as => {
        if (as.store((0,
        CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed)(xt.info)),
        xt.init) {
            as.storeBit(!0);
            let Cs = (0,
            Builder_1$4.beginCell)().store((0,
            StateInit_1$1.storeStateInit)(xt.init))
              , Ls = !1;
            Cn && Cn.forceRef ? Ls = !0 : as.availableBits - 2 >= Cs.bits ? Ls = !1 : Ls = !0,
            Ls ? (as.storeBit(!0),
            as.storeRef(Cs)) : (as.storeBit(!1),
            as.storeBuilder(Cs))
        } else
            as.storeBit(!1);
        let cs = !1;
        Cn && Cn.forceRef ? cs = !0 : as.availableBits - 1 >= xt.body.bits.length && as.refs + xt.body.refs.length <= 4 && !xt.body.isExotic ? cs = !1 : cs = !0,
        cs ? (as.storeBit(!0),
        as.storeRef(xt.body)) : (as.storeBit(!1),
        as.storeBuilder(xt.body.asBuilder()))
    }
}
MessageRelaxed.storeMessageRelaxed = storeMessageRelaxed;
var LibRef = {};
Object.defineProperty(LibRef, "__esModule", {
    value: !0
});
LibRef.storeLibRef = LibRef.loadLibRef = void 0;
function loadLibRef(xt) {
    return xt.loadUint(1) === 0 ? {
        type: "hash",
        libHash: xt.loadBuffer(32)
    } : {
        type: "ref",
        library: xt.loadRef()
    }
}
LibRef.loadLibRef = loadLibRef;
function storeLibRef(xt) {
    return Cn => {
        xt.type === "hash" ? (Cn.storeUint(0, 1),
        Cn.storeBuffer(xt.libHash)) : (Cn.storeUint(1, 1),
        Cn.storeRef(xt.library))
    }
}
LibRef.storeLibRef = storeLibRef;
Object.defineProperty(OutList, "__esModule", {
    value: !0
});
OutList.loadOutList = OutList.storeOutList = OutList.loadOutAction = OutList.storeOutAction = void 0;
const MessageRelaxed_1 = MessageRelaxed
  , Builder_1$3 = requireBuilder()
  , CurrencyCollection_1$4 = CurrencyCollection
  , LibRef_1 = LibRef;
function storeOutAction(xt) {
    switch (xt.type) {
    case "sendMsg":
        return storeOutActionSendMsg(xt);
    case "setCode":
        return storeOutActionSetCode(xt);
    case "reserve":
        return storeOutActionReserve(xt);
    case "changeLibrary":
        return storeOutActionChangeLibrary(xt);
    default:
        throw new Error(`Unknown action type ${xt.type}`)
    }
}
OutList.storeOutAction = storeOutAction;
const outActionSendMsgTag = 247711853;
function storeOutActionSendMsg(xt) {
    return Cn => {
        Cn.storeUint(outActionSendMsgTag, 32).storeUint(xt.mode, 8).storeRef((0,
        Builder_1$3.beginCell)().store((0,
        MessageRelaxed_1.storeMessageRelaxed)(xt.outMsg)).endCell())
    }
}
const outActionSetCodeTag = 2907562126;
function storeOutActionSetCode(xt) {
    return Cn => {
        Cn.storeUint(outActionSetCodeTag, 32).storeRef(xt.newCode)
    }
}
const outActionReserveTag = 921090057;
function storeOutActionReserve(xt) {
    return Cn => {
        Cn.storeUint(outActionReserveTag, 32).storeUint(xt.mode, 8).store((0,
        CurrencyCollection_1$4.storeCurrencyCollection)(xt.currency))
    }
}
const outActionChangeLibraryTag = 653925844;
function storeOutActionChangeLibrary(xt) {
    return Cn => {
        Cn.storeUint(outActionChangeLibraryTag, 32).storeUint(xt.mode, 7).store((0,
        LibRef_1.storeLibRef)(xt.libRef))
    }
}
function loadOutAction(xt) {
    const Cn = xt.loadUint(32);
    if (Cn === outActionSendMsgTag) {
        const as = xt.loadUint(8)
          , cs = (0,
        MessageRelaxed_1.loadMessageRelaxed)(xt.loadRef().beginParse());
        return {
            type: "sendMsg",
            mode: as,
            outMsg: cs
        }
    }
    if (Cn === outActionSetCodeTag)
        return {
            type: "setCode",
            newCode: xt.loadRef()
        };
    if (Cn === outActionReserveTag) {
        const as = xt.loadUint(8)
          , cs = (0,
        CurrencyCollection_1$4.loadCurrencyCollection)(xt);
        return {
            type: "reserve",
            mode: as,
            currency: cs
        }
    }
    if (Cn === outActionChangeLibraryTag) {
        const as = xt.loadUint(7)
          , cs = (0,
        LibRef_1.loadLibRef)(xt);
        return {
            type: "changeLibrary",
            mode: as,
            libRef: cs
        }
    }
    throw new Error(`Unknown out action tag 0x${Cn.toString(16)}`)
}
OutList.loadOutAction = loadOutAction;
function storeOutList(xt) {
    const Cn = xt.reduce( (as, cs) => (0,
    Builder_1$3.beginCell)().storeRef(as).store(storeOutAction(cs)).endCell(), (0,
    Builder_1$3.beginCell)().endCell());
    return as => {
        as.storeSlice(Cn.beginParse())
    }
}
OutList.storeOutList = storeOutList;
function loadOutList(xt) {
    const Cn = [];
    for (; xt.remainingRefs; ) {
        const as = xt.loadRef();
        Cn.push(loadOutAction(xt)),
        xt = as.beginParse()
    }
    return Cn.reverse()
}
OutList.loadOutList = loadOutList;
var CommonMessageInfo = {};
Object.defineProperty(CommonMessageInfo, "__esModule", {
    value: !0
});
CommonMessageInfo.storeCommonMessageInfo = CommonMessageInfo.loadCommonMessageInfo = void 0;
const CurrencyCollection_1$3 = CurrencyCollection;
function loadCommonMessageInfo(xt) {
    if (!xt.loadBit()) {
        const Ls = xt.loadBit()
          , Vs = xt.loadBit()
          , Ws = xt.loadBit()
          , Xs = xt.loadAddress()
          , ga = xt.loadAddress()
          , ba = (0,
        CurrencyCollection_1$3.loadCurrencyCollection)(xt)
          , yl = xt.loadCoins()
          , xl = xt.loadCoins()
          , wl = xt.loadUintBig(64)
          , _l = xt.loadUint(32);
        return {
            type: "internal",
            ihrDisabled: Ls,
            bounce: Vs,
            bounced: Ws,
            src: Xs,
            dest: ga,
            value: ba,
            ihrFee: yl,
            forwardFee: xl,
            createdLt: wl,
            createdAt: _l
        }
    }
    if (!xt.loadBit()) {
        const Ls = xt.loadMaybeExternalAddress()
          , Vs = xt.loadAddress()
          , Ws = xt.loadCoins();
        return {
            type: "external-in",
            src: Ls,
            dest: Vs,
            importFee: Ws
        }
    }
    const Cn = xt.loadAddress()
      , as = xt.loadMaybeExternalAddress()
      , cs = xt.loadUintBig(64)
      , Cs = xt.loadUint(32);
    return {
        type: "external-out",
        src: Cn,
        dest: as,
        createdLt: cs,
        createdAt: Cs
    }
}
CommonMessageInfo.loadCommonMessageInfo = loadCommonMessageInfo;
function storeCommonMessageInfo(xt) {
    return Cn => {
        if (xt.type === "internal")
            Cn.storeBit(0),
            Cn.storeBit(xt.ihrDisabled),
            Cn.storeBit(xt.bounce),
            Cn.storeBit(xt.bounced),
            Cn.storeAddress(xt.src),
            Cn.storeAddress(xt.dest),
            Cn.store((0,
            CurrencyCollection_1$3.storeCurrencyCollection)(xt.value)),
            Cn.storeCoins(xt.ihrFee),
            Cn.storeCoins(xt.forwardFee),
            Cn.storeUint(xt.createdLt, 64),
            Cn.storeUint(xt.createdAt, 32);
        else if (xt.type === "external-in")
            Cn.storeBit(1),
            Cn.storeBit(0),
            Cn.storeAddress(xt.src),
            Cn.storeAddress(xt.dest),
            Cn.storeCoins(xt.importFee);
        else if (xt.type === "external-out")
            Cn.storeBit(1),
            Cn.storeBit(1),
            Cn.storeAddress(xt.src),
            Cn.storeAddress(xt.dest),
            Cn.storeUint(xt.createdLt, 64),
            Cn.storeUint(xt.createdAt, 32);
        else
            throw new Error("Unknown CommonMessageInfo type")
    }
}
CommonMessageInfo.storeCommonMessageInfo = storeCommonMessageInfo;
var ComputeSkipReason = {};
Object.defineProperty(ComputeSkipReason, "__esModule", {
    value: !0
});
ComputeSkipReason.storeComputeSkipReason = ComputeSkipReason.loadComputeSkipReason = void 0;
function loadComputeSkipReason(xt) {
    let Cn = xt.loadUint(2);
    if (Cn === 0)
        return "no-state";
    if (Cn === 1)
        return "bad-state";
    if (Cn === 2)
        return "no-gas";
    throw new Error(`Unknown ComputeSkipReason: ${Cn}`)
}
ComputeSkipReason.loadComputeSkipReason = loadComputeSkipReason;
function storeComputeSkipReason(xt) {
    return Cn => {
        if (xt === "no-state")
            Cn.storeUint(0, 2);
        else if (xt === "bad-state")
            Cn.storeUint(1, 2);
        else if (xt === "no-gas")
            Cn.storeUint(2, 2);
        else
            throw new Error(`Unknown ComputeSkipReason: ${xt}`)
    }
}
ComputeSkipReason.storeComputeSkipReason = storeComputeSkipReason;
var DepthBalanceInfo = {};
Object.defineProperty(DepthBalanceInfo, "__esModule", {
    value: !0
});
DepthBalanceInfo.storeDepthBalanceInfo = DepthBalanceInfo.loadDepthBalanceInfo = void 0;
const CurrencyCollection_1$2 = CurrencyCollection;
function loadDepthBalanceInfo(xt) {
    return {
        splitDepth: xt.loadUint(5),
        balance: (0,
        CurrencyCollection_1$2.loadCurrencyCollection)(xt)
    }
}
DepthBalanceInfo.loadDepthBalanceInfo = loadDepthBalanceInfo;
function storeDepthBalanceInfo(xt) {
    return Cn => {
        Cn.storeUint(xt.splitDepth, 5),
        Cn.store((0,
        CurrencyCollection_1$2.storeCurrencyCollection)(xt.balance))
    }
}
DepthBalanceInfo.storeDepthBalanceInfo = storeDepthBalanceInfo;
var HashUpdate = {};
Object.defineProperty(HashUpdate, "__esModule", {
    value: !0
});
HashUpdate.storeHashUpdate = HashUpdate.loadHashUpdate = void 0;
function loadHashUpdate(xt) {
    if (xt.loadUint(8) !== 114)
        throw Error("Invalid data");
    const Cn = xt.loadBuffer(32)
      , as = xt.loadBuffer(32);
    return {
        oldHash: Cn,
        newHash: as
    }
}
HashUpdate.loadHashUpdate = loadHashUpdate;
function storeHashUpdate(xt) {
    return Cn => {
        Cn.storeUint(114, 8),
        Cn.storeBuffer(xt.oldHash),
        Cn.storeBuffer(xt.newHash)
    }
}
HashUpdate.storeHashUpdate = storeHashUpdate;
var MasterchainStateExtra = {};
Object.defineProperty(MasterchainStateExtra, "__esModule", {
    value: !0
});
MasterchainStateExtra.loadMasterchainStateExtra = void 0;
const Dictionary_1 = requireDictionary()
  , CurrencyCollection_1$1 = CurrencyCollection;
function loadMasterchainStateExtra(xt) {
    if (xt.loadUint(16) !== 52262)
        throw Error("Invalid data");
    xt.loadBit() && xt.loadRef();
    let Cn = xt.loadUintBig(256)
      , as = Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.Int(32), Dictionary_1.Dictionary.Values.Cell(), xt);
    const cs = (0,
    CurrencyCollection_1$1.loadCurrencyCollection)(xt);
    return {
        config: as,
        configAddress: Cn,
        globalBalance: cs
    }
}
MasterchainStateExtra.loadMasterchainStateExtra = loadMasterchainStateExtra;
var Message = {};
Object.defineProperty(Message, "__esModule", {
    value: !0
});
Message.MessageValue = Message.storeMessage = Message.loadMessage = void 0;
const Builder_1$2 = requireBuilder()
  , CommonMessageInfo_1 = CommonMessageInfo
  , StateInit_1 = StateInit;
function loadMessage(xt) {
    const Cn = (0,
    CommonMessageInfo_1.loadCommonMessageInfo)(xt);
    let as = null;
    xt.loadBit() && (xt.loadBit() ? as = (0,
    StateInit_1.loadStateInit)(xt.loadRef().beginParse()) : as = (0,
    StateInit_1.loadStateInit)(xt));
    const cs = xt.loadBit() ? xt.loadRef() : xt.asCell();
    return {
        info: Cn,
        init: as,
        body: cs
    }
}
Message.loadMessage = loadMessage;
function storeMessage(xt, Cn) {
    return as => {
        if (as.store((0,
        CommonMessageInfo_1.storeCommonMessageInfo)(xt.info)),
        xt.init) {
            as.storeBit(!0);
            let Cs = (0,
            Builder_1$2.beginCell)().store((0,
            StateInit_1.storeStateInit)(xt.init))
              , Ls = !1;
            Cn && Cn.forceRef ? Ls = !0 : Ls = as.availableBits - 2 < Cs.bits + xt.body.bits.length,
            Ls ? (as.storeBit(!0),
            as.storeRef(Cs)) : (as.storeBit(!1),
            as.storeBuilder(Cs))
        } else
            as.storeBit(!1);
        let cs = !1;
        Cn && Cn.forceRef ? cs = !0 : cs = as.availableBits - 1 < xt.body.bits.length || as.refs + xt.body.refs.length > 4,
        cs ? (as.storeBit(!0),
        as.storeRef(xt.body)) : (as.storeBit(!1),
        as.storeBuilder(xt.body.asBuilder()))
    }
}
Message.storeMessage = storeMessage;
Message.MessageValue = {
    serialize(xt, Cn) {
        Cn.storeRef((0,
        Builder_1$2.beginCell)().store(storeMessage(xt)))
    },
    parse(xt) {
        return loadMessage(xt.loadRef().beginParse())
    }
};
var SendMode$1 = {};
Object.defineProperty(SendMode$1, "__esModule", {
    value: !0
});
SendMode$1.SendMode = void 0;
var SendMode;
(function(xt) {
    xt[xt.CARRY_ALL_REMAINING_BALANCE = 128] = "CARRY_ALL_REMAINING_BALANCE",
    xt[xt.CARRY_ALL_REMAINING_INCOMING_VALUE = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE",
    xt[xt.DESTROY_ACCOUNT_IF_ZERO = 32] = "DESTROY_ACCOUNT_IF_ZERO",
    xt[xt.PAY_GAS_SEPARATELY = 1] = "PAY_GAS_SEPARATELY",
    xt[xt.IGNORE_ERRORS = 2] = "IGNORE_ERRORS",
    xt[xt.NONE = 0] = "NONE"
}
)(SendMode || (SendMode$1.SendMode = SendMode = {}));
var ReserveMode$1 = {};
Object.defineProperty(ReserveMode$1, "__esModule", {
    value: !0
});
ReserveMode$1.ReserveMode = void 0;
var ReserveMode;
(function(xt) {
    xt[xt.THIS_AMOUNT = 0] = "THIS_AMOUNT",
    xt[xt.LEAVE_THIS_AMOUNT = 1] = "LEAVE_THIS_AMOUNT",
    xt[xt.AT_MOST_THIS_AMOUNT = 2] = "AT_MOST_THIS_AMOUNT",
    xt[xt.LEAVE_MAX_THIS_AMOUNT = 3] = "LEAVE_MAX_THIS_AMOUNT",
    xt[xt.BEFORE_BALANCE_PLUS_THIS_AMOUNT = 4] = "BEFORE_BALANCE_PLUS_THIS_AMOUNT",
    xt[xt.LEAVE_BBALANCE_PLUS_THIS_AMOUNT = 5] = "LEAVE_BBALANCE_PLUS_THIS_AMOUNT",
    xt[xt.BEFORE_BALANCE_MINUS_THIS_AMOUNT = 12] = "BEFORE_BALANCE_MINUS_THIS_AMOUNT",
    xt[xt.LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT = 13] = "LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT"
}
)(ReserveMode || (ReserveMode$1.ReserveMode = ReserveMode = {}));
var ShardAccount = {};
Object.defineProperty(ShardAccount, "__esModule", {
    value: !0
});
ShardAccount.storeShardAccount = ShardAccount.loadShardAccount = void 0;
const Builder_1$1 = requireBuilder()
  , Account_1 = Account;
function loadShardAccount(xt) {
    let Cn = xt.loadRef(), as;
    if (!Cn.isExotic) {
        let cs = Cn.beginParse();
        cs.loadBit() && (as = (0,
        Account_1.loadAccount)(cs))
    }
    return {
        account: as,
        lastTransactionHash: xt.loadUintBig(256),
        lastTransactionLt: xt.loadUintBig(64)
    }
}
ShardAccount.loadShardAccount = loadShardAccount;
function storeShardAccount(xt) {
    return Cn => {
        xt.account ? Cn.storeRef((0,
        Builder_1$1.beginCell)().storeBit(!0).store((0,
        Account_1.storeAccount)(xt.account))) : Cn.storeRef((0,
        Builder_1$1.beginCell)().storeBit(!1)),
        Cn.storeUint(xt.lastTransactionHash, 256),
        Cn.storeUint(xt.lastTransactionLt, 64)
    }
}
ShardAccount.storeShardAccount = storeShardAccount;
var ShardAccounts = {};
(function(xt) {
    Object.defineProperty(xt, "__esModule", {
        value: !0
    }),
    xt.storeShardAccounts = xt.loadShardAccounts = xt.ShardAccountRefValue = void 0;
    const Cn = requireDictionary()
      , as = DepthBalanceInfo
      , cs = ShardAccount;
    xt.ShardAccountRefValue = {
        parse: Vs => {
            let Ws = (0,
            as.loadDepthBalanceInfo)(Vs)
              , Xs = (0,
            cs.loadShardAccount)(Vs);
            return {
                depthBalanceInfo: Ws,
                shardAccount: Xs
            }
        }
        ,
        serialize(Vs, Ws) {
            Ws.store((0,
            as.storeDepthBalanceInfo)(Vs.depthBalanceInfo)),
            Ws.store((0,
            cs.storeShardAccount)(Vs.shardAccount))
        }
    };
    function Cs(Vs) {
        return Cn.Dictionary.load(Cn.Dictionary.Keys.BigUint(256), xt.ShardAccountRefValue, Vs)
    }
    xt.loadShardAccounts = Cs;
    function Ls(Vs) {
        return Ws => {
            Ws.storeDict(Vs)
        }
    }
    xt.storeShardAccounts = Ls
}
)(ShardAccounts);
var ShardIdent = {};
Object.defineProperty(ShardIdent, "__esModule", {
    value: !0
});
ShardIdent.storeShardIdent = ShardIdent.loadShardIdent = void 0;
function loadShardIdent(xt) {
    if (xt.loadUint(2) !== 0)
        throw Error("Invalid data");
    return {
        shardPrefixBits: xt.loadUint(6),
        workchainId: xt.loadInt(32),
        shardPrefix: xt.loadUintBig(64)
    }
}
ShardIdent.loadShardIdent = loadShardIdent;
function storeShardIdent(xt) {
    return Cn => {
        Cn.storeUint(0, 2),
        Cn.storeUint(xt.shardPrefixBits, 6),
        Cn.storeInt(xt.workchainId, 32),
        Cn.storeUint(xt.shardPrefix, 64)
    }
}
ShardIdent.storeShardIdent = storeShardIdent;
var ShardStateUnsplit = {};
Object.defineProperty(ShardStateUnsplit, "__esModule", {
    value: !0
});
ShardStateUnsplit.loadShardStateUnsplit = void 0;
const MasterchainStateExtra_1 = MasterchainStateExtra
  , ShardAccounts_1 = ShardAccounts
  , ShardIdent_1 = ShardIdent;
function loadShardStateUnsplit(xt) {
    if (xt.loadUint(32) !== 2418257890)
        throw Error("Invalid data");
    let Cn = xt.loadInt(32)
      , as = (0,
    ShardIdent_1.loadShardIdent)(xt)
      , cs = xt.loadUint(32)
      , Cs = xt.loadUint(32)
      , Ls = xt.loadUint(32)
      , Vs = xt.loadUintBig(64)
      , Ws = xt.loadUint(32);
    xt.loadRef();
    let Xs = xt.loadBit(), ga = xt.loadRef(), ba;
    ga.isExotic || (ba = (0,
    ShardAccounts_1.loadShardAccounts)(ga.beginParse())),
    xt.loadRef();
    let yl = xt.loadBit()
      , xl = null;
    if (yl) {
        let wl = xt.loadRef();
        wl.isExotic || (xl = (0,
        MasterchainStateExtra_1.loadMasterchainStateExtra)(wl.beginParse()))
    }
    return {
        globalId: Cn,
        shardId: as,
        seqno: cs,
        vertSeqNo: Cs,
        genUtime: Ls,
        genLt: Vs,
        minRefMcSeqno: Ws,
        beforeSplit: Xs,
        accounts: ba,
        extras: xl
    }
}
ShardStateUnsplit.loadShardStateUnsplit = loadShardStateUnsplit;
var SplitMergeInfo = {};
Object.defineProperty(SplitMergeInfo, "__esModule", {
    value: !0
});
SplitMergeInfo.storeSplitMergeInfo = SplitMergeInfo.loadSplitMergeInfo = void 0;
function loadSplitMergeInfo(xt) {
    let Cn = xt.loadUint(6)
      , as = xt.loadUint(6)
      , cs = xt.loadUintBig(256)
      , Cs = xt.loadUintBig(256);
    return {
        currentShardPrefixLength: Cn,
        accountSplitDepth: as,
        thisAddress: cs,
        siblingAddress: Cs
    }
}
SplitMergeInfo.loadSplitMergeInfo = loadSplitMergeInfo;
function storeSplitMergeInfo(xt) {
    return Cn => {
        Cn.storeUint(xt.currentShardPrefixLength, 6),
        Cn.storeUint(xt.accountSplitDepth, 6),
        Cn.storeUint(xt.thisAddress, 256),
        Cn.storeUint(xt.siblingAddress, 256)
    }
}
SplitMergeInfo.storeSplitMergeInfo = storeSplitMergeInfo;
var StorageUsedShort = {};
Object.defineProperty(StorageUsedShort, "__esModule", {
    value: !0
});
StorageUsedShort.storeStorageUsedShort = StorageUsedShort.loadStorageUsedShort = void 0;
function loadStorageUsedShort(xt) {
    let Cn = xt.loadVarUintBig(3)
      , as = xt.loadVarUintBig(3);
    return {
        cells: Cn,
        bits: as
    }
}
StorageUsedShort.loadStorageUsedShort = loadStorageUsedShort;
function storeStorageUsedShort(xt) {
    return Cn => {
        Cn.storeVarUint(xt.cells, 3),
        Cn.storeVarUint(xt.bits, 3)
    }
}
StorageUsedShort.storeStorageUsedShort = storeStorageUsedShort;
var Transaction = {}
  , TransactionDescription = {}
  , TransactionActionPhase = {};
Object.defineProperty(TransactionActionPhase, "__esModule", {
    value: !0
});
TransactionActionPhase.storeTransactionActionPhase = TransactionActionPhase.loadTransactionActionPhase = void 0;
const AccountStatusChange_1$1 = AccountStatusChange
  , StorageUsedShort_1$1 = StorageUsedShort;
function loadTransactionActionPhase(xt) {
    let Cn = xt.loadBit()
      , as = xt.loadBit()
      , cs = xt.loadBit()
      , Cs = (0,
    AccountStatusChange_1$1.loadAccountStatusChange)(xt)
      , Ls = xt.loadBit() ? xt.loadCoins() : void 0
      , Vs = xt.loadBit() ? xt.loadCoins() : void 0
      , Ws = xt.loadInt(32)
      , Xs = xt.loadBit() ? xt.loadInt(32) : void 0
      , ga = xt.loadUint(16)
      , ba = xt.loadUint(16)
      , yl = xt.loadUint(16)
      , xl = xt.loadUint(16)
      , wl = xt.loadUintBig(256)
      , _l = (0,
    StorageUsedShort_1$1.loadStorageUsedShort)(xt);
    return {
        success: Cn,
        valid: as,
        noFunds: cs,
        statusChange: Cs,
        totalFwdFees: Ls,
        totalActionFees: Vs,
        resultCode: Ws,
        resultArg: Xs,
        totalActions: ga,
        specActions: ba,
        skippedActions: yl,
        messagesCreated: xl,
        actionListHash: wl,
        totalMessageSize: _l
    }
}
TransactionActionPhase.loadTransactionActionPhase = loadTransactionActionPhase;
function storeTransactionActionPhase(xt) {
    return Cn => {
        Cn.storeBit(xt.success),
        Cn.storeBit(xt.valid),
        Cn.storeBit(xt.noFunds),
        Cn.store((0,
        AccountStatusChange_1$1.storeAccountStatusChange)(xt.statusChange)),
        Cn.storeMaybeCoins(xt.totalFwdFees),
        Cn.storeMaybeCoins(xt.totalActionFees),
        Cn.storeInt(xt.resultCode, 32),
        Cn.storeMaybeInt(xt.resultArg, 32),
        Cn.storeUint(xt.totalActions, 16),
        Cn.storeUint(xt.specActions, 16),
        Cn.storeUint(xt.skippedActions, 16),
        Cn.storeUint(xt.messagesCreated, 16),
        Cn.storeUint(xt.actionListHash, 256),
        Cn.store((0,
        StorageUsedShort_1$1.storeStorageUsedShort)(xt.totalMessageSize))
    }
}
TransactionActionPhase.storeTransactionActionPhase = storeTransactionActionPhase;
var TransactionBouncePhase = {};
Object.defineProperty(TransactionBouncePhase, "__esModule", {
    value: !0
});
TransactionBouncePhase.storeTransactionBouncePhase = TransactionBouncePhase.loadTransactionBouncePhase = void 0;
const StorageUsedShort_1 = StorageUsedShort;
function loadTransactionBouncePhase(xt) {
    if (xt.loadBit()) {
        let Cn = (0,
        StorageUsedShort_1.loadStorageUsedShort)(xt)
          , as = xt.loadCoins()
          , cs = xt.loadCoins();
        return {
            type: "ok",
            messageSize: Cn,
            messageFees: as,
            forwardFees: cs
        }
    }
    if (xt.loadBit()) {
        let Cn = (0,
        StorageUsedShort_1.loadStorageUsedShort)(xt)
          , as = xt.loadCoins();
        return {
            type: "no-funds",
            messageSize: Cn,
            requiredForwardFees: as
        }
    }
    return {
        type: "negative-funds"
    }
}
TransactionBouncePhase.loadTransactionBouncePhase = loadTransactionBouncePhase;
function storeTransactionBouncePhase(xt) {
    return Cn => {
        if (xt.type === "ok")
            Cn.storeBit(!0),
            Cn.store((0,
            StorageUsedShort_1.storeStorageUsedShort)(xt.messageSize)),
            Cn.storeCoins(xt.messageFees),
            Cn.storeCoins(xt.forwardFees);
        else if (xt.type === "negative-funds")
            Cn.storeBit(!1),
            Cn.storeBit(!1);
        else if (xt.type === "no-funds")
            Cn.storeBit(!1),
            Cn.storeBit(!0),
            Cn.store((0,
            StorageUsedShort_1.storeStorageUsedShort)(xt.messageSize)),
            Cn.storeCoins(xt.requiredForwardFees);
        else
            throw new Error("Invalid TransactionBouncePhase type")
    }
}
TransactionBouncePhase.storeTransactionBouncePhase = storeTransactionBouncePhase;
var TransactionComputePhase = {};
Object.defineProperty(TransactionComputePhase, "__esModule", {
    value: !0
});
TransactionComputePhase.storeTransactionComputePhase = TransactionComputePhase.loadTransactionComputePhase = void 0;
const Builder_1 = requireBuilder()
  , ComputeSkipReason_1 = ComputeSkipReason;
function loadTransactionComputePhase(xt) {
    if (!xt.loadBit())
        return {
            type: "skipped",
            reason: (0,
            ComputeSkipReason_1.loadComputeSkipReason)(xt)
        };
    let Cn = xt.loadBit()
      , as = xt.loadBit()
      , cs = xt.loadBit()
      , Cs = xt.loadCoins();
    const Ls = xt.loadRef().beginParse();
    let Vs = Ls.loadVarUintBig(3)
      , Ws = Ls.loadVarUintBig(3)
      , Xs = Ls.loadBit() ? Ls.loadVarUintBig(2) : void 0
      , ga = Ls.loadUint(8)
      , ba = Ls.loadInt(32)
      , yl = Ls.loadBit() ? Ls.loadInt(32) : void 0
      , xl = Ls.loadUint(32)
      , wl = Ls.loadUintBig(256)
      , _l = Ls.loadUintBig(256);
    return {
        type: "vm",
        success: Cn,
        messageStateUsed: as,
        accountActivated: cs,
        gasFees: Cs,
        gasUsed: Vs,
        gasLimit: Ws,
        gasCredit: Xs,
        mode: ga,
        exitCode: ba,
        exitArg: yl,
        vmSteps: xl,
        vmInitStateHash: wl,
        vmFinalStateHash: _l
    }
}
TransactionComputePhase.loadTransactionComputePhase = loadTransactionComputePhase;
function storeTransactionComputePhase(xt) {
    return Cn => {
        if (xt.type === "skipped") {
            Cn.storeBit(0),
            Cn.store((0,
            ComputeSkipReason_1.storeComputeSkipReason)(xt.reason));
            return
        }
        Cn.storeBit(1),
        Cn.storeBit(xt.success),
        Cn.storeBit(xt.messageStateUsed),
        Cn.storeBit(xt.accountActivated),
        Cn.storeCoins(xt.gasFees),
        Cn.storeRef((0,
        Builder_1.beginCell)().storeVarUint(xt.gasUsed, 3).storeVarUint(xt.gasLimit, 3).store(as => xt.gasCredit !== void 0 && xt.gasCredit !== null ? as.storeBit(1).storeVarUint(xt.gasCredit, 2) : as.storeBit(0)).storeUint(xt.mode, 8).storeInt(xt.exitCode, 32).store(as => xt.exitArg !== void 0 && xt.exitArg !== null ? as.storeBit(1).storeInt(xt.exitArg, 32) : as.storeBit(0)).storeUint(xt.vmSteps, 32).storeUint(xt.vmInitStateHash, 256).storeUint(xt.vmFinalStateHash, 256).endCell())
    }
}
TransactionComputePhase.storeTransactionComputePhase = storeTransactionComputePhase;
var TransactionCreditPhase = {};
Object.defineProperty(TransactionCreditPhase, "__esModule", {
    value: !0
});
TransactionCreditPhase.storeTransactionCreditPhase = TransactionCreditPhase.loadTransactionCreditPhase = void 0;
const CurrencyCollection_1 = CurrencyCollection;
function loadTransactionCreditPhase(xt) {
    const Cn = xt.loadBit() ? xt.loadCoins() : void 0
      , as = (0,
    CurrencyCollection_1.loadCurrencyCollection)(xt);
    return {
        dueFeesColelcted: Cn,
        credit: as
    }
}
TransactionCreditPhase.loadTransactionCreditPhase = loadTransactionCreditPhase;
function storeTransactionCreditPhase(xt) {
    return Cn => {
        xt.dueFeesColelcted === null || xt.dueFeesColelcted === void 0 ? Cn.storeBit(!1) : (Cn.storeBit(!0),
        Cn.storeCoins(xt.dueFeesColelcted)),
        Cn.store((0,
        CurrencyCollection_1.storeCurrencyCollection)(xt.credit))
    }
}
TransactionCreditPhase.storeTransactionCreditPhase = storeTransactionCreditPhase;
var TransactionStoragePhase = {};
Object.defineProperty(TransactionStoragePhase, "__esModule", {
    value: !0
});
TransactionStoragePhase.storeTransactionsStoragePhase = TransactionStoragePhase.loadTransactionStoragePhase = void 0;
const AccountStatusChange_1 = AccountStatusChange;
function loadTransactionStoragePhase(xt) {
    const Cn = xt.loadCoins();
    let as;
    xt.loadBit() && (as = xt.loadCoins());
    const cs = (0,
    AccountStatusChange_1.loadAccountStatusChange)(xt);
    return {
        storageFeesCollected: Cn,
        storageFeesDue: as,
        statusChange: cs
    }
}
TransactionStoragePhase.loadTransactionStoragePhase = loadTransactionStoragePhase;
function storeTransactionsStoragePhase(xt) {
    return Cn => {
        Cn.storeCoins(xt.storageFeesCollected),
        xt.storageFeesDue === null || xt.storageFeesDue === void 0 ? Cn.storeBit(!1) : (Cn.storeBit(!0),
        Cn.storeCoins(xt.storageFeesDue)),
        Cn.store((0,
        AccountStatusChange_1.storeAccountStatusChange)(xt.statusChange))
    }
}
TransactionStoragePhase.storeTransactionsStoragePhase = storeTransactionsStoragePhase;
var hasRequiredTransactionDescription;
function requireTransactionDescription() {
    if (hasRequiredTransactionDescription)
        return TransactionDescription;
    hasRequiredTransactionDescription = 1,
    Object.defineProperty(TransactionDescription, "__esModule", {
        value: !0
    }),
    TransactionDescription.storeTransactionDescription = TransactionDescription.loadTransactionDescription = void 0;
    const xt = requireBuilder()
      , Cn = SplitMergeInfo
      , as = requireTransaction()
      , cs = TransactionActionPhase
      , Cs = TransactionBouncePhase
      , Ls = TransactionComputePhase
      , Vs = TransactionCreditPhase
      , Ws = TransactionStoragePhase;
    function Xs(ba) {
        let yl = ba.loadUint(4);
        if (yl === 0) {
            const xl = ba.loadBit();
            let wl;
            ba.loadBit() && (wl = (0,
            Ws.loadTransactionStoragePhase)(ba));
            let _l;
            ba.loadBit() && (_l = (0,
            Vs.loadTransactionCreditPhase)(ba));
            let El = (0,
            Ls.loadTransactionComputePhase)(ba), Cl;
            ba.loadBit() && (Cl = (0,
            cs.loadTransactionActionPhase)(ba.loadRef().beginParse()));
            let $l = ba.loadBit(), Sl;
            ba.loadBit() && (Sl = (0,
            Cs.loadTransactionBouncePhase)(ba));
            const Tl = ba.loadBit();
            return {
                type: "generic",
                creditFirst: xl,
                storagePhase: wl,
                creditPhase: _l,
                computePhase: El,
                actionPhase: Cl,
                bouncePhase: Sl,
                aborted: $l,
                destroyed: Tl
            }
        }
        if (yl === 1)
            return {
                type: "storage",
                storagePhase: (0,
                Ws.loadTransactionStoragePhase)(ba)
            };
        if (yl === 2 || yl === 3) {
            const xl = yl === 3;
            let wl = (0,
            Ws.loadTransactionStoragePhase)(ba), _l = (0,
            Ls.loadTransactionComputePhase)(ba), El;
            ba.loadBit() && (El = (0,
            cs.loadTransactionActionPhase)(ba.loadRef().beginParse()));
            const Cl = ba.loadBit()
              , $l = ba.loadBit();
            return {
                type: "tick-tock",
                isTock: xl,
                storagePhase: wl,
                computePhase: _l,
                actionPhase: El,
                aborted: Cl,
                destroyed: $l
            }
        }
        if (yl === 4) {
            let xl = (0,
            Cn.loadSplitMergeInfo)(ba), wl;
            ba.loadBit() && (wl = (0,
            Ws.loadTransactionStoragePhase)(ba));
            let _l = (0,
            Ls.loadTransactionComputePhase)(ba), El;
            ba.loadBit() && (El = (0,
            cs.loadTransactionActionPhase)(ba.loadRef().beginParse()));
            const Cl = ba.loadBit()
              , $l = ba.loadBit();
            return {
                type: "split-prepare",
                splitInfo: xl,
                storagePhase: wl,
                computePhase: _l,
                actionPhase: El,
                aborted: Cl,
                destroyed: $l
            }
        }
        if (yl === 5) {
            let xl = (0,
            Cn.loadSplitMergeInfo)(ba)
              , wl = (0,
            as.loadTransaction)(ba.loadRef().beginParse());
            const _l = ba.loadBit();
            return {
                type: "split-install",
                splitInfo: xl,
                prepareTransaction: wl,
                installed: _l
            }
        }
        throw Error(`Unsupported transaction description type ${yl}`)
    }
    TransactionDescription.loadTransactionDescription = Xs;
    function ga(ba) {
        return yl => {
            if (ba.type === "generic")
                yl.storeUint(0, 4),
                yl.storeBit(ba.creditFirst),
                ba.storagePhase ? (yl.storeBit(!0),
                yl.store((0,
                Ws.storeTransactionsStoragePhase)(ba.storagePhase))) : yl.storeBit(!1),
                ba.creditPhase ? (yl.storeBit(!0),
                yl.store((0,
                Vs.storeTransactionCreditPhase)(ba.creditPhase))) : yl.storeBit(!1),
                yl.store((0,
                Ls.storeTransactionComputePhase)(ba.computePhase)),
                ba.actionPhase ? (yl.storeBit(!0),
                yl.storeRef((0,
                xt.beginCell)().store((0,
                cs.storeTransactionActionPhase)(ba.actionPhase)))) : yl.storeBit(!1),
                yl.storeBit(ba.aborted),
                ba.bouncePhase ? (yl.storeBit(!0),
                yl.store((0,
                Cs.storeTransactionBouncePhase)(ba.bouncePhase))) : yl.storeBit(!1),
                yl.storeBit(ba.destroyed);
            else if (ba.type === "storage")
                yl.storeUint(1, 4),
                yl.store((0,
                Ws.storeTransactionsStoragePhase)(ba.storagePhase));
            else if (ba.type === "tick-tock")
                yl.storeUint(ba.isTock ? 3 : 2, 4),
                yl.store((0,
                Ws.storeTransactionsStoragePhase)(ba.storagePhase)),
                yl.store((0,
                Ls.storeTransactionComputePhase)(ba.computePhase)),
                ba.actionPhase ? (yl.storeBit(!0),
                yl.storeRef((0,
                xt.beginCell)().store((0,
                cs.storeTransactionActionPhase)(ba.actionPhase)))) : yl.storeBit(!1),
                yl.storeBit(ba.aborted),
                yl.storeBit(ba.destroyed);
            else if (ba.type === "split-prepare")
                yl.storeUint(4, 4),
                yl.store((0,
                Cn.storeSplitMergeInfo)(ba.splitInfo)),
                ba.storagePhase ? (yl.storeBit(!0),
                yl.store((0,
                Ws.storeTransactionsStoragePhase)(ba.storagePhase))) : yl.storeBit(!1),
                yl.store((0,
                Ls.storeTransactionComputePhase)(ba.computePhase)),
                ba.actionPhase ? (yl.storeBit(!0),
                yl.store((0,
                cs.storeTransactionActionPhase)(ba.actionPhase))) : yl.storeBit(!1),
                yl.storeBit(ba.aborted),
                yl.storeBit(ba.destroyed);
            else if (ba.type === "split-install")
                yl.storeUint(5, 4),
                yl.store((0,
                Cn.storeSplitMergeInfo)(ba.splitInfo)),
                yl.storeRef((0,
                xt.beginCell)().store((0,
                as.storeTransaction)(ba.prepareTransaction))),
                yl.storeBit(ba.installed);
            else
                throw Error(`Unsupported transaction description type ${ba.type}`)
        }
    }
    return TransactionDescription.storeTransactionDescription = ga,
    TransactionDescription
}
var hasRequiredTransaction;
function requireTransaction() {
    if (hasRequiredTransaction)
        return Transaction;
    hasRequiredTransaction = 1,
    Object.defineProperty(Transaction, "__esModule", {
        value: !0
    }),
    Transaction.storeTransaction = Transaction.loadTransaction = void 0;
    const xt = requireBuilder()
      , Cn = requireDictionary()
      , as = AccountStatus
      , cs = CurrencyCollection
      , Cs = HashUpdate
      , Ls = Message
      , Vs = requireTransactionDescription();
    function Ws(ga) {
        let ba = ga.asCell();
        if (ga.loadUint(4) !== 7)
            throw Error("Invalid data");
        let yl = ga.loadUintBig(256)
          , xl = ga.loadUintBig(64)
          , wl = ga.loadUintBig(256)
          , _l = ga.loadUintBig(64)
          , El = ga.loadUint(32)
          , Cl = ga.loadUint(15)
          , $l = (0,
        as.loadAccountStatus)(ga)
          , Sl = (0,
        as.loadAccountStatus)(ga)
          , Rl = ga.loadRef().beginParse()
          , Il = Rl.loadBit() ? (0,
        Ls.loadMessage)(Rl.loadRef().beginParse()) : void 0
          , Ml = Rl.loadDict(Cn.Dictionary.Keys.Uint(15), Ls.MessageValue);
        Rl.endParse();
        let Nl = (0,
        cs.loadCurrencyCollection)(ga)
          , Ll = (0,
        Cs.loadHashUpdate)(ga.loadRef().beginParse())
          , Fl = (0,
        Vs.loadTransactionDescription)(ga.loadRef().beginParse());
        return {
            address: yl,
            lt: xl,
            prevTransactionHash: wl,
            prevTransactionLt: _l,
            now: El,
            outMessagesCount: Cl,
            oldStatus: $l,
            endStatus: Sl,
            inMessage: Il,
            outMessages: Ml,
            totalFees: Nl,
            stateUpdate: Ll,
            description: Fl,
            raw: ba,
            hash: () => ba.hash()
        }
    }
    Transaction.loadTransaction = Ws;
    function Xs(ga) {
        return ba => {
            ba.storeUint(7, 4),
            ba.storeUint(ga.address, 256),
            ba.storeUint(ga.lt, 64),
            ba.storeUint(ga.prevTransactionHash, 256),
            ba.storeUint(ga.prevTransactionLt, 64),
            ba.storeUint(ga.now, 32),
            ba.storeUint(ga.outMessagesCount, 15),
            ba.store((0,
            as.storeAccountStatus)(ga.oldStatus)),
            ba.store((0,
            as.storeAccountStatus)(ga.endStatus));
            let yl = (0,
            xt.beginCell)();
            ga.inMessage ? (yl.storeBit(!0),
            yl.storeRef((0,
            xt.beginCell)().store((0,
            Ls.storeMessage)(ga.inMessage)))) : yl.storeBit(!1),
            yl.storeDict(ga.outMessages),
            ba.storeRef(yl),
            ba.store((0,
            cs.storeCurrencyCollection)(ga.totalFees)),
            ba.storeRef((0,
            xt.beginCell)().store((0,
            Cs.storeHashUpdate)(ga.stateUpdate))),
            ba.storeRef((0,
            xt.beginCell)().store((0,
            Vs.storeTransactionDescription)(ga.description)))
        }
    }
    return Transaction.storeTransaction = Xs,
    Transaction
}
(function(xt) {
    Object.defineProperty(xt, "__esModule", {
        value: !0
    }),
    xt.storeSplitMergeInfo = xt.loadSplitMergeInfo = xt.storeLibRef = xt.loadLibRef = xt.storeSimpleLibrary = xt.loadSimpleLibrary = xt.loadShardStateUnsplit = xt.storeShardIdent = xt.loadShardIdent = xt.storeShardAccounts = xt.loadShardAccounts = xt.ShardAccountRefValue = xt.storeShardAccount = xt.loadShardAccount = xt.ReserveMode = xt.SendMode = xt.storeMessageRelaxed = xt.loadMessageRelaxed = xt.storeMessage = xt.loadMessage = xt.loadMasterchainStateExtra = xt.storeHashUpdate = xt.loadHashUpdate = xt.storeDepthBalanceInfo = xt.loadDepthBalanceInfo = xt.storeCurrencyCollection = xt.loadCurrencyCollection = xt.storeComputeSkipReason = xt.loadComputeSkipReason = xt.storeCommonMessageInfoRelaxed = xt.loadCommonMessageInfoRelaxed = xt.storeCommonMessageInfo = xt.loadCommonMessageInfo = xt.storeOutList = xt.loadOutList = xt.storeOutAction = xt.loadOutAction = xt.storeAccountStorage = xt.loadAccountStorage = xt.storeAccountStatusChange = xt.loadAccountStatusChange = xt.storeAccountStatus = xt.loadAccountStatus = xt.storeAccountState = xt.loadAccountState = xt.storeAccount = xt.loadAccount = xt.comment = xt.external = xt.internal = void 0,
    xt.storeTransactionsStoragePhase = xt.loadTransactionStoragePhase = xt.storeTransactionDescription = xt.loadTransactionDescription = xt.storeTransactionCreditPhase = xt.loadTransactionCreditPhase = xt.storeTransactionComputePhase = xt.loadTransactionComputePhase = xt.storeTransactionBouncePhase = xt.loadTransactionBouncePhase = xt.storeTransactionActionPhase = xt.loadTransactionActionPhase = xt.storeTransaction = xt.loadTransaction = xt.storeTickTock = xt.loadTickTock = xt.storeStorageUsedShort = xt.loadStorageUsedShort = xt.storeStorageUsed = xt.loadStorageUsed = xt.storeStorageInfo = xt.loadStorageInfo = xt.storeStateInit = xt.loadStateInit = void 0;
    var Cn = _helpers;
    Object.defineProperty(xt, "internal", {
        enumerable: !0,
        get: function() {
            return Cn.internal
        }
    }),
    Object.defineProperty(xt, "external", {
        enumerable: !0,
        get: function() {
            return Cn.external
        }
    }),
    Object.defineProperty(xt, "comment", {
        enumerable: !0,
        get: function() {
            return Cn.comment
        }
    });
    var as = Account;
    Object.defineProperty(xt, "loadAccount", {
        enumerable: !0,
        get: function() {
            return as.loadAccount
        }
    }),
    Object.defineProperty(xt, "storeAccount", {
        enumerable: !0,
        get: function() {
            return as.storeAccount
        }
    });
    var cs = AccountState;
    Object.defineProperty(xt, "loadAccountState", {
        enumerable: !0,
        get: function() {
            return cs.loadAccountState
        }
    }),
    Object.defineProperty(xt, "storeAccountState", {
        enumerable: !0,
        get: function() {
            return cs.storeAccountState
        }
    });
    var Cs = AccountStatus;
    Object.defineProperty(xt, "loadAccountStatus", {
        enumerable: !0,
        get: function() {
            return Cs.loadAccountStatus
        }
    }),
    Object.defineProperty(xt, "storeAccountStatus", {
        enumerable: !0,
        get: function() {
            return Cs.storeAccountStatus
        }
    });
    var Ls = AccountStatusChange;
    Object.defineProperty(xt, "loadAccountStatusChange", {
        enumerable: !0,
        get: function() {
            return Ls.loadAccountStatusChange
        }
    }),
    Object.defineProperty(xt, "storeAccountStatusChange", {
        enumerable: !0,
        get: function() {
            return Ls.storeAccountStatusChange
        }
    });
    var Vs = AccountStorage;
    Object.defineProperty(xt, "loadAccountStorage", {
        enumerable: !0,
        get: function() {
            return Vs.loadAccountStorage
        }
    }),
    Object.defineProperty(xt, "storeAccountStorage", {
        enumerable: !0,
        get: function() {
            return Vs.storeAccountStorage
        }
    });
    var Ws = OutList;
    Object.defineProperty(xt, "loadOutAction", {
        enumerable: !0,
        get: function() {
            return Ws.loadOutAction
        }
    }),
    Object.defineProperty(xt, "storeOutAction", {
        enumerable: !0,
        get: function() {
            return Ws.storeOutAction
        }
    }),
    Object.defineProperty(xt, "loadOutList", {
        enumerable: !0,
        get: function() {
            return Ws.loadOutList
        }
    }),
    Object.defineProperty(xt, "storeOutList", {
        enumerable: !0,
        get: function() {
            return Ws.storeOutList
        }
    });
    var Xs = CommonMessageInfo;
    Object.defineProperty(xt, "loadCommonMessageInfo", {
        enumerable: !0,
        get: function() {
            return Xs.loadCommonMessageInfo
        }
    }),
    Object.defineProperty(xt, "storeCommonMessageInfo", {
        enumerable: !0,
        get: function() {
            return Xs.storeCommonMessageInfo
        }
    });
    var ga = CommonMessageInfoRelaxed;
    Object.defineProperty(xt, "loadCommonMessageInfoRelaxed", {
        enumerable: !0,
        get: function() {
            return ga.loadCommonMessageInfoRelaxed
        }
    }),
    Object.defineProperty(xt, "storeCommonMessageInfoRelaxed", {
        enumerable: !0,
        get: function() {
            return ga.storeCommonMessageInfoRelaxed
        }
    });
    var ba = ComputeSkipReason;
    Object.defineProperty(xt, "loadComputeSkipReason", {
        enumerable: !0,
        get: function() {
            return ba.loadComputeSkipReason
        }
    }),
    Object.defineProperty(xt, "storeComputeSkipReason", {
        enumerable: !0,
        get: function() {
            return ba.storeComputeSkipReason
        }
    });
    var yl = CurrencyCollection;
    Object.defineProperty(xt, "loadCurrencyCollection", {
        enumerable: !0,
        get: function() {
            return yl.loadCurrencyCollection
        }
    }),
    Object.defineProperty(xt, "storeCurrencyCollection", {
        enumerable: !0,
        get: function() {
            return yl.storeCurrencyCollection
        }
    });
    var xl = DepthBalanceInfo;
    Object.defineProperty(xt, "loadDepthBalanceInfo", {
        enumerable: !0,
        get: function() {
            return xl.loadDepthBalanceInfo
        }
    }),
    Object.defineProperty(xt, "storeDepthBalanceInfo", {
        enumerable: !0,
        get: function() {
            return xl.storeDepthBalanceInfo
        }
    });
    var wl = HashUpdate;
    Object.defineProperty(xt, "loadHashUpdate", {
        enumerable: !0,
        get: function() {
            return wl.loadHashUpdate
        }
    }),
    Object.defineProperty(xt, "storeHashUpdate", {
        enumerable: !0,
        get: function() {
            return wl.storeHashUpdate
        }
    });
    var _l = MasterchainStateExtra;
    Object.defineProperty(xt, "loadMasterchainStateExtra", {
        enumerable: !0,
        get: function() {
            return _l.loadMasterchainStateExtra
        }
    });
    var El = Message;
    Object.defineProperty(xt, "loadMessage", {
        enumerable: !0,
        get: function() {
            return El.loadMessage
        }
    }),
    Object.defineProperty(xt, "storeMessage", {
        enumerable: !0,
        get: function() {
            return El.storeMessage
        }
    });
    var Cl = MessageRelaxed;
    Object.defineProperty(xt, "loadMessageRelaxed", {
        enumerable: !0,
        get: function() {
            return Cl.loadMessageRelaxed
        }
    }),
    Object.defineProperty(xt, "storeMessageRelaxed", {
        enumerable: !0,
        get: function() {
            return Cl.storeMessageRelaxed
        }
    });
    var $l = SendMode$1;
    Object.defineProperty(xt, "SendMode", {
        enumerable: !0,
        get: function() {
            return $l.SendMode
        }
    });
    var Sl = ReserveMode$1;
    Object.defineProperty(xt, "ReserveMode", {
        enumerable: !0,
        get: function() {
            return Sl.ReserveMode
        }
    });
    var Tl = ShardAccount;
    Object.defineProperty(xt, "loadShardAccount", {
        enumerable: !0,
        get: function() {
            return Tl.loadShardAccount
        }
    }),
    Object.defineProperty(xt, "storeShardAccount", {
        enumerable: !0,
        get: function() {
            return Tl.storeShardAccount
        }
    });
    var Rl = ShardAccounts;
    Object.defineProperty(xt, "ShardAccountRefValue", {
        enumerable: !0,
        get: function() {
            return Rl.ShardAccountRefValue
        }
    }),
    Object.defineProperty(xt, "loadShardAccounts", {
        enumerable: !0,
        get: function() {
            return Rl.loadShardAccounts
        }
    }),
    Object.defineProperty(xt, "storeShardAccounts", {
        enumerable: !0,
        get: function() {
            return Rl.storeShardAccounts
        }
    });
    var Il = ShardIdent;
    Object.defineProperty(xt, "loadShardIdent", {
        enumerable: !0,
        get: function() {
            return Il.loadShardIdent
        }
    }),
    Object.defineProperty(xt, "storeShardIdent", {
        enumerable: !0,
        get: function() {
            return Il.storeShardIdent
        }
    });
    var Ml = ShardStateUnsplit;
    Object.defineProperty(xt, "loadShardStateUnsplit", {
        enumerable: !0,
        get: function() {
            return Ml.loadShardStateUnsplit
        }
    });
    var Nl = SimpleLibrary;
    Object.defineProperty(xt, "loadSimpleLibrary", {
        enumerable: !0,
        get: function() {
            return Nl.loadSimpleLibrary
        }
    }),
    Object.defineProperty(xt, "storeSimpleLibrary", {
        enumerable: !0,
        get: function() {
            return Nl.storeSimpleLibrary
        }
    });
    var Ll = LibRef;
    Object.defineProperty(xt, "loadLibRef", {
        enumerable: !0,
        get: function() {
            return Ll.loadLibRef
        }
    }),
    Object.defineProperty(xt, "storeLibRef", {
        enumerable: !0,
        get: function() {
            return Ll.storeLibRef
        }
    });
    var Fl = SplitMergeInfo;
    Object.defineProperty(xt, "loadSplitMergeInfo", {
        enumerable: !0,
        get: function() {
            return Fl.loadSplitMergeInfo
        }
    }),
    Object.defineProperty(xt, "storeSplitMergeInfo", {
        enumerable: !0,
        get: function() {
            return Fl.storeSplitMergeInfo
        }
    });
    var Ul = StateInit;
    Object.defineProperty(xt, "loadStateInit", {
        enumerable: !0,
        get: function() {
            return Ul.loadStateInit
        }
    }),
    Object.defineProperty(xt, "storeStateInit", {
        enumerable: !0,
        get: function() {
            return Ul.storeStateInit
        }
    });
    var Dl = StorageInto;
    Object.defineProperty(xt, "loadStorageInfo", {
        enumerable: !0,
        get: function() {
            return Dl.loadStorageInfo
        }
    }),
    Object.defineProperty(xt, "storeStorageInfo", {
        enumerable: !0,
        get: function() {
            return Dl.storeStorageInfo
        }
    });
    var Zl = StorageUsed;
    Object.defineProperty(xt, "loadStorageUsed", {
        enumerable: !0,
        get: function() {
            return Zl.loadStorageUsed
        }
    }),
    Object.defineProperty(xt, "storeStorageUsed", {
        enumerable: !0,
        get: function() {
            return Zl.storeStorageUsed
        }
    });
    var Gl = StorageUsedShort;
    Object.defineProperty(xt, "loadStorageUsedShort", {
        enumerable: !0,
        get: function() {
            return Gl.loadStorageUsedShort
        }
    }),
    Object.defineProperty(xt, "storeStorageUsedShort", {
        enumerable: !0,
        get: function() {
            return Gl.storeStorageUsedShort
        }
    });
    var Wl = TickTock;
    Object.defineProperty(xt, "loadTickTock", {
        enumerable: !0,
        get: function() {
            return Wl.loadTickTock
        }
    }),
    Object.defineProperty(xt, "storeTickTock", {
        enumerable: !0,
        get: function() {
            return Wl.storeTickTock
        }
    });
    var Ql = requireTransaction();
    Object.defineProperty(xt, "loadTransaction", {
        enumerable: !0,
        get: function() {
            return Ql.loadTransaction
        }
    }),
    Object.defineProperty(xt, "storeTransaction", {
        enumerable: !0,
        get: function() {
            return Ql.storeTransaction
        }
    });
    var cu = TransactionActionPhase;
    Object.defineProperty(xt, "loadTransactionActionPhase", {
        enumerable: !0,
        get: function() {
            return cu.loadTransactionActionPhase
        }
    }),
    Object.defineProperty(xt, "storeTransactionActionPhase", {
        enumerable: !0,
        get: function() {
            return cu.storeTransactionActionPhase
        }
    });
    var pu = TransactionBouncePhase;
    Object.defineProperty(xt, "loadTransactionBouncePhase", {
        enumerable: !0,
        get: function() {
            return pu.loadTransactionBouncePhase
        }
    }),
    Object.defineProperty(xt, "storeTransactionBouncePhase", {
        enumerable: !0,
        get: function() {
            return pu.storeTransactionBouncePhase
        }
    });
    var zl = TransactionComputePhase;
    Object.defineProperty(xt, "loadTransactionComputePhase", {
        enumerable: !0,
        get: function() {
            return zl.loadTransactionComputePhase
        }
    }),
    Object.defineProperty(xt, "storeTransactionComputePhase", {
        enumerable: !0,
        get: function() {
            return zl.storeTransactionComputePhase
        }
    });
    var Yl = TransactionCreditPhase;
    Object.defineProperty(xt, "loadTransactionCreditPhase", {
        enumerable: !0,
        get: function() {
            return Yl.loadTransactionCreditPhase
        }
    }),
    Object.defineProperty(xt, "storeTransactionCreditPhase", {
        enumerable: !0,
        get: function() {
            return Yl.storeTransactionCreditPhase
        }
    });
    var lu = requireTransactionDescription();
    Object.defineProperty(xt, "loadTransactionDescription", {
        enumerable: !0,
        get: function() {
            return lu.loadTransactionDescription
        }
    }),
    Object.defineProperty(xt, "storeTransactionDescription", {
        enumerable: !0,
        get: function() {
            return lu.storeTransactionDescription
        }
    });
    var mu = TransactionStoragePhase;
    Object.defineProperty(xt, "loadTransactionStoragePhase", {
        enumerable: !0,
        get: function() {
            return mu.loadTransactionStoragePhase
        }
    }),
    Object.defineProperty(xt, "storeTransactionsStoragePhase", {
        enumerable: !0,
        get: function() {
            return mu.storeTransactionsStoragePhase
        }
    })
}
)(_export);
var openContract$1 = {};
Object.defineProperty(openContract$1, "__esModule", {
    value: !0
});
openContract$1.openContract = void 0;
const Address_1 = Address$1
  , Cell_1 = requireCell();
function openContract(xt, Cn) {
    let as, cs = null;
    if (!Address_1.Address.isAddress(xt.address))
        throw Error("Invalid address");
    if (as = xt.address,
    xt.init) {
        if (!(xt.init.code instanceof Cell_1.Cell))
            throw Error("Invalid init.code");
        if (!(xt.init.data instanceof Cell_1.Cell))
            throw Error("Invalid init.data");
        cs = xt.init
    }
    let Cs = Cn({
        address: as,
        init: cs
    });
    return new Proxy(xt,{
        get(Ls, Vs) {
            const Ws = Ls[Vs];
            return typeof Vs == "string" && (Vs.startsWith("get") || Vs.startsWith("send") || Vs.startsWith("is")) && typeof Ws == "function" ? (...Xs) => Ws.apply(Ls, [Cs, ...Xs]) : Ws
        }
    })
}
openContract$1.openContract = openContract;
var ComputeError$1 = {};
Object.defineProperty(ComputeError$1, "__esModule", {
    value: !0
});
ComputeError$1.ComputeError = void 0;
class ComputeError extends Error {
    constructor(Cn, as, cs) {
        super(Cn),
        this.exitCode = as,
        this.debugLogs = cs && cs.debugLogs ? cs.debugLogs : null,
        this.logs = cs && cs.logs ? cs.logs : null,
        Object.setPrototypeOf(this, ComputeError.prototype)
    }
}
ComputeError$1.ComputeError = ComputeError;
var getMethodId$1 = {};
Object.defineProperty(getMethodId$1, "__esModule", {
    value: !0
});
getMethodId$1.getMethodId = void 0;
const TABLE = new Int16Array([0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793, 7920]);
function crc16(xt) {
    xt instanceof Buffer || (xt = Buffer.from(xt));
    let Cn = 0;
    for (let as = 0; as < xt.length; as++) {
        const cs = xt[as];
        Cn = (TABLE[(Cn >> 8 ^ cs) & 255] ^ Cn << 8) & 65535
    }
    return Cn
}
function getMethodId(xt) {
    return crc16(xt) & 65535 | 65536
}
getMethodId$1.getMethodId = getMethodId;
var safeSign$1 = {};
Object.defineProperty(safeSign$1, "__esModule", {
    value: !0
});
safeSign$1.safeSignVerify = safeSign$1.safeSign = void 0;
const crypto_1 = requireDist()
  , MIN_SEED_LENGTH = 8
  , MAX_SEED_LENGTH = 64;
function createSafeSignHash(xt, Cn) {
    let as = Buffer.from(Cn);
    if (as.length > MAX_SEED_LENGTH)
        throw Error("Seed can	 be longer than 64 bytes");
    if (as.length < MIN_SEED_LENGTH)
        throw Error("Seed must be at least 8 bytes");
    return (0,
    crypto_1.sha256_sync)(Buffer.concat([Buffer.from([255, 255]), as, xt.hash()]))
}
function safeSign(xt, Cn, as="ton-safe-sign-magic") {
    return (0,
    crypto_1.sign)(createSafeSignHash(xt, as), Cn)
}
safeSign$1.safeSign = safeSign;
function safeSignVerify(xt, Cn, as, cs="ton-safe-sign-magic") {
    return (0,
    crypto_1.signVerify)(createSafeSignHash(xt, cs), Cn, as)
}
safeSign$1.safeSignVerify = safeSignVerify;
(function(xt) {
    var Cn = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(Ql, cu, pu, zl) {
        zl === void 0 && (zl = pu);
        var Yl = Object.getOwnPropertyDescriptor(cu, pu);
        (!Yl || ("get"in Yl ? !cu.__esModule : Yl.writable || Yl.configurable)) && (Yl = {
            enumerable: !0,
            get: function() {
                return cu[pu]
            }
        }),
        Object.defineProperty(Ql, zl, Yl)
    }
    : function(Ql, cu, pu, zl) {
        zl === void 0 && (zl = pu),
        Ql[zl] = cu[pu]
    }
    )
      , as = commonjsGlobal && commonjsGlobal.__exportStar || function(Ql, cu) {
        for (var pu in Ql)
            pu !== "default" && !Object.prototype.hasOwnProperty.call(cu, pu) && Cn(cu, Ql, pu)
    }
    ;
    Object.defineProperty(xt, "__esModule", {
        value: !0
    }),
    xt.safeSignVerify = xt.safeSign = xt.getMethodId = xt.base32Encode = xt.base32Decode = xt.crc32c = xt.crc16 = xt.fromNano = xt.toNano = xt.ComputeError = xt.openContract = xt.TupleBuilder = xt.TupleReader = xt.serializeTuple = xt.parseTuple = xt.generateMerkleUpdate = xt.generateMerkleProofDirect = xt.generateMerkleProof = xt.exoticPruned = xt.exoticMerkleUpdate = xt.convertToMerkleProof = xt.exoticMerkleProof = xt.Dictionary = xt.Cell = xt.CellType = xt.Slice = xt.beginCell = xt.Builder = xt.BitBuilder = xt.BitReader = xt.BitString = xt.contractAddress = xt.ADNLAddress = xt.ExternalAddress = xt.address = xt.Address = void 0;
    var cs = Address$1;
    Object.defineProperty(xt, "Address", {
        enumerable: !0,
        get: function() {
            return cs.Address
        }
    }),
    Object.defineProperty(xt, "address", {
        enumerable: !0,
        get: function() {
            return cs.address
        }
    });
    var Cs = ExternalAddress$1;
    Object.defineProperty(xt, "ExternalAddress", {
        enumerable: !0,
        get: function() {
            return Cs.ExternalAddress
        }
    });
    var Ls = ADNLAddress$1;
    Object.defineProperty(xt, "ADNLAddress", {
        enumerable: !0,
        get: function() {
            return Ls.ADNLAddress
        }
    });
    var Vs = contractAddress$1;
    Object.defineProperty(xt, "contractAddress", {
        enumerable: !0,
        get: function() {
            return Vs.contractAddress
        }
    });
    var Ws = requireBitString();
    Object.defineProperty(xt, "BitString", {
        enumerable: !0,
        get: function() {
            return Ws.BitString
        }
    });
    var Xs = BitReader$1;
    Object.defineProperty(xt, "BitReader", {
        enumerable: !0,
        get: function() {
            return Xs.BitReader
        }
    });
    var ga = requireBitBuilder();
    Object.defineProperty(xt, "BitBuilder", {
        enumerable: !0,
        get: function() {
            return ga.BitBuilder
        }
    });
    var ba = requireBuilder();
    Object.defineProperty(xt, "Builder", {
        enumerable: !0,
        get: function() {
            return ba.Builder
        }
    }),
    Object.defineProperty(xt, "beginCell", {
        enumerable: !0,
        get: function() {
            return ba.beginCell
        }
    });
    var yl = requireSlice();
    Object.defineProperty(xt, "Slice", {
        enumerable: !0,
        get: function() {
            return yl.Slice
        }
    });
    var xl = CellType$1;
    Object.defineProperty(xt, "CellType", {
        enumerable: !0,
        get: function() {
            return xl.CellType
        }
    });
    var wl = requireCell();
    Object.defineProperty(xt, "Cell", {
        enumerable: !0,
        get: function() {
            return wl.Cell
        }
    });
    var _l = requireDictionary();
    Object.defineProperty(xt, "Dictionary", {
        enumerable: !0,
        get: function() {
            return _l.Dictionary
        }
    });
    var El = requireExoticMerkleProof();
    Object.defineProperty(xt, "exoticMerkleProof", {
        enumerable: !0,
        get: function() {
            return El.exoticMerkleProof
        }
    }),
    Object.defineProperty(xt, "convertToMerkleProof", {
        enumerable: !0,
        get: function() {
            return El.convertToMerkleProof
        }
    });
    var Cl = exoticMerkleUpdate$1;
    Object.defineProperty(xt, "exoticMerkleUpdate", {
        enumerable: !0,
        get: function() {
            return Cl.exoticMerkleUpdate
        }
    });
    var $l = exoticPruned$1;
    Object.defineProperty(xt, "exoticPruned", {
        enumerable: !0,
        get: function() {
            return $l.exoticPruned
        }
    });
    var Sl = requireGenerateMerkleProof();
    Object.defineProperty(xt, "generateMerkleProof", {
        enumerable: !0,
        get: function() {
            return Sl.generateMerkleProof
        }
    }),
    Object.defineProperty(xt, "generateMerkleProofDirect", {
        enumerable: !0,
        get: function() {
            return Sl.generateMerkleProofDirect
        }
    });
    var Tl = requireGenerateMerkleUpdate();
    Object.defineProperty(xt, "generateMerkleUpdate", {
        enumerable: !0,
        get: function() {
            return Tl.generateMerkleUpdate
        }
    });
    var Rl = tuple;
    Object.defineProperty(xt, "parseTuple", {
        enumerable: !0,
        get: function() {
            return Rl.parseTuple
        }
    }),
    Object.defineProperty(xt, "serializeTuple", {
        enumerable: !0,
        get: function() {
            return Rl.serializeTuple
        }
    });
    var Il = reader;
    Object.defineProperty(xt, "TupleReader", {
        enumerable: !0,
        get: function() {
            return Il.TupleReader
        }
    });
    var Ml = builder;
    Object.defineProperty(xt, "TupleBuilder", {
        enumerable: !0,
        get: function() {
            return Ml.TupleBuilder
        }
    }),
    as(_export, xt);
    var Nl = openContract$1;
    Object.defineProperty(xt, "openContract", {
        enumerable: !0,
        get: function() {
            return Nl.openContract
        }
    });
    var Ll = ComputeError$1;
    Object.defineProperty(xt, "ComputeError", {
        enumerable: !0,
        get: function() {
            return Ll.ComputeError
        }
    });
    var Fl = convert;
    Object.defineProperty(xt, "toNano", {
        enumerable: !0,
        get: function() {
            return Fl.toNano
        }
    }),
    Object.defineProperty(xt, "fromNano", {
        enumerable: !0,
        get: function() {
            return Fl.fromNano
        }
    });
    var Ul = crc16$2;
    Object.defineProperty(xt, "crc16", {
        enumerable: !0,
        get: function() {
            return Ul.crc16
        }
    });
    var Dl = crc32c$1;
    Object.defineProperty(xt, "crc32c", {
        enumerable: !0,
        get: function() {
            return Dl.crc32c
        }
    });
    var Zl = base32;
    Object.defineProperty(xt, "base32Decode", {
        enumerable: !0,
        get: function() {
            return Zl.base32Decode
        }
    }),
    Object.defineProperty(xt, "base32Encode", {
        enumerable: !0,
        get: function() {
            return Zl.base32Encode
        }
    });
    var Gl = getMethodId$1;
    Object.defineProperty(xt, "getMethodId", {
        enumerable: !0,
        get: function() {
            return Gl.getMethodId
        }
    });
    var Wl = safeSign$1;
    Object.defineProperty(xt, "safeSign", {
        enumerable: !0,
        get: function() {
            return Wl.safeSign
        }
    }),
    Object.defineProperty(xt, "safeSignVerify", {
        enumerable: !0,
        get: function() {
            return Wl.safeSignVerify
        }
    })
}
)(dist$1);
const numberFormatter = new Intl.NumberFormat("en-US",{
    maximumFractionDigits: 0
})
  , currencyFormatter = new Intl.NumberFormat("en-US",{
    maximumFractionDigits: 2
})
  , formatNanotons = (xt, Cn=!1) => {
    const as = Number(dist$1.fromNano(xt))
      , cs = (Cn ? Math.floor(as * 100) : Math.ceil(as * 100)) / 100;
    return currencyFormatter.format(cs).replace(",", " ")
}
  , formatPerMille = xt => xt ? `${xt / 10}%` : ""
  , popup$1 = "_popup_1k5md_1"
  , styles$1p = {
    popup: popup$1
}
  , Tooltip = ({translationKey: xt, prefixIcon: Cn, postfixIcon: as, position: cs="bottom"}) => {
    const {t: Cs} = useTranslation()
      , Vs = cs === "top" ? {
        initial: {
            y: 20,
            x: "-50%",
            opacity: 0
        },
        animate: {
            y: -20,
            x: "-50%",
            opacity: 1
        }
    } : {
        initial: {
            y: -20,
            x: "-50%",
            opacity: 0
        },
        animate: {
            y: 20,
            x: "-50%",
            opacity: 1
        }
    };
    return jsxRuntimeExports.jsx("div", {
        style: {
            position: "relative"
        },
        children: jsxRuntimeExports.jsxs(motion.div, {
            className: `${styles$1p.popup} ${styles$1p[cs]}`,
            initial: Vs.initial,
            animate: Vs.animate,
            exit: {
                opacity: 0
            },
            transition: {
                type: "spring",
                stiffness: 200,
                damping: 20
            },
            children: [Cn && Cn, jsxRuntimeExports.jsx("span", {
                children: Cs(xt)
            }), as && as]
        })
    })
}
;
function getInitialsForAvatar(xt) {
    const Cn = String(xt);
    if (Cn === "")
        return "U";
    const as = Cn.split(/[\s_-]+/);
    return as.length > 2 ? as.slice(0, 2).map(cs => cs[0]).join("") : as.map(cs => cs[0]).join("")
}
const wrapper$2 = "_wrapper_116ek_1"
  , badge = "_badge_116ek_6"
  , styles$1o = {
    wrapper: wrapper$2,
    badge,
    "top-right": "_top-right_116ek_18",
    "top-left": "_top-left_116ek_22",
    "bottom-right": "_bottom-right_116ek_26",
    "bottom-left": "_bottom-left_116ek_30"
}
  , Badge = ({children: xt, content: Cn, position: as="top-right", displayEmpty: cs=!1}) => jsxRuntimeExports.jsxs("div", {
    className: styles$1o.wrapper,
    children: [xt, (!!Cn || cs) && jsxRuntimeExports.jsx("div", {
        className: classNames$1(styles$1o.badge, styles$1o[as]),
        children: Cn
    })]
})
  , Header = () => {
    const xt = useNavigate();
    useLocation();
    const {hard: Cn, updateWallet: as, cartCount: cs, addModal: Cs, profile: Ls} = useStorage(_l => ({
        hard: _l.wallet.balance.hard,
        updateWallet: _l.wallet.updateWallet,
        addModal: _l.modal.addModal,
        profile: _l.profile,
        cartCount: _l.cart.gifts.length
    }))
      , Vs = useTonAddress(!0)
      , [Ws] = useTonConnectUI()
      , [Xs,ga] = reactExports.useState(!1)
      , [ba,yl] = reactExports.useState(!1)
      , xl = () => {
        Vs ? Cs(ModalNames.DEPOSIT) : (Ws.openModal(),
        ga(!0))
    }
      , wl = () => {
        Oc("https://t.me/mrkt_help_service_bot")
    }
    ;
    return reactExports.useEffect( () => {
        Vs && (as(Vs),
        Xs && (yl(!0),
        setTimeout( () => {
            yl(!1),
            ga(!1)
        }
        , 5e3)))
    }
    , [Vs]),
    jsxRuntimeExports.jsxs("div", {
        className: styles$1r.header,
        children: [jsxRuntimeExports.jsxs("div", {
            className: styles$1r.headerLeft,
            children: [jsxRuntimeExports.jsxs("div", {
                className: styles$1r.headerAvatarWrapper,
                onClick: () => xt("/profile"),
                children: [jsxRuntimeExports.jsx("div", {
                    className: styles$1r.headerAvatar,
                    children: Ls.photo ? jsxRuntimeExports.jsx("img", {
                        className: styles$1r.profilePhoto,
                        src: Ls.photo,
                        alt: "profile-pic"
                    }) : jsxRuntimeExports.jsx("div", {
                        className: styles$1r.profileInitials,
                        children: getInitialsForAvatar(Ls.fullName)
                    })
                }), jsxRuntimeExports.jsx(SvgInfoCircleBlue, {
                    className: styles$1r.profileIcon
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$1r.headerBalance,
                children: [jsxRuntimeExports.jsx(SvgTonIcon, {
                    className: styles$1r.headerBalanceIcon
                }), jsxRuntimeExports.jsx("span", {
                    className: styles$1r.headerBalanceAmount,
                    children: formatNanotons(Cn, !0)
                }), jsxRuntimeExports.jsxs("div", {
                    className: styles$1r.headerWalletTooltipWrapper,
                    children: [jsxRuntimeExports.jsx(Button, {
                        onClick: xl,
                        size: "small",
                        iconButton: !0,
                        children: jsxRuntimeExports.jsx(SvgAddWallet, {
                            className: styles$1r.headerIcon
                        })
                    }), ba && jsxRuntimeExports.jsx(Tooltip, {
                        translationKey: "Wallet connected"
                    })]
                })]
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$1r.headerRight,
            children: [jsxRuntimeExports.jsx(Button, {
                onClick: wl,
                size: "small",
                iconButton: !0,
                children: jsxRuntimeExports.jsx(SvgSupport, {
                    className: styles$1r.headerIconMedium
                })
            }), jsxRuntimeExports.jsx(Badge, {
                content: cs,
                children: jsxRuntimeExports.jsx(Button, {
                    onClick: () => Cs(ModalNames.CART),
                    size: "small",
                    iconButton: !0,
                    children: jsxRuntimeExports.jsx(SvgCart, {
                        className: styles$1r.headerIcon
                    })
                })
            })]
        })]
    })
}
  , tabs$1 = "_tabs_5a5rv_1"
  , tabsWrapper$2 = "_tabsWrapper_5a5rv_6"
  , tab$1 = "_tab_5a5rv_1"
  , active$3 = "_active_5a5rv_26"
  , indicator$1 = "_indicator_5a5rv_31"
  , tooltipWrapper$6 = "_tooltipWrapper_5a5rv_41"
  , styles$1n = {
    tabs: tabs$1,
    tabsWrapper: tabsWrapper$2,
    tab: tab$1,
    active: active$3,
    indicator: indicator$1,
    tooltipWrapper: tooltipWrapper$6
}
  , StickersTab = () => {
    const {showTooltip: xt, setShowTooltip: Cn} = useStorage(as => as.stickers);
    return reactExports.useEffect( () => {
        xt && setTimeout( () => Cn(!1), 1e3)
    }
    , [xt]),
    jsxRuntimeExports.jsx("div", {
        className: styles$1n.tooltipWrapper,
        children: xt && jsxRuntimeExports.jsx(Tooltip, {
            translationKey: "tab_stickers_onboarding",
            position: "top"
        })
    })
}
  , TABS_DATA = [{
    name: "tab_market",
    path: "/"
}, {
    name: "tab_stickers",
    path: "/stickers"
}, {
    name: "tab_mygifts",
    path: "/my-gifts"
}, {
    name: "tab_giveaway",
    path: "/giveaways"
}, {
    name: "tab_feed",
    path: "/feed"
}]
  , NavBar = () => {
    const xt = useLocation()
      , Cn = useNavigate()
      , {t: as} = useTranslation()
      , cs = reactExports.useRef({})
      , Cs = reactExports.useRef(null)
      , Ls = reactExports.useRef(!1)
      , {currentPath: Vs, previousPath: Ws, setPath: Xs, lastKnownPositions: ga, updatePositions: ba, shouldUpdatePath: yl, setShouldUpdatePath: xl} = useStorage(Ll => Ll.navigation)
      , {setShowTooltip: wl} = useStorage(Ll => Ll.stickers)
      , [_l,El] = reactExports.useState({})
      , [Cl,$l] = reactExports.useState(null)
      , [Sl,Tl] = reactExports.useState(null);
    reactExports.useEffect( () => {
        xt.pathname !== Vs ? yl ? (Xs(xt.pathname),
        Cn(Vs),
        Xs(Vs)) : Xs(xt.pathname) : xl(!1)
    }
    , [xt.pathname, Vs, Xs, yl]);
    const Rl = reactExports.useCallback( () => {
        const Ll = Cs.current;
        if (!Ll)
            return;
        const Fl = Ll.getBoundingClientRect()
          , Ul = {};
        Object.entries(cs.current).forEach( ([Dl,Zl]) => {
            if (Zl) {
                const Gl = Zl.getBoundingClientRect();
                Ul[Dl] = {
                    left: Gl.left - Fl.left,
                    width: Gl.width
                }
            }
        }
        ),
        El(Ul),
        Ls.current || ba(Ul)
    }
    , [ba])
      , Il = Ll => TABS_DATA.some(Fl => Fl.path === Ll);
    reactExports.useEffect( () => {
        Rl();
        const Ll = () => {
            Rl()
        }
        ;
        return window.addEventListener("resize", Ll),
        () => window.removeEventListener("resize", Ll)
    }
    , [Rl]),
    reactExports.useEffect( () => {
        const Ll = setTimeout(Rl, 50);
        return () => clearTimeout(Ll)
    }
    , [Rl]),
    reactExports.useEffect( () => {
        if (!Ls.current && Il(Vs)) {
            const Ll = _l[Vs] || ga[Vs]
              , Fl = Il(Ws) ? _l[Ws] || ga[Ws] : void 0;
            Ll && (Tl(Fl || Ll),
            $l(Ll))
        } else
            Tl(null),
            $l(null)
    }
    , [Vs, Ws, _l, ga]);
    const Ml = reactExports.useCallback(Ll => {
        var Fl;
        if (Ll === "/stickers") {
            wl(!0);
            return
        }
        if (Vs !== Ll) {
            wl(!1);
            const Ul = _l[Ll] || ga[Ll];
            let Dl = Il(Vs) ? _l[Vs] || ga[Vs] : null;
            if (!Dl) {
                const Zl = (Fl = TABS_DATA[0]) == null ? void 0 : Fl.path;
                Dl = _l[Zl] || ga[Zl]
            }
            Ul && Dl && (Ls.current = !0,
            Tl(Dl),
            $l(Ul)),
            Cn(Ll)
        }
    }
    , [Vs, Cn, _l, ga])
      , Nl = () => {
        Ls.current = !1,
        Rl()
    }
    ;
    return jsxRuntimeExports.jsx("div", {
        className: styles$1n.tabs,
        children: jsxRuntimeExports.jsxs("div", {
            className: styles$1n.tabsWrapper,
            ref: Cs,
            children: [TABS_DATA.map(Ll => jsxRuntimeExports.jsxs("div", {
                ref: Fl => cs.current[Ll.path] = Fl,
                className: `${styles$1n.tab} ${Vs === Ll.path ? styles$1n.active : ""}`,
                onClick: () => Ml(Ll.path),
                children: [as(Ll.name), Ll.path === "/stickers" && jsxRuntimeExports.jsx(StickersTab, {})]
            }, Ll.path)), jsxRuntimeExports.jsx(AnimatePresence, {
                children: Il(Vs) && Cl && jsxRuntimeExports.jsx(motion.div, {
                    className: styles$1n.indicator,
                    initial: Sl ? {
                        x: Sl.left,
                        width: Sl.width,
                        opacity: 1
                    } : !1,
                    animate: {
                        x: Cl.left,
                        width: Cl.width,
                        opacity: 1
                    },
                    transition: {
                        type: "spring",
                        stiffness: 1e3,
                        damping: 100
                    },
                    onAnimationComplete: Nl
                })
            })]
        })
    })
}
  , listControls = "_listControls_11uk0_1"
  , clickableIcon = "_clickableIcon_11uk0_7"
  , styles$1m = {
    listControls,
    clickableIcon
}
  , SvgLens = xt => reactExports.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 22 22",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("g", {
    id: "Outline_24px"
}, reactExports.createElement("g", {
    id: "Group"
}, reactExports.createElement("path", {
    id: "Vector",
    d: "M10.5862 15.1723C13.119 15.1723 15.1723 13.119 15.1723 10.5862C15.1723 8.05329 13.119 6 10.5862 6C8.05329 6 6 8.05329 6 10.5862C6 13.119 8.05329 15.1723 10.5862 15.1723Z",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_2",
    d: "M17 17L13.8269 13.8269",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))))
  , input$4 = "_input_3pwhx_1"
  , inputField = "_inputField_3pwhx_10"
  , inputIcon$2 = "_inputIcon_3pwhx_30"
  , inputWrapper$2 = "_inputWrapper_3pwhx_42"
  , inputError$3 = "_inputError_3pwhx_49"
  , styles$1l = {
    input: input$4,
    inputField,
    inputIcon: inputIcon$2,
    inputWrapper: inputWrapper$2,
    inputError: inputError$3
};
function debounce(xt, Cn) {
    let as = null;
    const cs = (...Cs) => {
        as && clearTimeout(as),
        as = setTimeout( () => {
            xt(...Cs)
        }
        , Cn)
    }
    ;
    return cs.cancel = () => {
        as && (clearTimeout(as),
        as = null)
    }
    ,
    cs
}
const Input = ({placeholder: xt="", onChange: Cn, onValidate: as, icon: cs, className: Cs, containerClassName: Ls, maxLength: Vs=11, maxDecimalDigits: Ws=1 / 0, error: Xs, inputMode: ga="text", ...ba}) => {
    const yl = reactExports.useRef(as);
    reactExports.useEffect( () => {
        yl.current = as
    }
    , [as]);
    const xl = reactExports.useCallback(debounce(_l => {
        var El;
        (El = yl.current) == null || El.call(yl, _l)
    }
    , 500), [])
      , wl = _l => {
        const El = _l.target.value;
        if (ga !== "text") {
            if (El === "" || /^\d*[.,]?\d*$/.test(El)) {
                const [,Cl=""] = El.replace(",", ".").split(".");
                if (Cl.length > Ws)
                    return;
                Vs && El.length <= Vs ? (_l.target.value = El,
                Cn == null || Cn(_l)) : El.length > Vs && (_l.target.value = El.slice(0, Vs),
                Cn == null || Cn(_l)),
                xl(_l.target.value)
            }
        } else
            Cn == null || Cn(_l)
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: classNames$1(styles$1l.input, Ls),
        children: [jsxRuntimeExports.jsxs("div", {
            className: styles$1l.inputWrapper,
            children: [jsxRuntimeExports.jsx("input", {
                className: classNames$1(styles$1l.inputField, Cs),
                placeholder: xt,
                onChange: wl,
                inputMode: ga,
                ...ba
            }), cs && jsxRuntimeExports.jsx("div", {
                className: styles$1l.inputIcon,
                children: cs
            })]
        }), !!Xs && jsxRuntimeExports.jsx("span", {
            className: styles$1l.inputError,
            children: Xs
        })]
    })
}
;
function useDebouncedValue(xt, Cn, as={
    leading: !1
}) {
    const [cs,Cs] = reactExports.useState(xt)
      , Ls = reactExports.useRef(!1)
      , Vs = reactExports.useRef(null)
      , Ws = reactExports.useRef(!1)
      , Xs = () => window.clearTimeout(Vs.current);
    return reactExports.useEffect( () => {
        Ls.current && (!Ws.current && as.leading ? (Ws.current = !0,
        Cs(xt)) : (Xs(),
        Vs.current = window.setTimeout( () => {
            Ws.current = !1,
            Cs(xt)
        }
        , Cn)))
    }
    , [xt, as.leading, Cn]),
    reactExports.useEffect( () => (Ls.current = !0,
    Xs), []),
    [cs, Xs]
}
function useDisclosure(xt=!1, Cn) {
    const {onOpen: as, onClose: cs} = {}
      , [Cs,Ls] = reactExports.useState(xt)
      , Vs = reactExports.useCallback( () => {
        Ls(ga => ga || (as == null || as(),
        !0))
    }
    , [as])
      , Ws = reactExports.useCallback( () => {
        Ls(ga => ga && (cs == null || cs(),
        !1))
    }
    , [cs])
      , Xs = reactExports.useCallback( () => {
        Cs ? Ws() : Vs()
    }
    , [Ws, Vs, Cs]);
    return [Cs, {
        open: Vs,
        close: Ws,
        toggle: Xs
    }]
}
function useTimeout(xt, Cn, as={
    autoInvoke: !1
}) {
    const cs = reactExports.useRef(null)
      , Cs = reactExports.useCallback( (...Vs) => {
        cs.current || (cs.current = window.setTimeout( () => {
            xt(Vs),
            cs.current = null
        }
        , Cn))
    }
    , [Cn])
      , Ls = reactExports.useCallback( () => {
        cs.current && (window.clearTimeout(cs.current),
        cs.current = null)
    }
    , []);
    return reactExports.useEffect( () => (as.autoInvoke && Cs(),
    Ls), [Ls, Cs]),
    {
        start: Cs,
        clear: Ls
    }
}
const primary = "_primary_13ypa_1"
  , secondary = "_secondary_13ypa_5"
  , accent = "_accent_13ypa_9"
  , spinner$1 = "_spinner_13ypa_13"
  , spin = "_spin_13ypa_13"
  , styles$1k = {
    primary,
    secondary,
    accent,
    spinner: spinner$1,
    spin
}
  , Spinner = ({color: xt="primary", size: Cn=24, className: as}) => jsxRuntimeExports.jsx("div", {
    className: styles$1k[xt],
    children: jsxRuntimeExports.jsx(SvgSpinner, {
        className: classNames$1(styles$1k.spinner, as),
        style: {
            width: Cn,
            height: Cn
        }
    })
})
  , Searchbar = () => {
    const {t: xt} = useTranslation()
      , {minQueryLength: Cn, maxQueryLength: as, setQuery: cs, query: Cs} = useStorage(Cl => ({
        addModal: Cl.modal.addModal,
        minQueryLength: Cl.app.minQueryLength,
        maxQueryLength: Cl.app.maxQueryLength,
        setQuery: Cl.filters.setQuery,
        query: Cl.filters.query
    }))
      , Ls = useQueryClient()
      , [Vs,Ws] = reactExports.useState(Cs || "")
      , [Xs] = useDebouncedValue(Vs, 100)
      , [ga,ba] = reactExports.useState(!1)
      , yl = reactExports.useRef(null);
    reactExports.useEffect( () => {
        const Cl = () => Ls.isFetching({
            queryKey: [QueryKeys.gifts]
        }) > 0 || Ls.isFetching({
            queryKey: [QueryKeys.myGifts]
        }) > 0 || Ls.isFetching({
            queryKey: [QueryKeys.promotions]
        }) > 0;
        ba(Cl());
        const $l = Ls.getQueryCache().subscribe( () => {
            ba(Cl())
        }
        );
        return () => {
            $l()
        }
    }
    , [Ls]);
    const xl = Cl => {
        const $l = Cl.target.value;
        $l.length <= as && Ws($l)
    }
      , wl = () => {
        if (yl.current) {
            const Cl = yl.current.querySelector("input");
            Cl instanceof HTMLInputElement && Cl.focus()
        }
    }
      , _l = () => {
        if (Ws(""),
        cs(null),
        yl.current) {
            const Cl = yl.current.querySelector("input");
            Cl instanceof HTMLInputElement && Cl.focus()
        }
    }
    ;
    reactExports.useEffect( () => {
        Xs.length < Cn ? cs(null) : Xs.length >= Cn && cs(Xs)
    }
    , [Xs, Cn, cs]);
    const El = () => ga ? jsxRuntimeExports.jsx(Spinner, {
        size: 12
    }) : Vs.length > 0 ? jsxRuntimeExports.jsx(ClearButton, {
        onClick: _l
    }) : jsxRuntimeExports.jsx(SvgLens, {
        onClick: wl,
        className: styles$1m.clickableIcon
    });
    return jsxRuntimeExports.jsx("div", {
        className: styles$1m.listControls,
        ref: yl,
        children: jsxRuntimeExports.jsx(Input, {
            placeholder: xt("filter_input_tooltip"),
            icon: El(),
            onChange: xl,
            value: Vs,
            maxLength: as,
            inputMode: "text",
            id: "search-input"
        })
    })
}
  , ClearButton = ({onClick: xt}) => jsxRuntimeExports.jsxs("div", {
    onClick: xt,
    style: {
        width: 12,
        height: 12,
        position: "relative",
        cursor: "pointer"
    },
    children: [jsxRuntimeExports.jsx("div", {
        style: {
            position: "absolute",
            width: "100%",
            height: "1px",
            backgroundColor: "#7E7E82",
            top: "50%",
            transform: "rotate(45deg)"
        }
    }), jsxRuntimeExports.jsx("div", {
        style: {
            position: "absolute",
            width: "100%",
            height: "1px",
            backgroundColor: "#7E7E82",
            top: "50%",
            transform: "rotate(-45deg)"
        }
    })]
})
  , SvgCloseIcon = xt => reactExports.createElement("svg", {
    width: 20,
    height: 21,
    viewBox: "0 0 20 21",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("g", {
    id: "Line / Bot Close Icon"
}, reactExports.createElement("path", {
    id: "Vector 294",
    d: "M6 6.5L10 10.5M10 10.5L14 14.5M10 10.5L14 6.5M10 10.5L6 14.5",
    stroke: "#7E7E82",
    strokeLinecap: "round",
    strokeLinejoin: "round"
})))
  , SvgChevronDown = xt => reactExports.createElement("svg", {
    width: 12,
    height: 12,
    viewBox: "0 0 12 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M10 4L6.0597 8L2 4",
    stroke: "#7E7E82",
    strokeLinecap: "round"
}))
  , filterChips = "_filterChips_1b5aq_1"
  , filterChipsWrapper = "_filterChipsWrapper_1b5aq_9"
  , listControlsIcon = "_listControlsIcon_1b5aq_19"
  , filterChip = "_filterChip_1b5aq_1"
  , active$2 = "_active_1b5aq_40"
  , clearFilterIcon = "_clearFilterIcon_1b5aq_45"
  , expandFilterIcon = "_expandFilterIcon_1b5aq_54"
  , styles$1j = {
    filterChips,
    filterChipsWrapper,
    listControlsIcon,
    filterChip,
    active: active$2,
    clearFilterIcon,
    expandFilterIcon
}
  , FilterChip = ({name: xt, count: Cn, onClear: as, onClick: cs}) => {
    const {t: Cs} = useTranslation()
      , Ls = Cn !== 0
      , Vs = Ws => {
        Ws.stopPropagation(),
        as()
    }
    ;
    return jsxRuntimeExports.jsxs(motion.div, {
        onClick: cs,
        className: classNames$1(styles$1j.filterChip, {
            [styles$1j.active]: Ls
        }),
        children: [jsxRuntimeExports.jsx("span", {
            children: Cs(xt)
        }), Ls && jsxRuntimeExports.jsx("span", {
            children: `(${Cn})`
        }), Ls ? jsxRuntimeExports.jsx(SvgCloseIcon, {
            className: styles$1j.clearFilterIcon,
            onClick: Vs
        }) : jsxRuntimeExports.jsx(SvgChevronDown, {
            className: styles$1j.expandFilterIcon
        })]
    })
}
  , fetchCollections = async () => {
    try {
        return await (await fetch(getApiUrl("/api/v1/gifts/collections"), {
            method: "GET"
        })).json()
    } catch (xt) {
        return console.error("Error while fetching collections", xt),
        null
    }
}
  , fetchModels = async xt => {
    try {
        return xt.length === 0 ? [] : await (await fetch(getApiUrl("/api/v1/gifts/models"), {
            method: "POST",
            body: JSON.stringify({
                collections: xt
            }),
            headers: {
                "Content-Type": "application/json"
            }
        })).json()
    } catch {
        return null
    }
}
  , fetchBackdrops = async xt => {
    try {
        return await (await fetch(getApiUrl("/api/v1/gifts/backdrops"), {
            method: "POST",
            body: JSON.stringify({
                collections: xt
            }),
            headers: {
                "Content-Type": "application/json"
            }
        })).json()
    } catch {
        return null
    }
}
  , fetchSymbols = async xt => {
    try {
        return await (await fetch(getApiUrl("/api/v1/gifts/symbols"), {
            method: "POST",
            body: JSON.stringify({
                collections: xt
            }),
            headers: {
                "Content-Type": "application/json"
            }
        })).json()
    } catch {
        return null
    }
}
;
function uniqBy(xt, Cn) {
    const as = typeof Cn == "function" ? Cn : cs => cs[Cn];
    return [...xt.reduce( (cs, Cs) => {
        const Ls = Cs == null ? Cs : as(Cs);
        return cs.has(Ls) || cs.set(Ls, Cs),
        cs
    }
    , new Map).values()]
}
const collectionsQueryOptions = () => ({
    queryKey: [QueryKeys.collections],
    queryFn: () => fetchCollections()
})
  , modelsQueryOptions = xt => ({
    queryKey: [QueryKeys.models, xt],
    queryFn: () => fetchModels(xt ?? []),
    placeholderData: keepPreviousData
})
  , backdropsQueryOptions = xt => ({
    queryKey: [QueryKeys.backdrops, xt],
    queryFn: () => fetchBackdrops(xt ?? []),
    placeholderData: keepPreviousData,
    select: Cn => Cn && uniqBy(Cn, as => as.backdropName)
})
  , symbolsQueryOptions = xt => ({
    queryKey: [QueryKeys.symbols, xt],
    queryFn: () => fetchSymbols(xt ?? []),
    placeholderData: keepPreviousData,
    select: Cn => Cn && uniqBy(Cn, as => as.symbolName)
})
  , useFiltersCount = xt => {
    const Cn = useStorage(ga => ga.filters.filters)
      , as = reactExports.useMemo( () => Cn.collectionNames.length, [Cn])
      , cs = reactExports.useMemo( () => Cn.modelNames.length, [Cn])
      , Cs = reactExports.useMemo( () => Cn.backdropNames.length, [Cn])
      , Ls = reactExports.useMemo( () => {
        var ga;
        return (ga = Cn.symbolNames) == null ? void 0 : ga.length
    }
    , [Cn])
      , Vs = reactExports.useMemo( () => +(Cn.maxPrice !== null) + +(Cn.minPrice !== null), [Cn])
      , Ws = reactExports.useMemo( () => Array.isArray(Cn.type) ? Cn.type.length : 0, [Cn])
      , Xs = reactExports.useMemo( () => xt ? as !== 0 || cs !== 0 || Cs !== 0 || Ws !== 0 : as !== 0 || cs !== 0 || Cs !== 0 || Ls !== 0 || Vs !== 0 || Cn.mintable !== null, [as, cs, Cs, Ls, Vs, Ws, Cn, xt]);
    return {
        collectionsCount: as,
        modelsCount: cs,
        backdropsCount: Cs,
        symbolsCount: Ls,
        priceCount: Vs,
        dirty: Xs
    }
}
  , useUpdateModelsByNFT = () => {
    const {filters: xt, setFilters: Cn} = useStorage(Cs => Cs.filters)
      , {collectionNames: as} = xt
      , {data: cs} = useQuery(modelsQueryOptions(as));
    reactExports.useEffect( () => {
        Array.isArray(cs) && Cn({
            ...xt,
            modelNames: xt.modelNames.filter(Cs => cs.find(Ls => Ls.modelName === Cs))
        })
    }
    , [cs])
}
  , SvgSetting = xt => reactExports.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("g", {
    id: "setting-4"
}, reactExports.createElement("g", {
    id: "vuesax/linear/setting-4"
}, reactExports.createElement("g", {
    id: "setting-4_2"
}, reactExports.createElement("path", {
    id: "Vector",
    d: "M18.3334 5.41666H13.3334",
    stroke: "#0A84FF",
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_2",
    d: "M4.99996 5.41666H1.66663",
    stroke: "#0A84FF",
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_3",
    d: "M8.33329 8.33333C9.94412 8.33333 11.25 7.0275 11.25 5.41667C11.25 3.80584 9.94412 2.5 8.33329 2.5C6.72246 2.5 5.41663 3.80584 5.41663 5.41667C5.41663 7.0275 6.72246 8.33333 8.33329 8.33333Z",
    stroke: "#0A84FF",
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_4",
    d: "M18.3333 14.5833H15",
    stroke: "#0A84FF",
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_5",
    d: "M6.66663 14.5833H1.66663",
    stroke: "#0A84FF",
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_6",
    d: "M11.6667 17.5C13.2775 17.5 14.5833 16.1942 14.5833 14.5833C14.5833 12.9725 13.2775 11.6667 11.6667 11.6667C10.0558 11.6667 8.75 12.9725 8.75 14.5833C8.75 16.1942 10.0558 17.5 11.6667 17.5Z",
    stroke: "#0A84FF",
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
})))))
  , SvgSort = xt => reactExports.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M2.5 5.83331H17.5",
    stroke: "currentColor",
    strokeLinecap: "round"
}), reactExports.createElement("path", {
    d: "M5 10H15",
    stroke: "currentColor",
    strokeLinecap: "round"
}), reactExports.createElement("path", {
    d: "M8.33337 14.1667H11.6667",
    stroke: "currentColor",
    strokeLinecap: "round"
}))
  , marketFilters = ["filter_nft", "filter_model", "filter_backdrop", "filter_symbol", "filter_price"]
  , feedFilters = ["filter_nft", "filter_model", "filter_backdrop"]
  , FilterChips = () => {
    const xt = useLocation()
      , {t: Cn} = useTranslation()
      , as = reactExports.useMemo( () => xt.pathname.includes("/feed"), [xt.pathname])
      , {ordering: cs, lowToHigh: Cs, resetCollections: Ls, resetModels: Vs, resetBackdrops: Ws, resetSymbols: Xs, resetPrice: ga} = useStorage(Il => as ? {
        ordering: Il.filters.feedOrdering,
        lowToHigh: Il.filters.feedLowToHigh,
        resetCollections: Il.filters.resetCollections,
        resetModels: Il.filters.resetModels,
        resetBackdrops: Il.filters.resetBackdrops,
        resetSymbols: void 0,
        resetPrice: void 0
    } : {
        ordering: Il.filters.ordering,
        lowToHigh: Il.filters.lowToHigh,
        resetCollections: Il.filters.resetCollections,
        resetModels: Il.filters.resetModels,
        resetBackdrops: Il.filters.resetBackdrops,
        resetSymbols: Il.filters.resetSymbols,
        resetPrice: Il.filters.resetPrice
    })
      , {addModal: ba} = useStorage(Il => Il.modal)
      , yl = useFiltersCount(as)
      , {collectionsCount: xl, modelsCount: wl, backdropsCount: _l, symbolsCount: El, priceCount: Cl, dirty: $l} = {
        collectionsCount: yl.collectionsCount,
        modelsCount: yl.modelsCount,
        backdropsCount: yl.backdropsCount,
        symbolsCount: "symbolsCount"in yl ? Number(yl.symbolsCount) : 0,
        priceCount: "priceCount"in yl ? Number(yl.priceCount) : 0,
        dirty: yl.dirty
    }
      , Sl = reactExports.useRef(null)
      , Tl = reactExports.useMemo( () => as ? feedFilters : marketFilters, [as])
      , Rl = reactExports.useMemo( () => {
        const Il = () => {}
        ;
        return [{
            name: "filter_nft",
            count: xl,
            onClick: () => ba(ModalNames.FILTERS_COLLECTION),
            onClear: Ls,
            show: Tl.includes("filter_nft")
        }, {
            name: "filter_model",
            count: wl,
            onClick: () => ba(ModalNames.FILTERS_MODEL),
            onClear: Vs,
            show: Tl.includes("filter_model")
        }, {
            name: "filter_backdrop",
            count: _l,
            onClick: () => ba(ModalNames.FILTERS_BACKDROP),
            onClear: Ws,
            show: Tl.includes("filter_backdrop")
        }, {
            name: "filter_symbol",
            count: El,
            onClick: () => ba(ModalNames.FILTERS_SYMBOL),
            onClear: Xs || Il,
            show: Tl.includes("filter_symbol") && !!Xs
        }, {
            name: "filter_price",
            count: Cl,
            onClick: () => ba(ModalNames.FILTERS_PRICE),
            onClear: ga || Il,
            show: Tl.includes("filter_price") && !!ga
        }].sort( (Nl, Ll) => Math.sign(Ll.count) - Math.sign(Nl.count))
    }
    , [xl, wl, _l, El, Cl, Ls, Vs, Ws, Xs, ga, ba, Tl, as]);
    return useUpdateModelsByNFT(),
    jsxRuntimeExports.jsx(motion.div, {
        ref: Sl,
        className: styles$1j.filterChipsWrapper,
        onWheel: Il => {
            Sl.current && (Sl.current.scrollLeft += Il.deltaY)
        }
        ,
        children: jsxRuntimeExports.jsxs("div", {
            className: styles$1j.filterChips,
            children: [jsxRuntimeExports.jsx(Button, {
                onClick: () => ba(as ? ModalNames.FEED_SORT : ModalNames.SORT),
                size: "small",
                iconButton: !0,
                variant: cs === GiftOrdering.None && !Cs ? "secondary" : "primary",
                children: jsxRuntimeExports.jsx(SvgSort, {
                    className: styles$1j.listControlsIcon
                })
            }), jsxRuntimeExports.jsx(Button, {
                onClick: () => ba(as ? ModalNames.FEED_FILTERS_ALL : ModalNames.FILTERS_ALL),
                size: "small",
                iconButton: !0,
                variant: $l ? "primary" : "secondary",
                children: jsxRuntimeExports.jsx(SvgSetting, {
                    className: styles$1j.listControlsIcon
                })
            }), Rl.map(Il => jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                children: Il.show && jsxRuntimeExports.jsx(FilterChip, {
                    name: Cn(Il.name),
                    count: Il.count,
                    onClick: Il.onClick,
                    onClear: Il.onClear
                }, Il.name)
            }))]
        })
    })
}
  , pagesWithSearchbar = ["/my-gifts", "/auction", "/"]
  , pagesWithFilters = ["/my-gifts", "/auction", "/", "/feed"]
  , Page = ({children: xt, back: Cn}) => {
    const as = useNavigate()
      , cs = useLocation()
      , {addBackButtonHandler: Cs, removeBackButtonHandler: Ls, resetFilters: Vs} = useStorage(ga => ({
        addBackButtonHandler: ga.backButton.addBackButtonHandler,
        removeBackButtonHandler: ga.backButton.removeBackButtonHandler,
        modal: ga.modal,
        resetFilters: ga.filters.resetFilters
    }));
    reactExports.useEffect( () => {
        if (Cn) {
            const ga = () => as(-1);
            return Cs(HANDLER_NAMES.PAGE_BACK_HANDLER, ga),
            () => {
                Ls(HANDLER_NAMES.PAGE_BACK_HANDLER)
            }
        } else
            Ls(HANDLER_NAMES.PAGE_BACK_HANDLER)
    }
    , [Cn, as, Cs, Ls]),
    reactExports.useEffect( () => {
        window.scrollTo(0, 0)
    }
    , [cs.pathname]);
    const Ws = pagesWithSearchbar.includes(cs.pathname)
      , Xs = pagesWithFilters.includes(cs.pathname);
    return jsxRuntimeExports.jsxs("div", {
        className: styles$1s.page,
        children: [jsxRuntimeExports.jsxs("div", {
            className: classNames$1(styles$1s.pageHeadersWrapper, isMobile() && styles$1s.safeArea),
            children: [jsxRuntimeExports.jsx(Header, {}), jsxRuntimeExports.jsx(NavBar, {}), (Ws || Xs) && jsxRuntimeExports.jsxs("div", {
                className: styles$1s.pageControlsWrapper,
                children: [Ws && jsxRuntimeExports.jsx(Searchbar, {}), Xs && jsxRuntimeExports.jsx(FilterChips, {})]
            })]
        }), jsxRuntimeExports.jsx("div", {
            className: classNames$1(styles$1s.pageContentWrapper, isMobile() && styles$1s.safeArea),
            children: xt
        })]
    })
}
  , Auction = () => jsxRuntimeExports.jsx(Page, {
    back: !1,
    children: "Auction"
})
  , segmentedControl = "_segmentedControl_15a9l_1"
  , segment = "_segment_15a9l_1"
  , segmentContent = "_segmentContent_15a9l_22"
  , active$1 = "_active_15a9l_40"
  , activeBackground = "_activeBackground_15a9l_45"
  , styles$1i = {
    segmentedControl,
    segment,
    segmentContent,
    active: active$1,
    activeBackground
}
  , SegmentedTabs = ({tabs: xt, activeKey: Cn, onChange: as, className: cs=""}) => {
    const Cs = (Vs, Ws) => {
        as(Vs)
    }
      , {t: Ls} = useTranslation();
    return jsxRuntimeExports.jsx("div", {
        className: `${styles$1i.segmentedControl} ${cs}`,
        children: xt.map(Vs => jsxRuntimeExports.jsxs("div", {
            className: `${styles$1i.segment} ${Cn === Vs.key ? styles$1i.active : ""}`,
            onClick: Ws => Cs(Vs.key),
            children: [Cn === Vs.key && jsxRuntimeExports.jsx(motion.div, {
                className: styles$1i.activeBackground
            }), jsxRuntimeExports.jsx("div", {
                className: styles$1i.segmentContent,
                children: jsxRuntimeExports.jsx("span", {
                    children: Ls(Vs.label)
                })
            })]
        }, Vs.key))
    })
}
  , giveawayPageContainer = "_giveawayPageContainer_fsxjz_1"
  , tabsWrapper$1 = "_tabsWrapper_fsxjz_12"
  , tabsContentWrapper = "_tabsContentWrapper_fsxjz_20"
  , styles$1h = {
    giveawayPageContainer,
    tabsWrapper: tabsWrapper$1,
    tabsContentWrapper
}
  , item$2 = "_item_1spk8_1"
  , header$3 = "_header_1spk8_12"
  , giveawayByText = "_giveawayByText_1spk8_20"
  , channelName = "_channelName_1spk8_27"
  , content$8 = "_content_1spk8_36"
  , imageContainer$1 = "_imageContainer_1spk8_44"
  , info$4 = "_info_1spk8_59"
  , infoRow = "_infoRow_1spk8_70"
  , infoRowSpaceBetween = "_infoRowSpaceBetween_1spk8_80"
  , infoLabel = "_infoLabel_1spk8_91"
  , infoValue = "_infoValue_1spk8_98"
  , currencyContainer = "_currencyContainer_1spk8_105"
  , tonAmount = "_tonAmount_1spk8_112"
  , iconTon = "_iconTon_1spk8_120"
  , buyButton$1 = "_buyButton_1spk8_136"
  , secondaryButtonText$1 = "_secondaryButtonText_1spk8_140"
  , errorButtonText = "_errorButtonText_1spk8_144"
  , freeText = "_freeText_1spk8_152"
  , devider = "_devider_1spk8_162"
  , styles$1g = {
    item: item$2,
    header: header$3,
    giveawayByText,
    channelName,
    content: content$8,
    imageContainer: imageContainer$1,
    info: info$4,
    infoRow,
    infoRowSpaceBetween,
    infoLabel,
    infoValue,
    currencyContainer,
    tonAmount,
    iconTon,
    buyButton: buyButton$1,
    secondaryButtonText: secondaryButtonText$1,
    errorButtonText,
    freeText,
    devider
}
  , giftItem$1 = "_giftItem_1ytml_2"
  , giftItemChipsContainer = "_giftItemChipsContainer_1ytml_21"
  , giftItemMyGiftChip = "_giftItemMyGiftChip_1ytml_30"
  , giftItemGiveawayChip = "_giftItemGiveawayChip_1ytml_30"
  , giftThumbnail = "_giftThumbnail_1ytml_59"
  , styles$1f = {
    giftItem: giftItem$1,
    giftItemChipsContainer,
    giftItemMyGiftChip,
    giftItemGiveawayChip,
    giftThumbnail
};
function ownKeys$1(xt, Cn) {
    var as = Object.keys(xt);
    if (Object.getOwnPropertySymbols) {
        var cs = Object.getOwnPropertySymbols(xt);
        Cn && (cs = cs.filter(function(Cs) {
            return Object.getOwnPropertyDescriptor(xt, Cs).enumerable
        })),
        as.push.apply(as, cs)
    }
    return as
}
function _objectSpread2$1(xt) {
    for (var Cn = 1; Cn < arguments.length; Cn++) {
        var as = arguments[Cn] != null ? arguments[Cn] : {};
        Cn % 2 ? ownKeys$1(Object(as), !0).forEach(function(cs) {
            _defineProperty$1(xt, cs, as[cs])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(xt, Object.getOwnPropertyDescriptors(as)) : ownKeys$1(Object(as)).forEach(function(cs) {
            Object.defineProperty(xt, cs, Object.getOwnPropertyDescriptor(as, cs))
        })
    }
    return xt
}
function asyncGeneratorStep(xt, Cn, as, cs, Cs, Ls, Vs) {
    try {
        var Ws = xt[Ls](Vs)
          , Xs = Ws.value
    } catch (ga) {
        return void as(ga)
    }
    Ws.done ? Cn(Xs) : Promise.resolve(Xs).then(cs, Cs)
}
function _asyncToGenerator(xt) {
    return function() {
        var Cn = this
          , as = arguments;
        return new Promise(function(cs, Cs) {
            var Ls = xt.apply(Cn, as);
            function Vs(Xs) {
                asyncGeneratorStep(Ls, cs, Cs, Vs, Ws, "next", Xs)
            }
            function Ws(Xs) {
                asyncGeneratorStep(Ls, cs, Cs, Vs, Ws, "throw", Xs)
            }
            Vs(void 0)
        }
        )
    }
}
function _defineProperty$1(xt, Cn, as) {
    return Cn in xt ? Object.defineProperty(xt, Cn, {
        value: as,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : xt[Cn] = as,
    xt
}
function _taggedTemplateLiteral(xt, Cn) {
    return Cn || (Cn = xt.slice(0)),
    Object.freeze(Object.defineProperties(xt, {
        raw: {
            value: Object.freeze(Cn)
        }
    }))
}
function __decorate(xt, Cn, as, cs) {
    var Cs, Ls = arguments.length, Vs = Ls < 3 ? Cn : cs;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        Vs = Reflect.decorate(xt, Cn, as, cs);
    else
        for (var Ws = xt.length - 1; Ws >= 0; Ws--)
            (Cs = xt[Ws]) && (Vs = (Ls < 3 ? Cs(Vs) : Ls > 3 ? Cs(Cn, as, Vs) : Cs(Cn, as)) || Vs);
    return Ls > 3 && Vs && Object.defineProperty(Cn, as, Vs),
    Vs
}
var t$3$1 = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets"in Document.prototype && "replace"in CSSStyleSheet.prototype
  , e$8 = Symbol()
  , n$5$1 = new Map;
let s$3$1 = class {
    constructor(Cn, as) {
        if (this._$cssResult$ = !0,
        as !== e$8)
            throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = Cn
    }
    get styleSheet() {
        var Cn = n$5$1.get(this.cssText);
        return t$3$1 && Cn === void 0 && (n$5$1.set(this.cssText, Cn = new CSSStyleSheet),
        Cn.replaceSync(this.cssText)),
        Cn
    }
    toString() {
        return this.cssText
    }
}
;
var o$5$1 = xt => new s$3$1(typeof xt == "string" ? xt : xt + "",e$8), r$3$1 = function(xt) {
    for (var Cn = arguments.length, as = new Array(Cn > 1 ? Cn - 1 : 0), cs = 1; cs < Cn; cs++)
        as[cs - 1] = arguments[cs];
    var Cs = xt.length === 1 ? xt[0] : as.reduce( (Ls, Vs, Ws) => Ls + (Xs => {
        if (Xs._$cssResult$ === !0)
            return Xs.cssText;
        if (typeof Xs == "number")
            return Xs;
        throw Error("Value passed to 'css' function must be a 'css' function result: " + Xs + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")
    }
    )(Vs) + xt[Ws + 1], xt[0]);
    return new s$3$1(Cs,e$8)
}, i$3$1 = (xt, Cn) => {
    t$3$1 ? xt.adoptedStyleSheets = Cn.map(as => as instanceof CSSStyleSheet ? as : as.styleSheet) : Cn.forEach(as => {
        var cs = document.createElement("style")
          , Cs = window.litNonce;
        Cs !== void 0 && cs.setAttribute("nonce", Cs),
        cs.textContent = as.cssText,
        xt.appendChild(cs)
    }
    )
}
, S$1$1 = t$3$1 ? xt => xt : xt => xt instanceof CSSStyleSheet ? (Cn => {
    var as = "";
    for (var cs of Cn.cssRules)
        as += cs.cssText;
    return o$5$1(as)
}
)(xt) : xt, s$2$1, e$7 = window.trustedTypes, r$2$1 = e$7 ? e$7.emptyScript : "", h$2$1 = window.reactiveElementPolyfillSupport, o$4$1 = {
    toAttribute(xt, Cn) {
        switch (Cn) {
        case Boolean:
            xt = xt ? r$2$1 : null;
            break;
        case Object:
        case Array:
            xt = xt == null ? xt : JSON.stringify(xt)
        }
        return xt
    },
    fromAttribute(xt, Cn) {
        var as = xt;
        switch (Cn) {
        case Boolean:
            as = xt !== null;
            break;
        case Number:
            as = xt === null ? null : Number(xt);
            break;
        case Object:
        case Array:
            try {
                as = JSON.parse(xt)
            } catch {
                as = null
            }
        }
        return as
    }
}, n$4$1 = (xt, Cn) => Cn !== xt && (Cn == Cn || xt == xt), l$3$1 = {
    attribute: !0,
    type: String,
    converter: o$4$1,
    reflect: !1,
    hasChanged: n$4$1
}, t$2$1;
let a$1$1 = class extends HTMLElement {
    constructor() {
        super(),
        this._$Et = new Map,
        this.isUpdatePending = !1,
        this.hasUpdated = !1,
        this._$Ei = null,
        this.o()
    }
    static addInitializer(Cn) {
        var as;
        (as = this.l) !== null && as !== void 0 || (this.l = []),
        this.l.push(Cn)
    }
    static get observedAttributes() {
        this.finalize();
        var Cn = [];
        return this.elementProperties.forEach( (as, cs) => {
            var Cs = this._$Eh(cs, as);
            Cs !== void 0 && (this._$Eu.set(Cs, cs),
            Cn.push(Cs))
        }
        ),
        Cn
    }
    static createProperty(Cn) {
        var as = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : l$3$1;
        if (as.state && (as.attribute = !1),
        this.finalize(),
        this.elementProperties.set(Cn, as),
        !as.noAccessor && !this.prototype.hasOwnProperty(Cn)) {
            var cs = typeof Cn == "symbol" ? Symbol() : "__" + Cn
              , Cs = this.getPropertyDescriptor(Cn, cs, as);
            Cs !== void 0 && Object.defineProperty(this.prototype, Cn, Cs)
        }
    }
    static getPropertyDescriptor(Cn, as, cs) {
        return {
            get() {
                return this[as]
            },
            set(Cs) {
                var Ls = this[Cn];
                this[as] = Cs,
                this.requestUpdate(Cn, Ls, cs)
            },
            configurable: !0,
            enumerable: !0
        }
    }
    static getPropertyOptions(Cn) {
        return this.elementProperties.get(Cn) || l$3$1
    }
    static finalize() {
        if (this.hasOwnProperty("finalized"))
            return !1;
        this.finalized = !0;
        var Cn = Object.getPrototypeOf(this);
        if (Cn.finalize(),
        this.elementProperties = new Map(Cn.elementProperties),
        this._$Eu = new Map,
        this.hasOwnProperty("properties")) {
            var as = this.properties
              , cs = [...Object.getOwnPropertyNames(as), ...Object.getOwnPropertySymbols(as)];
            for (var Cs of cs)
                this.createProperty(Cs, as[Cs])
        }
        return this.elementStyles = this.finalizeStyles(this.styles),
        !0
    }
    static finalizeStyles(Cn) {
        var as = [];
        if (Array.isArray(Cn)) {
            var cs = new Set(Cn.flat(1 / 0).reverse());
            for (var Cs of cs)
                as.unshift(S$1$1(Cs))
        } else
            Cn !== void 0 && as.push(S$1$1(Cn));
        return as
    }
    static _$Eh(Cn, as) {
        var cs = as.attribute;
        return cs === !1 ? void 0 : typeof cs == "string" ? cs : typeof Cn == "string" ? Cn.toLowerCase() : void 0
    }
    o() {
        var Cn;
        this._$Ep = new Promise(as => this.enableUpdating = as),
        this._$AL = new Map,
        this._$Em(),
        this.requestUpdate(),
        (Cn = this.constructor.l) === null || Cn === void 0 || Cn.forEach(as => as(this))
    }
    addController(Cn) {
        var as, cs;
        ((as = this._$Eg) !== null && as !== void 0 ? as : this._$Eg = []).push(Cn),
        this.renderRoot !== void 0 && this.isConnected && ((cs = Cn.hostConnected) === null || cs === void 0 || cs.call(Cn))
    }
    removeController(Cn) {
        var as;
        (as = this._$Eg) === null || as === void 0 || as.splice(this._$Eg.indexOf(Cn) >>> 0, 1)
    }
    _$Em() {
        this.constructor.elementProperties.forEach( (Cn, as) => {
            this.hasOwnProperty(as) && (this._$Et.set(as, this[as]),
            delete this[as])
        }
        )
    }
    createRenderRoot() {
        var Cn, as = (Cn = this.shadowRoot) !== null && Cn !== void 0 ? Cn : this.attachShadow(this.constructor.shadowRootOptions);
        return i$3$1(as, this.constructor.elementStyles),
        as
    }
    connectedCallback() {
        var Cn;
        this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()),
        this.enableUpdating(!0),
        (Cn = this._$Eg) === null || Cn === void 0 || Cn.forEach(as => {
            var cs;
            return (cs = as.hostConnected) === null || cs === void 0 ? void 0 : cs.call(as)
        }
        )
    }
    enableUpdating(Cn) {}
    disconnectedCallback() {
        var Cn;
        (Cn = this._$Eg) === null || Cn === void 0 || Cn.forEach(as => {
            var cs;
            return (cs = as.hostDisconnected) === null || cs === void 0 ? void 0 : cs.call(as)
        }
        )
    }
    attributeChangedCallback(Cn, as, cs) {
        this._$AK(Cn, cs)
    }
    _$ES(Cn, as) {
        var cs, Cs, Ls = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : l$3$1, Vs = this.constructor._$Eh(Cn, Ls);
        if (Vs !== void 0 && Ls.reflect === !0) {
            var Ws = ((Cs = (cs = Ls.converter) === null || cs === void 0 ? void 0 : cs.toAttribute) !== null && Cs !== void 0 ? Cs : o$4$1.toAttribute)(as, Ls.type);
            this._$Ei = Cn,
            Ws == null ? this.removeAttribute(Vs) : this.setAttribute(Vs, Ws),
            this._$Ei = null
        }
    }
    _$AK(Cn, as) {
        var cs, Cs, Ls, Vs = this.constructor, Ws = Vs._$Eu.get(Cn);
        if (Ws !== void 0 && this._$Ei !== Ws) {
            var Xs = Vs.getPropertyOptions(Ws)
              , ga = Xs.converter
              , ba = (Ls = (Cs = (cs = ga) === null || cs === void 0 ? void 0 : cs.fromAttribute) !== null && Cs !== void 0 ? Cs : typeof ga == "function" ? ga : null) !== null && Ls !== void 0 ? Ls : o$4$1.fromAttribute;
            this._$Ei = Ws,
            this[Ws] = ba(as, Xs.type),
            this._$Ei = null
        }
    }
    requestUpdate(Cn, as, cs) {
        var Cs = !0;
        Cn !== void 0 && (((cs = cs || this.constructor.getPropertyOptions(Cn)).hasChanged || n$4$1)(this[Cn], as) ? (this._$AL.has(Cn) || this._$AL.set(Cn, as),
        cs.reflect === !0 && this._$Ei !== Cn && (this._$E_ === void 0 && (this._$E_ = new Map),
        this._$E_.set(Cn, cs))) : Cs = !1),
        !this.isUpdatePending && Cs && (this._$Ep = this._$EC())
    }
    _$EC() {
        var Cn = this;
        return _asyncToGenerator(function*() {
            Cn.isUpdatePending = !0;
            try {
                yield Cn._$Ep
            } catch (cs) {
                Promise.reject(cs)
            }
            var as = Cn.scheduleUpdate();
            return as != null && (yield as),
            !Cn.isUpdatePending
        })()
    }
    scheduleUpdate() {
        return this.performUpdate()
    }
    performUpdate() {
        var Cn;
        if (this.isUpdatePending) {
            this.hasUpdated,
            this._$Et && (this._$Et.forEach( (Cs, Ls) => this[Ls] = Cs),
            this._$Et = void 0);
            var as = !1
              , cs = this._$AL;
            try {
                (as = this.shouldUpdate(cs)) ? (this.willUpdate(cs),
                (Cn = this._$Eg) === null || Cn === void 0 || Cn.forEach(Cs => {
                    var Ls;
                    return (Ls = Cs.hostUpdate) === null || Ls === void 0 ? void 0 : Ls.call(Cs)
                }
                ),
                this.update(cs)) : this._$EU()
            } catch (Cs) {
                throw as = !1,
                this._$EU(),
                Cs
            }
            as && this._$AE(cs)
        }
    }
    willUpdate(Cn) {}
    _$AE(Cn) {
        var as;
        (as = this._$Eg) === null || as === void 0 || as.forEach(cs => {
            var Cs;
            return (Cs = cs.hostUpdated) === null || Cs === void 0 ? void 0 : Cs.call(cs)
        }
        ),
        this.hasUpdated || (this.hasUpdated = !0,
        this.firstUpdated(Cn)),
        this.updated(Cn)
    }
    _$EU() {
        this._$AL = new Map,
        this.isUpdatePending = !1
    }
    get updateComplete() {
        return this.getUpdateComplete()
    }
    getUpdateComplete() {
        return this._$Ep
    }
    shouldUpdate(Cn) {
        return !0
    }
    update(Cn) {
        this._$E_ !== void 0 && (this._$E_.forEach( (as, cs) => this._$ES(cs, this[cs], as)),
        this._$E_ = void 0),
        this._$EU()
    }
    updated(Cn) {}
    firstUpdated(Cn) {}
}
;
a$1$1.finalized = !0,
a$1$1.elementProperties = new Map,
a$1$1.elementStyles = [],
a$1$1.shadowRootOptions = {
    mode: "open"
},
h$2$1 == null || h$2$1({
    ReactiveElement: a$1$1
}),
((s$2$1 = globalThis.reactiveElementVersions) !== null && s$2$1 !== void 0 ? s$2$1 : globalThis.reactiveElementVersions = []).push("1.2.1");
var i$2$1 = globalThis.trustedTypes
  , s$1$1 = i$2$1 ? i$2$1.createPolicy("lit-html", {
    createHTML: xt => xt
}) : void 0
  , e$6 = "lit$".concat((Math.random() + "").slice(9), "$")
  , o$3$1 = "?" + e$6
  , n$3$1 = "<".concat(o$3$1, ">")
  , l$2$1 = document
  , h$1$1 = function() {
    var xt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return l$2$1.createComment(xt)
}
  , r$1$1 = xt => xt === null || typeof xt != "object" && typeof xt != "function"
  , d$4 = Array.isArray
  , u$8 = xt => {
    var Cn;
    return d$4(xt) || typeof ((Cn = xt) === null || Cn === void 0 ? void 0 : Cn[Symbol.iterator]) == "function"
}
  , c$7 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g
  , v$1 = /-->/g
  , a$a = />/g
  , f$a = />|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g
  , _$5 = /'/g
  , m$4 = /"/g
  , g$2 = /^(?:script|style|textarea)$/i
  , p$4 = xt => function(Cn) {
    for (var as = arguments.length, cs = new Array(as > 1 ? as - 1 : 0), Cs = 1; Cs < as; Cs++)
        cs[Cs - 1] = arguments[Cs];
    return {
        _$litType$: xt,
        strings: Cn,
        values: cs
    }
}
  , $$2 = p$4(1)
  , b$2 = Symbol.for("lit-noChange")
  , w$3 = Symbol.for("lit-nothing")
  , T$4 = new WeakMap
  , x$3 = (xt, Cn, as) => {
    var cs, Cs, Ls = (cs = as == null ? void 0 : as.renderBefore) !== null && cs !== void 0 ? cs : Cn, Vs = Ls._$litPart$;
    if (Vs === void 0) {
        var Ws = (Cs = as == null ? void 0 : as.renderBefore) !== null && Cs !== void 0 ? Cs : null;
        Ls._$litPart$ = Vs = new N$1(Cn.insertBefore(h$1$1(), Ws),Ws,void 0,as ?? {})
    }
    return Vs._$AI(xt),
    Vs
}
  , A$3 = l$2$1.createTreeWalker(l$2$1, 129, null, !1)
  , C$5 = (xt, Cn) => {
    for (var as, cs = xt.length - 1, Cs = [], Ls = Cn === 2 ? "<svg>" : "", Vs = c$7, Ws = 0; Ws < cs; Ws++) {
        for (var Xs = xt[Ws], ga = void 0, ba = void 0, yl = -1, xl = 0; xl < Xs.length && (Vs.lastIndex = xl,
        (ba = Vs.exec(Xs)) !== null); )
            xl = Vs.lastIndex,
            Vs === c$7 ? ba[1] === "!--" ? Vs = v$1 : ba[1] !== void 0 ? Vs = a$a : ba[2] !== void 0 ? (g$2.test(ba[2]) && (as = RegExp("</" + ba[2], "g")),
            Vs = f$a) : ba[3] !== void 0 && (Vs = f$a) : Vs === f$a ? ba[0] === ">" ? (Vs = as ?? c$7,
            yl = -1) : ba[1] === void 0 ? yl = -2 : (yl = Vs.lastIndex - ba[2].length,
            ga = ba[1],
            Vs = ba[3] === void 0 ? f$a : ba[3] === '"' ? m$4 : _$5) : Vs === m$4 || Vs === _$5 ? Vs = f$a : Vs === v$1 || Vs === a$a ? Vs = c$7 : (Vs = f$a,
            as = void 0);
        var wl = Vs === f$a && xt[Ws + 1].startsWith("/>") ? " " : "";
        Ls += Vs === c$7 ? Xs + n$3$1 : yl >= 0 ? (Cs.push(ga),
        Xs.slice(0, yl) + "$lit$" + Xs.slice(yl) + e$6 + wl) : Xs + e$6 + (yl === -2 ? (Cs.push(void 0),
        Ws) : wl)
    }
    var _l = Ls + (xt[cs] || "<?>") + (Cn === 2 ? "</svg>" : "");
    if (!Array.isArray(xt) || !xt.hasOwnProperty("raw"))
        throw Error("invalid template strings array");
    return [s$1$1 !== void 0 ? s$1$1.createHTML(_l) : _l, Cs]
}
;
let E$3 = class n0 {
    constructor(Cn, as) {
        var cs, {strings: Cs, _$litType$: Ls} = Cn;
        this.parts = [];
        var Vs = 0
          , Ws = 0
          , Xs = Cs.length - 1
          , ga = this.parts
          , [ba,yl] = C$5(Cs, Ls);
        if (this.el = n0.createElement(ba, as),
        A$3.currentNode = this.el.content,
        Ls === 2) {
            var xl = this.el.content
              , wl = xl.firstChild;
            wl.remove(),
            xl.append(...wl.childNodes)
        }
        for (; (cs = A$3.nextNode()) !== null && ga.length < Xs; ) {
            if (cs.nodeType === 1) {
                if (cs.hasAttributes()) {
                    var _l = [];
                    for (var El of cs.getAttributeNames())
                        if (El.endsWith("$lit$") || El.startsWith(e$6)) {
                            var Cl = yl[Ws++];
                            if (_l.push(El),
                            Cl !== void 0) {
                                var $l = cs.getAttribute(Cl.toLowerCase() + "$lit$").split(e$6)
                                  , Sl = /([.?@])?(.*)/.exec(Cl);
                                ga.push({
                                    type: 1,
                                    index: Vs,
                                    name: Sl[2],
                                    strings: $l,
                                    ctor: Sl[1] === "." ? M$4 : Sl[1] === "?" ? H$7 : Sl[1] === "@" ? I$2 : S$2
                                })
                            } else
                                ga.push({
                                    type: 6,
                                    index: Vs
                                })
                        }
                    for (var Tl of _l)
                        cs.removeAttribute(Tl)
                }
                if (g$2.test(cs.tagName)) {
                    var Rl = cs.textContent.split(e$6)
                      , Il = Rl.length - 1;
                    if (Il > 0) {
                        cs.textContent = i$2$1 ? i$2$1.emptyScript : "";
                        for (var Ml = 0; Ml < Il; Ml++)
                            cs.append(Rl[Ml], h$1$1()),
                            A$3.nextNode(),
                            ga.push({
                                type: 2,
                                index: ++Vs
                            });
                        cs.append(Rl[Il], h$1$1())
                    }
                }
            } else if (cs.nodeType === 8)
                if (cs.data === o$3$1)
                    ga.push({
                        type: 2,
                        index: Vs
                    });
                else
                    for (var Nl = -1; (Nl = cs.data.indexOf(e$6, Nl + 1)) !== -1; )
                        ga.push({
                            type: 7,
                            index: Vs
                        }),
                        Nl += e$6.length - 1;
            Vs++
        }
    }
    static createElement(Cn, as) {
        var cs = l$2$1.createElement("template");
        return cs.innerHTML = Cn,
        cs
    }
}
;
function P$5(xt, Cn) {
    var as, cs, Cs, Ls, Vs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : xt, Ws = arguments.length > 3 ? arguments[3] : void 0;
    if (Cn === b$2)
        return Cn;
    var Xs = Ws !== void 0 ? (as = Vs._$Cl) === null || as === void 0 ? void 0 : as[Ws] : Vs._$Cu
      , ga = r$1$1(Cn) ? void 0 : Cn._$litDirective$;
    return (Xs == null ? void 0 : Xs.constructor) !== ga && ((cs = Xs == null ? void 0 : Xs._$AO) === null || cs === void 0 || cs.call(Xs, !1),
    ga === void 0 ? Xs = void 0 : (Xs = new ga(xt))._$AT(xt, Vs, Ws),
    Ws !== void 0 ? ((Cs = (Ls = Vs)._$Cl) !== null && Cs !== void 0 ? Cs : Ls._$Cl = [])[Ws] = Xs : Vs._$Cu = Xs),
    Xs !== void 0 && (Cn = P$5(xt, Xs._$AS(xt, Cn.values), Xs, Ws)),
    Cn
}
let V$2 = class {
    constructor(Cn, as) {
        this.v = [],
        this._$AN = void 0,
        this._$AD = Cn,
        this._$AM = as
    }
    get parentNode() {
        return this._$AM.parentNode
    }
    get _$AU() {
        return this._$AM._$AU
    }
    p(Cn) {
        var as, {el: {content: cs}, parts: Cs} = this._$AD, Ls = ((as = Cn == null ? void 0 : Cn.creationScope) !== null && as !== void 0 ? as : l$2$1).importNode(cs, !0);
        A$3.currentNode = Ls;
        for (var Vs = A$3.nextNode(), Ws = 0, Xs = 0, ga = Cs[0]; ga !== void 0; ) {
            if (Ws === ga.index) {
                var ba = void 0;
                ga.type === 2 ? ba = new N$1(Vs,Vs.nextSibling,this,Cn) : ga.type === 1 ? ba = new ga.ctor(Vs,ga.name,ga.strings,this,Cn) : ga.type === 6 && (ba = new L$2(Vs,this,Cn)),
                this.v.push(ba),
                ga = Cs[++Xs]
            }
            Ws !== (ga == null ? void 0 : ga.index) && (Vs = A$3.nextNode(),
            Ws++)
        }
        return Ls
    }
    m(Cn) {
        var as = 0;
        for (var cs of this.v)
            cs !== void 0 && (cs.strings !== void 0 ? (cs._$AI(Cn, cs, as),
            as += cs.strings.length - 2) : cs._$AI(Cn[as])),
            as++
    }
}
  , N$1 = class r0 {
    constructor(Cn, as, cs, Cs) {
        var Ls;
        this.type = 2,
        this._$AH = w$3,
        this._$AN = void 0,
        this._$AA = Cn,
        this._$AB = as,
        this._$AM = cs,
        this.options = Cs,
        this._$Cg = (Ls = Cs == null ? void 0 : Cs.isConnected) === null || Ls === void 0 || Ls
    }
    get _$AU() {
        var Cn, as;
        return (as = (Cn = this._$AM) === null || Cn === void 0 ? void 0 : Cn._$AU) !== null && as !== void 0 ? as : this._$Cg
    }
    get parentNode() {
        var Cn = this._$AA.parentNode
          , as = this._$AM;
        return as !== void 0 && Cn.nodeType === 11 && (Cn = as.parentNode),
        Cn
    }
    get startNode() {
        return this._$AA
    }
    get endNode() {
        return this._$AB
    }
    _$AI(Cn) {
        Cn = P$5(this, Cn, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this),
        r$1$1(Cn) ? Cn === w$3 || Cn == null || Cn === "" ? (this._$AH !== w$3 && this._$AR(),
        this._$AH = w$3) : Cn !== this._$AH && Cn !== b$2 && this.$(Cn) : Cn._$litType$ !== void 0 ? this.T(Cn) : Cn.nodeType !== void 0 ? this.S(Cn) : u$8(Cn) ? this.A(Cn) : this.$(Cn)
    }
    M(Cn) {
        var as = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._$AB;
        return this._$AA.parentNode.insertBefore(Cn, as)
    }
    S(Cn) {
        this._$AH !== Cn && (this._$AR(),
        this._$AH = this.M(Cn))
    }
    $(Cn) {
        this._$AH !== w$3 && r$1$1(this._$AH) ? this._$AA.nextSibling.data = Cn : this.S(l$2$1.createTextNode(Cn)),
        this._$AH = Cn
    }
    T(Cn) {
        var as, {values: cs, _$litType$: Cs} = Cn, Ls = typeof Cs == "number" ? this._$AC(Cn) : (Cs.el === void 0 && (Cs.el = E$3.createElement(Cs.h, this.options)),
        Cs);
        if (((as = this._$AH) === null || as === void 0 ? void 0 : as._$AD) === Ls)
            this._$AH.m(cs);
        else {
            var Vs = new V$2(Ls,this)
              , Ws = Vs.p(this.options);
            Vs.m(cs),
            this.S(Ws),
            this._$AH = Vs
        }
    }
    _$AC(Cn) {
        var as = T$4.get(Cn.strings);
        return as === void 0 && T$4.set(Cn.strings, as = new E$3(Cn)),
        as
    }
    A(Cn) {
        d$4(this._$AH) || (this._$AH = [],
        this._$AR());
        var as, cs = this._$AH, Cs = 0;
        for (var Ls of Cn)
            Cs === cs.length ? cs.push(as = new r0(this.M(h$1$1()),this.M(h$1$1()),this,this.options)) : as = cs[Cs],
            as._$AI(Ls),
            Cs++;
        Cs < cs.length && (this._$AR(as && as._$AB.nextSibling, Cs),
        cs.length = Cs)
    }
    _$AR() {
        var Cn, as = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this._$AA.nextSibling, cs = arguments.length > 1 ? arguments[1] : void 0;
        for ((Cn = this._$AP) === null || Cn === void 0 || Cn.call(this, !1, !0, cs); as && as !== this._$AB; ) {
            var Cs = as.nextSibling;
            as.remove(),
            as = Cs
        }
    }
    setConnected(Cn) {
        var as;
        this._$AM === void 0 && (this._$Cg = Cn,
        (as = this._$AP) === null || as === void 0 || as.call(this, Cn))
    }
}
  , S$2 = class {
    constructor(Cn, as, cs, Cs, Ls) {
        this.type = 1,
        this._$AH = w$3,
        this._$AN = void 0,
        this.element = Cn,
        this.name = as,
        this._$AM = Cs,
        this.options = Ls,
        cs.length > 2 || cs[0] !== "" || cs[1] !== "" ? (this._$AH = Array(cs.length - 1).fill(new String),
        this.strings = cs) : this._$AH = w$3
    }
    get tagName() {
        return this.element.tagName
    }
    get _$AU() {
        return this._$AM._$AU
    }
    _$AI(Cn) {
        var as = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this
          , cs = arguments.length > 2 ? arguments[2] : void 0
          , Cs = arguments.length > 3 ? arguments[3] : void 0
          , Ls = this.strings
          , Vs = !1;
        if (Ls === void 0)
            Cn = P$5(this, Cn, as, 0),
            (Vs = !r$1$1(Cn) || Cn !== this._$AH && Cn !== b$2) && (this._$AH = Cn);
        else {
            var Ws, Xs, ga = Cn;
            for (Cn = Ls[0],
            Ws = 0; Ws < Ls.length - 1; Ws++)
                (Xs = P$5(this, ga[cs + Ws], as, Ws)) === b$2 && (Xs = this._$AH[Ws]),
                Vs || (Vs = !r$1$1(Xs) || Xs !== this._$AH[Ws]),
                Xs === w$3 ? Cn = w$3 : Cn !== w$3 && (Cn += (Xs ?? "") + Ls[Ws + 1]),
                this._$AH[Ws] = Xs
        }
        Vs && !Cs && this.k(Cn)
    }
    k(Cn) {
        Cn === w$3 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, Cn ?? "")
    }
}
  , M$4 = class extends S$2 {
    constructor() {
        super(...arguments),
        this.type = 3
    }
    k(Cn) {
        this.element[this.name] = Cn === w$3 ? void 0 : Cn
    }
}
;
var k$1 = i$2$1 ? i$2$1.emptyScript : "";
let H$7 = class extends S$2 {
    constructor() {
        super(...arguments),
        this.type = 4
    }
    k(Cn) {
        Cn && Cn !== w$3 ? this.element.setAttribute(this.name, k$1) : this.element.removeAttribute(this.name)
    }
}
  , I$2 = class extends S$2 {
    constructor(Cn, as, cs, Cs, Ls) {
        super(Cn, as, cs, Cs, Ls),
        this.type = 5
    }
    _$AI(Cn) {
        var as;
        if ((Cn = (as = P$5(this, Cn, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this, 0)) !== null && as !== void 0 ? as : w$3) !== b$2) {
            var cs = this._$AH
              , Cs = Cn === w$3 && cs !== w$3 || Cn.capture !== cs.capture || Cn.once !== cs.once || Cn.passive !== cs.passive
              , Ls = Cn !== w$3 && (cs === w$3 || Cs);
            Cs && this.element.removeEventListener(this.name, this, cs),
            Ls && this.element.addEventListener(this.name, this, Cn),
            this._$AH = Cn
        }
    }
    handleEvent(Cn) {
        var as, cs;
        typeof this._$AH == "function" ? this._$AH.call((cs = (as = this.options) === null || as === void 0 ? void 0 : as.host) !== null && cs !== void 0 ? cs : this.element, Cn) : this._$AH.handleEvent(Cn)
    }
}
  , L$2 = class {
    constructor(Cn, as, cs) {
        this.element = Cn,
        this.type = 6,
        this._$AN = void 0,
        this._$AM = as,
        this.options = cs
    }
    get _$AU() {
        return this._$AM._$AU
    }
    _$AI(Cn) {
        P$5(this, Cn)
    }
}
;
var z$2 = window.litHtmlPolyfillSupport, l$1$1, o$2$1;
z$2 == null || z$2(E$3, N$1),
((t$2$1 = globalThis.litHtmlVersions) !== null && t$2$1 !== void 0 ? t$2$1 : globalThis.litHtmlVersions = []).push("2.1.2");
let s$a = class extends a$1$1 {
    constructor() {
        super(...arguments),
        this.renderOptions = {
            host: this
        },
        this._$Dt = void 0
    }
    createRenderRoot() {
        var Cn, as, cs = super.createRenderRoot();
        return (Cn = (as = this.renderOptions).renderBefore) !== null && Cn !== void 0 || (as.renderBefore = cs.firstChild),
        cs
    }
    update(Cn) {
        var as = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected),
        super.update(Cn),
        this._$Dt = x$3(as, this.renderRoot, this.renderOptions)
    }
    connectedCallback() {
        var Cn;
        super.connectedCallback(),
        (Cn = this._$Dt) === null || Cn === void 0 || Cn.setConnected(!0)
    }
    disconnectedCallback() {
        var Cn;
        super.disconnectedCallback(),
        (Cn = this._$Dt) === null || Cn === void 0 || Cn.setConnected(!1)
    }
    render() {
        return b$2
    }
}
;
s$a.finalized = !0,
s$a._$litElement$ = !0,
(l$1$1 = globalThis.litElementHydrateSupport) === null || l$1$1 === void 0 || l$1$1.call(globalThis, {
    LitElement: s$a
});
var n$2$1 = globalThis.litElementPolyfillSupport;
n$2$1 == null || n$2$1({
    LitElement: s$a
});
((o$2$1 = globalThis.litElementVersions) !== null && o$2$1 !== void 0 ? o$2$1 : globalThis.litElementVersions = []).push("3.1.2");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var n$1$1 = xt => Cn => typeof Cn == "function" ? ( (as, cs) => (window.customElements.define(as, cs),
cs))(xt, Cn) : ( (as, cs) => {
    var {kind: Cs, elements: Ls} = cs;
    return {
        kind: Cs,
        elements: Ls,
        finisher(Vs) {
            window.customElements.define(as, Vs)
        }
    }
}
)(xt, Cn)
  , i$1$1 = (xt, Cn) => Cn.kind === "method" && Cn.descriptor && !("value"in Cn.descriptor) ? _objectSpread2$1(_objectSpread2$1({}, Cn), {}, {
    finisher(as) {
        as.createProperty(Cn.key, xt)
    }
}) : {
    kind: "field",
    key: Symbol(),
    placement: "own",
    descriptor: {},
    originalKey: Cn.key,
    initializer() {
        typeof Cn.initializer == "function" && (this[Cn.key] = Cn.initializer.call(this))
    },
    finisher(as) {
        as.createProperty(Cn.key, xt)
    }
};
function e$5$1(xt) {
    return (Cn, as) => as !== void 0 ? ( (cs, Cs, Ls) => {
        Cs.constructor.createProperty(Ls, cs)
    }
    )(xt, Cn, as) : i$1$1(xt, Cn)
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var o$1$1 = xt => {
    var {finisher: Cn, descriptor: as} = xt;
    return (cs, Cs) => {
        var Ls;
        if (Cs === void 0) {
            var Vs = (Ls = cs.originalKey) !== null && Ls !== void 0 ? Ls : cs.key
              , Ws = as != null ? {
                kind: "method",
                placement: "prototype",
                key: Vs,
                descriptor: as(cs.key)
            } : _objectSpread2$1(_objectSpread2$1({}, cs), {}, {
                key: Vs
            });
            return Cn != null && (Ws.finisher = function(ga) {
                Cn(ga, Vs)
            }
            ),
            Ws
        }
        var Xs = cs.constructor;
        as !== void 0 && Object.defineProperty(cs, Cs, as(Cs)),
        Cn == null || Cn(Xs, Cs)
    }
}
, n$6;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function i$6(xt, Cn) {
    return o$1$1({
        descriptor: as => {
            var cs = {
                get() {
                    var Cs, Ls;
                    return (Ls = (Cs = this.renderRoot) === null || Cs === void 0 ? void 0 : Cs.querySelector(xt)) !== null && Ls !== void 0 ? Ls : null
                },
                enumerable: !0,
                configurable: !0
            };
            return cs
        }
    })
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
((n$6 = window.HTMLSlotElement) === null || n$6 === void 0 ? void 0 : n$6.prototype.assignedElements) != null;
var lottie$1 = {
    exports: {}
};
(function(module, exports) {
    var factory;
    typeof navigator < "u" && (factory = function() {
        var svgNS = "http://www.w3.org/2000/svg"
          , locationHref = ""
          , _useWebWorker = !1
          , initialDefaultFrame = -999999
          , setWebWorker = function(xt) {
            _useWebWorker = !!xt
        }
          , getWebWorker = function() {
            return _useWebWorker
        }
          , setLocationHref = function(xt) {
            locationHref = xt
        }
          , getLocationHref = function() {
            return locationHref
        };
        function createTag(xt) {
            return document.createElement(xt)
        }
        function extendPrototype(xt, Cn) {
            var as, cs, Cs = xt.length;
            for (as = 0; as < Cs; as += 1)
                for (var Ls in cs = xt[as].prototype)
                    Object.prototype.hasOwnProperty.call(cs, Ls) && (Cn.prototype[Ls] = cs[Ls])
        }
        function getDescriptor(xt, Cn) {
            return Object.getOwnPropertyDescriptor(xt, Cn)
        }
        function createProxyFunction(xt) {
            function Cn() {}
            return Cn.prototype = xt,
            Cn
        }
        var audioControllerFactory = function() {
            function xt(Cn) {
                this.audios = [],
                this.audioFactory = Cn,
                this._volume = 1,
                this._isMuted = !1
            }
            return xt.prototype = {
                addAudio: function(Cn) {
                    this.audios.push(Cn)
                },
                pause: function() {
                    var Cn, as = this.audios.length;
                    for (Cn = 0; Cn < as; Cn += 1)
                        this.audios[Cn].pause()
                },
                resume: function() {
                    var Cn, as = this.audios.length;
                    for (Cn = 0; Cn < as; Cn += 1)
                        this.audios[Cn].resume()
                },
                setRate: function(Cn) {
                    var as, cs = this.audios.length;
                    for (as = 0; as < cs; as += 1)
                        this.audios[as].setRate(Cn)
                },
                createAudio: function(Cn) {
                    return this.audioFactory ? this.audioFactory(Cn) : window.Howl ? new window.Howl({
                        src: [Cn]
                    }) : {
                        isPlaying: !1,
                        play: function() {
                            this.isPlaying = !0
                        },
                        seek: function() {
                            this.isPlaying = !1
                        },
                        playing: function() {},
                        rate: function() {},
                        setVolume: function() {}
                    }
                },
                setAudioFactory: function(Cn) {
                    this.audioFactory = Cn
                },
                setVolume: function(Cn) {
                    this._volume = Cn,
                    this._updateVolume()
                },
                mute: function() {
                    this._isMuted = !0,
                    this._updateVolume()
                },
                unmute: function() {
                    this._isMuted = !1,
                    this._updateVolume()
                },
                getVolume: function() {
                    return this._volume
                },
                _updateVolume: function() {
                    var Cn, as = this.audios.length;
                    for (Cn = 0; Cn < as; Cn += 1)
                        this.audios[Cn].volume(this._volume * (this._isMuted ? 0 : 1))
                }
            },
            function() {
                return new xt
            }
        }()
          , createTypedArray = function() {
            function xt(Cn, as) {
                var cs, Cs = 0, Ls = [];
                switch (Cn) {
                case "int16":
                case "uint8c":
                    cs = 1;
                    break;
                default:
                    cs = 1.1
                }
                for (Cs = 0; Cs < as; Cs += 1)
                    Ls.push(cs);
                return Ls
            }
            return typeof Uint8ClampedArray == "function" && typeof Float32Array == "function" ? function(Cn, as) {
                return Cn === "float32" ? new Float32Array(as) : Cn === "int16" ? new Int16Array(as) : Cn === "uint8c" ? new Uint8ClampedArray(as) : xt(Cn, as)
            }
            : xt
        }();
        function createSizedArray(xt) {
            return Array.apply(null, {
                length: xt
            })
        }
        function _typeof$6(xt) {
            return _typeof$6 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Cn) {
                return typeof Cn
            }
            : function(Cn) {
                return Cn && typeof Symbol == "function" && Cn.constructor === Symbol && Cn !== Symbol.prototype ? "symbol" : typeof Cn
            }
            ,
            _typeof$6(xt)
        }
        var subframeEnabled = !0
          , expressionsPlugin = null
          , expressionsInterfaces = null
          , idPrefix$1 = ""
          , isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
          , bmPow = Math.pow
          , bmSqrt = Math.sqrt
          , bmFloor = Math.floor
          , bmMax = Math.max
          , bmMin = Math.min
          , BMMath = {};
        (function() {
            var xt, Cn = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"], as = Cn.length;
            for (xt = 0; xt < as; xt += 1)
                BMMath[Cn[xt]] = Math[Cn[xt]]
        }
        )(),
        BMMath.random = Math.random,
        BMMath.abs = function(xt) {
            if (_typeof$6(xt) === "object" && xt.length) {
                var Cn, as = createSizedArray(xt.length), cs = xt.length;
                for (Cn = 0; Cn < cs; Cn += 1)
                    as[Cn] = Math.abs(xt[Cn]);
                return as
            }
            return Math.abs(xt)
        }
        ;
        var defaultCurveSegments = 150
          , degToRads = Math.PI / 180
          , roundCorner = .5519;
        function styleDiv(xt) {
            xt.style.position = "absolute",
            xt.style.top = 0,
            xt.style.left = 0,
            xt.style.display = "block",
            xt.style.transformOrigin = "0 0",
            xt.style.webkitTransformOrigin = "0 0",
            xt.style.backfaceVisibility = "visible",
            xt.style.webkitBackfaceVisibility = "visible",
            xt.style.transformStyle = "preserve-3d",
            xt.style.webkitTransformStyle = "preserve-3d",
            xt.style.mozTransformStyle = "preserve-3d"
        }
        function BMEnterFrameEvent(xt, Cn, as, cs) {
            this.type = xt,
            this.currentTime = Cn,
            this.totalTime = as,
            this.direction = cs < 0 ? -1 : 1
        }
        function BMCompleteEvent(xt, Cn) {
            this.type = xt,
            this.direction = Cn < 0 ? -1 : 1
        }
        function BMCompleteLoopEvent(xt, Cn, as, cs) {
            this.type = xt,
            this.currentLoop = as,
            this.totalLoops = Cn,
            this.direction = cs < 0 ? -1 : 1
        }
        function BMSegmentStartEvent(xt, Cn, as) {
            this.type = xt,
            this.firstFrame = Cn,
            this.totalFrames = as
        }
        function BMDestroyEvent(xt, Cn) {
            this.type = xt,
            this.target = Cn
        }
        function BMRenderFrameErrorEvent(xt, Cn) {
            this.type = "renderFrameError",
            this.nativeError = xt,
            this.currentTime = Cn
        }
        function BMConfigErrorEvent(xt) {
            this.type = "configError",
            this.nativeError = xt
        }
        var createElementID = (_count = 0,
        function() {
            return idPrefix$1 + "__lottie_element_" + (_count += 1)
        }
        ), _count;
        function HSVtoRGB(xt, Cn, as) {
            var cs, Cs, Ls, Vs, Ws, Xs, ga, ba;
            switch (Xs = as * (1 - Cn),
            ga = as * (1 - (Ws = 6 * xt - (Vs = Math.floor(6 * xt))) * Cn),
            ba = as * (1 - (1 - Ws) * Cn),
            Vs % 6) {
            case 0:
                cs = as,
                Cs = ba,
                Ls = Xs;
                break;
            case 1:
                cs = ga,
                Cs = as,
                Ls = Xs;
                break;
            case 2:
                cs = Xs,
                Cs = as,
                Ls = ba;
                break;
            case 3:
                cs = Xs,
                Cs = ga,
                Ls = as;
                break;
            case 4:
                cs = ba,
                Cs = Xs,
                Ls = as;
                break;
            case 5:
                cs = as,
                Cs = Xs,
                Ls = ga
            }
            return [cs, Cs, Ls]
        }
        function RGBtoHSV(xt, Cn, as) {
            var cs, Cs = Math.max(xt, Cn, as), Ls = Math.min(xt, Cn, as), Vs = Cs - Ls, Ws = Cs === 0 ? 0 : Vs / Cs, Xs = Cs / 255;
            switch (Cs) {
            case Ls:
                cs = 0;
                break;
            case xt:
                cs = Cn - as + Vs * (Cn < as ? 6 : 0),
                cs /= 6 * Vs;
                break;
            case Cn:
                cs = as - xt + 2 * Vs,
                cs /= 6 * Vs;
                break;
            case as:
                cs = xt - Cn + 4 * Vs,
                cs /= 6 * Vs
            }
            return [cs, Ws, Xs]
        }
        function addSaturationToRGB(xt, Cn) {
            var as = RGBtoHSV(255 * xt[0], 255 * xt[1], 255 * xt[2]);
            return as[1] += Cn,
            as[1] > 1 ? as[1] = 1 : as[1] <= 0 && (as[1] = 0),
            HSVtoRGB(as[0], as[1], as[2])
        }
        function addBrightnessToRGB(xt, Cn) {
            var as = RGBtoHSV(255 * xt[0], 255 * xt[1], 255 * xt[2]);
            return as[2] += Cn,
            as[2] > 1 ? as[2] = 1 : as[2] < 0 && (as[2] = 0),
            HSVtoRGB(as[0], as[1], as[2])
        }
        function addHueToRGB(xt, Cn) {
            var as = RGBtoHSV(255 * xt[0], 255 * xt[1], 255 * xt[2]);
            return as[0] += Cn / 360,
            as[0] > 1 ? as[0] -= 1 : as[0] < 0 && (as[0] += 1),
            HSVtoRGB(as[0], as[1], as[2])
        }
        var rgbToHex = function() {
            var xt, Cn, as = [];
            for (xt = 0; xt < 256; xt += 1)
                Cn = xt.toString(16),
                as[xt] = Cn.length === 1 ? "0" + Cn : Cn;
            return function(cs, Cs, Ls) {
                return cs < 0 && (cs = 0),
                Cs < 0 && (Cs = 0),
                Ls < 0 && (Ls = 0),
                "#" + as[cs] + as[Cs] + as[Ls]
            }
        }()
          , setSubframeEnabled = function(xt) {
            subframeEnabled = !!xt
        }
          , getSubframeEnabled = function() {
            return subframeEnabled
        }
          , setExpressionsPlugin = function(xt) {
            expressionsPlugin = xt
        }
          , getExpressionsPlugin = function() {
            return expressionsPlugin
        }
          , setExpressionInterfaces = function(xt) {
            expressionsInterfaces = xt
        }
          , getExpressionInterfaces = function() {
            return expressionsInterfaces
        }
          , setDefaultCurveSegments = function(xt) {
            defaultCurveSegments = xt
        }
          , getDefaultCurveSegments = function() {
            return defaultCurveSegments
        }
          , setIdPrefix = function(xt) {
            idPrefix$1 = xt
        };
        function createNS(xt) {
            return document.createElementNS(svgNS, xt)
        }
        function _typeof$5(xt) {
            return _typeof$5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Cn) {
                return typeof Cn
            }
            : function(Cn) {
                return Cn && typeof Symbol == "function" && Cn.constructor === Symbol && Cn !== Symbol.prototype ? "symbol" : typeof Cn
            }
            ,
            _typeof$5(xt)
        }
        var dataManager = function() {
            var xt, Cn, as = 1, cs = [], Cs = {
                onmessage: function() {},
                postMessage: function(Xs) {
                    xt({
                        data: Xs
                    })
                }
            }, Ls = {
                postMessage: function(Xs) {
                    Cs.onmessage({
                        data: Xs
                    })
                }
            };
            function Vs() {
                Cn || (Cn = function(Xs) {
                    if (window.Worker && window.Blob && getWebWorker()) {
                        var ga = new Blob(["var _workerSelf = self; self.onmessage = ", Xs.toString()],{
                            type: "text/javascript"
                        })
                          , ba = URL.createObjectURL(ga);
                        return new Worker(ba)
                    }
                    return xt = Xs,
                    Cs
                }(function(Xs) {
                    if (Ls.dataManager || (Ls.dataManager = function() {
                        function ba(Nl, Ll) {
                            var Fl, Ul, Dl, Zl, Gl, Wl, Ql = Nl.length;
                            for (Ul = 0; Ul < Ql; Ul += 1)
                                if ("ks"in (Fl = Nl[Ul]) && !Fl.completed) {
                                    if (Fl.completed = !0,
                                    Fl.hasMask) {
                                        var cu = Fl.masksProperties;
                                        for (Zl = cu.length,
                                        Dl = 0; Dl < Zl; Dl += 1)
                                            if (cu[Dl].pt.k.i)
                                                wl(cu[Dl].pt.k);
                                            else
                                                for (Wl = cu[Dl].pt.k.length,
                                                Gl = 0; Gl < Wl; Gl += 1)
                                                    cu[Dl].pt.k[Gl].s && wl(cu[Dl].pt.k[Gl].s[0]),
                                                    cu[Dl].pt.k[Gl].e && wl(cu[Dl].pt.k[Gl].e[0])
                                    }
                                    Fl.ty === 0 ? (Fl.layers = yl(Fl.refId, Ll),
                                    ba(Fl.layers, Ll)) : Fl.ty === 4 ? xl(Fl.shapes) : Fl.ty === 5 && Il(Fl)
                                }
                        }
                        function yl(Nl, Ll) {
                            var Fl = function(Ul, Dl) {
                                for (var Zl = 0, Gl = Dl.length; Zl < Gl; ) {
                                    if (Dl[Zl].id === Ul)
                                        return Dl[Zl];
                                    Zl += 1
                                }
                                return null
                            }(Nl, Ll);
                            return Fl ? Fl.layers.__used ? JSON.parse(JSON.stringify(Fl.layers)) : (Fl.layers.__used = !0,
                            Fl.layers) : null
                        }
                        function xl(Nl) {
                            var Ll, Fl, Ul;
                            for (Ll = Nl.length - 1; Ll >= 0; Ll -= 1)
                                if (Nl[Ll].ty === "sh")
                                    if (Nl[Ll].ks.k.i)
                                        wl(Nl[Ll].ks.k);
                                    else
                                        for (Ul = Nl[Ll].ks.k.length,
                                        Fl = 0; Fl < Ul; Fl += 1)
                                            Nl[Ll].ks.k[Fl].s && wl(Nl[Ll].ks.k[Fl].s[0]),
                                            Nl[Ll].ks.k[Fl].e && wl(Nl[Ll].ks.k[Fl].e[0]);
                                else
                                    Nl[Ll].ty === "gr" && xl(Nl[Ll].it)
                        }
                        function wl(Nl) {
                            var Ll, Fl = Nl.i.length;
                            for (Ll = 0; Ll < Fl; Ll += 1)
                                Nl.i[Ll][0] += Nl.v[Ll][0],
                                Nl.i[Ll][1] += Nl.v[Ll][1],
                                Nl.o[Ll][0] += Nl.v[Ll][0],
                                Nl.o[Ll][1] += Nl.v[Ll][1]
                        }
                        function _l(Nl, Ll) {
                            var Fl = Ll ? Ll.split(".") : [100, 100, 100];
                            return Nl[0] > Fl[0] || !(Fl[0] > Nl[0]) && (Nl[1] > Fl[1] || !(Fl[1] > Nl[1]) && (Nl[2] > Fl[2] || !(Fl[2] > Nl[2]) && null))
                        }
                        var El, Cl = function() {
                            var Nl = [4, 4, 14];
                            function Ll(Fl) {
                                var Ul, Dl, Zl, Gl = Fl.length;
                                for (Ul = 0; Ul < Gl; Ul += 1)
                                    Fl[Ul].ty === 5 && (Zl = void 0,
                                    Zl = (Dl = Fl[Ul]).t.d,
                                    Dl.t.d = {
                                        k: [{
                                            s: Zl,
                                            t: 0
                                        }]
                                    })
                            }
                            return function(Fl) {
                                if (_l(Nl, Fl.v) && (Ll(Fl.layers),
                                Fl.assets)) {
                                    var Ul, Dl = Fl.assets.length;
                                    for (Ul = 0; Ul < Dl; Ul += 1)
                                        Fl.assets[Ul].layers && Ll(Fl.assets[Ul].layers)
                                }
                            }
                        }(), $l = (El = [4, 7, 99],
                        function(Nl) {
                            if (Nl.chars && !_l(El, Nl.v)) {
                                var Ll, Fl = Nl.chars.length;
                                for (Ll = 0; Ll < Fl; Ll += 1) {
                                    var Ul = Nl.chars[Ll];
                                    Ul.data && Ul.data.shapes && (xl(Ul.data.shapes),
                                    Ul.data.ip = 0,
                                    Ul.data.op = 99999,
                                    Ul.data.st = 0,
                                    Ul.data.sr = 1,
                                    Ul.data.ks = {
                                        p: {
                                            k: [0, 0],
                                            a: 0
                                        },
                                        s: {
                                            k: [100, 100],
                                            a: 0
                                        },
                                        a: {
                                            k: [0, 0],
                                            a: 0
                                        },
                                        r: {
                                            k: 0,
                                            a: 0
                                        },
                                        o: {
                                            k: 100,
                                            a: 0
                                        }
                                    },
                                    Nl.chars[Ll].t || (Ul.data.shapes.push({
                                        ty: "no"
                                    }),
                                    Ul.data.shapes[0].it.push({
                                        p: {
                                            k: [0, 0],
                                            a: 0
                                        },
                                        s: {
                                            k: [100, 100],
                                            a: 0
                                        },
                                        a: {
                                            k: [0, 0],
                                            a: 0
                                        },
                                        r: {
                                            k: 0,
                                            a: 0
                                        },
                                        o: {
                                            k: 100,
                                            a: 0
                                        },
                                        sk: {
                                            k: 0,
                                            a: 0
                                        },
                                        sa: {
                                            k: 0,
                                            a: 0
                                        },
                                        ty: "tr"
                                    })))
                                }
                            }
                        }
                        ), Sl = function() {
                            var Nl = [5, 7, 15];
                            function Ll(Fl) {
                                var Ul, Dl, Zl = Fl.length;
                                for (Ul = 0; Ul < Zl; Ul += 1)
                                    Fl[Ul].ty === 5 && (Dl = void 0,
                                    typeof (Dl = Fl[Ul].t.p).a == "number" && (Dl.a = {
                                        a: 0,
                                        k: Dl.a
                                    }),
                                    typeof Dl.p == "number" && (Dl.p = {
                                        a: 0,
                                        k: Dl.p
                                    }),
                                    typeof Dl.r == "number" && (Dl.r = {
                                        a: 0,
                                        k: Dl.r
                                    }))
                            }
                            return function(Fl) {
                                if (_l(Nl, Fl.v) && (Ll(Fl.layers),
                                Fl.assets)) {
                                    var Ul, Dl = Fl.assets.length;
                                    for (Ul = 0; Ul < Dl; Ul += 1)
                                        Fl.assets[Ul].layers && Ll(Fl.assets[Ul].layers)
                                }
                            }
                        }(), Tl = function() {
                            var Nl = [4, 1, 9];
                            function Ll(Ul) {
                                var Dl, Zl, Gl, Wl = Ul.length;
                                for (Dl = 0; Dl < Wl; Dl += 1)
                                    if (Ul[Dl].ty === "gr")
                                        Ll(Ul[Dl].it);
                                    else if (Ul[Dl].ty === "fl" || Ul[Dl].ty === "st")
                                        if (Ul[Dl].c.k && Ul[Dl].c.k[0].i)
                                            for (Gl = Ul[Dl].c.k.length,
                                            Zl = 0; Zl < Gl; Zl += 1)
                                                Ul[Dl].c.k[Zl].s && (Ul[Dl].c.k[Zl].s[0] /= 255,
                                                Ul[Dl].c.k[Zl].s[1] /= 255,
                                                Ul[Dl].c.k[Zl].s[2] /= 255,
                                                Ul[Dl].c.k[Zl].s[3] /= 255),
                                                Ul[Dl].c.k[Zl].e && (Ul[Dl].c.k[Zl].e[0] /= 255,
                                                Ul[Dl].c.k[Zl].e[1] /= 255,
                                                Ul[Dl].c.k[Zl].e[2] /= 255,
                                                Ul[Dl].c.k[Zl].e[3] /= 255);
                                        else
                                            Ul[Dl].c.k[0] /= 255,
                                            Ul[Dl].c.k[1] /= 255,
                                            Ul[Dl].c.k[2] /= 255,
                                            Ul[Dl].c.k[3] /= 255
                            }
                            function Fl(Ul) {
                                var Dl, Zl = Ul.length;
                                for (Dl = 0; Dl < Zl; Dl += 1)
                                    Ul[Dl].ty === 4 && Ll(Ul[Dl].shapes)
                            }
                            return function(Ul) {
                                if (_l(Nl, Ul.v) && (Fl(Ul.layers),
                                Ul.assets)) {
                                    var Dl, Zl = Ul.assets.length;
                                    for (Dl = 0; Dl < Zl; Dl += 1)
                                        Ul.assets[Dl].layers && Fl(Ul.assets[Dl].layers)
                                }
                            }
                        }(), Rl = function() {
                            var Nl = [4, 4, 18];
                            function Ll(Ul) {
                                var Dl, Zl, Gl;
                                for (Dl = Ul.length - 1; Dl >= 0; Dl -= 1)
                                    if (Ul[Dl].ty === "sh")
                                        if (Ul[Dl].ks.k.i)
                                            Ul[Dl].ks.k.c = Ul[Dl].closed;
                                        else
                                            for (Gl = Ul[Dl].ks.k.length,
                                            Zl = 0; Zl < Gl; Zl += 1)
                                                Ul[Dl].ks.k[Zl].s && (Ul[Dl].ks.k[Zl].s[0].c = Ul[Dl].closed),
                                                Ul[Dl].ks.k[Zl].e && (Ul[Dl].ks.k[Zl].e[0].c = Ul[Dl].closed);
                                    else
                                        Ul[Dl].ty === "gr" && Ll(Ul[Dl].it)
                            }
                            function Fl(Ul) {
                                var Dl, Zl, Gl, Wl, Ql, cu, pu = Ul.length;
                                for (Zl = 0; Zl < pu; Zl += 1) {
                                    if ((Dl = Ul[Zl]).hasMask) {
                                        var zl = Dl.masksProperties;
                                        for (Wl = zl.length,
                                        Gl = 0; Gl < Wl; Gl += 1)
                                            if (zl[Gl].pt.k.i)
                                                zl[Gl].pt.k.c = zl[Gl].cl;
                                            else
                                                for (cu = zl[Gl].pt.k.length,
                                                Ql = 0; Ql < cu; Ql += 1)
                                                    zl[Gl].pt.k[Ql].s && (zl[Gl].pt.k[Ql].s[0].c = zl[Gl].cl),
                                                    zl[Gl].pt.k[Ql].e && (zl[Gl].pt.k[Ql].e[0].c = zl[Gl].cl)
                                    }
                                    Dl.ty === 4 && Ll(Dl.shapes)
                                }
                            }
                            return function(Ul) {
                                if (_l(Nl, Ul.v) && (Fl(Ul.layers),
                                Ul.assets)) {
                                    var Dl, Zl = Ul.assets.length;
                                    for (Dl = 0; Dl < Zl; Dl += 1)
                                        Ul.assets[Dl].layers && Fl(Ul.assets[Dl].layers)
                                }
                            }
                        }();
                        function Il(Nl) {
                            Nl.t.a.length === 0 && Nl.t.p
                        }
                        var Ml = {
                            completeData: function(Nl) {
                                Nl.__complete || (Tl(Nl),
                                Cl(Nl),
                                $l(Nl),
                                Sl(Nl),
                                Rl(Nl),
                                ba(Nl.layers, Nl.assets),
                                function(Ll, Fl) {
                                    if (Ll) {
                                        var Ul = 0
                                          , Dl = Ll.length;
                                        for (Ul = 0; Ul < Dl; Ul += 1)
                                            Ll[Ul].t === 1 && (Ll[Ul].data.layers = yl(Ll[Ul].data.refId, Fl),
                                            ba(Ll[Ul].data.layers, Fl))
                                    }
                                }(Nl.chars, Nl.assets),
                                Nl.__complete = !0)
                            }
                        };
                        return Ml.checkColors = Tl,
                        Ml.checkChars = $l,
                        Ml.checkPathProperties = Sl,
                        Ml.checkShapes = Rl,
                        Ml.completeLayers = ba,
                        Ml
                    }()),
                    Ls.assetLoader || (Ls.assetLoader = function() {
                        function ba(yl) {
                            var xl = yl.getResponseHeader("content-type");
                            return xl && yl.responseType === "json" && xl.indexOf("json") !== -1 || yl.response && _typeof$5(yl.response) === "object" ? yl.response : yl.response && typeof yl.response == "string" ? JSON.parse(yl.response) : yl.responseText ? JSON.parse(yl.responseText) : null
                        }
                        return {
                            load: function(yl, xl, wl, _l) {
                                var El, Cl = new XMLHttpRequest;
                                try {
                                    Cl.responseType = "json"
                                } catch {}
                                Cl.onreadystatechange = function() {
                                    if (Cl.readyState === 4)
                                        if (Cl.status === 200)
                                            El = ba(Cl),
                                            wl(El);
                                        else
                                            try {
                                                El = ba(Cl),
                                                wl(El)
                                            } catch ($l) {
                                                _l && _l($l)
                                            }
                                }
                                ;
                                try {
                                    Cl.open(["G", "E", "T"].join(""), yl, !0)
                                } catch {
                                    Cl.open(["G", "E", "T"].join(""), xl + "/" + yl, !0)
                                }
                                Cl.send()
                            }
                        }
                    }()),
                    Xs.data.type === "loadAnimation")
                        Ls.assetLoader.load(Xs.data.path, Xs.data.fullPath, function(ba) {
                            Ls.dataManager.completeData(ba),
                            Ls.postMessage({
                                id: Xs.data.id,
                                payload: ba,
                                status: "success"
                            })
                        }, function() {
                            Ls.postMessage({
                                id: Xs.data.id,
                                status: "error"
                            })
                        });
                    else if (Xs.data.type === "complete") {
                        var ga = Xs.data.animation;
                        Ls.dataManager.completeData(ga),
                        Ls.postMessage({
                            id: Xs.data.id,
                            payload: ga,
                            status: "success"
                        })
                    } else
                        Xs.data.type === "loadData" && Ls.assetLoader.load(Xs.data.path, Xs.data.fullPath, function(ba) {
                            Ls.postMessage({
                                id: Xs.data.id,
                                payload: ba,
                                status: "success"
                            })
                        }, function() {
                            Ls.postMessage({
                                id: Xs.data.id,
                                status: "error"
                            })
                        })
                }),
                Cn.onmessage = function(Xs) {
                    var ga = Xs.data
                      , ba = ga.id
                      , yl = cs[ba];
                    cs[ba] = null,
                    ga.status === "success" ? yl.onComplete(ga.payload) : yl.onError && yl.onError()
                }
                )
            }
            function Ws(Xs, ga) {
                var ba = "processId_" + (as += 1);
                return cs[ba] = {
                    onComplete: Xs,
                    onError: ga
                },
                ba
            }
            return {
                loadAnimation: function(Xs, ga, ba) {
                    Vs();
                    var yl = Ws(ga, ba);
                    Cn.postMessage({
                        type: "loadAnimation",
                        path: Xs,
                        fullPath: window.location.origin + window.location.pathname,
                        id: yl
                    })
                },
                loadData: function(Xs, ga, ba) {
                    Vs();
                    var yl = Ws(ga, ba);
                    Cn.postMessage({
                        type: "loadData",
                        path: Xs,
                        fullPath: window.location.origin + window.location.pathname,
                        id: yl
                    })
                },
                completeAnimation: function(Xs, ga, ba) {
                    Vs();
                    var yl = Ws(ga, ba);
                    Cn.postMessage({
                        type: "complete",
                        animation: Xs,
                        id: yl
                    })
                }
            }
        }()
          , ImagePreloader = function() {
            var xt = function() {
                var Ws = createTag("canvas");
                Ws.width = 1,
                Ws.height = 1;
                var Xs = Ws.getContext("2d");
                return Xs.fillStyle = "rgba(0,0,0,0)",
                Xs.fillRect(0, 0, 1, 1),
                Ws
            }();
            function Cn() {
                this.loadedAssets += 1,
                this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
            }
            function as() {
                this.loadedFootagesCount += 1,
                this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
            }
            function cs(Ws, Xs, ga) {
                var ba = "";
                if (Ws.e)
                    ba = Ws.p;
                else if (Xs) {
                    var yl = Ws.p;
                    yl.indexOf("images/") !== -1 && (yl = yl.split("/")[1]),
                    ba = Xs + yl
                } else
                    ba = ga,
                    ba += Ws.u ? Ws.u : "",
                    ba += Ws.p;
                return ba
            }
            function Cs(Ws) {
                var Xs = 0
                  , ga = setInterval((function() {
                    (Ws.getBBox().width || Xs > 500) && (this._imageLoaded(),
                    clearInterval(ga)),
                    Xs += 1
                }
                ).bind(this), 50)
            }
            function Ls(Ws) {
                var Xs = {
                    assetData: Ws
                }
                  , ga = cs(Ws, this.assetsPath, this.path);
                return dataManager.loadData(ga, (function(ba) {
                    Xs.img = ba,
                    this._footageLoaded()
                }
                ).bind(this), (function() {
                    Xs.img = {},
                    this._footageLoaded()
                }
                ).bind(this)),
                Xs
            }
            function Vs() {
                this._imageLoaded = Cn.bind(this),
                this._footageLoaded = as.bind(this),
                this.testImageLoaded = Cs.bind(this),
                this.createFootageData = Ls.bind(this),
                this.assetsPath = "",
                this.path = "",
                this.totalImages = 0,
                this.totalFootages = 0,
                this.loadedAssets = 0,
                this.loadedFootagesCount = 0,
                this.imagesLoadedCb = null,
                this.images = []
            }
            return Vs.prototype = {
                loadAssets: function(Ws, Xs) {
                    var ga;
                    this.imagesLoadedCb = Xs;
                    var ba = Ws.length;
                    for (ga = 0; ga < ba; ga += 1)
                        Ws[ga].layers || (Ws[ga].t && Ws[ga].t !== "seq" ? Ws[ga].t === 3 && (this.totalFootages += 1,
                        this.images.push(this.createFootageData(Ws[ga]))) : (this.totalImages += 1,
                        this.images.push(this._createImageData(Ws[ga]))))
                },
                setAssetsPath: function(Ws) {
                    this.assetsPath = Ws || ""
                },
                setPath: function(Ws) {
                    this.path = Ws || ""
                },
                loadedImages: function() {
                    return this.totalImages === this.loadedAssets
                },
                loadedFootages: function() {
                    return this.totalFootages === this.loadedFootagesCount
                },
                destroy: function() {
                    this.imagesLoadedCb = null,
                    this.images.length = 0
                },
                getAsset: function(Ws) {
                    for (var Xs = 0, ga = this.images.length; Xs < ga; ) {
                        if (this.images[Xs].assetData === Ws)
                            return this.images[Xs].img;
                        Xs += 1
                    }
                    return null
                },
                createImgData: function(Ws) {
                    var Xs = cs(Ws, this.assetsPath, this.path)
                      , ga = createTag("img");
                    ga.crossOrigin = "anonymous",
                    ga.addEventListener("load", this._imageLoaded, !1),
                    ga.addEventListener("error", (function() {
                        ba.img = xt,
                        this._imageLoaded()
                    }
                    ).bind(this), !1),
                    ga.src = Xs;
                    var ba = {
                        img: ga,
                        assetData: Ws
                    };
                    return ba
                },
                createImageData: function(Ws) {
                    var Xs = cs(Ws, this.assetsPath, this.path)
                      , ga = createNS("image");
                    isSafari ? this.testImageLoaded(ga) : ga.addEventListener("load", this._imageLoaded, !1),
                    ga.addEventListener("error", (function() {
                        ba.img = xt,
                        this._imageLoaded()
                    }
                    ).bind(this), !1),
                    ga.setAttributeNS("http://www.w3.org/1999/xlink", "href", Xs),
                    this._elementHelper.append ? this._elementHelper.append(ga) : this._elementHelper.appendChild(ga);
                    var ba = {
                        img: ga,
                        assetData: Ws
                    };
                    return ba
                },
                imageLoaded: Cn,
                footageLoaded: as,
                setCacheType: function(Ws, Xs) {
                    Ws === "svg" ? (this._elementHelper = Xs,
                    this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this)
                }
            },
            Vs
        }();
        function BaseEvent() {}
        BaseEvent.prototype = {
            triggerEvent: function(xt, Cn) {
                if (this._cbs[xt])
                    for (var as = this._cbs[xt], cs = 0; cs < as.length; cs += 1)
                        as[cs](Cn)
            },
            addEventListener: function(xt, Cn) {
                return this._cbs[xt] || (this._cbs[xt] = []),
                this._cbs[xt].push(Cn),
                (function() {
                    this.removeEventListener(xt, Cn)
                }
                ).bind(this)
            },
            removeEventListener: function(xt, Cn) {
                if (Cn) {
                    if (this._cbs[xt]) {
                        for (var as = 0, cs = this._cbs[xt].length; as < cs; )
                            this._cbs[xt][as] === Cn && (this._cbs[xt].splice(as, 1),
                            as -= 1,
                            cs -= 1),
                            as += 1;
                        this._cbs[xt].length || (this._cbs[xt] = null)
                    }
                } else
                    this._cbs[xt] = null
            }
        };
        var markerParser = function() {
            function xt(Cn) {
                for (var as, cs = Cn.split(`\r
`), Cs = {}, Ls = 0, Vs = 0; Vs < cs.length; Vs += 1)
                    (as = cs[Vs].split(":")).length === 2 && (Cs[as[0]] = as[1].trim(),
                    Ls += 1);
                if (Ls === 0)
                    throw new Error;
                return Cs
            }
            return function(Cn) {
                for (var as = [], cs = 0; cs < Cn.length; cs += 1) {
                    var Cs = Cn[cs]
                      , Ls = {
                        time: Cs.tm,
                        duration: Cs.dr
                    };
                    try {
                        Ls.payload = JSON.parse(Cn[cs].cm)
                    } catch {
                        try {
                            Ls.payload = xt(Cn[cs].cm)
                        } catch {
                            Ls.payload = {
                                name: Cn[cs].cm
                            }
                        }
                    }
                    as.push(Ls)
                }
                return as
            }
        }()
          , ProjectInterface = function() {
            function xt(Cn) {
                this.compositions.push(Cn)
            }
            return function() {
                function Cn(as) {
                    for (var cs = 0, Cs = this.compositions.length; cs < Cs; ) {
                        if (this.compositions[cs].data && this.compositions[cs].data.nm === as)
                            return this.compositions[cs].prepareFrame && this.compositions[cs].data.xt && this.compositions[cs].prepareFrame(this.currentFrame),
                            this.compositions[cs].compInterface;
                        cs += 1
                    }
                    return null
                }
                return Cn.compositions = [],
                Cn.currentFrame = 0,
                Cn.registerComposition = xt,
                Cn
            }
        }()
          , renderers = {}
          , registerRenderer = function(xt, Cn) {
            renderers[xt] = Cn
        };
        function getRenderer(xt) {
            return renderers[xt]
        }
        function getRegisteredRenderer() {
            if (renderers.canvas)
                return "canvas";
            for (var xt in renderers)
                if (renderers[xt])
                    return xt;
            return ""
        }
        function _typeof$4(xt) {
            return _typeof$4 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Cn) {
                return typeof Cn
            }
            : function(Cn) {
                return Cn && typeof Symbol == "function" && Cn.constructor === Symbol && Cn !== Symbol.prototype ? "symbol" : typeof Cn
            }
            ,
            _typeof$4(xt)
        }
        var AnimationItem = function() {
            this._cbs = [],
            this.name = "",
            this.path = "",
            this.isLoaded = !1,
            this.currentFrame = 0,
            this.currentRawFrame = 0,
            this.firstFrame = 0,
            this.totalFrames = 0,
            this.frameRate = 0,
            this.frameMult = 0,
            this.playSpeed = 1,
            this.playDirection = 1,
            this.playCount = 0,
            this.animationData = {},
            this.assets = [],
            this.isPaused = !0,
            this.autoplay = !1,
            this.loop = !0,
            this.renderer = null,
            this.animationID = createElementID(),
            this.assetsPath = "",
            this.timeCompleted = 0,
            this.segmentPos = 0,
            this.isSubframeEnabled = getSubframeEnabled(),
            this.segments = [],
            this._idle = !0,
            this._completedLoop = !1,
            this.projectInterface = ProjectInterface(),
            this.imagePreloader = new ImagePreloader,
            this.audioController = audioControllerFactory(),
            this.markers = [],
            this.configAnimation = this.configAnimation.bind(this),
            this.onSetupError = this.onSetupError.bind(this),
            this.onSegmentComplete = this.onSegmentComplete.bind(this),
            this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame",0,0,0),
            this.expressionsPlugin = getExpressionsPlugin()
        };
        extendPrototype([BaseEvent], AnimationItem),
        AnimationItem.prototype.setParams = function(xt) {
            (xt.wrapper || xt.container) && (this.wrapper = xt.wrapper || xt.container);
            var Cn = "svg";
            xt.animType ? Cn = xt.animType : xt.renderer && (Cn = xt.renderer);
            var as = getRenderer(Cn);
            this.renderer = new as(this,xt.rendererSettings),
            this.imagePreloader.setCacheType(Cn, this.renderer.globalData.defs),
            this.renderer.setProjectInterface(this.projectInterface),
            this.animType = Cn,
            xt.loop === "" || xt.loop === null || xt.loop === void 0 || xt.loop === !0 ? this.loop = !0 : xt.loop === !1 ? this.loop = !1 : this.loop = parseInt(xt.loop, 10),
            this.autoplay = !("autoplay"in xt) || xt.autoplay,
            this.name = xt.name ? xt.name : "",
            this.autoloadSegments = !Object.prototype.hasOwnProperty.call(xt, "autoloadSegments") || xt.autoloadSegments,
            this.assetsPath = xt.assetsPath,
            this.initialSegment = xt.initialSegment,
            xt.audioFactory && this.audioController.setAudioFactory(xt.audioFactory),
            xt.animationData ? this.setupAnimation(xt.animationData) : xt.path && (xt.path.lastIndexOf("\\") !== -1 ? this.path = xt.path.substr(0, xt.path.lastIndexOf("\\") + 1) : this.path = xt.path.substr(0, xt.path.lastIndexOf("/") + 1),
            this.fileName = xt.path.substr(xt.path.lastIndexOf("/") + 1),
            this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")),
            dataManager.loadAnimation(xt.path, this.configAnimation, this.onSetupError))
        }
        ,
        AnimationItem.prototype.onSetupError = function() {
            this.trigger("data_failed")
        }
        ,
        AnimationItem.prototype.setupAnimation = function(xt) {
            dataManager.completeAnimation(xt, this.configAnimation)
        }
        ,
        AnimationItem.prototype.setData = function(xt, Cn) {
            Cn && _typeof$4(Cn) !== "object" && (Cn = JSON.parse(Cn));
            var as = {
                wrapper: xt,
                animationData: Cn
            }
              , cs = xt.attributes;
            as.path = cs.getNamedItem("data-animation-path") ? cs.getNamedItem("data-animation-path").value : cs.getNamedItem("data-bm-path") ? cs.getNamedItem("data-bm-path").value : cs.getNamedItem("bm-path") ? cs.getNamedItem("bm-path").value : "",
            as.animType = cs.getNamedItem("data-anim-type") ? cs.getNamedItem("data-anim-type").value : cs.getNamedItem("data-bm-type") ? cs.getNamedItem("data-bm-type").value : cs.getNamedItem("bm-type") ? cs.getNamedItem("bm-type").value : cs.getNamedItem("data-bm-renderer") ? cs.getNamedItem("data-bm-renderer").value : cs.getNamedItem("bm-renderer") ? cs.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas";
            var Cs = cs.getNamedItem("data-anim-loop") ? cs.getNamedItem("data-anim-loop").value : cs.getNamedItem("data-bm-loop") ? cs.getNamedItem("data-bm-loop").value : cs.getNamedItem("bm-loop") ? cs.getNamedItem("bm-loop").value : "";
            Cs === "false" ? as.loop = !1 : Cs === "true" ? as.loop = !0 : Cs !== "" && (as.loop = parseInt(Cs, 10));
            var Ls = cs.getNamedItem("data-anim-autoplay") ? cs.getNamedItem("data-anim-autoplay").value : cs.getNamedItem("data-bm-autoplay") ? cs.getNamedItem("data-bm-autoplay").value : !cs.getNamedItem("bm-autoplay") || cs.getNamedItem("bm-autoplay").value;
            as.autoplay = Ls !== "false",
            as.name = cs.getNamedItem("data-name") ? cs.getNamedItem("data-name").value : cs.getNamedItem("data-bm-name") ? cs.getNamedItem("data-bm-name").value : cs.getNamedItem("bm-name") ? cs.getNamedItem("bm-name").value : "",
            (cs.getNamedItem("data-anim-prerender") ? cs.getNamedItem("data-anim-prerender").value : cs.getNamedItem("data-bm-prerender") ? cs.getNamedItem("data-bm-prerender").value : cs.getNamedItem("bm-prerender") ? cs.getNamedItem("bm-prerender").value : "") === "false" && (as.prerender = !1),
            as.path ? this.setParams(as) : this.trigger("destroy")
        }
        ,
        AnimationItem.prototype.includeLayers = function(xt) {
            xt.op > this.animationData.op && (this.animationData.op = xt.op,
            this.totalFrames = Math.floor(xt.op - this.animationData.ip));
            var Cn, as, cs = this.animationData.layers, Cs = cs.length, Ls = xt.layers, Vs = Ls.length;
            for (as = 0; as < Vs; as += 1)
                for (Cn = 0; Cn < Cs; ) {
                    if (cs[Cn].id === Ls[as].id) {
                        cs[Cn] = Ls[as];
                        break
                    }
                    Cn += 1
                }
            if ((xt.chars || xt.fonts) && (this.renderer.globalData.fontManager.addChars(xt.chars),
            this.renderer.globalData.fontManager.addFonts(xt.fonts, this.renderer.globalData.defs)),
            xt.assets)
                for (Cs = xt.assets.length,
                Cn = 0; Cn < Cs; Cn += 1)
                    this.animationData.assets.push(xt.assets[Cn]);
            this.animationData.__complete = !1,
            dataManager.completeAnimation(this.animationData, this.onSegmentComplete)
        }
        ,
        AnimationItem.prototype.onSegmentComplete = function(xt) {
            this.animationData = xt;
            var Cn = getExpressionsPlugin();
            Cn && Cn.initExpressions(this),
            this.loadNextSegment()
        }
        ,
        AnimationItem.prototype.loadNextSegment = function() {
            var xt = this.animationData.segments;
            if (!xt || xt.length === 0 || !this.autoloadSegments)
                return this.trigger("data_ready"),
                void (this.timeCompleted = this.totalFrames);
            var Cn = xt.shift();
            this.timeCompleted = Cn.time * this.frameRate;
            var as = this.path + this.fileName + "_" + this.segmentPos + ".json";
            this.segmentPos += 1,
            dataManager.loadData(as, this.includeLayers.bind(this), (function() {
                this.trigger("data_failed")
            }
            ).bind(this))
        }
        ,
        AnimationItem.prototype.loadSegments = function() {
            this.animationData.segments || (this.timeCompleted = this.totalFrames),
            this.loadNextSegment()
        }
        ,
        AnimationItem.prototype.imagesLoaded = function() {
            this.trigger("loaded_images"),
            this.checkLoaded()
        }
        ,
        AnimationItem.prototype.preloadImages = function() {
            this.imagePreloader.setAssetsPath(this.assetsPath),
            this.imagePreloader.setPath(this.path),
            this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this))
        }
        ,
        AnimationItem.prototype.configAnimation = function(xt) {
            if (this.renderer)
                try {
                    this.animationData = xt,
                    this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]),
                    this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip),
                    this.firstFrame = Math.round(this.animationData.ip)),
                    this.renderer.configAnimation(xt),
                    xt.assets || (xt.assets = []),
                    this.assets = this.animationData.assets,
                    this.frameRate = this.animationData.fr,
                    this.frameMult = this.animationData.fr / 1e3,
                    this.renderer.searchExtraCompositions(xt.assets),
                    this.markers = markerParser(xt.markers || []),
                    this.trigger("config_ready"),
                    this.preloadImages(),
                    this.loadSegments(),
                    this.updaFrameModifier(),
                    this.waitForFontsLoaded(),
                    this.isPaused && this.audioController.pause()
                } catch (Cn) {
                    this.triggerConfigError(Cn)
                }
        }
        ,
        AnimationItem.prototype.waitForFontsLoaded = function() {
            this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20))
        }
        ,
        AnimationItem.prototype.checkLoaded = function() {
            if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
                this.isLoaded = !0;
                var xt = getExpressionsPlugin();
                xt && xt.initExpressions(this),
                this.renderer.initItems(),
                setTimeout((function() {
                    this.trigger("DOMLoaded")
                }
                ).bind(this), 0),
                this.gotoFrame(),
                this.autoplay && this.play()
            }
        }
        ,
        AnimationItem.prototype.resize = function(xt, Cn) {
            var as = typeof xt == "number" ? xt : void 0
              , cs = typeof Cn == "number" ? Cn : void 0;
            this.renderer.updateContainerSize(as, cs)
        }
        ,
        AnimationItem.prototype.setSubframe = function(xt) {
            this.isSubframeEnabled = !!xt
        }
        ,
        AnimationItem.prototype.gotoFrame = function() {
            this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame,
            this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted),
            this.trigger("enterFrame"),
            this.renderFrame(),
            this.trigger("drawnFrame")
        }
        ,
        AnimationItem.prototype.renderFrame = function() {
            if (this.isLoaded !== !1 && this.renderer)
                try {
                    this.expressionsPlugin && this.expressionsPlugin.resetFrame(),
                    this.renderer.renderFrame(this.currentFrame + this.firstFrame)
                } catch (xt) {
                    this.triggerRenderFrameError(xt)
                }
        }
        ,
        AnimationItem.prototype.play = function(xt) {
            xt && this.name !== xt || this.isPaused === !0 && (this.isPaused = !1,
            this.trigger("_play"),
            this.audioController.resume(),
            this._idle && (this._idle = !1,
            this.trigger("_active")))
        }
        ,
        AnimationItem.prototype.pause = function(xt) {
            xt && this.name !== xt || this.isPaused === !1 && (this.isPaused = !0,
            this.trigger("_pause"),
            this._idle = !0,
            this.trigger("_idle"),
            this.audioController.pause())
        }
        ,
        AnimationItem.prototype.togglePause = function(xt) {
            xt && this.name !== xt || (this.isPaused === !0 ? this.play() : this.pause())
        }
        ,
        AnimationItem.prototype.stop = function(xt) {
            xt && this.name !== xt || (this.pause(),
            this.playCount = 0,
            this._completedLoop = !1,
            this.setCurrentRawFrameValue(0))
        }
        ,
        AnimationItem.prototype.getMarkerData = function(xt) {
            for (var Cn, as = 0; as < this.markers.length; as += 1)
                if ((Cn = this.markers[as]).payload && Cn.payload.name === xt)
                    return Cn;
            return null
        }
        ,
        AnimationItem.prototype.goToAndStop = function(xt, Cn, as) {
            if (!as || this.name === as) {
                var cs = Number(xt);
                if (isNaN(cs)) {
                    var Cs = this.getMarkerData(xt);
                    Cs && this.goToAndStop(Cs.time, !0)
                } else
                    Cn ? this.setCurrentRawFrameValue(xt) : this.setCurrentRawFrameValue(xt * this.frameModifier);
                this.pause()
            }
        }
        ,
        AnimationItem.prototype.goToAndPlay = function(xt, Cn, as) {
            if (!as || this.name === as) {
                var cs = Number(xt);
                if (isNaN(cs)) {
                    var Cs = this.getMarkerData(xt);
                    Cs && (Cs.duration ? this.playSegments([Cs.time, Cs.time + Cs.duration], !0) : this.goToAndStop(Cs.time, !0))
                } else
                    this.goToAndStop(cs, Cn, as);
                this.play()
            }
        }
        ,
        AnimationItem.prototype.advanceTime = function(xt) {
            if (this.isPaused !== !0 && this.isLoaded !== !1) {
                var Cn = this.currentRawFrame + xt * this.frameModifier
                  , as = !1;
                Cn >= this.totalFrames - 1 && this.frameModifier > 0 ? this.loop && this.playCount !== this.loop ? Cn >= this.totalFrames ? (this.playCount += 1,
                this.checkSegments(Cn % this.totalFrames) || (this.setCurrentRawFrameValue(Cn % this.totalFrames),
                this._completedLoop = !0,
                this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(Cn) : this.checkSegments(Cn > this.totalFrames ? Cn % this.totalFrames : 0) || (as = !0,
                Cn = this.totalFrames - 1) : Cn < 0 ? this.checkSegments(Cn % this.totalFrames) || (!this.loop || this.playCount-- <= 0 && this.loop !== !0 ? (as = !0,
                Cn = 0) : (this.setCurrentRawFrameValue(this.totalFrames + Cn % this.totalFrames),
                this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0)) : this.setCurrentRawFrameValue(Cn),
                as && (this.setCurrentRawFrameValue(Cn),
                this.pause(),
                this.trigger("complete"))
            }
        }
        ,
        AnimationItem.prototype.adjustSegment = function(xt, Cn) {
            this.playCount = 0,
            xt[1] < xt[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)),
            this.totalFrames = xt[0] - xt[1],
            this.timeCompleted = this.totalFrames,
            this.firstFrame = xt[1],
            this.setCurrentRawFrameValue(this.totalFrames - .001 - Cn)) : xt[1] > xt[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)),
            this.totalFrames = xt[1] - xt[0],
            this.timeCompleted = this.totalFrames,
            this.firstFrame = xt[0],
            this.setCurrentRawFrameValue(.001 + Cn)),
            this.trigger("segmentStart")
        }
        ,
        AnimationItem.prototype.setSegment = function(xt, Cn) {
            var as = -1;
            this.isPaused && (this.currentRawFrame + this.firstFrame < xt ? as = xt : this.currentRawFrame + this.firstFrame > Cn && (as = Cn - xt)),
            this.firstFrame = xt,
            this.totalFrames = Cn - xt,
            this.timeCompleted = this.totalFrames,
            as !== -1 && this.goToAndStop(as, !0)
        }
        ,
        AnimationItem.prototype.playSegments = function(xt, Cn) {
            if (Cn && (this.segments.length = 0),
            _typeof$4(xt[0]) === "object") {
                var as, cs = xt.length;
                for (as = 0; as < cs; as += 1)
                    this.segments.push(xt[as])
            } else
                this.segments.push(xt);
            this.segments.length && Cn && this.adjustSegment(this.segments.shift(), 0),
            this.isPaused && this.play()
        }
        ,
        AnimationItem.prototype.resetSegments = function(xt) {
            this.segments.length = 0,
            this.segments.push([this.animationData.ip, this.animationData.op]),
            xt && this.checkSegments(0)
        }
        ,
        AnimationItem.prototype.checkSegments = function(xt) {
            return !!this.segments.length && (this.adjustSegment(this.segments.shift(), xt),
            !0)
        }
        ,
        AnimationItem.prototype.destroy = function(xt) {
            xt && this.name !== xt || !this.renderer || (this.renderer.destroy(),
            this.imagePreloader.destroy(),
            this.trigger("destroy"),
            this._cbs = null,
            this.onEnterFrame = null,
            this.onLoopComplete = null,
            this.onComplete = null,
            this.onSegmentStart = null,
            this.onDestroy = null,
            this.renderer = null,
            this.expressionsPlugin = null,
            this.imagePreloader = null,
            this.projectInterface = null)
        }
        ,
        AnimationItem.prototype.setCurrentRawFrameValue = function(xt) {
            this.currentRawFrame = xt,
            this.gotoFrame()
        }
        ,
        AnimationItem.prototype.setSpeed = function(xt) {
            this.playSpeed = xt,
            this.updaFrameModifier()
        }
        ,
        AnimationItem.prototype.setDirection = function(xt) {
            this.playDirection = xt < 0 ? -1 : 1,
            this.updaFrameModifier()
        }
        ,
        AnimationItem.prototype.setLoop = function(xt) {
            this.loop = xt
        }
        ,
        AnimationItem.prototype.setVolume = function(xt, Cn) {
            Cn && this.name !== Cn || this.audioController.setVolume(xt)
        }
        ,
        AnimationItem.prototype.getVolume = function() {
            return this.audioController.getVolume()
        }
        ,
        AnimationItem.prototype.mute = function(xt) {
            xt && this.name !== xt || this.audioController.mute()
        }
        ,
        AnimationItem.prototype.unmute = function(xt) {
            xt && this.name !== xt || this.audioController.unmute()
        }
        ,
        AnimationItem.prototype.updaFrameModifier = function() {
            this.frameModifier = this.frameMult * this.playSpeed * this.playDirection,
            this.audioController.setRate(this.playSpeed * this.playDirection)
        }
        ,
        AnimationItem.prototype.getPath = function() {
            return this.path
        }
        ,
        AnimationItem.prototype.getAssetsPath = function(xt) {
            var Cn = "";
            if (xt.e)
                Cn = xt.p;
            else if (this.assetsPath) {
                var as = xt.p;
                as.indexOf("images/") !== -1 && (as = as.split("/")[1]),
                Cn = this.assetsPath + as
            } else
                Cn = this.path,
                Cn += xt.u ? xt.u : "",
                Cn += xt.p;
            return Cn
        }
        ,
        AnimationItem.prototype.getAssetData = function(xt) {
            for (var Cn = 0, as = this.assets.length; Cn < as; ) {
                if (xt === this.assets[Cn].id)
                    return this.assets[Cn];
                Cn += 1
            }
            return null
        }
        ,
        AnimationItem.prototype.hide = function() {
            this.renderer.hide()
        }
        ,
        AnimationItem.prototype.show = function() {
            this.renderer.show()
        }
        ,
        AnimationItem.prototype.getDuration = function(xt) {
            return xt ? this.totalFrames : this.totalFrames / this.frameRate
        }
        ,
        AnimationItem.prototype.updateDocumentData = function(xt, Cn, as) {
            try {
                this.renderer.getElementByPath(xt).updateDocumentData(Cn, as)
            } catch {}
        }
        ,
        AnimationItem.prototype.trigger = function(xt) {
            if (this._cbs && this._cbs[xt])
                switch (xt) {
                case "enterFrame":
                    this.triggerEvent(xt, new BMEnterFrameEvent(xt,this.currentFrame,this.totalFrames,this.frameModifier));
                    break;
                case "drawnFrame":
                    this.drawnFrameEvent.currentTime = this.currentFrame,
                    this.drawnFrameEvent.totalTime = this.totalFrames,
                    this.drawnFrameEvent.direction = this.frameModifier,
                    this.triggerEvent(xt, this.drawnFrameEvent);
                    break;
                case "loopComplete":
                    this.triggerEvent(xt, new BMCompleteLoopEvent(xt,this.loop,this.playCount,this.frameMult));
                    break;
                case "complete":
                    this.triggerEvent(xt, new BMCompleteEvent(xt,this.frameMult));
                    break;
                case "segmentStart":
                    this.triggerEvent(xt, new BMSegmentStartEvent(xt,this.firstFrame,this.totalFrames));
                    break;
                case "destroy":
                    this.triggerEvent(xt, new BMDestroyEvent(xt,this));
                    break;
                default:
                    this.triggerEvent(xt)
                }
            xt === "enterFrame" && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(xt,this.currentFrame,this.totalFrames,this.frameMult)),
            xt === "loopComplete" && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(xt,this.loop,this.playCount,this.frameMult)),
            xt === "complete" && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(xt,this.frameMult)),
            xt === "segmentStart" && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(xt,this.firstFrame,this.totalFrames)),
            xt === "destroy" && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(xt,this))
        }
        ,
        AnimationItem.prototype.triggerRenderFrameError = function(xt) {
            var Cn = new BMRenderFrameErrorEvent(xt,this.currentFrame);
            this.triggerEvent("error", Cn),
            this.onError && this.onError.call(this, Cn)
        }
        ,
        AnimationItem.prototype.triggerConfigError = function(xt) {
            var Cn = new BMConfigErrorEvent(xt,this.currentFrame);
            this.triggerEvent("error", Cn),
            this.onError && this.onError.call(this, Cn)
        }
        ;
        var animationManager = function() {
            var xt = {}
              , Cn = []
              , as = 0
              , cs = 0
              , Cs = 0
              , Ls = !0
              , Vs = !1;
            function Ws(El) {
                for (var Cl = 0, $l = El.target; Cl < cs; )
                    Cn[Cl].animation === $l && (Cn.splice(Cl, 1),
                    Cl -= 1,
                    cs -= 1,
                    $l.isPaused || ba()),
                    Cl += 1
            }
            function Xs(El, Cl) {
                if (!El)
                    return null;
                for (var $l = 0; $l < cs; ) {
                    if (Cn[$l].elem === El && Cn[$l].elem !== null)
                        return Cn[$l].animation;
                    $l += 1
                }
                var Sl = new AnimationItem;
                return yl(Sl, El),
                Sl.setData(El, Cl),
                Sl
            }
            function ga() {
                Cs += 1,
                _l()
            }
            function ba() {
                Cs -= 1
            }
            function yl(El, Cl) {
                El.addEventListener("destroy", Ws),
                El.addEventListener("_active", ga),
                El.addEventListener("_idle", ba),
                Cn.push({
                    elem: Cl,
                    animation: El
                }),
                cs += 1
            }
            function xl(El) {
                var Cl, $l = El - as;
                for (Cl = 0; Cl < cs; Cl += 1)
                    Cn[Cl].animation.advanceTime($l);
                as = El,
                Cs && !Vs ? window.requestAnimationFrame(xl) : Ls = !0
            }
            function wl(El) {
                as = El,
                window.requestAnimationFrame(xl)
            }
            function _l() {
                !Vs && Cs && Ls && (window.requestAnimationFrame(wl),
                Ls = !1)
            }
            return xt.registerAnimation = Xs,
            xt.loadAnimation = function(El) {
                var Cl = new AnimationItem;
                return yl(Cl, null),
                Cl.setParams(El),
                Cl
            }
            ,
            xt.setSpeed = function(El, Cl) {
                var $l;
                for ($l = 0; $l < cs; $l += 1)
                    Cn[$l].animation.setSpeed(El, Cl)
            }
            ,
            xt.setDirection = function(El, Cl) {
                var $l;
                for ($l = 0; $l < cs; $l += 1)
                    Cn[$l].animation.setDirection(El, Cl)
            }
            ,
            xt.play = function(El) {
                var Cl;
                for (Cl = 0; Cl < cs; Cl += 1)
                    Cn[Cl].animation.play(El)
            }
            ,
            xt.pause = function(El) {
                var Cl;
                for (Cl = 0; Cl < cs; Cl += 1)
                    Cn[Cl].animation.pause(El)
            }
            ,
            xt.stop = function(El) {
                var Cl;
                for (Cl = 0; Cl < cs; Cl += 1)
                    Cn[Cl].animation.stop(El)
            }
            ,
            xt.togglePause = function(El) {
                var Cl;
                for (Cl = 0; Cl < cs; Cl += 1)
                    Cn[Cl].animation.togglePause(El)
            }
            ,
            xt.searchAnimations = function(El, Cl, $l) {
                var Sl, Tl = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))), Rl = Tl.length;
                for (Sl = 0; Sl < Rl; Sl += 1)
                    $l && Tl[Sl].setAttribute("data-bm-type", $l),
                    Xs(Tl[Sl], El);
                if (Cl && Rl === 0) {
                    $l || ($l = "svg");
                    var Il = document.getElementsByTagName("body")[0];
                    Il.innerText = "";
                    var Ml = createTag("div");
                    Ml.style.width = "100%",
                    Ml.style.height = "100%",
                    Ml.setAttribute("data-bm-type", $l),
                    Il.appendChild(Ml),
                    Xs(Ml, El)
                }
            }
            ,
            xt.resize = function() {
                var El;
                for (El = 0; El < cs; El += 1)
                    Cn[El].animation.resize()
            }
            ,
            xt.goToAndStop = function(El, Cl, $l) {
                var Sl;
                for (Sl = 0; Sl < cs; Sl += 1)
                    Cn[Sl].animation.goToAndStop(El, Cl, $l)
            }
            ,
            xt.destroy = function(El) {
                var Cl;
                for (Cl = cs - 1; Cl >= 0; Cl -= 1)
                    Cn[Cl].animation.destroy(El)
            }
            ,
            xt.freeze = function() {
                Vs = !0
            }
            ,
            xt.unfreeze = function() {
                Vs = !1,
                _l()
            }
            ,
            xt.setVolume = function(El, Cl) {
                var $l;
                for ($l = 0; $l < cs; $l += 1)
                    Cn[$l].animation.setVolume(El, Cl)
            }
            ,
            xt.mute = function(El) {
                var Cl;
                for (Cl = 0; Cl < cs; Cl += 1)
                    Cn[Cl].animation.mute(El)
            }
            ,
            xt.unmute = function(El) {
                var Cl;
                for (Cl = 0; Cl < cs; Cl += 1)
                    Cn[Cl].animation.unmute(El)
            }
            ,
            xt.getRegisteredAnimations = function() {
                var El, Cl = Cn.length, $l = [];
                for (El = 0; El < Cl; El += 1)
                    $l.push(Cn[El].animation);
                return $l
            }
            ,
            xt
        }()
          , BezierFactory = function() {
            var xt = {
                getBezierEasing: function(ba, yl, xl, wl, _l) {
                    var El = _l || ("bez_" + ba + "_" + yl + "_" + xl + "_" + wl).replace(/\./g, "p");
                    if (Cn[El])
                        return Cn[El];
                    var Cl = new ga([ba, yl, xl, wl]);
                    return Cn[El] = Cl,
                    Cl
                }
            }
              , Cn = {}
              , as = .1
              , cs = typeof Float32Array == "function";
            function Cs(ba, yl) {
                return 1 - 3 * yl + 3 * ba
            }
            function Ls(ba, yl) {
                return 3 * yl - 6 * ba
            }
            function Vs(ba) {
                return 3 * ba
            }
            function Ws(ba, yl, xl) {
                return ((Cs(yl, xl) * ba + Ls(yl, xl)) * ba + Vs(yl)) * ba
            }
            function Xs(ba, yl, xl) {
                return 3 * Cs(yl, xl) * ba * ba + 2 * Ls(yl, xl) * ba + Vs(yl)
            }
            function ga(ba) {
                this._p = ba,
                this._mSampleValues = cs ? new Float32Array(11) : new Array(11),
                this._precomputed = !1,
                this.get = this.get.bind(this)
            }
            return ga.prototype = {
                get: function(ba) {
                    var yl = this._p[0]
                      , xl = this._p[1]
                      , wl = this._p[2]
                      , _l = this._p[3];
                    return this._precomputed || this._precompute(),
                    yl === xl && wl === _l ? ba : ba === 0 ? 0 : ba === 1 ? 1 : Ws(this._getTForX(ba), xl, _l)
                },
                _precompute: function() {
                    var ba = this._p[0]
                      , yl = this._p[1]
                      , xl = this._p[2]
                      , wl = this._p[3];
                    this._precomputed = !0,
                    ba === yl && xl === wl || this._calcSampleValues()
                },
                _calcSampleValues: function() {
                    for (var ba = this._p[0], yl = this._p[2], xl = 0; xl < 11; ++xl)
                        this._mSampleValues[xl] = Ws(xl * as, ba, yl)
                },
                _getTForX: function(ba) {
                    for (var yl = this._p[0], xl = this._p[2], wl = this._mSampleValues, _l = 0, El = 1; El !== 10 && wl[El] <= ba; ++El)
                        _l += as;
                    var Cl = _l + (ba - wl[--El]) / (wl[El + 1] - wl[El]) * as
                      , $l = Xs(Cl, yl, xl);
                    return $l >= .001 ? function(Sl, Tl, Rl, Il) {
                        for (var Ml = 0; Ml < 4; ++Ml) {
                            var Nl = Xs(Tl, Rl, Il);
                            if (Nl === 0)
                                return Tl;
                            Tl -= (Ws(Tl, Rl, Il) - Sl) / Nl
                        }
                        return Tl
                    }(ba, Cl, yl, xl) : $l === 0 ? Cl : function(Sl, Tl, Rl, Il, Ml) {
                        var Nl, Ll, Fl = 0;
                        do
                            (Nl = Ws(Ll = Tl + (Rl - Tl) / 2, Il, Ml) - Sl) > 0 ? Rl = Ll : Tl = Ll;
                        while (Math.abs(Nl) > 1e-7 && ++Fl < 10);
                        return Ll
                    }(ba, _l, _l + as, yl, xl)
                }
            },
            xt
        }()
          , pooling = {
            double: function(xt) {
                return xt.concat(createSizedArray(xt.length))
            }
        }
          , poolFactory = function(xt, Cn, as) {
            var cs = 0
              , Cs = xt
              , Ls = createSizedArray(Cs);
            return {
                newElement: function() {
                    return cs ? Ls[cs -= 1] : Cn()
                },
                release: function(Vs) {
                    cs === Cs && (Ls = pooling.double(Ls),
                    Cs *= 2),
                    as && as(Vs),
                    Ls[cs] = Vs,
                    cs += 1
                }
            }
        }
          , bezierLengthPool = poolFactory(8, function() {
            return {
                addedLength: 0,
                percents: createTypedArray("float32", getDefaultCurveSegments()),
                lengths: createTypedArray("float32", getDefaultCurveSegments())
            }
        })
          , segmentsLengthPool = poolFactory(8, function() {
            return {
                lengths: [],
                totalLength: 0
            }
        }, function(xt) {
            var Cn, as = xt.lengths.length;
            for (Cn = 0; Cn < as; Cn += 1)
                bezierLengthPool.release(xt.lengths[Cn]);
            xt.lengths.length = 0
        });
        function bezFunction() {
            var xt = Math;
            function Cn(ga, ba, yl, xl, wl, _l) {
                var El = ga * xl + ba * wl + yl * _l - wl * xl - _l * ga - yl * ba;
                return El > -.001 && El < .001
            }
            var as = function(ga, ba, yl, xl) {
                var wl, _l, El, Cl, $l, Sl, Tl = getDefaultCurveSegments(), Rl = 0, Il = [], Ml = [], Nl = bezierLengthPool.newElement();
                for (El = yl.length,
                wl = 0; wl < Tl; wl += 1) {
                    for ($l = wl / (Tl - 1),
                    Sl = 0,
                    _l = 0; _l < El; _l += 1)
                        Cl = bmPow(1 - $l, 3) * ga[_l] + 3 * bmPow(1 - $l, 2) * $l * yl[_l] + 3 * (1 - $l) * bmPow($l, 2) * xl[_l] + bmPow($l, 3) * ba[_l],
                        Il[_l] = Cl,
                        Ml[_l] !== null && (Sl += bmPow(Il[_l] - Ml[_l], 2)),
                        Ml[_l] = Il[_l];
                    Sl && (Rl += Sl = bmSqrt(Sl)),
                    Nl.percents[wl] = $l,
                    Nl.lengths[wl] = Rl
                }
                return Nl.addedLength = Rl,
                Nl
            };
            function cs(ga) {
                this.segmentLength = 0,
                this.points = new Array(ga)
            }
            function Cs(ga, ba) {
                this.partialLength = ga,
                this.point = ba
            }
            var Ls, Vs = (Ls = {},
            function(ga, ba, yl, xl) {
                var wl = (ga[0] + "_" + ga[1] + "_" + ba[0] + "_" + ba[1] + "_" + yl[0] + "_" + yl[1] + "_" + xl[0] + "_" + xl[1]).replace(/\./g, "p");
                if (!Ls[wl]) {
                    var _l, El, Cl, $l, Sl, Tl, Rl, Il = getDefaultCurveSegments(), Ml = 0, Nl = null;
                    ga.length === 2 && (ga[0] !== ba[0] || ga[1] !== ba[1]) && Cn(ga[0], ga[1], ba[0], ba[1], ga[0] + yl[0], ga[1] + yl[1]) && Cn(ga[0], ga[1], ba[0], ba[1], ba[0] + xl[0], ba[1] + xl[1]) && (Il = 2);
                    var Ll = new cs(Il);
                    for (Cl = yl.length,
                    _l = 0; _l < Il; _l += 1) {
                        for (Rl = createSizedArray(Cl),
                        Sl = _l / (Il - 1),
                        Tl = 0,
                        El = 0; El < Cl; El += 1)
                            $l = bmPow(1 - Sl, 3) * ga[El] + 3 * bmPow(1 - Sl, 2) * Sl * (ga[El] + yl[El]) + 3 * (1 - Sl) * bmPow(Sl, 2) * (ba[El] + xl[El]) + bmPow(Sl, 3) * ba[El],
                            Rl[El] = $l,
                            Nl !== null && (Tl += bmPow(Rl[El] - Nl[El], 2));
                        Ml += Tl = bmSqrt(Tl),
                        Ll.points[_l] = new Cs(Tl,Rl),
                        Nl = Rl
                    }
                    Ll.segmentLength = Ml,
                    Ls[wl] = Ll
                }
                return Ls[wl]
            }
            );
            function Ws(ga, ba) {
                var yl = ba.percents
                  , xl = ba.lengths
                  , wl = yl.length
                  , _l = bmFloor((wl - 1) * ga)
                  , El = ga * ba.addedLength
                  , Cl = 0;
                if (_l === wl - 1 || _l === 0 || El === xl[_l])
                    return yl[_l];
                for (var $l = xl[_l] > El ? -1 : 1, Sl = !0; Sl; )
                    if (xl[_l] <= El && xl[_l + 1] > El ? (Cl = (El - xl[_l]) / (xl[_l + 1] - xl[_l]),
                    Sl = !1) : _l += $l,
                    _l < 0 || _l >= wl - 1) {
                        if (_l === wl - 1)
                            return yl[_l];
                        Sl = !1
                    }
                return yl[_l] + (yl[_l + 1] - yl[_l]) * Cl
            }
            var Xs = createTypedArray("float32", 8);
            return {
                getSegmentsLength: function(ga) {
                    var ba, yl = segmentsLengthPool.newElement(), xl = ga.c, wl = ga.v, _l = ga.o, El = ga.i, Cl = ga._length, $l = yl.lengths, Sl = 0;
                    for (ba = 0; ba < Cl - 1; ba += 1)
                        $l[ba] = as(wl[ba], wl[ba + 1], _l[ba], El[ba + 1]),
                        Sl += $l[ba].addedLength;
                    return xl && Cl && ($l[ba] = as(wl[ba], wl[0], _l[ba], El[0]),
                    Sl += $l[ba].addedLength),
                    yl.totalLength = Sl,
                    yl
                },
                getNewSegment: function(ga, ba, yl, xl, wl, _l, El) {
                    wl < 0 ? wl = 0 : wl > 1 && (wl = 1);
                    var Cl, $l = Ws(wl, El), Sl = Ws(_l = _l > 1 ? 1 : _l, El), Tl = ga.length, Rl = 1 - $l, Il = 1 - Sl, Ml = Rl * Rl * Rl, Nl = $l * Rl * Rl * 3, Ll = $l * $l * Rl * 3, Fl = $l * $l * $l, Ul = Rl * Rl * Il, Dl = $l * Rl * Il + Rl * $l * Il + Rl * Rl * Sl, Zl = $l * $l * Il + Rl * $l * Sl + $l * Rl * Sl, Gl = $l * $l * Sl, Wl = Rl * Il * Il, Ql = $l * Il * Il + Rl * Sl * Il + Rl * Il * Sl, cu = $l * Sl * Il + Rl * Sl * Sl + $l * Il * Sl, pu = $l * Sl * Sl, zl = Il * Il * Il, Yl = Sl * Il * Il + Il * Sl * Il + Il * Il * Sl, lu = Sl * Sl * Il + Il * Sl * Sl + Sl * Il * Sl, mu = Sl * Sl * Sl;
                    for (Cl = 0; Cl < Tl; Cl += 1)
                        Xs[4 * Cl] = xt.round(1e3 * (Ml * ga[Cl] + Nl * yl[Cl] + Ll * xl[Cl] + Fl * ba[Cl])) / 1e3,
                        Xs[4 * Cl + 1] = xt.round(1e3 * (Ul * ga[Cl] + Dl * yl[Cl] + Zl * xl[Cl] + Gl * ba[Cl])) / 1e3,
                        Xs[4 * Cl + 2] = xt.round(1e3 * (Wl * ga[Cl] + Ql * yl[Cl] + cu * xl[Cl] + pu * ba[Cl])) / 1e3,
                        Xs[4 * Cl + 3] = xt.round(1e3 * (zl * ga[Cl] + Yl * yl[Cl] + lu * xl[Cl] + mu * ba[Cl])) / 1e3;
                    return Xs
                },
                getPointInSegment: function(ga, ba, yl, xl, wl, _l) {
                    var El = Ws(wl, _l)
                      , Cl = 1 - El;
                    return [xt.round(1e3 * (Cl * Cl * Cl * ga[0] + (El * Cl * Cl + Cl * El * Cl + Cl * Cl * El) * yl[0] + (El * El * Cl + Cl * El * El + El * Cl * El) * xl[0] + El * El * El * ba[0])) / 1e3, xt.round(1e3 * (Cl * Cl * Cl * ga[1] + (El * Cl * Cl + Cl * El * Cl + Cl * Cl * El) * yl[1] + (El * El * Cl + Cl * El * El + El * Cl * El) * xl[1] + El * El * El * ba[1])) / 1e3]
                },
                buildBezierData: Vs,
                pointOnLine2D: Cn,
                pointOnLine3D: function(ga, ba, yl, xl, wl, _l, El, Cl, $l) {
                    if (yl === 0 && _l === 0 && $l === 0)
                        return Cn(ga, ba, xl, wl, El, Cl);
                    var Sl, Tl = xt.sqrt(xt.pow(xl - ga, 2) + xt.pow(wl - ba, 2) + xt.pow(_l - yl, 2)), Rl = xt.sqrt(xt.pow(El - ga, 2) + xt.pow(Cl - ba, 2) + xt.pow($l - yl, 2)), Il = xt.sqrt(xt.pow(El - xl, 2) + xt.pow(Cl - wl, 2) + xt.pow($l - _l, 2));
                    return (Sl = Tl > Rl ? Tl > Il ? Tl - Rl - Il : Il - Rl - Tl : Il > Rl ? Il - Rl - Tl : Rl - Tl - Il) > -1e-4 && Sl < 1e-4
                }
            }
        }
        var bez = bezFunction()
          , initFrame = initialDefaultFrame
          , mathAbs = Math.abs;
        function interpolateValue(xt, Cn) {
            var as, cs = this.offsetTime;
            this.propType === "multidimensional" && (as = createTypedArray("float32", this.pv.length));
            for (var Cs, Ls, Vs, Ws, Xs, ga, ba, yl, xl, wl = Cn.lastIndex, _l = wl, El = this.keyframes.length - 1, Cl = !0; Cl; ) {
                if (Cs = this.keyframes[_l],
                Ls = this.keyframes[_l + 1],
                _l === El - 1 && xt >= Ls.t - cs) {
                    Cs.h && (Cs = Ls),
                    wl = 0;
                    break
                }
                if (Ls.t - cs > xt) {
                    wl = _l;
                    break
                }
                _l < El - 1 ? _l += 1 : (wl = 0,
                Cl = !1)
            }
            Vs = this.keyframesMetadata[_l] || {};
            var $l, Sl = Ls.t - cs, Tl = Cs.t - cs;
            if (Cs.to) {
                Vs.bezierData || (Vs.bezierData = bez.buildBezierData(Cs.s, Ls.s || Cs.e, Cs.to, Cs.ti));
                var Rl = Vs.bezierData;
                if (xt >= Sl || xt < Tl) {
                    var Il = xt >= Sl ? Rl.points.length - 1 : 0;
                    for (Xs = Rl.points[Il].point.length,
                    Ws = 0; Ws < Xs; Ws += 1)
                        as[Ws] = Rl.points[Il].point[Ws]
                } else {
                    Vs.__fnct ? xl = Vs.__fnct : (xl = BezierFactory.getBezierEasing(Cs.o.x, Cs.o.y, Cs.i.x, Cs.i.y, Cs.n).get,
                    Vs.__fnct = xl),
                    ga = xl((xt - Tl) / (Sl - Tl));
                    var Ml, Nl = Rl.segmentLength * ga, Ll = Cn.lastFrame < xt && Cn._lastKeyframeIndex === _l ? Cn._lastAddedLength : 0;
                    for (yl = Cn.lastFrame < xt && Cn._lastKeyframeIndex === _l ? Cn._lastPoint : 0,
                    Cl = !0,
                    ba = Rl.points.length; Cl; ) {
                        if (Ll += Rl.points[yl].partialLength,
                        Nl === 0 || ga === 0 || yl === Rl.points.length - 1) {
                            for (Xs = Rl.points[yl].point.length,
                            Ws = 0; Ws < Xs; Ws += 1)
                                as[Ws] = Rl.points[yl].point[Ws];
                            break
                        }
                        if (Nl >= Ll && Nl < Ll + Rl.points[yl + 1].partialLength) {
                            for (Ml = (Nl - Ll) / Rl.points[yl + 1].partialLength,
                            Xs = Rl.points[yl].point.length,
                            Ws = 0; Ws < Xs; Ws += 1)
                                as[Ws] = Rl.points[yl].point[Ws] + (Rl.points[yl + 1].point[Ws] - Rl.points[yl].point[Ws]) * Ml;
                            break
                        }
                        yl < ba - 1 ? yl += 1 : Cl = !1
                    }
                    Cn._lastPoint = yl,
                    Cn._lastAddedLength = Ll - Rl.points[yl].partialLength,
                    Cn._lastKeyframeIndex = _l
                }
            } else {
                var Fl, Ul, Dl, Zl, Gl;
                if (El = Cs.s.length,
                $l = Ls.s || Cs.e,
                this.sh && Cs.h !== 1)
                    xt >= Sl ? (as[0] = $l[0],
                    as[1] = $l[1],
                    as[2] = $l[2]) : xt <= Tl ? (as[0] = Cs.s[0],
                    as[1] = Cs.s[1],
                    as[2] = Cs.s[2]) : quaternionToEuler(as, slerp(createQuaternion(Cs.s), createQuaternion($l), (xt - Tl) / (Sl - Tl)));
                else
                    for (_l = 0; _l < El; _l += 1)
                        Cs.h !== 1 && (xt >= Sl ? ga = 1 : xt < Tl ? ga = 0 : (Cs.o.x.constructor === Array ? (Vs.__fnct || (Vs.__fnct = []),
                        Vs.__fnct[_l] ? xl = Vs.__fnct[_l] : (Fl = Cs.o.x[_l] === void 0 ? Cs.o.x[0] : Cs.o.x[_l],
                        Ul = Cs.o.y[_l] === void 0 ? Cs.o.y[0] : Cs.o.y[_l],
                        Dl = Cs.i.x[_l] === void 0 ? Cs.i.x[0] : Cs.i.x[_l],
                        Zl = Cs.i.y[_l] === void 0 ? Cs.i.y[0] : Cs.i.y[_l],
                        xl = BezierFactory.getBezierEasing(Fl, Ul, Dl, Zl).get,
                        Vs.__fnct[_l] = xl)) : Vs.__fnct ? xl = Vs.__fnct : (Fl = Cs.o.x,
                        Ul = Cs.o.y,
                        Dl = Cs.i.x,
                        Zl = Cs.i.y,
                        xl = BezierFactory.getBezierEasing(Fl, Ul, Dl, Zl).get,
                        Cs.keyframeMetadata = xl),
                        ga = xl((xt - Tl) / (Sl - Tl)))),
                        $l = Ls.s || Cs.e,
                        Gl = Cs.h === 1 ? Cs.s[_l] : Cs.s[_l] + ($l[_l] - Cs.s[_l]) * ga,
                        this.propType === "multidimensional" ? as[_l] = Gl : as = Gl
            }
            return Cn.lastIndex = wl,
            as
        }
        function slerp(xt, Cn, as) {
            var cs, Cs, Ls, Vs, Ws, Xs = [], ga = xt[0], ba = xt[1], yl = xt[2], xl = xt[3], wl = Cn[0], _l = Cn[1], El = Cn[2], Cl = Cn[3];
            return (Cs = ga * wl + ba * _l + yl * El + xl * Cl) < 0 && (Cs = -Cs,
            wl = -wl,
            _l = -_l,
            El = -El,
            Cl = -Cl),
            1 - Cs > 1e-6 ? (cs = Math.acos(Cs),
            Ls = Math.sin(cs),
            Vs = Math.sin((1 - as) * cs) / Ls,
            Ws = Math.sin(as * cs) / Ls) : (Vs = 1 - as,
            Ws = as),
            Xs[0] = Vs * ga + Ws * wl,
            Xs[1] = Vs * ba + Ws * _l,
            Xs[2] = Vs * yl + Ws * El,
            Xs[3] = Vs * xl + Ws * Cl,
            Xs
        }
        function quaternionToEuler(xt, Cn) {
            var as = Cn[0]
              , cs = Cn[1]
              , Cs = Cn[2]
              , Ls = Cn[3]
              , Vs = Math.atan2(2 * cs * Ls - 2 * as * Cs, 1 - 2 * cs * cs - 2 * Cs * Cs)
              , Ws = Math.asin(2 * as * cs + 2 * Cs * Ls)
              , Xs = Math.atan2(2 * as * Ls - 2 * cs * Cs, 1 - 2 * as * as - 2 * Cs * Cs);
            xt[0] = Vs / degToRads,
            xt[1] = Ws / degToRads,
            xt[2] = Xs / degToRads
        }
        function createQuaternion(xt) {
            var Cn = xt[0] * degToRads
              , as = xt[1] * degToRads
              , cs = xt[2] * degToRads
              , Cs = Math.cos(Cn / 2)
              , Ls = Math.cos(as / 2)
              , Vs = Math.cos(cs / 2)
              , Ws = Math.sin(Cn / 2)
              , Xs = Math.sin(as / 2)
              , ga = Math.sin(cs / 2);
            return [Ws * Xs * Vs + Cs * Ls * ga, Ws * Ls * Vs + Cs * Xs * ga, Cs * Xs * Vs - Ws * Ls * ga, Cs * Ls * Vs - Ws * Xs * ga]
        }
        function getValueAtCurrentTime() {
            var xt = this.comp.renderedFrame - this.offsetTime
              , Cn = this.keyframes[0].t - this.offsetTime
              , as = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
            if (!(xt === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= as && xt >= as || this._caching.lastFrame < Cn && xt < Cn))) {
                this._caching.lastFrame >= xt && (this._caching._lastKeyframeIndex = -1,
                this._caching.lastIndex = 0);
                var cs = this.interpolateValue(xt, this._caching);
                this.pv = cs
            }
            return this._caching.lastFrame = xt,
            this.pv
        }
        function setVValue(xt) {
            var Cn;
            if (this.propType === "unidimensional")
                Cn = xt * this.mult,
                mathAbs(this.v - Cn) > 1e-5 && (this.v = Cn,
                this._mdf = !0);
            else
                for (var as = 0, cs = this.v.length; as < cs; )
                    Cn = xt[as] * this.mult,
                    mathAbs(this.v[as] - Cn) > 1e-5 && (this.v[as] = Cn,
                    this._mdf = !0),
                    as += 1
        }
        function processEffectsSequence() {
            if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length)
                if (this.lock)
                    this.setVValue(this.pv);
                else {
                    var xt;
                    this.lock = !0,
                    this._mdf = this._isFirstFrame;
                    var Cn = this.effectsSequence.length
                      , as = this.kf ? this.pv : this.data.k;
                    for (xt = 0; xt < Cn; xt += 1)
                        as = this.effectsSequence[xt](as);
                    this.setVValue(as),
                    this._isFirstFrame = !1,
                    this.lock = !1,
                    this.frameId = this.elem.globalData.frameId
                }
        }
        function addEffect(xt) {
            this.effectsSequence.push(xt),
            this.container.addDynamicProperty(this)
        }
        function ValueProperty(xt, Cn, as, cs) {
            this.propType = "unidimensional",
            this.mult = as || 1,
            this.data = Cn,
            this.v = as ? Cn.k * as : Cn.k,
            this.pv = Cn.k,
            this._mdf = !1,
            this.elem = xt,
            this.container = cs,
            this.comp = xt.comp,
            this.k = !1,
            this.kf = !1,
            this.vel = 0,
            this.effectsSequence = [],
            this._isFirstFrame = !0,
            this.getValue = processEffectsSequence,
            this.setVValue = setVValue,
            this.addEffect = addEffect
        }
        function MultiDimensionalProperty(xt, Cn, as, cs) {
            var Cs;
            this.propType = "multidimensional",
            this.mult = as || 1,
            this.data = Cn,
            this._mdf = !1,
            this.elem = xt,
            this.container = cs,
            this.comp = xt.comp,
            this.k = !1,
            this.kf = !1,
            this.frameId = -1;
            var Ls = Cn.k.length;
            for (this.v = createTypedArray("float32", Ls),
            this.pv = createTypedArray("float32", Ls),
            this.vel = createTypedArray("float32", Ls),
            Cs = 0; Cs < Ls; Cs += 1)
                this.v[Cs] = Cn.k[Cs] * this.mult,
                this.pv[Cs] = Cn.k[Cs];
            this._isFirstFrame = !0,
            this.effectsSequence = [],
            this.getValue = processEffectsSequence,
            this.setVValue = setVValue,
            this.addEffect = addEffect
        }
        function KeyframedValueProperty(xt, Cn, as, cs) {
            this.propType = "unidimensional",
            this.keyframes = Cn.k,
            this.keyframesMetadata = [],
            this.offsetTime = xt.data.st,
            this.frameId = -1,
            this._caching = {
                lastFrame: initFrame,
                lastIndex: 0,
                value: 0,
                _lastKeyframeIndex: -1
            },
            this.k = !0,
            this.kf = !0,
            this.data = Cn,
            this.mult = as || 1,
            this.elem = xt,
            this.container = cs,
            this.comp = xt.comp,
            this.v = initFrame,
            this.pv = initFrame,
            this._isFirstFrame = !0,
            this.getValue = processEffectsSequence,
            this.setVValue = setVValue,
            this.interpolateValue = interpolateValue,
            this.effectsSequence = [getValueAtCurrentTime.bind(this)],
            this.addEffect = addEffect
        }
        function KeyframedMultidimensionalProperty(xt, Cn, as, cs) {
            var Cs;
            this.propType = "multidimensional";
            var Ls, Vs, Ws, Xs, ga = Cn.k.length;
            for (Cs = 0; Cs < ga - 1; Cs += 1)
                Cn.k[Cs].to && Cn.k[Cs].s && Cn.k[Cs + 1] && Cn.k[Cs + 1].s && (Ls = Cn.k[Cs].s,
                Vs = Cn.k[Cs + 1].s,
                Ws = Cn.k[Cs].to,
                Xs = Cn.k[Cs].ti,
                (Ls.length === 2 && (Ls[0] !== Vs[0] || Ls[1] !== Vs[1]) && bez.pointOnLine2D(Ls[0], Ls[1], Vs[0], Vs[1], Ls[0] + Ws[0], Ls[1] + Ws[1]) && bez.pointOnLine2D(Ls[0], Ls[1], Vs[0], Vs[1], Vs[0] + Xs[0], Vs[1] + Xs[1]) || Ls.length === 3 && (Ls[0] !== Vs[0] || Ls[1] !== Vs[1] || Ls[2] !== Vs[2]) && bez.pointOnLine3D(Ls[0], Ls[1], Ls[2], Vs[0], Vs[1], Vs[2], Ls[0] + Ws[0], Ls[1] + Ws[1], Ls[2] + Ws[2]) && bez.pointOnLine3D(Ls[0], Ls[1], Ls[2], Vs[0], Vs[1], Vs[2], Vs[0] + Xs[0], Vs[1] + Xs[1], Vs[2] + Xs[2])) && (Cn.k[Cs].to = null,
                Cn.k[Cs].ti = null),
                Ls[0] === Vs[0] && Ls[1] === Vs[1] && Ws[0] === 0 && Ws[1] === 0 && Xs[0] === 0 && Xs[1] === 0 && (Ls.length === 2 || Ls[2] === Vs[2] && Ws[2] === 0 && Xs[2] === 0) && (Cn.k[Cs].to = null,
                Cn.k[Cs].ti = null));
            this.effectsSequence = [getValueAtCurrentTime.bind(this)],
            this.data = Cn,
            this.keyframes = Cn.k,
            this.keyframesMetadata = [],
            this.offsetTime = xt.data.st,
            this.k = !0,
            this.kf = !0,
            this._isFirstFrame = !0,
            this.mult = as || 1,
            this.elem = xt,
            this.container = cs,
            this.comp = xt.comp,
            this.getValue = processEffectsSequence,
            this.setVValue = setVValue,
            this.interpolateValue = interpolateValue,
            this.frameId = -1;
            var ba = Cn.k[0].s.length;
            for (this.v = createTypedArray("float32", ba),
            this.pv = createTypedArray("float32", ba),
            Cs = 0; Cs < ba; Cs += 1)
                this.v[Cs] = initFrame,
                this.pv[Cs] = initFrame;
            this._caching = {
                lastFrame: initFrame,
                lastIndex: 0,
                value: createTypedArray("float32", ba)
            },
            this.addEffect = addEffect
        }
        var PropertyFactory = (ob = {
            getProp: function(xt, Cn, as, cs, Cs) {
                var Ls;
                if (Cn.sid && (Cn = xt.globalData.slotManager.getProp(Cn)),
                Cn.k.length)
                    if (typeof Cn.k[0] == "number")
                        Ls = new MultiDimensionalProperty(xt,Cn,cs,Cs);
                    else
                        switch (as) {
                        case 0:
                            Ls = new KeyframedValueProperty(xt,Cn,cs,Cs);
                            break;
                        case 1:
                            Ls = new KeyframedMultidimensionalProperty(xt,Cn,cs,Cs)
                        }
                else
                    Ls = new ValueProperty(xt,Cn,cs,Cs);
                return Ls.effectsSequence.length && Cs.addDynamicProperty(Ls),
                Ls
            }
        },
        ob), ob;
        function DynamicPropertyContainer() {}
        DynamicPropertyContainer.prototype = {
            addDynamicProperty: function(xt) {
                this.dynamicProperties.indexOf(xt) === -1 && (this.dynamicProperties.push(xt),
                this.container.addDynamicProperty(this),
                this._isAnimated = !0)
            },
            iterateDynamicProperties: function() {
                var xt;
                this._mdf = !1;
                var Cn = this.dynamicProperties.length;
                for (xt = 0; xt < Cn; xt += 1)
                    this.dynamicProperties[xt].getValue(),
                    this.dynamicProperties[xt]._mdf && (this._mdf = !0)
            },
            initDynamicPropertyContainer: function(xt) {
                this.container = xt,
                this.dynamicProperties = [],
                this._mdf = !1,
                this._isAnimated = !1
            }
        };
        var pointPool = poolFactory(8, function() {
            return createTypedArray("float32", 2)
        });
        function ShapePath() {
            this.c = !1,
            this._length = 0,
            this._maxLength = 8,
            this.v = createSizedArray(this._maxLength),
            this.o = createSizedArray(this._maxLength),
            this.i = createSizedArray(this._maxLength)
        }
        ShapePath.prototype.setPathData = function(xt, Cn) {
            this.c = xt,
            this.setLength(Cn);
            for (var as = 0; as < Cn; )
                this.v[as] = pointPool.newElement(),
                this.o[as] = pointPool.newElement(),
                this.i[as] = pointPool.newElement(),
                as += 1
        }
        ,
        ShapePath.prototype.setLength = function(xt) {
            for (; this._maxLength < xt; )
                this.doubleArrayLength();
            this._length = xt
        }
        ,
        ShapePath.prototype.doubleArrayLength = function() {
            this.v = this.v.concat(createSizedArray(this._maxLength)),
            this.i = this.i.concat(createSizedArray(this._maxLength)),
            this.o = this.o.concat(createSizedArray(this._maxLength)),
            this._maxLength *= 2
        }
        ,
        ShapePath.prototype.setXYAt = function(xt, Cn, as, cs, Cs) {
            var Ls;
            switch (this._length = Math.max(this._length, cs + 1),
            this._length >= this._maxLength && this.doubleArrayLength(),
            as) {
            case "v":
                Ls = this.v;
                break;
            case "i":
                Ls = this.i;
                break;
            case "o":
                Ls = this.o;
                break;
            default:
                Ls = []
            }
            (!Ls[cs] || Ls[cs] && !Cs) && (Ls[cs] = pointPool.newElement()),
            Ls[cs][0] = xt,
            Ls[cs][1] = Cn
        }
        ,
        ShapePath.prototype.setTripleAt = function(xt, Cn, as, cs, Cs, Ls, Vs, Ws) {
            this.setXYAt(xt, Cn, "v", Vs, Ws),
            this.setXYAt(as, cs, "o", Vs, Ws),
            this.setXYAt(Cs, Ls, "i", Vs, Ws)
        }
        ,
        ShapePath.prototype.reverse = function() {
            var xt = new ShapePath;
            xt.setPathData(this.c, this._length);
            var Cn = this.v
              , as = this.o
              , cs = this.i
              , Cs = 0;
            this.c && (xt.setTripleAt(Cn[0][0], Cn[0][1], cs[0][0], cs[0][1], as[0][0], as[0][1], 0, !1),
            Cs = 1);
            var Ls, Vs = this._length - 1, Ws = this._length;
            for (Ls = Cs; Ls < Ws; Ls += 1)
                xt.setTripleAt(Cn[Vs][0], Cn[Vs][1], cs[Vs][0], cs[Vs][1], as[Vs][0], as[Vs][1], Ls, !1),
                Vs -= 1;
            return xt
        }
        ,
        ShapePath.prototype.length = function() {
            return this._length
        }
        ;
        var shapePool = (factory = poolFactory(4, function() {
            return new ShapePath
        }, function(xt) {
            var Cn, as = xt._length;
            for (Cn = 0; Cn < as; Cn += 1)
                pointPool.release(xt.v[Cn]),
                pointPool.release(xt.i[Cn]),
                pointPool.release(xt.o[Cn]),
                xt.v[Cn] = null,
                xt.i[Cn] = null,
                xt.o[Cn] = null;
            xt._length = 0,
            xt.c = !1
        }),
        factory.clone = function(xt) {
            var Cn, as = factory.newElement(), cs = xt._length === void 0 ? xt.v.length : xt._length;
            for (as.setLength(cs),
            as.c = xt.c,
            Cn = 0; Cn < cs; Cn += 1)
                as.setTripleAt(xt.v[Cn][0], xt.v[Cn][1], xt.o[Cn][0], xt.o[Cn][1], xt.i[Cn][0], xt.i[Cn][1], Cn);
            return as
        }
        ,
        factory), factory;
        function ShapeCollection() {
            this._length = 0,
            this._maxLength = 4,
            this.shapes = createSizedArray(this._maxLength)
        }
        ShapeCollection.prototype.addShape = function(xt) {
            this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)),
            this._maxLength *= 2),
            this.shapes[this._length] = xt,
            this._length += 1
        }
        ,
        ShapeCollection.prototype.releaseShapes = function() {
            var xt;
            for (xt = 0; xt < this._length; xt += 1)
                shapePool.release(this.shapes[xt]);
            this._length = 0
        }
        ;
        var shapeCollectionPool = function() {
            var xt = {
                newShapeCollection: function() {
                    return Cn ? cs[Cn -= 1] : new ShapeCollection
                },
                release: function(Cs) {
                    var Ls, Vs = Cs._length;
                    for (Ls = 0; Ls < Vs; Ls += 1)
                        shapePool.release(Cs.shapes[Ls]);
                    Cs._length = 0,
                    Cn === as && (cs = pooling.double(cs),
                    as *= 2),
                    cs[Cn] = Cs,
                    Cn += 1
                }
            }
              , Cn = 0
              , as = 4
              , cs = createSizedArray(as);
            return xt
        }()
          , ShapePropertyFactory = function() {
            var xt = -999999;
            function Cn(wl, _l, El) {
                var Cl, $l, Sl, Tl, Rl, Il, Ml, Nl, Ll, Fl = El.lastIndex, Ul = this.keyframes;
                if (wl < Ul[0].t - this.offsetTime)
                    Cl = Ul[0].s[0],
                    Sl = !0,
                    Fl = 0;
                else if (wl >= Ul[Ul.length - 1].t - this.offsetTime)
                    Cl = Ul[Ul.length - 1].s ? Ul[Ul.length - 1].s[0] : Ul[Ul.length - 2].e[0],
                    Sl = !0;
                else {
                    for (var Dl, Zl, Gl, Wl = Fl, Ql = Ul.length - 1, cu = !0; cu && (Dl = Ul[Wl],
                    !((Zl = Ul[Wl + 1]).t - this.offsetTime > wl)); )
                        Wl < Ql - 1 ? Wl += 1 : cu = !1;
                    if (Gl = this.keyframesMetadata[Wl] || {},
                    Fl = Wl,
                    !(Sl = Dl.h === 1)) {
                        if (wl >= Zl.t - this.offsetTime)
                            Nl = 1;
                        else if (wl < Dl.t - this.offsetTime)
                            Nl = 0;
                        else {
                            var pu;
                            Gl.__fnct ? pu = Gl.__fnct : (pu = BezierFactory.getBezierEasing(Dl.o.x, Dl.o.y, Dl.i.x, Dl.i.y).get,
                            Gl.__fnct = pu),
                            Nl = pu((wl - (Dl.t - this.offsetTime)) / (Zl.t - this.offsetTime - (Dl.t - this.offsetTime)))
                        }
                        $l = Zl.s ? Zl.s[0] : Dl.e[0]
                    }
                    Cl = Dl.s[0]
                }
                for (Il = _l._length,
                Ml = Cl.i[0].length,
                El.lastIndex = Fl,
                Tl = 0; Tl < Il; Tl += 1)
                    for (Rl = 0; Rl < Ml; Rl += 1)
                        Ll = Sl ? Cl.i[Tl][Rl] : Cl.i[Tl][Rl] + ($l.i[Tl][Rl] - Cl.i[Tl][Rl]) * Nl,
                        _l.i[Tl][Rl] = Ll,
                        Ll = Sl ? Cl.o[Tl][Rl] : Cl.o[Tl][Rl] + ($l.o[Tl][Rl] - Cl.o[Tl][Rl]) * Nl,
                        _l.o[Tl][Rl] = Ll,
                        Ll = Sl ? Cl.v[Tl][Rl] : Cl.v[Tl][Rl] + ($l.v[Tl][Rl] - Cl.v[Tl][Rl]) * Nl,
                        _l.v[Tl][Rl] = Ll
            }
            function as() {
                var wl = this.comp.renderedFrame - this.offsetTime
                  , _l = this.keyframes[0].t - this.offsetTime
                  , El = this.keyframes[this.keyframes.length - 1].t - this.offsetTime
                  , Cl = this._caching.lastFrame;
                return Cl !== xt && (Cl < _l && wl < _l || Cl > El && wl > El) || (this._caching.lastIndex = Cl < wl ? this._caching.lastIndex : 0,
                this.interpolateShape(wl, this.pv, this._caching)),
                this._caching.lastFrame = wl,
                this.pv
            }
            function cs() {
                this.paths = this.localShapeCollection
            }
            function Cs(wl) {
                (function(_l, El) {
                    if (_l._length !== El._length || _l.c !== El.c)
                        return !1;
                    var Cl, $l = _l._length;
                    for (Cl = 0; Cl < $l; Cl += 1)
                        if (_l.v[Cl][0] !== El.v[Cl][0] || _l.v[Cl][1] !== El.v[Cl][1] || _l.o[Cl][0] !== El.o[Cl][0] || _l.o[Cl][1] !== El.o[Cl][1] || _l.i[Cl][0] !== El.i[Cl][0] || _l.i[Cl][1] !== El.i[Cl][1])
                            return !1;
                    return !0
                }
                )(this.v, wl) || (this.v = shapePool.clone(wl),
                this.localShapeCollection.releaseShapes(),
                this.localShapeCollection.addShape(this.v),
                this._mdf = !0,
                this.paths = this.localShapeCollection)
            }
            function Ls() {
                if (this.elem.globalData.frameId !== this.frameId)
                    if (this.effectsSequence.length)
                        if (this.lock)
                            this.setVValue(this.pv);
                        else {
                            var wl, _l;
                            this.lock = !0,
                            this._mdf = !1,
                            wl = this.kf ? this.pv : this.data.ks ? this.data.ks.k : this.data.pt.k;
                            var El = this.effectsSequence.length;
                            for (_l = 0; _l < El; _l += 1)
                                wl = this.effectsSequence[_l](wl);
                            this.setVValue(wl),
                            this.lock = !1,
                            this.frameId = this.elem.globalData.frameId
                        }
                    else
                        this._mdf = !1
            }
            function Vs(wl, _l, El) {
                this.propType = "shape",
                this.comp = wl.comp,
                this.container = wl,
                this.elem = wl,
                this.data = _l,
                this.k = !1,
                this.kf = !1,
                this._mdf = !1;
                var Cl = El === 3 ? _l.pt.k : _l.ks.k;
                this.v = shapePool.clone(Cl),
                this.pv = shapePool.clone(this.v),
                this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                this.paths = this.localShapeCollection,
                this.paths.addShape(this.v),
                this.reset = cs,
                this.effectsSequence = []
            }
            function Ws(wl) {
                this.effectsSequence.push(wl),
                this.container.addDynamicProperty(this)
            }
            function Xs(wl, _l, El) {
                this.propType = "shape",
                this.comp = wl.comp,
                this.elem = wl,
                this.container = wl,
                this.offsetTime = wl.data.st,
                this.keyframes = El === 3 ? _l.pt.k : _l.ks.k,
                this.keyframesMetadata = [],
                this.k = !0,
                this.kf = !0;
                var Cl = this.keyframes[0].s[0].i.length;
                this.v = shapePool.newElement(),
                this.v.setPathData(this.keyframes[0].s[0].c, Cl),
                this.pv = shapePool.clone(this.v),
                this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                this.paths = this.localShapeCollection,
                this.paths.addShape(this.v),
                this.lastFrame = xt,
                this.reset = cs,
                this._caching = {
                    lastFrame: xt,
                    lastIndex: 0
                },
                this.effectsSequence = [as.bind(this)]
            }
            Vs.prototype.interpolateShape = Cn,
            Vs.prototype.getValue = Ls,
            Vs.prototype.setVValue = Cs,
            Vs.prototype.addEffect = Ws,
            Xs.prototype.getValue = Ls,
            Xs.prototype.interpolateShape = Cn,
            Xs.prototype.setVValue = Cs,
            Xs.prototype.addEffect = Ws;
            var ga = function() {
                var wl = roundCorner;
                function _l(El, Cl) {
                    this.v = shapePool.newElement(),
                    this.v.setPathData(!0, 4),
                    this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                    this.paths = this.localShapeCollection,
                    this.localShapeCollection.addShape(this.v),
                    this.d = Cl.d,
                    this.elem = El,
                    this.comp = El.comp,
                    this.frameId = -1,
                    this.initDynamicPropertyContainer(El),
                    this.p = PropertyFactory.getProp(El, Cl.p, 1, 0, this),
                    this.s = PropertyFactory.getProp(El, Cl.s, 1, 0, this),
                    this.dynamicProperties.length ? this.k = !0 : (this.k = !1,
                    this.convertEllToPath())
                }
                return _l.prototype = {
                    reset: cs,
                    getValue: function() {
                        this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
                        this.iterateDynamicProperties(),
                        this._mdf && this.convertEllToPath())
                    },
                    convertEllToPath: function() {
                        var El = this.p.v[0]
                          , Cl = this.p.v[1]
                          , $l = this.s.v[0] / 2
                          , Sl = this.s.v[1] / 2
                          , Tl = this.d !== 3
                          , Rl = this.v;
                        Rl.v[0][0] = El,
                        Rl.v[0][1] = Cl - Sl,
                        Rl.v[1][0] = Tl ? El + $l : El - $l,
                        Rl.v[1][1] = Cl,
                        Rl.v[2][0] = El,
                        Rl.v[2][1] = Cl + Sl,
                        Rl.v[3][0] = Tl ? El - $l : El + $l,
                        Rl.v[3][1] = Cl,
                        Rl.i[0][0] = Tl ? El - $l * wl : El + $l * wl,
                        Rl.i[0][1] = Cl - Sl,
                        Rl.i[1][0] = Tl ? El + $l : El - $l,
                        Rl.i[1][1] = Cl - Sl * wl,
                        Rl.i[2][0] = Tl ? El + $l * wl : El - $l * wl,
                        Rl.i[2][1] = Cl + Sl,
                        Rl.i[3][0] = Tl ? El - $l : El + $l,
                        Rl.i[3][1] = Cl + Sl * wl,
                        Rl.o[0][0] = Tl ? El + $l * wl : El - $l * wl,
                        Rl.o[0][1] = Cl - Sl,
                        Rl.o[1][0] = Tl ? El + $l : El - $l,
                        Rl.o[1][1] = Cl + Sl * wl,
                        Rl.o[2][0] = Tl ? El - $l * wl : El + $l * wl,
                        Rl.o[2][1] = Cl + Sl,
                        Rl.o[3][0] = Tl ? El - $l : El + $l,
                        Rl.o[3][1] = Cl - Sl * wl
                    }
                },
                extendPrototype([DynamicPropertyContainer], _l),
                _l
            }()
              , ba = function() {
                function wl(_l, El) {
                    this.v = shapePool.newElement(),
                    this.v.setPathData(!0, 0),
                    this.elem = _l,
                    this.comp = _l.comp,
                    this.data = El,
                    this.frameId = -1,
                    this.d = El.d,
                    this.initDynamicPropertyContainer(_l),
                    El.sy === 1 ? (this.ir = PropertyFactory.getProp(_l, El.ir, 0, 0, this),
                    this.is = PropertyFactory.getProp(_l, El.is, 0, .01, this),
                    this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath,
                    this.pt = PropertyFactory.getProp(_l, El.pt, 0, 0, this),
                    this.p = PropertyFactory.getProp(_l, El.p, 1, 0, this),
                    this.r = PropertyFactory.getProp(_l, El.r, 0, degToRads, this),
                    this.or = PropertyFactory.getProp(_l, El.or, 0, 0, this),
                    this.os = PropertyFactory.getProp(_l, El.os, 0, .01, this),
                    this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                    this.localShapeCollection.addShape(this.v),
                    this.paths = this.localShapeCollection,
                    this.dynamicProperties.length ? this.k = !0 : (this.k = !1,
                    this.convertToPath())
                }
                return wl.prototype = {
                    reset: cs,
                    getValue: function() {
                        this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
                        this.iterateDynamicProperties(),
                        this._mdf && this.convertToPath())
                    },
                    convertStarToPath: function() {
                        var _l, El, Cl, $l, Sl = 2 * Math.floor(this.pt.v), Tl = 2 * Math.PI / Sl, Rl = !0, Il = this.or.v, Ml = this.ir.v, Nl = this.os.v, Ll = this.is.v, Fl = 2 * Math.PI * Il / (2 * Sl), Ul = 2 * Math.PI * Ml / (2 * Sl), Dl = -Math.PI / 2;
                        Dl += this.r.v;
                        var Zl = this.data.d === 3 ? -1 : 1;
                        for (this.v._length = 0,
                        _l = 0; _l < Sl; _l += 1) {
                            Cl = Rl ? Nl : Ll,
                            $l = Rl ? Fl : Ul;
                            var Gl = (El = Rl ? Il : Ml) * Math.cos(Dl)
                              , Wl = El * Math.sin(Dl)
                              , Ql = Gl === 0 && Wl === 0 ? 0 : Wl / Math.sqrt(Gl * Gl + Wl * Wl)
                              , cu = Gl === 0 && Wl === 0 ? 0 : -Gl / Math.sqrt(Gl * Gl + Wl * Wl);
                            Gl += +this.p.v[0],
                            Wl += +this.p.v[1],
                            this.v.setTripleAt(Gl, Wl, Gl - Ql * $l * Cl * Zl, Wl - cu * $l * Cl * Zl, Gl + Ql * $l * Cl * Zl, Wl + cu * $l * Cl * Zl, _l, !0),
                            Rl = !Rl,
                            Dl += Tl * Zl
                        }
                    },
                    convertPolygonToPath: function() {
                        var _l, El = Math.floor(this.pt.v), Cl = 2 * Math.PI / El, $l = this.or.v, Sl = this.os.v, Tl = 2 * Math.PI * $l / (4 * El), Rl = .5 * -Math.PI, Il = this.data.d === 3 ? -1 : 1;
                        for (Rl += this.r.v,
                        this.v._length = 0,
                        _l = 0; _l < El; _l += 1) {
                            var Ml = $l * Math.cos(Rl)
                              , Nl = $l * Math.sin(Rl)
                              , Ll = Ml === 0 && Nl === 0 ? 0 : Nl / Math.sqrt(Ml * Ml + Nl * Nl)
                              , Fl = Ml === 0 && Nl === 0 ? 0 : -Ml / Math.sqrt(Ml * Ml + Nl * Nl);
                            Ml += +this.p.v[0],
                            Nl += +this.p.v[1],
                            this.v.setTripleAt(Ml, Nl, Ml - Ll * Tl * Sl * Il, Nl - Fl * Tl * Sl * Il, Ml + Ll * Tl * Sl * Il, Nl + Fl * Tl * Sl * Il, _l, !0),
                            Rl += Cl * Il
                        }
                        this.paths.length = 0,
                        this.paths[0] = this.v
                    }
                },
                extendPrototype([DynamicPropertyContainer], wl),
                wl
            }()
              , yl = function() {
                function wl(_l, El) {
                    this.v = shapePool.newElement(),
                    this.v.c = !0,
                    this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                    this.localShapeCollection.addShape(this.v),
                    this.paths = this.localShapeCollection,
                    this.elem = _l,
                    this.comp = _l.comp,
                    this.frameId = -1,
                    this.d = El.d,
                    this.initDynamicPropertyContainer(_l),
                    this.p = PropertyFactory.getProp(_l, El.p, 1, 0, this),
                    this.s = PropertyFactory.getProp(_l, El.s, 1, 0, this),
                    this.r = PropertyFactory.getProp(_l, El.r, 0, 0, this),
                    this.dynamicProperties.length ? this.k = !0 : (this.k = !1,
                    this.convertRectToPath())
                }
                return wl.prototype = {
                    convertRectToPath: function() {
                        var _l = this.p.v[0]
                          , El = this.p.v[1]
                          , Cl = this.s.v[0] / 2
                          , $l = this.s.v[1] / 2
                          , Sl = bmMin(Cl, $l, this.r.v)
                          , Tl = Sl * (1 - roundCorner);
                        this.v._length = 0,
                        this.d === 2 || this.d === 1 ? (this.v.setTripleAt(_l + Cl, El - $l + Sl, _l + Cl, El - $l + Sl, _l + Cl, El - $l + Tl, 0, !0),
                        this.v.setTripleAt(_l + Cl, El + $l - Sl, _l + Cl, El + $l - Tl, _l + Cl, El + $l - Sl, 1, !0),
                        Sl !== 0 ? (this.v.setTripleAt(_l + Cl - Sl, El + $l, _l + Cl - Sl, El + $l, _l + Cl - Tl, El + $l, 2, !0),
                        this.v.setTripleAt(_l - Cl + Sl, El + $l, _l - Cl + Tl, El + $l, _l - Cl + Sl, El + $l, 3, !0),
                        this.v.setTripleAt(_l - Cl, El + $l - Sl, _l - Cl, El + $l - Sl, _l - Cl, El + $l - Tl, 4, !0),
                        this.v.setTripleAt(_l - Cl, El - $l + Sl, _l - Cl, El - $l + Tl, _l - Cl, El - $l + Sl, 5, !0),
                        this.v.setTripleAt(_l - Cl + Sl, El - $l, _l - Cl + Sl, El - $l, _l - Cl + Tl, El - $l, 6, !0),
                        this.v.setTripleAt(_l + Cl - Sl, El - $l, _l + Cl - Tl, El - $l, _l + Cl - Sl, El - $l, 7, !0)) : (this.v.setTripleAt(_l - Cl, El + $l, _l - Cl + Tl, El + $l, _l - Cl, El + $l, 2),
                        this.v.setTripleAt(_l - Cl, El - $l, _l - Cl, El - $l + Tl, _l - Cl, El - $l, 3))) : (this.v.setTripleAt(_l + Cl, El - $l + Sl, _l + Cl, El - $l + Tl, _l + Cl, El - $l + Sl, 0, !0),
                        Sl !== 0 ? (this.v.setTripleAt(_l + Cl - Sl, El - $l, _l + Cl - Sl, El - $l, _l + Cl - Tl, El - $l, 1, !0),
                        this.v.setTripleAt(_l - Cl + Sl, El - $l, _l - Cl + Tl, El - $l, _l - Cl + Sl, El - $l, 2, !0),
                        this.v.setTripleAt(_l - Cl, El - $l + Sl, _l - Cl, El - $l + Sl, _l - Cl, El - $l + Tl, 3, !0),
                        this.v.setTripleAt(_l - Cl, El + $l - Sl, _l - Cl, El + $l - Tl, _l - Cl, El + $l - Sl, 4, !0),
                        this.v.setTripleAt(_l - Cl + Sl, El + $l, _l - Cl + Sl, El + $l, _l - Cl + Tl, El + $l, 5, !0),
                        this.v.setTripleAt(_l + Cl - Sl, El + $l, _l + Cl - Tl, El + $l, _l + Cl - Sl, El + $l, 6, !0),
                        this.v.setTripleAt(_l + Cl, El + $l - Sl, _l + Cl, El + $l - Sl, _l + Cl, El + $l - Tl, 7, !0)) : (this.v.setTripleAt(_l - Cl, El - $l, _l - Cl + Tl, El - $l, _l - Cl, El - $l, 1, !0),
                        this.v.setTripleAt(_l - Cl, El + $l, _l - Cl, El + $l - Tl, _l - Cl, El + $l, 2, !0),
                        this.v.setTripleAt(_l + Cl, El + $l, _l + Cl - Tl, El + $l, _l + Cl, El + $l, 3, !0)))
                    },
                    getValue: function() {
                        this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
                        this.iterateDynamicProperties(),
                        this._mdf && this.convertRectToPath())
                    },
                    reset: cs
                },
                extendPrototype([DynamicPropertyContainer], wl),
                wl
            }()
              , xl = {
                getShapeProp: function(wl, _l, El) {
                    var Cl;
                    return El === 3 || El === 4 ? Cl = (El === 3 ? _l.pt : _l.ks).k.length ? new Xs(wl,_l,El) : new Vs(wl,_l,El) : El === 5 ? Cl = new yl(wl,_l) : El === 6 ? Cl = new ga(wl,_l) : El === 7 && (Cl = new ba(wl,_l)),
                    Cl.k && wl.addDynamicProperty(Cl),
                    Cl
                },
                getConstructorFunction: function() {
                    return Vs
                },
                getKeyframedConstructorFunction: function() {
                    return Xs
                }
            };
            return xl
        }()
          , Matrix = function() {
            var xt = Math.cos
              , Cn = Math.sin
              , as = Math.tan
              , cs = Math.round;
            function Cs() {
                return this.props[0] = 1,
                this.props[1] = 0,
                this.props[2] = 0,
                this.props[3] = 0,
                this.props[4] = 0,
                this.props[5] = 1,
                this.props[6] = 0,
                this.props[7] = 0,
                this.props[8] = 0,
                this.props[9] = 0,
                this.props[10] = 1,
                this.props[11] = 0,
                this.props[12] = 0,
                this.props[13] = 0,
                this.props[14] = 0,
                this.props[15] = 1,
                this
            }
            function Ls(zl) {
                if (zl === 0)
                    return this;
                var Yl = xt(zl)
                  , lu = Cn(zl);
                return this._t(Yl, -lu, 0, 0, lu, Yl, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }
            function Vs(zl) {
                if (zl === 0)
                    return this;
                var Yl = xt(zl)
                  , lu = Cn(zl);
                return this._t(1, 0, 0, 0, 0, Yl, -lu, 0, 0, lu, Yl, 0, 0, 0, 0, 1)
            }
            function Ws(zl) {
                if (zl === 0)
                    return this;
                var Yl = xt(zl)
                  , lu = Cn(zl);
                return this._t(Yl, 0, lu, 0, 0, 1, 0, 0, -lu, 0, Yl, 0, 0, 0, 0, 1)
            }
            function Xs(zl) {
                if (zl === 0)
                    return this;
                var Yl = xt(zl)
                  , lu = Cn(zl);
                return this._t(Yl, -lu, 0, 0, lu, Yl, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }
            function ga(zl, Yl) {
                return this._t(1, Yl, zl, 1, 0, 0)
            }
            function ba(zl, Yl) {
                return this.shear(as(zl), as(Yl))
            }
            function yl(zl, Yl) {
                var lu = xt(Yl)
                  , mu = Cn(Yl);
                return this._t(lu, mu, 0, 0, -mu, lu, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, as(zl), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(lu, -mu, 0, 0, mu, lu, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }
            function xl(zl, Yl, lu) {
                return lu || lu === 0 || (lu = 1),
                zl === 1 && Yl === 1 && lu === 1 ? this : this._t(zl, 0, 0, 0, 0, Yl, 0, 0, 0, 0, lu, 0, 0, 0, 0, 1)
            }
            function wl(zl, Yl, lu, mu, Cu, ju, Lu, Au, Du, Qu, fu, yu, vu, _u, xu, Ru) {
                return this.props[0] = zl,
                this.props[1] = Yl,
                this.props[2] = lu,
                this.props[3] = mu,
                this.props[4] = Cu,
                this.props[5] = ju,
                this.props[6] = Lu,
                this.props[7] = Au,
                this.props[8] = Du,
                this.props[9] = Qu,
                this.props[10] = fu,
                this.props[11] = yu,
                this.props[12] = vu,
                this.props[13] = _u,
                this.props[14] = xu,
                this.props[15] = Ru,
                this
            }
            function _l(zl, Yl, lu) {
                return lu = lu || 0,
                zl !== 0 || Yl !== 0 || lu !== 0 ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, zl, Yl, lu, 1) : this
            }
            function El(zl, Yl, lu, mu, Cu, ju, Lu, Au, Du, Qu, fu, yu, vu, _u, xu, Ru) {
                var Iu = this.props;
                if (zl === 1 && Yl === 0 && lu === 0 && mu === 0 && Cu === 0 && ju === 1 && Lu === 0 && Au === 0 && Du === 0 && Qu === 0 && fu === 1 && yu === 0)
                    return Iu[12] = Iu[12] * zl + Iu[15] * vu,
                    Iu[13] = Iu[13] * ju + Iu[15] * _u,
                    Iu[14] = Iu[14] * fu + Iu[15] * xu,
                    Iu[15] *= Ru,
                    this._identityCalculated = !1,
                    this;
                var Ku = Iu[0]
                  , dp = Iu[1]
                  , lp = Iu[2]
                  , qu = Iu[3]
                  , hp = Iu[4]
                  , fp = Iu[5]
                  , Lp = Iu[6]
                  , uu = Iu[7]
                  , gu = Iu[8]
                  , Eu = Iu[9]
                  , nu = Iu[10]
                  , Kl = Iu[11]
                  , Bl = Iu[12]
                  , Pl = Iu[13]
                  , Al = Iu[14]
                  , Vl = Iu[15];
                return Iu[0] = Ku * zl + dp * Cu + lp * Du + qu * vu,
                Iu[1] = Ku * Yl + dp * ju + lp * Qu + qu * _u,
                Iu[2] = Ku * lu + dp * Lu + lp * fu + qu * xu,
                Iu[3] = Ku * mu + dp * Au + lp * yu + qu * Ru,
                Iu[4] = hp * zl + fp * Cu + Lp * Du + uu * vu,
                Iu[5] = hp * Yl + fp * ju + Lp * Qu + uu * _u,
                Iu[6] = hp * lu + fp * Lu + Lp * fu + uu * xu,
                Iu[7] = hp * mu + fp * Au + Lp * yu + uu * Ru,
                Iu[8] = gu * zl + Eu * Cu + nu * Du + Kl * vu,
                Iu[9] = gu * Yl + Eu * ju + nu * Qu + Kl * _u,
                Iu[10] = gu * lu + Eu * Lu + nu * fu + Kl * xu,
                Iu[11] = gu * mu + Eu * Au + nu * yu + Kl * Ru,
                Iu[12] = Bl * zl + Pl * Cu + Al * Du + Vl * vu,
                Iu[13] = Bl * Yl + Pl * ju + Al * Qu + Vl * _u,
                Iu[14] = Bl * lu + Pl * Lu + Al * fu + Vl * xu,
                Iu[15] = Bl * mu + Pl * Au + Al * yu + Vl * Ru,
                this._identityCalculated = !1,
                this
            }
            function Cl(zl) {
                var Yl = zl.props;
                return this.transform(Yl[0], Yl[1], Yl[2], Yl[3], Yl[4], Yl[5], Yl[6], Yl[7], Yl[8], Yl[9], Yl[10], Yl[11], Yl[12], Yl[13], Yl[14], Yl[15])
            }
            function $l() {
                return this._identityCalculated || (this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1),
                this._identityCalculated = !0),
                this._identity
            }
            function Sl(zl) {
                for (var Yl = 0; Yl < 16; ) {
                    if (zl.props[Yl] !== this.props[Yl])
                        return !1;
                    Yl += 1
                }
                return !0
            }
            function Tl(zl) {
                var Yl;
                for (Yl = 0; Yl < 16; Yl += 1)
                    zl.props[Yl] = this.props[Yl];
                return zl
            }
            function Rl(zl) {
                var Yl;
                for (Yl = 0; Yl < 16; Yl += 1)
                    this.props[Yl] = zl[Yl]
            }
            function Il(zl, Yl, lu) {
                return {
                    x: zl * this.props[0] + Yl * this.props[4] + lu * this.props[8] + this.props[12],
                    y: zl * this.props[1] + Yl * this.props[5] + lu * this.props[9] + this.props[13],
                    z: zl * this.props[2] + Yl * this.props[6] + lu * this.props[10] + this.props[14]
                }
            }
            function Ml(zl, Yl, lu) {
                return zl * this.props[0] + Yl * this.props[4] + lu * this.props[8] + this.props[12]
            }
            function Nl(zl, Yl, lu) {
                return zl * this.props[1] + Yl * this.props[5] + lu * this.props[9] + this.props[13]
            }
            function Ll(zl, Yl, lu) {
                return zl * this.props[2] + Yl * this.props[6] + lu * this.props[10] + this.props[14]
            }
            function Fl() {
                var zl = this.props[0] * this.props[5] - this.props[1] * this.props[4]
                  , Yl = this.props[5] / zl
                  , lu = -this.props[1] / zl
                  , mu = -this.props[4] / zl
                  , Cu = this.props[0] / zl
                  , ju = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / zl
                  , Lu = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / zl
                  , Au = new Matrix;
                return Au.props[0] = Yl,
                Au.props[1] = lu,
                Au.props[4] = mu,
                Au.props[5] = Cu,
                Au.props[12] = ju,
                Au.props[13] = Lu,
                Au
            }
            function Ul(zl) {
                return this.getInverseMatrix().applyToPointArray(zl[0], zl[1], zl[2] || 0)
            }
            function Dl(zl) {
                var Yl, lu = zl.length, mu = [];
                for (Yl = 0; Yl < lu; Yl += 1)
                    mu[Yl] = Ul(zl[Yl]);
                return mu
            }
            function Zl(zl, Yl, lu) {
                var mu = createTypedArray("float32", 6);
                if (this.isIdentity())
                    mu[0] = zl[0],
                    mu[1] = zl[1],
                    mu[2] = Yl[0],
                    mu[3] = Yl[1],
                    mu[4] = lu[0],
                    mu[5] = lu[1];
                else {
                    var Cu = this.props[0]
                      , ju = this.props[1]
                      , Lu = this.props[4]
                      , Au = this.props[5]
                      , Du = this.props[12]
                      , Qu = this.props[13];
                    mu[0] = zl[0] * Cu + zl[1] * Lu + Du,
                    mu[1] = zl[0] * ju + zl[1] * Au + Qu,
                    mu[2] = Yl[0] * Cu + Yl[1] * Lu + Du,
                    mu[3] = Yl[0] * ju + Yl[1] * Au + Qu,
                    mu[4] = lu[0] * Cu + lu[1] * Lu + Du,
                    mu[5] = lu[0] * ju + lu[1] * Au + Qu
                }
                return mu
            }
            function Gl(zl, Yl, lu) {
                return this.isIdentity() ? [zl, Yl, lu] : [zl * this.props[0] + Yl * this.props[4] + lu * this.props[8] + this.props[12], zl * this.props[1] + Yl * this.props[5] + lu * this.props[9] + this.props[13], zl * this.props[2] + Yl * this.props[6] + lu * this.props[10] + this.props[14]]
            }
            function Wl(zl, Yl) {
                if (this.isIdentity())
                    return zl + "," + Yl;
                var lu = this.props;
                return Math.round(100 * (zl * lu[0] + Yl * lu[4] + lu[12])) / 100 + "," + Math.round(100 * (zl * lu[1] + Yl * lu[5] + lu[13])) / 100
            }
            function Ql() {
                for (var zl = 0, Yl = this.props, lu = "matrix3d("; zl < 16; )
                    lu += cs(1e4 * Yl[zl]) / 1e4,
                    lu += zl === 15 ? ")" : ",",
                    zl += 1;
                return lu
            }
            function cu(zl) {
                return zl < 1e-6 && zl > 0 || zl > -1e-6 && zl < 0 ? cs(1e4 * zl) / 1e4 : zl
            }
            function pu() {
                var zl = this.props;
                return "matrix(" + cu(zl[0]) + "," + cu(zl[1]) + "," + cu(zl[4]) + "," + cu(zl[5]) + "," + cu(zl[12]) + "," + cu(zl[13]) + ")"
            }
            return function() {
                this.reset = Cs,
                this.rotate = Ls,
                this.rotateX = Vs,
                this.rotateY = Ws,
                this.rotateZ = Xs,
                this.skew = ba,
                this.skewFromAxis = yl,
                this.shear = ga,
                this.scale = xl,
                this.setTransform = wl,
                this.translate = _l,
                this.transform = El,
                this.multiply = Cl,
                this.applyToPoint = Il,
                this.applyToX = Ml,
                this.applyToY = Nl,
                this.applyToZ = Ll,
                this.applyToPointArray = Gl,
                this.applyToTriplePoints = Zl,
                this.applyToPointStringified = Wl,
                this.toCSS = Ql,
                this.to2dCSS = pu,
                this.clone = Tl,
                this.cloneFromProps = Rl,
                this.equals = Sl,
                this.inversePoints = Dl,
                this.inversePoint = Ul,
                this.getInverseMatrix = Fl,
                this._t = this.transform,
                this.isIdentity = $l,
                this._identity = !0,
                this._identityCalculated = !1,
                this.props = createTypedArray("float32", 16),
                this.reset()
            }
        }();
        function _typeof$3(xt) {
            return _typeof$3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Cn) {
                return typeof Cn
            }
            : function(Cn) {
                return Cn && typeof Symbol == "function" && Cn.constructor === Symbol && Cn !== Symbol.prototype ? "symbol" : typeof Cn
            }
            ,
            _typeof$3(xt)
        }
        var lottie = {};
        function setLocation(xt) {
            setLocationHref(xt)
        }
        function searchAnimations() {
            animationManager.searchAnimations()
        }
        function setSubframeRendering(xt) {
            setSubframeEnabled(xt)
        }
        function setPrefix(xt) {
            setIdPrefix(xt)
        }
        function loadAnimation(xt) {
            return animationManager.loadAnimation(xt)
        }
        function setQuality(xt) {
            if (typeof xt == "string")
                switch (xt) {
                case "high":
                    setDefaultCurveSegments(200);
                    break;
                default:
                case "medium":
                    setDefaultCurveSegments(50);
                    break;
                case "low":
                    setDefaultCurveSegments(10)
                }
            else
                !isNaN(xt) && xt > 1 && setDefaultCurveSegments(xt)
        }
        function inBrowser() {
            return typeof navigator < "u"
        }
        function installPlugin(xt, Cn) {
            xt === "expressions" && setExpressionsPlugin(Cn)
        }
        function getFactory(xt) {
            switch (xt) {
            case "propertyFactory":
                return PropertyFactory;
            case "shapePropertyFactory":
                return ShapePropertyFactory;
            case "matrix":
                return Matrix;
            default:
                return null
            }
        }
        function checkReady() {
            document.readyState === "complete" && (clearInterval(readyStateCheckInterval),
            searchAnimations())
        }
        function getQueryVariable(xt) {
            for (var Cn = queryString.split("&"), as = 0; as < Cn.length; as += 1) {
                var cs = Cn[as].split("=");
                if (decodeURIComponent(cs[0]) == xt)
                    return decodeURIComponent(cs[1])
            }
            return null
        }
        lottie.play = animationManager.play,
        lottie.pause = animationManager.pause,
        lottie.setLocationHref = setLocation,
        lottie.togglePause = animationManager.togglePause,
        lottie.setSpeed = animationManager.setSpeed,
        lottie.setDirection = animationManager.setDirection,
        lottie.stop = animationManager.stop,
        lottie.searchAnimations = searchAnimations,
        lottie.registerAnimation = animationManager.registerAnimation,
        lottie.loadAnimation = loadAnimation,
        lottie.setSubframeRendering = setSubframeRendering,
        lottie.resize = animationManager.resize,
        lottie.goToAndStop = animationManager.goToAndStop,
        lottie.destroy = animationManager.destroy,
        lottie.setQuality = setQuality,
        lottie.inBrowser = inBrowser,
        lottie.installPlugin = installPlugin,
        lottie.freeze = animationManager.freeze,
        lottie.unfreeze = animationManager.unfreeze,
        lottie.setVolume = animationManager.setVolume,
        lottie.mute = animationManager.mute,
        lottie.unmute = animationManager.unmute,
        lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations,
        lottie.useWebWorker = setWebWorker,
        lottie.setIDPrefix = setPrefix,
        lottie.__getFactory = getFactory,
        lottie.version = "5.12.2";
        var queryString = "";
        {
            var scripts = document.getElementsByTagName("script")
              , index = scripts.length - 1
              , myScript = scripts[index] || {
                src: ""
            };
            queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "",
            getQueryVariable("renderer")
        }
        var readyStateCheckInterval = setInterval(checkReady, 100);
        try {
            _typeof$3(exports) !== "object" && (window.bodymovin = lottie)
        } catch (xt) {}
        var ShapeModifiers = function() {
            var xt = {}
              , Cn = {};
            return xt.registerModifier = function(as, cs) {
                Cn[as] || (Cn[as] = cs)
            }
            ,
            xt.getModifier = function(as, cs, Cs) {
                return new Cn[as](cs,Cs)
            }
            ,
            xt
        }();
        function ShapeModifier() {}
        function TrimModifier() {}
        function PuckerAndBloatModifier() {}
        ShapeModifier.prototype.initModifierProperties = function() {}
        ,
        ShapeModifier.prototype.addShapeToModifier = function() {}
        ,
        ShapeModifier.prototype.addShape = function(xt) {
            if (!this.closed) {
                xt.sh.container.addDynamicProperty(xt.sh);
                var Cn = {
                    shape: xt.sh,
                    data: xt,
                    localShapeCollection: shapeCollectionPool.newShapeCollection()
                };
                this.shapes.push(Cn),
                this.addShapeToModifier(Cn),
                this._isAnimated && xt.setAsAnimated()
            }
        }
        ,
        ShapeModifier.prototype.init = function(xt, Cn) {
            this.shapes = [],
            this.elem = xt,
            this.initDynamicPropertyContainer(xt),
            this.initModifierProperties(xt, Cn),
            this.frameId = initialDefaultFrame,
            this.closed = !1,
            this.k = !1,
            this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
        }
        ,
        ShapeModifier.prototype.processKeys = function() {
            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
            this.iterateDynamicProperties())
        }
        ,
        extendPrototype([DynamicPropertyContainer], ShapeModifier),
        extendPrototype([ShapeModifier], TrimModifier),
        TrimModifier.prototype.initModifierProperties = function(xt, Cn) {
            this.s = PropertyFactory.getProp(xt, Cn.s, 0, .01, this),
            this.e = PropertyFactory.getProp(xt, Cn.e, 0, .01, this),
            this.o = PropertyFactory.getProp(xt, Cn.o, 0, 0, this),
            this.sValue = 0,
            this.eValue = 0,
            this.getValue = this.processKeys,
            this.m = Cn.m,
            this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length
        }
        ,
        TrimModifier.prototype.addShapeToModifier = function(xt) {
            xt.pathsData = []
        }
        ,
        TrimModifier.prototype.calculateShapeEdges = function(xt, Cn, as, cs, Cs) {
            var Ls = [];
            Cn <= 1 ? Ls.push({
                s: xt,
                e: Cn
            }) : xt >= 1 ? Ls.push({
                s: xt - 1,
                e: Cn - 1
            }) : (Ls.push({
                s: xt,
                e: 1
            }),
            Ls.push({
                s: 0,
                e: Cn - 1
            }));
            var Vs, Ws, Xs = [], ga = Ls.length;
            for (Vs = 0; Vs < ga; Vs += 1) {
                var ba, yl;
                (Ws = Ls[Vs]).e * Cs < cs || Ws.s * Cs > cs + as || (ba = Ws.s * Cs <= cs ? 0 : (Ws.s * Cs - cs) / as,
                yl = Ws.e * Cs >= cs + as ? 1 : (Ws.e * Cs - cs) / as,
                Xs.push([ba, yl]))
            }
            return Xs.length || Xs.push([0, 0]),
            Xs
        }
        ,
        TrimModifier.prototype.releasePathsData = function(xt) {
            var Cn, as = xt.length;
            for (Cn = 0; Cn < as; Cn += 1)
                segmentsLengthPool.release(xt[Cn]);
            return xt.length = 0,
            xt
        }
        ,
        TrimModifier.prototype.processShapes = function(xt) {
            var Cn, as, cs, Cs;
            if (this._mdf || xt) {
                var Ls = this.o.v % 360 / 360;
                if (Ls < 0 && (Ls += 1),
                (Cn = this.s.v > 1 ? 1 + Ls : this.s.v < 0 ? 0 + Ls : this.s.v + Ls) > (as = this.e.v > 1 ? 1 + Ls : this.e.v < 0 ? 0 + Ls : this.e.v + Ls)) {
                    var Vs = Cn;
                    Cn = as,
                    as = Vs
                }
                Cn = 1e-4 * Math.round(1e4 * Cn),
                as = 1e-4 * Math.round(1e4 * as),
                this.sValue = Cn,
                this.eValue = as
            } else
                Cn = this.sValue,
                as = this.eValue;
            var Ws, Xs, ga, ba, yl, xl = this.shapes.length, wl = 0;
            if (as === Cn)
                for (Cs = 0; Cs < xl; Cs += 1)
                    this.shapes[Cs].localShapeCollection.releaseShapes(),
                    this.shapes[Cs].shape._mdf = !0,
                    this.shapes[Cs].shape.paths = this.shapes[Cs].localShapeCollection,
                    this._mdf && (this.shapes[Cs].pathsData.length = 0);
            else if (as === 1 && Cn === 0 || as === 0 && Cn === 1) {
                if (this._mdf)
                    for (Cs = 0; Cs < xl; Cs += 1)
                        this.shapes[Cs].pathsData.length = 0,
                        this.shapes[Cs].shape._mdf = !0
            } else {
                var _l, El, Cl = [];
                for (Cs = 0; Cs < xl; Cs += 1)
                    if ((_l = this.shapes[Cs]).shape._mdf || this._mdf || xt || this.m === 2) {
                        if (Xs = (cs = _l.shape.paths)._length,
                        yl = 0,
                        !_l.shape._mdf && _l.pathsData.length)
                            yl = _l.totalShapeLength;
                        else {
                            for (ga = this.releasePathsData(_l.pathsData),
                            Ws = 0; Ws < Xs; Ws += 1)
                                ba = bez.getSegmentsLength(cs.shapes[Ws]),
                                ga.push(ba),
                                yl += ba.totalLength;
                            _l.totalShapeLength = yl,
                            _l.pathsData = ga
                        }
                        wl += yl,
                        _l.shape._mdf = !0
                    } else
                        _l.shape.paths = _l.localShapeCollection;
                var $l, Sl = Cn, Tl = as, Rl = 0;
                for (Cs = xl - 1; Cs >= 0; Cs -= 1)
                    if ((_l = this.shapes[Cs]).shape._mdf) {
                        for ((El = _l.localShapeCollection).releaseShapes(),
                        this.m === 2 && xl > 1 ? ($l = this.calculateShapeEdges(Cn, as, _l.totalShapeLength, Rl, wl),
                        Rl += _l.totalShapeLength) : $l = [[Sl, Tl]],
                        Xs = $l.length,
                        Ws = 0; Ws < Xs; Ws += 1) {
                            Sl = $l[Ws][0],
                            Tl = $l[Ws][1],
                            Cl.length = 0,
                            Tl <= 1 ? Cl.push({
                                s: _l.totalShapeLength * Sl,
                                e: _l.totalShapeLength * Tl
                            }) : Sl >= 1 ? Cl.push({
                                s: _l.totalShapeLength * (Sl - 1),
                                e: _l.totalShapeLength * (Tl - 1)
                            }) : (Cl.push({
                                s: _l.totalShapeLength * Sl,
                                e: _l.totalShapeLength
                            }),
                            Cl.push({
                                s: 0,
                                e: _l.totalShapeLength * (Tl - 1)
                            }));
                            var Il = this.addShapes(_l, Cl[0]);
                            if (Cl[0].s !== Cl[0].e) {
                                if (Cl.length > 1)
                                    if (_l.shape.paths.shapes[_l.shape.paths._length - 1].c) {
                                        var Ml = Il.pop();
                                        this.addPaths(Il, El),
                                        Il = this.addShapes(_l, Cl[1], Ml)
                                    } else
                                        this.addPaths(Il, El),
                                        Il = this.addShapes(_l, Cl[1]);
                                this.addPaths(Il, El)
                            }
                        }
                        _l.shape.paths = El
                    }
            }
        }
        ,
        TrimModifier.prototype.addPaths = function(xt, Cn) {
            var as, cs = xt.length;
            for (as = 0; as < cs; as += 1)
                Cn.addShape(xt[as])
        }
        ,
        TrimModifier.prototype.addSegment = function(xt, Cn, as, cs, Cs, Ls, Vs) {
            Cs.setXYAt(Cn[0], Cn[1], "o", Ls),
            Cs.setXYAt(as[0], as[1], "i", Ls + 1),
            Vs && Cs.setXYAt(xt[0], xt[1], "v", Ls),
            Cs.setXYAt(cs[0], cs[1], "v", Ls + 1)
        }
        ,
        TrimModifier.prototype.addSegmentFromArray = function(xt, Cn, as, cs) {
            Cn.setXYAt(xt[1], xt[5], "o", as),
            Cn.setXYAt(xt[2], xt[6], "i", as + 1),
            cs && Cn.setXYAt(xt[0], xt[4], "v", as),
            Cn.setXYAt(xt[3], xt[7], "v", as + 1)
        }
        ,
        TrimModifier.prototype.addShapes = function(xt, Cn, as) {
            var cs, Cs, Ls, Vs, Ws, Xs, ga, ba, yl = xt.pathsData, xl = xt.shape.paths.shapes, wl = xt.shape.paths._length, _l = 0, El = [], Cl = !0;
            for (as ? (Ws = as._length,
            ba = as._length) : (as = shapePool.newElement(),
            Ws = 0,
            ba = 0),
            El.push(as),
            cs = 0; cs < wl; cs += 1) {
                for (Xs = yl[cs].lengths,
                as.c = xl[cs].c,
                Ls = xl[cs].c ? Xs.length : Xs.length + 1,
                Cs = 1; Cs < Ls; Cs += 1)
                    if (_l + (Vs = Xs[Cs - 1]).addedLength < Cn.s)
                        _l += Vs.addedLength,
                        as.c = !1;
                    else {
                        if (_l > Cn.e) {
                            as.c = !1;
                            break
                        }
                        Cn.s <= _l && Cn.e >= _l + Vs.addedLength ? (this.addSegment(xl[cs].v[Cs - 1], xl[cs].o[Cs - 1], xl[cs].i[Cs], xl[cs].v[Cs], as, Ws, Cl),
                        Cl = !1) : (ga = bez.getNewSegment(xl[cs].v[Cs - 1], xl[cs].v[Cs], xl[cs].o[Cs - 1], xl[cs].i[Cs], (Cn.s - _l) / Vs.addedLength, (Cn.e - _l) / Vs.addedLength, Xs[Cs - 1]),
                        this.addSegmentFromArray(ga, as, Ws, Cl),
                        Cl = !1,
                        as.c = !1),
                        _l += Vs.addedLength,
                        Ws += 1
                    }
                if (xl[cs].c && Xs.length) {
                    if (Vs = Xs[Cs - 1],
                    _l <= Cn.e) {
                        var $l = Xs[Cs - 1].addedLength;
                        Cn.s <= _l && Cn.e >= _l + $l ? (this.addSegment(xl[cs].v[Cs - 1], xl[cs].o[Cs - 1], xl[cs].i[0], xl[cs].v[0], as, Ws, Cl),
                        Cl = !1) : (ga = bez.getNewSegment(xl[cs].v[Cs - 1], xl[cs].v[0], xl[cs].o[Cs - 1], xl[cs].i[0], (Cn.s - _l) / $l, (Cn.e - _l) / $l, Xs[Cs - 1]),
                        this.addSegmentFromArray(ga, as, Ws, Cl),
                        Cl = !1,
                        as.c = !1)
                    } else
                        as.c = !1;
                    _l += Vs.addedLength,
                    Ws += 1
                }
                if (as._length && (as.setXYAt(as.v[ba][0], as.v[ba][1], "i", ba),
                as.setXYAt(as.v[as._length - 1][0], as.v[as._length - 1][1], "o", as._length - 1)),
                _l > Cn.e)
                    break;
                cs < wl - 1 && (as = shapePool.newElement(),
                Cl = !0,
                El.push(as),
                Ws = 0)
            }
            return El
        }
        ,
        extendPrototype([ShapeModifier], PuckerAndBloatModifier),
        PuckerAndBloatModifier.prototype.initModifierProperties = function(xt, Cn) {
            this.getValue = this.processKeys,
            this.amount = PropertyFactory.getProp(xt, Cn.a, 0, null, this),
            this._isAnimated = !!this.amount.effectsSequence.length
        }
        ,
        PuckerAndBloatModifier.prototype.processPath = function(xt, Cn) {
            var as = Cn / 100
              , cs = [0, 0]
              , Cs = xt._length
              , Ls = 0;
            for (Ls = 0; Ls < Cs; Ls += 1)
                cs[0] += xt.v[Ls][0],
                cs[1] += xt.v[Ls][1];
            cs[0] /= Cs,
            cs[1] /= Cs;
            var Vs, Ws, Xs, ga, ba, yl, xl = shapePool.newElement();
            for (xl.c = xt.c,
            Ls = 0; Ls < Cs; Ls += 1)
                Vs = xt.v[Ls][0] + (cs[0] - xt.v[Ls][0]) * as,
                Ws = xt.v[Ls][1] + (cs[1] - xt.v[Ls][1]) * as,
                Xs = xt.o[Ls][0] + (cs[0] - xt.o[Ls][0]) * -as,
                ga = xt.o[Ls][1] + (cs[1] - xt.o[Ls][1]) * -as,
                ba = xt.i[Ls][0] + (cs[0] - xt.i[Ls][0]) * -as,
                yl = xt.i[Ls][1] + (cs[1] - xt.i[Ls][1]) * -as,
                xl.setTripleAt(Vs, Ws, Xs, ga, ba, yl, Ls);
            return xl
        }
        ,
        PuckerAndBloatModifier.prototype.processShapes = function(xt) {
            var Cn, as, cs, Cs, Ls, Vs, Ws = this.shapes.length, Xs = this.amount.v;
            if (Xs !== 0)
                for (as = 0; as < Ws; as += 1) {
                    if (Vs = (Ls = this.shapes[as]).localShapeCollection,
                    Ls.shape._mdf || this._mdf || xt)
                        for (Vs.releaseShapes(),
                        Ls.shape._mdf = !0,
                        Cn = Ls.shape.paths.shapes,
                        Cs = Ls.shape.paths._length,
                        cs = 0; cs < Cs; cs += 1)
                            Vs.addShape(this.processPath(Cn[cs], Xs));
                    Ls.shape.paths = Ls.localShapeCollection
                }
            this.dynamicProperties.length || (this._mdf = !1)
        }
        ;
        var TransformPropertyFactory = function() {
            var xt = [0, 0];
            function Cn(as, cs, Cs) {
                if (this.elem = as,
                this.frameId = -1,
                this.propType = "transform",
                this.data = cs,
                this.v = new Matrix,
                this.pre = new Matrix,
                this.appliedTransformations = 0,
                this.initDynamicPropertyContainer(Cs || as),
                cs.p && cs.p.s ? (this.px = PropertyFactory.getProp(as, cs.p.x, 0, 0, this),
                this.py = PropertyFactory.getProp(as, cs.p.y, 0, 0, this),
                cs.p.z && (this.pz = PropertyFactory.getProp(as, cs.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(as, cs.p || {
                    k: [0, 0, 0]
                }, 1, 0, this),
                cs.rx) {
                    if (this.rx = PropertyFactory.getProp(as, cs.rx, 0, degToRads, this),
                    this.ry = PropertyFactory.getProp(as, cs.ry, 0, degToRads, this),
                    this.rz = PropertyFactory.getProp(as, cs.rz, 0, degToRads, this),
                    cs.or.k[0].ti) {
                        var Ls, Vs = cs.or.k.length;
                        for (Ls = 0; Ls < Vs; Ls += 1)
                            cs.or.k[Ls].to = null,
                            cs.or.k[Ls].ti = null
                    }
                    this.or = PropertyFactory.getProp(as, cs.or, 1, degToRads, this),
                    this.or.sh = !0
                } else
                    this.r = PropertyFactory.getProp(as, cs.r || {
                        k: 0
                    }, 0, degToRads, this);
                cs.sk && (this.sk = PropertyFactory.getProp(as, cs.sk, 0, degToRads, this),
                this.sa = PropertyFactory.getProp(as, cs.sa, 0, degToRads, this)),
                this.a = PropertyFactory.getProp(as, cs.a || {
                    k: [0, 0, 0]
                }, 1, 0, this),
                this.s = PropertyFactory.getProp(as, cs.s || {
                    k: [100, 100, 100]
                }, 1, .01, this),
                cs.o ? this.o = PropertyFactory.getProp(as, cs.o, 0, .01, as) : this.o = {
                    _mdf: !1,
                    v: 1
                },
                this._isDirty = !0,
                this.dynamicProperties.length || this.getValue(!0)
            }
            return Cn.prototype = {
                applyToMatrix: function(as) {
                    var cs = this._mdf;
                    this.iterateDynamicProperties(),
                    this._mdf = this._mdf || cs,
                    this.a && as.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                    this.s && as.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                    this.sk && as.skewFromAxis(-this.sk.v, this.sa.v),
                    this.r ? as.rotate(-this.r.v) : as.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]),
                    this.data.p.s ? this.data.p.z ? as.translate(this.px.v, this.py.v, -this.pz.v) : as.translate(this.px.v, this.py.v, 0) : as.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                },
                getValue: function(as) {
                    if (this.elem.globalData.frameId !== this.frameId) {
                        if (this._isDirty && (this.precalculateMatrix(),
                        this._isDirty = !1),
                        this.iterateDynamicProperties(),
                        this._mdf || as) {
                            var cs;
                            if (this.v.cloneFromProps(this.pre.props),
                            this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                            this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                            this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v),
                            this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]),
                            this.autoOriented) {
                                var Cs, Ls;
                                if (cs = this.elem.globalData.frameRate,
                                this.p && this.p.keyframes && this.p.getValueAtTime)
                                    this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (Cs = this.p.getValueAtTime((this.p.keyframes[0].t + .01) / cs, 0),
                                    Ls = this.p.getValueAtTime(this.p.keyframes[0].t / cs, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (Cs = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / cs, 0),
                                    Ls = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - .05) / cs, 0)) : (Cs = this.p.pv,
                                    Ls = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - .01) / cs, this.p.offsetTime));
                                else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                                    Cs = [],
                                    Ls = [];
                                    var Vs = this.px
                                      , Ws = this.py;
                                    Vs._caching.lastFrame + Vs.offsetTime <= Vs.keyframes[0].t ? (Cs[0] = Vs.getValueAtTime((Vs.keyframes[0].t + .01) / cs, 0),
                                    Cs[1] = Ws.getValueAtTime((Ws.keyframes[0].t + .01) / cs, 0),
                                    Ls[0] = Vs.getValueAtTime(Vs.keyframes[0].t / cs, 0),
                                    Ls[1] = Ws.getValueAtTime(Ws.keyframes[0].t / cs, 0)) : Vs._caching.lastFrame + Vs.offsetTime >= Vs.keyframes[Vs.keyframes.length - 1].t ? (Cs[0] = Vs.getValueAtTime(Vs.keyframes[Vs.keyframes.length - 1].t / cs, 0),
                                    Cs[1] = Ws.getValueAtTime(Ws.keyframes[Ws.keyframes.length - 1].t / cs, 0),
                                    Ls[0] = Vs.getValueAtTime((Vs.keyframes[Vs.keyframes.length - 1].t - .01) / cs, 0),
                                    Ls[1] = Ws.getValueAtTime((Ws.keyframes[Ws.keyframes.length - 1].t - .01) / cs, 0)) : (Cs = [Vs.pv, Ws.pv],
                                    Ls[0] = Vs.getValueAtTime((Vs._caching.lastFrame + Vs.offsetTime - .01) / cs, Vs.offsetTime),
                                    Ls[1] = Ws.getValueAtTime((Ws._caching.lastFrame + Ws.offsetTime - .01) / cs, Ws.offsetTime))
                                } else
                                    Cs = Ls = xt;
                                this.v.rotate(-Math.atan2(Cs[1] - Ls[1], Cs[0] - Ls[0]))
                            }
                            this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                        }
                        this.frameId = this.elem.globalData.frameId
                    }
                },
                precalculateMatrix: function() {
                    if (this.appliedTransformations = 0,
                    this.pre.reset(),
                    !this.a.effectsSequence.length && (this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                    this.appliedTransformations = 1,
                    !this.s.effectsSequence.length)) {
                        if (this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                        this.appliedTransformations = 2,
                        this.sk) {
                            if (this.sk.effectsSequence.length || this.sa.effectsSequence.length)
                                return;
                            this.pre.skewFromAxis(-this.sk.v, this.sa.v),
                            this.appliedTransformations = 3
                        }
                        this.r ? this.r.effectsSequence.length || (this.pre.rotate(-this.r.v),
                        this.appliedTransformations = 4) : this.rz.effectsSequence.length || this.ry.effectsSequence.length || this.rx.effectsSequence.length || this.or.effectsSequence.length || (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]),
                        this.appliedTransformations = 4)
                    }
                },
                autoOrient: function() {}
            },
            extendPrototype([DynamicPropertyContainer], Cn),
            Cn.prototype.addDynamicProperty = function(as) {
                this._addDynamicProperty(as),
                this.elem.addDynamicProperty(as),
                this._isDirty = !0
            }
            ,
            Cn.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty,
            {
                getTransformProperty: function(as, cs, Cs) {
                    return new Cn(as,cs,Cs)
                }
            }
        }();
        function RepeaterModifier() {}
        function RoundCornersModifier() {}
        function floatEqual(xt, Cn) {
            return 1e5 * Math.abs(xt - Cn) <= Math.min(Math.abs(xt), Math.abs(Cn))
        }
        function floatZero(xt) {
            return Math.abs(xt) <= 1e-5
        }
        function lerp(xt, Cn, as) {
            return xt * (1 - as) + Cn * as
        }
        function lerpPoint(xt, Cn, as) {
            return [lerp(xt[0], Cn[0], as), lerp(xt[1], Cn[1], as)]
        }
        function quadRoots(xt, Cn, as) {
            if (xt === 0)
                return [];
            var cs = Cn * Cn - 4 * xt * as;
            if (cs < 0)
                return [];
            var Cs = -Cn / (2 * xt);
            if (cs === 0)
                return [Cs];
            var Ls = Math.sqrt(cs) / (2 * xt);
            return [Cs - Ls, Cs + Ls]
        }
        function polynomialCoefficients(xt, Cn, as, cs) {
            return [3 * Cn - xt - 3 * as + cs, 3 * xt - 6 * Cn + 3 * as, -3 * xt + 3 * Cn, xt]
        }
        function singlePoint(xt) {
            return new PolynomialBezier(xt,xt,xt,xt,!1)
        }
        function PolynomialBezier(xt, Cn, as, cs, Cs) {
            Cs && pointEqual(xt, Cn) && (Cn = lerpPoint(xt, cs, 1 / 3)),
            Cs && pointEqual(as, cs) && (as = lerpPoint(xt, cs, 2 / 3));
            var Ls = polynomialCoefficients(xt[0], Cn[0], as[0], cs[0])
              , Vs = polynomialCoefficients(xt[1], Cn[1], as[1], cs[1]);
            this.a = [Ls[0], Vs[0]],
            this.b = [Ls[1], Vs[1]],
            this.c = [Ls[2], Vs[2]],
            this.d = [Ls[3], Vs[3]],
            this.points = [xt, Cn, as, cs]
        }
        function extrema(xt, Cn) {
            var as = xt.points[0][Cn]
              , cs = xt.points[xt.points.length - 1][Cn];
            if (as > cs) {
                var Cs = cs;
                cs = as,
                as = Cs
            }
            for (var Ls = quadRoots(3 * xt.a[Cn], 2 * xt.b[Cn], xt.c[Cn]), Vs = 0; Vs < Ls.length; Vs += 1)
                if (Ls[Vs] > 0 && Ls[Vs] < 1) {
                    var Ws = xt.point(Ls[Vs])[Cn];
                    Ws < as ? as = Ws : Ws > cs && (cs = Ws)
                }
            return {
                min: as,
                max: cs
            }
        }
        function intersectData(xt, Cn, as) {
            var cs = xt.boundingBox();
            return {
                cx: cs.cx,
                cy: cs.cy,
                width: cs.width,
                height: cs.height,
                bez: xt,
                t: (Cn + as) / 2,
                t1: Cn,
                t2: as
            }
        }
        function splitData(xt) {
            var Cn = xt.bez.split(.5);
            return [intersectData(Cn[0], xt.t1, xt.t), intersectData(Cn[1], xt.t, xt.t2)]
        }
        function boxIntersect(xt, Cn) {
            return 2 * Math.abs(xt.cx - Cn.cx) < xt.width + Cn.width && 2 * Math.abs(xt.cy - Cn.cy) < xt.height + Cn.height
        }
        function intersectsImpl(xt, Cn, as, cs, Cs, Ls) {
            if (boxIntersect(xt, Cn))
                if (as >= Ls || xt.width <= cs && xt.height <= cs && Cn.width <= cs && Cn.height <= cs)
                    Cs.push([xt.t, Cn.t]);
                else {
                    var Vs = splitData(xt)
                      , Ws = splitData(Cn);
                    intersectsImpl(Vs[0], Ws[0], as + 1, cs, Cs, Ls),
                    intersectsImpl(Vs[0], Ws[1], as + 1, cs, Cs, Ls),
                    intersectsImpl(Vs[1], Ws[0], as + 1, cs, Cs, Ls),
                    intersectsImpl(Vs[1], Ws[1], as + 1, cs, Cs, Ls)
                }
        }
        function crossProduct(xt, Cn) {
            return [xt[1] * Cn[2] - xt[2] * Cn[1], xt[2] * Cn[0] - xt[0] * Cn[2], xt[0] * Cn[1] - xt[1] * Cn[0]]
        }
        function lineIntersection(xt, Cn, as, cs) {
            var Cs = [xt[0], xt[1], 1]
              , Ls = [Cn[0], Cn[1], 1]
              , Vs = [as[0], as[1], 1]
              , Ws = [cs[0], cs[1], 1]
              , Xs = crossProduct(crossProduct(Cs, Ls), crossProduct(Vs, Ws));
            return floatZero(Xs[2]) ? null : [Xs[0] / Xs[2], Xs[1] / Xs[2]]
        }
        function polarOffset(xt, Cn, as) {
            return [xt[0] + Math.cos(Cn) * as, xt[1] - Math.sin(Cn) * as]
        }
        function pointDistance(xt, Cn) {
            return Math.hypot(xt[0] - Cn[0], xt[1] - Cn[1])
        }
        function pointEqual(xt, Cn) {
            return floatEqual(xt[0], Cn[0]) && floatEqual(xt[1], Cn[1])
        }
        function ZigZagModifier() {}
        function setPoint(xt, Cn, as, cs, Cs, Ls, Vs) {
            var Ws = as - Math.PI / 2
              , Xs = as + Math.PI / 2
              , ga = Cn[0] + Math.cos(as) * cs * Cs
              , ba = Cn[1] - Math.sin(as) * cs * Cs;
            xt.setTripleAt(ga, ba, ga + Math.cos(Ws) * Ls, ba - Math.sin(Ws) * Ls, ga + Math.cos(Xs) * Vs, ba - Math.sin(Xs) * Vs, xt.length())
        }
        function getPerpendicularVector(xt, Cn) {
            var as = [Cn[0] - xt[0], Cn[1] - xt[1]]
              , cs = .5 * -Math.PI;
            return [Math.cos(cs) * as[0] - Math.sin(cs) * as[1], Math.sin(cs) * as[0] + Math.cos(cs) * as[1]]
        }
        function getProjectingAngle(xt, Cn) {
            var as = Cn === 0 ? xt.length() - 1 : Cn - 1
              , cs = (Cn + 1) % xt.length()
              , Cs = getPerpendicularVector(xt.v[as], xt.v[cs]);
            return Math.atan2(0, 1) - Math.atan2(Cs[1], Cs[0])
        }
        function zigZagCorner(xt, Cn, as, cs, Cs, Ls, Vs) {
            var Ws = getProjectingAngle(Cn, as)
              , Xs = Cn.v[as % Cn._length]
              , ga = Cn.v[as === 0 ? Cn._length - 1 : as - 1]
              , ba = Cn.v[(as + 1) % Cn._length]
              , yl = Ls === 2 ? Math.sqrt(Math.pow(Xs[0] - ga[0], 2) + Math.pow(Xs[1] - ga[1], 2)) : 0
              , xl = Ls === 2 ? Math.sqrt(Math.pow(Xs[0] - ba[0], 2) + Math.pow(Xs[1] - ba[1], 2)) : 0;
            setPoint(xt, Cn.v[as % Cn._length], Ws, Vs, cs, xl / (2 * (Cs + 1)), yl / (2 * (Cs + 1)))
        }
        function zigZagSegment(xt, Cn, as, cs, Cs, Ls) {
            for (var Vs = 0; Vs < cs; Vs += 1) {
                var Ws = (Vs + 1) / (cs + 1)
                  , Xs = Cs === 2 ? Math.sqrt(Math.pow(Cn.points[3][0] - Cn.points[0][0], 2) + Math.pow(Cn.points[3][1] - Cn.points[0][1], 2)) : 0
                  , ga = Cn.normalAngle(Ws);
                setPoint(xt, Cn.point(Ws), ga, Ls, as, Xs / (2 * (cs + 1)), Xs / (2 * (cs + 1))),
                Ls = -Ls
            }
            return Ls
        }
        function linearOffset(xt, Cn, as) {
            var cs = Math.atan2(Cn[0] - xt[0], Cn[1] - xt[1]);
            return [polarOffset(xt, cs, as), polarOffset(Cn, cs, as)]
        }
        function offsetSegment(xt, Cn) {
            var as, cs, Cs, Ls, Vs, Ws, Xs;
            as = (Xs = linearOffset(xt.points[0], xt.points[1], Cn))[0],
            cs = Xs[1],
            Cs = (Xs = linearOffset(xt.points[1], xt.points[2], Cn))[0],
            Ls = Xs[1],
            Vs = (Xs = linearOffset(xt.points[2], xt.points[3], Cn))[0],
            Ws = Xs[1];
            var ga = lineIntersection(as, cs, Cs, Ls);
            ga === null && (ga = cs);
            var ba = lineIntersection(Vs, Ws, Cs, Ls);
            return ba === null && (ba = Vs),
            new PolynomialBezier(as,ga,ba,Ws)
        }
        function joinLines(xt, Cn, as, cs, Cs) {
            var Ls = Cn.points[3]
              , Vs = as.points[0];
            if (cs === 3 || pointEqual(Ls, Vs))
                return Ls;
            if (cs === 2) {
                var Ws = -Cn.tangentAngle(1)
                  , Xs = -as.tangentAngle(0) + Math.PI
                  , ga = lineIntersection(Ls, polarOffset(Ls, Ws + Math.PI / 2, 100), Vs, polarOffset(Vs, Ws + Math.PI / 2, 100))
                  , ba = ga ? pointDistance(ga, Ls) : pointDistance(Ls, Vs) / 2
                  , yl = polarOffset(Ls, Ws, 2 * ba * roundCorner);
                return xt.setXYAt(yl[0], yl[1], "o", xt.length() - 1),
                yl = polarOffset(Vs, Xs, 2 * ba * roundCorner),
                xt.setTripleAt(Vs[0], Vs[1], Vs[0], Vs[1], yl[0], yl[1], xt.length()),
                Vs
            }
            var xl = lineIntersection(pointEqual(Ls, Cn.points[2]) ? Cn.points[0] : Cn.points[2], Ls, Vs, pointEqual(Vs, as.points[1]) ? as.points[3] : as.points[1]);
            return xl && pointDistance(xl, Ls) < Cs ? (xt.setTripleAt(xl[0], xl[1], xl[0], xl[1], xl[0], xl[1], xt.length()),
            xl) : Ls
        }
        function getIntersection(xt, Cn) {
            var as = xt.intersections(Cn);
            return as.length && floatEqual(as[0][0], 1) && as.shift(),
            as.length ? as[0] : null
        }
        function pruneSegmentIntersection(xt, Cn) {
            var as = xt.slice()
              , cs = Cn.slice()
              , Cs = getIntersection(xt[xt.length - 1], Cn[0]);
            return Cs && (as[xt.length - 1] = xt[xt.length - 1].split(Cs[0])[0],
            cs[0] = Cn[0].split(Cs[1])[1]),
            xt.length > 1 && Cn.length > 1 && (Cs = getIntersection(xt[0], Cn[Cn.length - 1])) ? [[xt[0].split(Cs[0])[0]], [Cn[Cn.length - 1].split(Cs[1])[1]]] : [as, cs]
        }
        function pruneIntersections(xt) {
            for (var Cn, as = 1; as < xt.length; as += 1)
                Cn = pruneSegmentIntersection(xt[as - 1], xt[as]),
                xt[as - 1] = Cn[0],
                xt[as] = Cn[1];
            return xt.length > 1 && (Cn = pruneSegmentIntersection(xt[xt.length - 1], xt[0]),
            xt[xt.length - 1] = Cn[0],
            xt[0] = Cn[1]),
            xt
        }
        function offsetSegmentSplit(xt, Cn) {
            var as, cs, Cs, Ls, Vs = xt.inflectionPoints();
            if (Vs.length === 0)
                return [offsetSegment(xt, Cn)];
            if (Vs.length === 1 || floatEqual(Vs[1], 1))
                return as = (Cs = xt.split(Vs[0]))[0],
                cs = Cs[1],
                [offsetSegment(as, Cn), offsetSegment(cs, Cn)];
            as = (Cs = xt.split(Vs[0]))[0];
            var Ws = (Vs[1] - Vs[0]) / (1 - Vs[0]);
            return Ls = (Cs = Cs[1].split(Ws))[0],
            cs = Cs[1],
            [offsetSegment(as, Cn), offsetSegment(Ls, Cn), offsetSegment(cs, Cn)]
        }
        function OffsetPathModifier() {}
        function getFontProperties(xt) {
            for (var Cn = xt.fStyle ? xt.fStyle.split(" ") : [], as = "normal", cs = "normal", Cs = Cn.length, Ls = 0; Ls < Cs; Ls += 1)
                switch (Cn[Ls].toLowerCase()) {
                case "italic":
                    cs = "italic";
                    break;
                case "bold":
                    as = "700";
                    break;
                case "black":
                    as = "900";
                    break;
                case "medium":
                    as = "500";
                    break;
                case "regular":
                case "normal":
                    as = "400";
                    break;
                case "light":
                case "thin":
                    as = "200"
                }
            return {
                style: cs,
                weight: xt.fWeight || as
            }
        }
        extendPrototype([ShapeModifier], RepeaterModifier),
        RepeaterModifier.prototype.initModifierProperties = function(xt, Cn) {
            this.getValue = this.processKeys,
            this.c = PropertyFactory.getProp(xt, Cn.c, 0, null, this),
            this.o = PropertyFactory.getProp(xt, Cn.o, 0, null, this),
            this.tr = TransformPropertyFactory.getTransformProperty(xt, Cn.tr, this),
            this.so = PropertyFactory.getProp(xt, Cn.tr.so, 0, .01, this),
            this.eo = PropertyFactory.getProp(xt, Cn.tr.eo, 0, .01, this),
            this.data = Cn,
            this.dynamicProperties.length || this.getValue(!0),
            this._isAnimated = !!this.dynamicProperties.length,
            this.pMatrix = new Matrix,
            this.rMatrix = new Matrix,
            this.sMatrix = new Matrix,
            this.tMatrix = new Matrix,
            this.matrix = new Matrix
        }
        ,
        RepeaterModifier.prototype.applyTransforms = function(xt, Cn, as, cs, Cs, Ls) {
            var Vs = Ls ? -1 : 1
              , Ws = cs.s.v[0] + (1 - cs.s.v[0]) * (1 - Cs)
              , Xs = cs.s.v[1] + (1 - cs.s.v[1]) * (1 - Cs);
            xt.translate(cs.p.v[0] * Vs * Cs, cs.p.v[1] * Vs * Cs, cs.p.v[2]),
            Cn.translate(-cs.a.v[0], -cs.a.v[1], cs.a.v[2]),
            Cn.rotate(-cs.r.v * Vs * Cs),
            Cn.translate(cs.a.v[0], cs.a.v[1], cs.a.v[2]),
            as.translate(-cs.a.v[0], -cs.a.v[1], cs.a.v[2]),
            as.scale(Ls ? 1 / Ws : Ws, Ls ? 1 / Xs : Xs),
            as.translate(cs.a.v[0], cs.a.v[1], cs.a.v[2])
        }
        ,
        RepeaterModifier.prototype.init = function(xt, Cn, as, cs) {
            for (this.elem = xt,
            this.arr = Cn,
            this.pos = as,
            this.elemsData = cs,
            this._currentCopies = 0,
            this._elements = [],
            this._groups = [],
            this.frameId = -1,
            this.initDynamicPropertyContainer(xt),
            this.initModifierProperties(xt, Cn[as]); as > 0; )
                as -= 1,
                this._elements.unshift(Cn[as]);
            this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
        }
        ,
        RepeaterModifier.prototype.resetElements = function(xt) {
            var Cn, as = xt.length;
            for (Cn = 0; Cn < as; Cn += 1)
                xt[Cn]._processed = !1,
                xt[Cn].ty === "gr" && this.resetElements(xt[Cn].it)
        }
        ,
        RepeaterModifier.prototype.cloneElements = function(xt) {
            var Cn = JSON.parse(JSON.stringify(xt));
            return this.resetElements(Cn),
            Cn
        }
        ,
        RepeaterModifier.prototype.changeGroupRender = function(xt, Cn) {
            var as, cs = xt.length;
            for (as = 0; as < cs; as += 1)
                xt[as]._render = Cn,
                xt[as].ty === "gr" && this.changeGroupRender(xt[as].it, Cn)
        }
        ,
        RepeaterModifier.prototype.processShapes = function(xt) {
            var Cn, as, cs, Cs, Ls, Vs = !1;
            if (this._mdf || xt) {
                var Ws, Xs = Math.ceil(this.c.v);
                if (this._groups.length < Xs) {
                    for (; this._groups.length < Xs; ) {
                        var ga = {
                            it: this.cloneElements(this._elements),
                            ty: "gr"
                        };
                        ga.it.push({
                            a: {
                                a: 0,
                                ix: 1,
                                k: [0, 0]
                            },
                            nm: "Transform",
                            o: {
                                a: 0,
                                ix: 7,
                                k: 100
                            },
                            p: {
                                a: 0,
                                ix: 2,
                                k: [0, 0]
                            },
                            r: {
                                a: 1,
                                ix: 6,
                                k: [{
                                    s: 0,
                                    e: 0,
                                    t: 0
                                }, {
                                    s: 0,
                                    e: 0,
                                    t: 1
                                }]
                            },
                            s: {
                                a: 0,
                                ix: 3,
                                k: [100, 100]
                            },
                            sa: {
                                a: 0,
                                ix: 5,
                                k: 0
                            },
                            sk: {
                                a: 0,
                                ix: 4,
                                k: 0
                            },
                            ty: "tr"
                        }),
                        this.arr.splice(0, 0, ga),
                        this._groups.splice(0, 0, ga),
                        this._currentCopies += 1
                    }
                    this.elem.reloadShapes(),
                    Vs = !0
                }
                for (Ls = 0,
                cs = 0; cs <= this._groups.length - 1; cs += 1) {
                    if (Ws = Ls < Xs,
                    this._groups[cs]._render = Ws,
                    this.changeGroupRender(this._groups[cs].it, Ws),
                    !Ws) {
                        var ba = this.elemsData[cs].it
                          , yl = ba[ba.length - 1];
                        yl.transform.op.v !== 0 ? (yl.transform.op._mdf = !0,
                        yl.transform.op.v = 0) : yl.transform.op._mdf = !1
                    }
                    Ls += 1
                }
                this._currentCopies = Xs;
                var xl = this.o.v
                  , wl = xl % 1
                  , _l = xl > 0 ? Math.floor(xl) : Math.ceil(xl)
                  , El = this.pMatrix.props
                  , Cl = this.rMatrix.props
                  , $l = this.sMatrix.props;
                this.pMatrix.reset(),
                this.rMatrix.reset(),
                this.sMatrix.reset(),
                this.tMatrix.reset(),
                this.matrix.reset();
                var Sl, Tl, Rl = 0;
                if (xl > 0) {
                    for (; Rl < _l; )
                        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1),
                        Rl += 1;
                    wl && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, wl, !1),
                    Rl += wl)
                } else if (xl < 0) {
                    for (; Rl > _l; )
                        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0),
                        Rl -= 1;
                    wl && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -wl, !0),
                    Rl -= wl)
                }
                for (cs = this.data.m === 1 ? 0 : this._currentCopies - 1,
                Cs = this.data.m === 1 ? 1 : -1,
                Ls = this._currentCopies; Ls; ) {
                    if (Tl = (as = (Cn = this.elemsData[cs].it)[Cn.length - 1].transform.mProps.v.props).length,
                    Cn[Cn.length - 1].transform.mProps._mdf = !0,
                    Cn[Cn.length - 1].transform.op._mdf = !0,
                    Cn[Cn.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (cs / (this._currentCopies - 1)),
                    Rl !== 0) {
                        for ((cs !== 0 && Cs === 1 || cs !== this._currentCopies - 1 && Cs === -1) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1),
                        this.matrix.transform(Cl[0], Cl[1], Cl[2], Cl[3], Cl[4], Cl[5], Cl[6], Cl[7], Cl[8], Cl[9], Cl[10], Cl[11], Cl[12], Cl[13], Cl[14], Cl[15]),
                        this.matrix.transform($l[0], $l[1], $l[2], $l[3], $l[4], $l[5], $l[6], $l[7], $l[8], $l[9], $l[10], $l[11], $l[12], $l[13], $l[14], $l[15]),
                        this.matrix.transform(El[0], El[1], El[2], El[3], El[4], El[5], El[6], El[7], El[8], El[9], El[10], El[11], El[12], El[13], El[14], El[15]),
                        Sl = 0; Sl < Tl; Sl += 1)
                            as[Sl] = this.matrix.props[Sl];
                        this.matrix.reset()
                    } else
                        for (this.matrix.reset(),
                        Sl = 0; Sl < Tl; Sl += 1)
                            as[Sl] = this.matrix.props[Sl];
                    Rl += 1,
                    Ls -= 1,
                    cs += Cs
                }
            } else
                for (Ls = this._currentCopies,
                cs = 0,
                Cs = 1; Ls; )
                    as = (Cn = this.elemsData[cs].it)[Cn.length - 1].transform.mProps.v.props,
                    Cn[Cn.length - 1].transform.mProps._mdf = !1,
                    Cn[Cn.length - 1].transform.op._mdf = !1,
                    Ls -= 1,
                    cs += Cs;
            return Vs
        }
        ,
        RepeaterModifier.prototype.addShape = function() {}
        ,
        extendPrototype([ShapeModifier], RoundCornersModifier),
        RoundCornersModifier.prototype.initModifierProperties = function(xt, Cn) {
            this.getValue = this.processKeys,
            this.rd = PropertyFactory.getProp(xt, Cn.r, 0, null, this),
            this._isAnimated = !!this.rd.effectsSequence.length
        }
        ,
        RoundCornersModifier.prototype.processPath = function(xt, Cn) {
            var as, cs = shapePool.newElement();
            cs.c = xt.c;
            var Cs, Ls, Vs, Ws, Xs, ga, ba, yl, xl, wl, _l, El, Cl = xt._length, $l = 0;
            for (as = 0; as < Cl; as += 1)
                Cs = xt.v[as],
                Vs = xt.o[as],
                Ls = xt.i[as],
                Cs[0] === Vs[0] && Cs[1] === Vs[1] && Cs[0] === Ls[0] && Cs[1] === Ls[1] ? as !== 0 && as !== Cl - 1 || xt.c ? (Ws = as === 0 ? xt.v[Cl - 1] : xt.v[as - 1],
                ga = (Xs = Math.sqrt(Math.pow(Cs[0] - Ws[0], 2) + Math.pow(Cs[1] - Ws[1], 2))) ? Math.min(Xs / 2, Cn) / Xs : 0,
                ba = _l = Cs[0] + (Ws[0] - Cs[0]) * ga,
                yl = El = Cs[1] - (Cs[1] - Ws[1]) * ga,
                xl = ba - (ba - Cs[0]) * roundCorner,
                wl = yl - (yl - Cs[1]) * roundCorner,
                cs.setTripleAt(ba, yl, xl, wl, _l, El, $l),
                $l += 1,
                Ws = as === Cl - 1 ? xt.v[0] : xt.v[as + 1],
                ga = (Xs = Math.sqrt(Math.pow(Cs[0] - Ws[0], 2) + Math.pow(Cs[1] - Ws[1], 2))) ? Math.min(Xs / 2, Cn) / Xs : 0,
                ba = xl = Cs[0] + (Ws[0] - Cs[0]) * ga,
                yl = wl = Cs[1] + (Ws[1] - Cs[1]) * ga,
                _l = ba - (ba - Cs[0]) * roundCorner,
                El = yl - (yl - Cs[1]) * roundCorner,
                cs.setTripleAt(ba, yl, xl, wl, _l, El, $l),
                $l += 1) : (cs.setTripleAt(Cs[0], Cs[1], Vs[0], Vs[1], Ls[0], Ls[1], $l),
                $l += 1) : (cs.setTripleAt(xt.v[as][0], xt.v[as][1], xt.o[as][0], xt.o[as][1], xt.i[as][0], xt.i[as][1], $l),
                $l += 1);
            return cs
        }
        ,
        RoundCornersModifier.prototype.processShapes = function(xt) {
            var Cn, as, cs, Cs, Ls, Vs, Ws = this.shapes.length, Xs = this.rd.v;
            if (Xs !== 0)
                for (as = 0; as < Ws; as += 1) {
                    if (Vs = (Ls = this.shapes[as]).localShapeCollection,
                    Ls.shape._mdf || this._mdf || xt)
                        for (Vs.releaseShapes(),
                        Ls.shape._mdf = !0,
                        Cn = Ls.shape.paths.shapes,
                        Cs = Ls.shape.paths._length,
                        cs = 0; cs < Cs; cs += 1)
                            Vs.addShape(this.processPath(Cn[cs], Xs));
                    Ls.shape.paths = Ls.localShapeCollection
                }
            this.dynamicProperties.length || (this._mdf = !1)
        }
        ,
        PolynomialBezier.prototype.point = function(xt) {
            return [((this.a[0] * xt + this.b[0]) * xt + this.c[0]) * xt + this.d[0], ((this.a[1] * xt + this.b[1]) * xt + this.c[1]) * xt + this.d[1]]
        }
        ,
        PolynomialBezier.prototype.derivative = function(xt) {
            return [(3 * xt * this.a[0] + 2 * this.b[0]) * xt + this.c[0], (3 * xt * this.a[1] + 2 * this.b[1]) * xt + this.c[1]]
        }
        ,
        PolynomialBezier.prototype.tangentAngle = function(xt) {
            var Cn = this.derivative(xt);
            return Math.atan2(Cn[1], Cn[0])
        }
        ,
        PolynomialBezier.prototype.normalAngle = function(xt) {
            var Cn = this.derivative(xt);
            return Math.atan2(Cn[0], Cn[1])
        }
        ,
        PolynomialBezier.prototype.inflectionPoints = function() {
            var xt = this.a[1] * this.b[0] - this.a[0] * this.b[1];
            if (floatZero(xt))
                return [];
            var Cn = -.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / xt
              , as = Cn * Cn - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / xt;
            if (as < 0)
                return [];
            var cs = Math.sqrt(as);
            return floatZero(cs) ? cs > 0 && cs < 1 ? [Cn] : [] : [Cn - cs, Cn + cs].filter(function(Cs) {
                return Cs > 0 && Cs < 1
            })
        }
        ,
        PolynomialBezier.prototype.split = function(xt) {
            if (xt <= 0)
                return [singlePoint(this.points[0]), this];
            if (xt >= 1)
                return [this, singlePoint(this.points[this.points.length - 1])];
            var Cn = lerpPoint(this.points[0], this.points[1], xt)
              , as = lerpPoint(this.points[1], this.points[2], xt)
              , cs = lerpPoint(this.points[2], this.points[3], xt)
              , Cs = lerpPoint(Cn, as, xt)
              , Ls = lerpPoint(as, cs, xt)
              , Vs = lerpPoint(Cs, Ls, xt);
            return [new PolynomialBezier(this.points[0],Cn,Cs,Vs,!0), new PolynomialBezier(Vs,Ls,cs,this.points[3],!0)]
        }
        ,
        PolynomialBezier.prototype.bounds = function() {
            return {
                x: extrema(this, 0),
                y: extrema(this, 1)
            }
        }
        ,
        PolynomialBezier.prototype.boundingBox = function() {
            var xt = this.bounds();
            return {
                left: xt.x.min,
                right: xt.x.max,
                top: xt.y.min,
                bottom: xt.y.max,
                width: xt.x.max - xt.x.min,
                height: xt.y.max - xt.y.min,
                cx: (xt.x.max + xt.x.min) / 2,
                cy: (xt.y.max + xt.y.min) / 2
            }
        }
        ,
        PolynomialBezier.prototype.intersections = function(xt, Cn, as) {
            Cn === void 0 && (Cn = 2),
            as === void 0 && (as = 7);
            var cs = [];
            return intersectsImpl(intersectData(this, 0, 1), intersectData(xt, 0, 1), 0, Cn, cs, as),
            cs
        }
        ,
        PolynomialBezier.shapeSegment = function(xt, Cn) {
            var as = (Cn + 1) % xt.length();
            return new PolynomialBezier(xt.v[Cn],xt.o[Cn],xt.i[as],xt.v[as],!0)
        }
        ,
        PolynomialBezier.shapeSegmentInverted = function(xt, Cn) {
            var as = (Cn + 1) % xt.length();
            return new PolynomialBezier(xt.v[as],xt.i[as],xt.o[Cn],xt.v[Cn],!0)
        }
        ,
        extendPrototype([ShapeModifier], ZigZagModifier),
        ZigZagModifier.prototype.initModifierProperties = function(xt, Cn) {
            this.getValue = this.processKeys,
            this.amplitude = PropertyFactory.getProp(xt, Cn.s, 0, null, this),
            this.frequency = PropertyFactory.getProp(xt, Cn.r, 0, null, this),
            this.pointsType = PropertyFactory.getProp(xt, Cn.pt, 0, null, this),
            this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0
        }
        ,
        ZigZagModifier.prototype.processPath = function(xt, Cn, as, cs) {
            var Cs = xt._length
              , Ls = shapePool.newElement();
            if (Ls.c = xt.c,
            xt.c || (Cs -= 1),
            Cs === 0)
                return Ls;
            var Vs = -1
              , Ws = PolynomialBezier.shapeSegment(xt, 0);
            zigZagCorner(Ls, xt, 0, Cn, as, cs, Vs);
            for (var Xs = 0; Xs < Cs; Xs += 1)
                Vs = zigZagSegment(Ls, Ws, Cn, as, cs, -Vs),
                Ws = Xs !== Cs - 1 || xt.c ? PolynomialBezier.shapeSegment(xt, (Xs + 1) % Cs) : null,
                zigZagCorner(Ls, xt, Xs + 1, Cn, as, cs, Vs);
            return Ls
        }
        ,
        ZigZagModifier.prototype.processShapes = function(xt) {
            var Cn, as, cs, Cs, Ls, Vs, Ws = this.shapes.length, Xs = this.amplitude.v, ga = Math.max(0, Math.round(this.frequency.v)), ba = this.pointsType.v;
            if (Xs !== 0)
                for (as = 0; as < Ws; as += 1) {
                    if (Vs = (Ls = this.shapes[as]).localShapeCollection,
                    Ls.shape._mdf || this._mdf || xt)
                        for (Vs.releaseShapes(),
                        Ls.shape._mdf = !0,
                        Cn = Ls.shape.paths.shapes,
                        Cs = Ls.shape.paths._length,
                        cs = 0; cs < Cs; cs += 1)
                            Vs.addShape(this.processPath(Cn[cs], Xs, ga, ba));
                    Ls.shape.paths = Ls.localShapeCollection
                }
            this.dynamicProperties.length || (this._mdf = !1)
        }
        ,
        extendPrototype([ShapeModifier], OffsetPathModifier),
        OffsetPathModifier.prototype.initModifierProperties = function(xt, Cn) {
            this.getValue = this.processKeys,
            this.amount = PropertyFactory.getProp(xt, Cn.a, 0, null, this),
            this.miterLimit = PropertyFactory.getProp(xt, Cn.ml, 0, null, this),
            this.lineJoin = Cn.lj,
            this._isAnimated = this.amount.effectsSequence.length !== 0
        }
        ,
        OffsetPathModifier.prototype.processPath = function(xt, Cn, as, cs) {
            var Cs = shapePool.newElement();
            Cs.c = xt.c;
            var Ls, Vs, Ws, Xs = xt.length();
            xt.c || (Xs -= 1);
            var ga = [];
            for (Ls = 0; Ls < Xs; Ls += 1)
                Ws = PolynomialBezier.shapeSegment(xt, Ls),
                ga.push(offsetSegmentSplit(Ws, Cn));
            if (!xt.c)
                for (Ls = Xs - 1; Ls >= 0; Ls -= 1)
                    Ws = PolynomialBezier.shapeSegmentInverted(xt, Ls),
                    ga.push(offsetSegmentSplit(Ws, Cn));
            ga = pruneIntersections(ga);
            var ba = null
              , yl = null;
            for (Ls = 0; Ls < ga.length; Ls += 1) {
                var xl = ga[Ls];
                for (yl && (ba = joinLines(Cs, yl, xl[0], as, cs)),
                yl = xl[xl.length - 1],
                Vs = 0; Vs < xl.length; Vs += 1)
                    Ws = xl[Vs],
                    ba && pointEqual(Ws.points[0], ba) ? Cs.setXYAt(Ws.points[1][0], Ws.points[1][1], "o", Cs.length() - 1) : Cs.setTripleAt(Ws.points[0][0], Ws.points[0][1], Ws.points[1][0], Ws.points[1][1], Ws.points[0][0], Ws.points[0][1], Cs.length()),
                    Cs.setTripleAt(Ws.points[3][0], Ws.points[3][1], Ws.points[3][0], Ws.points[3][1], Ws.points[2][0], Ws.points[2][1], Cs.length()),
                    ba = Ws.points[3]
            }
            return ga.length && joinLines(Cs, yl, ga[0][0], as, cs),
            Cs
        }
        ,
        OffsetPathModifier.prototype.processShapes = function(xt) {
            var Cn, as, cs, Cs, Ls, Vs, Ws = this.shapes.length, Xs = this.amount.v, ga = this.miterLimit.v, ba = this.lineJoin;
            if (Xs !== 0)
                for (as = 0; as < Ws; as += 1) {
                    if (Vs = (Ls = this.shapes[as]).localShapeCollection,
                    Ls.shape._mdf || this._mdf || xt)
                        for (Vs.releaseShapes(),
                        Ls.shape._mdf = !0,
                        Cn = Ls.shape.paths.shapes,
                        Cs = Ls.shape.paths._length,
                        cs = 0; cs < Cs; cs += 1)
                            Vs.addShape(this.processPath(Cn[cs], Xs, ba, ga));
                    Ls.shape.paths = Ls.localShapeCollection
                }
            this.dynamicProperties.length || (this._mdf = !1)
        }
        ;
        var FontManager = function() {
            var xt = {
                w: 0,
                size: 0,
                shapes: [],
                data: {
                    shapes: []
                }
            }
              , Cn = [];
            Cn = Cn.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
            var as = 127988
              , cs = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];
            function Cs(ba, yl) {
                var xl = createTag("span");
                xl.setAttribute("aria-hidden", !0),
                xl.style.fontFamily = yl;
                var wl = createTag("span");
                wl.innerText = "giItT1WQy@!-/#",
                xl.style.position = "absolute",
                xl.style.left = "-10000px",
                xl.style.top = "-10000px",
                xl.style.fontSize = "300px",
                xl.style.fontVariant = "normal",
                xl.style.fontStyle = "normal",
                xl.style.fontWeight = "normal",
                xl.style.letterSpacing = "0",
                xl.appendChild(wl),
                document.body.appendChild(xl);
                var _l = wl.offsetWidth;
                return wl.style.fontFamily = function(El) {
                    var Cl, $l = El.split(","), Sl = $l.length, Tl = [];
                    for (Cl = 0; Cl < Sl; Cl += 1)
                        $l[Cl] !== "sans-serif" && $l[Cl] !== "monospace" && Tl.push($l[Cl]);
                    return Tl.join(",")
                }(ba) + ", " + yl,
                {
                    node: wl,
                    w: _l,
                    parent: xl
                }
            }
            function Ls(ba, yl) {
                var xl, wl = document.body && yl ? "svg" : "canvas", _l = getFontProperties(ba);
                if (wl === "svg") {
                    var El = createNS("text");
                    El.style.fontSize = "100px",
                    El.setAttribute("font-family", ba.fFamily),
                    El.setAttribute("font-style", _l.style),
                    El.setAttribute("font-weight", _l.weight),
                    El.textContent = "1",
                    ba.fClass ? (El.style.fontFamily = "inherit",
                    El.setAttribute("class", ba.fClass)) : El.style.fontFamily = ba.fFamily,
                    yl.appendChild(El),
                    xl = El
                } else {
                    var Cl = new OffscreenCanvas(500,500).getContext("2d");
                    Cl.font = _l.style + " " + _l.weight + " 100px " + ba.fFamily,
                    xl = Cl
                }
                return {
                    measureText: function($l) {
                        return wl === "svg" ? (xl.textContent = $l,
                        xl.getComputedTextLength()) : xl.measureText($l).width
                    }
                }
            }
            function Vs(ba) {
                var yl = 0
                  , xl = ba.charCodeAt(0);
                if (xl >= 55296 && xl <= 56319) {
                    var wl = ba.charCodeAt(1);
                    wl >= 56320 && wl <= 57343 && (yl = 1024 * (xl - 55296) + wl - 56320 + 65536)
                }
                return yl
            }
            function Ws(ba) {
                var yl = Vs(ba);
                return yl >= 127462 && yl <= 127487
            }
            var Xs = function() {
                this.fonts = [],
                this.chars = null,
                this.typekitLoaded = 0,
                this.isLoaded = !1,
                this._warned = !1,
                this.initTime = Date.now(),
                this.setIsLoadedBinded = this.setIsLoaded.bind(this),
                this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this)
            };
            Xs.isModifier = function(ba, yl) {
                var xl = ba.toString(16) + yl.toString(16);
                return cs.indexOf(xl) !== -1
            }
            ,
            Xs.isZeroWidthJoiner = function(ba) {
                return ba === 8205
            }
            ,
            Xs.isFlagEmoji = function(ba) {
                return Ws(ba.substr(0, 2)) && Ws(ba.substr(2, 2))
            }
            ,
            Xs.isRegionalCode = Ws,
            Xs.isCombinedCharacter = function(ba) {
                return Cn.indexOf(ba) !== -1
            }
            ,
            Xs.isRegionalFlag = function(ba, yl) {
                var xl = Vs(ba.substr(yl, 2));
                if (xl !== as)
                    return !1;
                var wl = 0;
                for (yl += 2; wl < 5; ) {
                    if ((xl = Vs(ba.substr(yl, 2))) < 917601 || xl > 917626)
                        return !1;
                    wl += 1,
                    yl += 2
                }
                return Vs(ba.substr(yl, 2)) === 917631
            }
            ,
            Xs.isVariationSelector = function(ba) {
                return ba === 65039
            }
            ,
            Xs.BLACK_FLAG_CODE_POINT = as;
            var ga = {
                addChars: function(ba) {
                    if (ba) {
                        var yl;
                        this.chars || (this.chars = []);
                        var xl, wl, _l = ba.length, El = this.chars.length;
                        for (yl = 0; yl < _l; yl += 1) {
                            for (xl = 0,
                            wl = !1; xl < El; )
                                this.chars[xl].style === ba[yl].style && this.chars[xl].fFamily === ba[yl].fFamily && this.chars[xl].ch === ba[yl].ch && (wl = !0),
                                xl += 1;
                            wl || (this.chars.push(ba[yl]),
                            El += 1)
                        }
                    }
                },
                addFonts: function(ba, yl) {
                    if (ba) {
                        if (this.chars)
                            return this.isLoaded = !0,
                            void (this.fonts = ba.list);
                        if (!document.body)
                            return this.isLoaded = !0,
                            ba.list.forEach(function(Ml) {
                                Ml.helper = Ls(Ml),
                                Ml.cache = {}
                            }),
                            void (this.fonts = ba.list);
                        var xl, wl = ba.list, _l = wl.length, El = _l;
                        for (xl = 0; xl < _l; xl += 1) {
                            var Cl, $l, Sl = !0;
                            if (wl[xl].loaded = !1,
                            wl[xl].monoCase = Cs(wl[xl].fFamily, "monospace"),
                            wl[xl].sansCase = Cs(wl[xl].fFamily, "sans-serif"),
                            wl[xl].fPath) {
                                if (wl[xl].fOrigin === "p" || wl[xl].origin === 3) {
                                    if ((Cl = document.querySelectorAll('style[f-forigin="p"][f-family="' + wl[xl].fFamily + '"], style[f-origin="3"][f-family="' + wl[xl].fFamily + '"]')).length > 0 && (Sl = !1),
                                    Sl) {
                                        var Tl = createTag("style");
                                        Tl.setAttribute("f-forigin", wl[xl].fOrigin),
                                        Tl.setAttribute("f-origin", wl[xl].origin),
                                        Tl.setAttribute("f-family", wl[xl].fFamily),
                                        Tl.type = "text/css",
                                        Tl.innerText = "@font-face {font-family: " + wl[xl].fFamily + "; font-style: normal; src: url('" + wl[xl].fPath + "');}",
                                        yl.appendChild(Tl)
                                    }
                                } else if (wl[xl].fOrigin === "g" || wl[xl].origin === 1) {
                                    for (Cl = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'),
                                    $l = 0; $l < Cl.length; $l += 1)
                                        Cl[$l].href.indexOf(wl[xl].fPath) !== -1 && (Sl = !1);
                                    if (Sl) {
                                        var Rl = createTag("link");
                                        Rl.setAttribute("f-forigin", wl[xl].fOrigin),
                                        Rl.setAttribute("f-origin", wl[xl].origin),
                                        Rl.type = "text/css",
                                        Rl.rel = "stylesheet",
                                        Rl.href = wl[xl].fPath,
                                        document.body.appendChild(Rl)
                                    }
                                } else if (wl[xl].fOrigin === "t" || wl[xl].origin === 2) {
                                    for (Cl = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'),
                                    $l = 0; $l < Cl.length; $l += 1)
                                        wl[xl].fPath === Cl[$l].src && (Sl = !1);
                                    if (Sl) {
                                        var Il = createTag("link");
                                        Il.setAttribute("f-forigin", wl[xl].fOrigin),
                                        Il.setAttribute("f-origin", wl[xl].origin),
                                        Il.setAttribute("rel", "stylesheet"),
                                        Il.setAttribute("href", wl[xl].fPath),
                                        yl.appendChild(Il)
                                    }
                                }
                            } else
                                wl[xl].loaded = !0,
                                El -= 1;
                            wl[xl].helper = Ls(wl[xl], yl),
                            wl[xl].cache = {},
                            this.fonts.push(wl[xl])
                        }
                        El === 0 ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100)
                    } else
                        this.isLoaded = !0
                },
                getCharData: function(ba, yl, xl) {
                    for (var wl = 0, _l = this.chars.length; wl < _l; ) {
                        if (this.chars[wl].ch === ba && this.chars[wl].style === yl && this.chars[wl].fFamily === xl)
                            return this.chars[wl];
                        wl += 1
                    }
                    return (typeof ba == "string" && ba.charCodeAt(0) !== 13 || !ba) && console && console.warn && !this._warned && (this._warned = !0,
                    console.warn("Missing character from exported characters list: ", ba, yl, xl)),
                    xt
                },
                getFontByName: function(ba) {
                    for (var yl = 0, xl = this.fonts.length; yl < xl; ) {
                        if (this.fonts[yl].fName === ba)
                            return this.fonts[yl];
                        yl += 1
                    }
                    return this.fonts[0]
                },
                measureText: function(ba, yl, xl) {
                    var wl = this.getFontByName(yl)
                      , _l = ba;
                    if (!wl.cache[_l]) {
                        var El = wl.helper;
                        if (ba === " ") {
                            var Cl = El.measureText("|" + ba + "|")
                              , $l = El.measureText("||");
                            wl.cache[_l] = (Cl - $l) / 100
                        } else
                            wl.cache[_l] = El.measureText(ba) / 100
                    }
                    return wl.cache[_l] * xl
                },
                checkLoadedFonts: function() {
                    var ba, yl, xl, wl = this.fonts.length, _l = wl;
                    for (ba = 0; ba < wl; ba += 1)
                        this.fonts[ba].loaded ? _l -= 1 : this.fonts[ba].fOrigin === "n" || this.fonts[ba].origin === 0 ? this.fonts[ba].loaded = !0 : (yl = this.fonts[ba].monoCase.node,
                        xl = this.fonts[ba].monoCase.w,
                        yl.offsetWidth !== xl ? (_l -= 1,
                        this.fonts[ba].loaded = !0) : (yl = this.fonts[ba].sansCase.node,
                        xl = this.fonts[ba].sansCase.w,
                        yl.offsetWidth !== xl && (_l -= 1,
                        this.fonts[ba].loaded = !0)),
                        this.fonts[ba].loaded && (this.fonts[ba].sansCase.parent.parentNode.removeChild(this.fonts[ba].sansCase.parent),
                        this.fonts[ba].monoCase.parent.parentNode.removeChild(this.fonts[ba].monoCase.parent)));
                    _l !== 0 && Date.now() - this.initTime < 5e3 ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10)
                },
                setIsLoaded: function() {
                    this.isLoaded = !0
                }
            };
            return Xs.prototype = ga,
            Xs
        }();
        function SlotManager(xt) {
            this.animationData = xt
        }
        function slotFactory(xt) {
            return new SlotManager(xt)
        }
        function RenderableElement() {}
        SlotManager.prototype.getProp = function(xt) {
            return this.animationData.slots && this.animationData.slots[xt.sid] ? Object.assign(xt, this.animationData.slots[xt.sid].p) : xt
        }
        ,
        RenderableElement.prototype = {
            initRenderable: function() {
                this.isInRange = !1,
                this.hidden = !1,
                this.isTransparent = !1,
                this.renderableComponents = []
            },
            addRenderableComponent: function(xt) {
                this.renderableComponents.indexOf(xt) === -1 && this.renderableComponents.push(xt)
            },
            removeRenderableComponent: function(xt) {
                this.renderableComponents.indexOf(xt) !== -1 && this.renderableComponents.splice(this.renderableComponents.indexOf(xt), 1)
            },
            prepareRenderableFrame: function(xt) {
                this.checkLayerLimits(xt)
            },
            checkTransparency: function() {
                this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0,
                this.hide()) : this.isTransparent && (this.isTransparent = !1,
                this.show())
            },
            checkLayerLimits: function(xt) {
                this.data.ip - this.data.st <= xt && this.data.op - this.data.st > xt ? this.isInRange !== !0 && (this.globalData._mdf = !0,
                this._mdf = !0,
                this.isInRange = !0,
                this.show()) : this.isInRange !== !1 && (this.globalData._mdf = !0,
                this.isInRange = !1,
                this.hide())
            },
            renderRenderable: function() {
                var xt, Cn = this.renderableComponents.length;
                for (xt = 0; xt < Cn; xt += 1)
                    this.renderableComponents[xt].renderFrame(this._isFirstFrame)
            },
            sourceRectAtTime: function() {
                return {
                    top: 0,
                    left: 0,
                    width: 100,
                    height: 100
                }
            },
            getLayerSize: function() {
                return this.data.ty === 5 ? {
                    w: this.data.textData.width,
                    h: this.data.textData.height
                } : {
                    w: this.data.width,
                    h: this.data.height
                }
            }
        };
        var getBlendMode = (blendModeEnums = {
            0: "source-over",
            1: "multiply",
            2: "screen",
            3: "overlay",
            4: "darken",
            5: "lighten",
            6: "color-dodge",
            7: "color-burn",
            8: "hard-light",
            9: "soft-light",
            10: "difference",
            11: "exclusion",
            12: "hue",
            13: "saturation",
            14: "color",
            15: "luminosity"
        },
        function(xt) {
            return blendModeEnums[xt] || ""
        }
        ), blendModeEnums;
        function SliderEffect(xt, Cn, as) {
            this.p = PropertyFactory.getProp(Cn, xt.v, 0, 0, as)
        }
        function AngleEffect(xt, Cn, as) {
            this.p = PropertyFactory.getProp(Cn, xt.v, 0, 0, as)
        }
        function ColorEffect(xt, Cn, as) {
            this.p = PropertyFactory.getProp(Cn, xt.v, 1, 0, as)
        }
        function PointEffect(xt, Cn, as) {
            this.p = PropertyFactory.getProp(Cn, xt.v, 1, 0, as)
        }
        function LayerIndexEffect(xt, Cn, as) {
            this.p = PropertyFactory.getProp(Cn, xt.v, 0, 0, as)
        }
        function MaskIndexEffect(xt, Cn, as) {
            this.p = PropertyFactory.getProp(Cn, xt.v, 0, 0, as)
        }
        function CheckboxEffect(xt, Cn, as) {
            this.p = PropertyFactory.getProp(Cn, xt.v, 0, 0, as)
        }
        function NoValueEffect() {
            this.p = {}
        }
        function EffectsManager(xt, Cn) {
            var as, cs = xt.ef || [];
            this.effectElements = [];
            var Cs, Ls = cs.length;
            for (as = 0; as < Ls; as += 1)
                Cs = new GroupEffect(cs[as],Cn),
                this.effectElements.push(Cs)
        }
        function GroupEffect(xt, Cn) {
            this.init(xt, Cn)
        }
        function BaseElement() {}
        function FrameElement() {}
        function FootageElement(xt, Cn, as) {
            this.initFrame(),
            this.initRenderable(),
            this.assetData = Cn.getAssetData(xt.refId),
            this.footageData = Cn.imageLoader.getAsset(this.assetData),
            this.initBaseData(xt, Cn, as)
        }
        function AudioElement(xt, Cn, as) {
            this.initFrame(),
            this.initRenderable(),
            this.assetData = Cn.getAssetData(xt.refId),
            this.initBaseData(xt, Cn, as),
            this._isPlaying = !1,
            this._canPlay = !1;
            var cs = this.globalData.getAssetsPath(this.assetData);
            this.audio = this.globalData.audioController.createAudio(cs),
            this._currentTime = 0,
            this.globalData.audioController.addAudio(this),
            this._volumeMultiplier = 1,
            this._volume = 1,
            this._previousVolume = null,
            this.tm = xt.tm ? PropertyFactory.getProp(this, xt.tm, 0, Cn.frameRate, this) : {
                _placeholder: !0
            },
            this.lv = PropertyFactory.getProp(this, xt.au && xt.au.lv ? xt.au.lv : {
                k: [100]
            }, 1, .01, this)
        }
        function BaseRenderer() {}
        extendPrototype([DynamicPropertyContainer], GroupEffect),
        GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties,
        GroupEffect.prototype.init = function(xt, Cn) {
            var as;
            this.data = xt,
            this.effectElements = [],
            this.initDynamicPropertyContainer(Cn);
            var cs, Cs = this.data.ef.length, Ls = this.data.ef;
            for (as = 0; as < Cs; as += 1) {
                switch (cs = null,
                Ls[as].ty) {
                case 0:
                    cs = new SliderEffect(Ls[as],Cn,this);
                    break;
                case 1:
                    cs = new AngleEffect(Ls[as],Cn,this);
                    break;
                case 2:
                    cs = new ColorEffect(Ls[as],Cn,this);
                    break;
                case 3:
                    cs = new PointEffect(Ls[as],Cn,this);
                    break;
                case 4:
                case 7:
                    cs = new CheckboxEffect(Ls[as],Cn,this);
                    break;
                case 10:
                    cs = new LayerIndexEffect(Ls[as],Cn,this);
                    break;
                case 11:
                    cs = new MaskIndexEffect(Ls[as],Cn,this);
                    break;
                case 5:
                    cs = new EffectsManager(Ls[as],Cn);
                    break;
                default:
                    cs = new NoValueEffect(Ls[as])
                }
                cs && this.effectElements.push(cs)
            }
        }
        ,
        BaseElement.prototype = {
            checkMasks: function() {
                if (!this.data.hasMask)
                    return !1;
                for (var xt = 0, Cn = this.data.masksProperties.length; xt < Cn; ) {
                    if (this.data.masksProperties[xt].mode !== "n" && this.data.masksProperties[xt].cl !== !1)
                        return !0;
                    xt += 1
                }
                return !1
            },
            initExpressions: function() {
                var xt = getExpressionInterfaces();
                if (xt) {
                    var Cn = xt("layer")
                      , as = xt("effects")
                      , cs = xt("shape")
                      , Cs = xt("text")
                      , Ls = xt("comp");
                    this.layerInterface = Cn(this),
                    this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager);
                    var Vs = as.createEffectsInterface(this, this.layerInterface);
                    this.layerInterface.registerEffectsInterface(Vs),
                    this.data.ty === 0 || this.data.xt ? this.compInterface = Ls(this) : this.data.ty === 4 ? (this.layerInterface.shapeInterface = cs(this.shapesData, this.itemsData, this.layerInterface),
                    this.layerInterface.content = this.layerInterface.shapeInterface) : this.data.ty === 5 && (this.layerInterface.textInterface = Cs(this),
                    this.layerInterface.text = this.layerInterface.textInterface)
                }
            },
            setBlendMode: function() {
                var xt = getBlendMode(this.data.bm);
                (this.baseElement || this.layerElement).style["mix-blend-mode"] = xt
            },
            initBaseData: function(xt, Cn, as) {
                this.globalData = Cn,
                this.comp = as,
                this.data = xt,
                this.layerId = createElementID(),
                this.data.sr || (this.data.sr = 1),
                this.effectsManager = new EffectsManager(this.data,this,this.dynamicProperties)
            },
            getType: function() {
                return this.type
            },
            sourceRectAtTime: function() {}
        },
        FrameElement.prototype = {
            initFrame: function() {
                this._isFirstFrame = !1,
                this.dynamicProperties = [],
                this._mdf = !1
            },
            prepareProperties: function(xt, Cn) {
                var as, cs = this.dynamicProperties.length;
                for (as = 0; as < cs; as += 1)
                    (Cn || this._isParent && this.dynamicProperties[as].propType === "transform") && (this.dynamicProperties[as].getValue(),
                    this.dynamicProperties[as]._mdf && (this.globalData._mdf = !0,
                    this._mdf = !0))
            },
            addDynamicProperty: function(xt) {
                this.dynamicProperties.indexOf(xt) === -1 && this.dynamicProperties.push(xt)
            }
        },
        FootageElement.prototype.prepareFrame = function() {}
        ,
        extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement),
        FootageElement.prototype.getBaseElement = function() {
            return null
        }
        ,
        FootageElement.prototype.renderFrame = function() {}
        ,
        FootageElement.prototype.destroy = function() {}
        ,
        FootageElement.prototype.initExpressions = function() {
            var xt = getExpressionInterfaces();
            if (xt) {
                var Cn = xt("footage");
                this.layerInterface = Cn(this)
            }
        }
        ,
        FootageElement.prototype.getFootageData = function() {
            return this.footageData
        }
        ,
        AudioElement.prototype.prepareFrame = function(xt) {
            if (this.prepareRenderableFrame(xt, !0),
            this.prepareProperties(xt, !0),
            this.tm._placeholder)
                this._currentTime = xt / this.data.sr;
            else {
                var Cn = this.tm.v;
                this._currentTime = Cn
            }
            this._volume = this.lv.v[0];
            var as = this._volume * this._volumeMultiplier;
            this._previousVolume !== as && (this._previousVolume = as,
            this.audio.volume(as))
        }
        ,
        extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement),
        AudioElement.prototype.renderFrame = function() {
            this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > .1) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(),
            this.audio.seek(this._currentTime / this.globalData.frameRate),
            this._isPlaying = !0))
        }
        ,
        AudioElement.prototype.show = function() {}
        ,
        AudioElement.prototype.hide = function() {
            this.audio.pause(),
            this._isPlaying = !1
        }
        ,
        AudioElement.prototype.pause = function() {
            this.audio.pause(),
            this._isPlaying = !1,
            this._canPlay = !1
        }
        ,
        AudioElement.prototype.resume = function() {
            this._canPlay = !0
        }
        ,
        AudioElement.prototype.setRate = function(xt) {
            this.audio.rate(xt)
        }
        ,
        AudioElement.prototype.volume = function(xt) {
            this._volumeMultiplier = xt,
            this._previousVolume = xt * this._volume,
            this.audio.volume(this._previousVolume)
        }
        ,
        AudioElement.prototype.getBaseElement = function() {
            return null
        }
        ,
        AudioElement.prototype.destroy = function() {}
        ,
        AudioElement.prototype.sourceRectAtTime = function() {}
        ,
        AudioElement.prototype.initExpressions = function() {}
        ,
        BaseRenderer.prototype.checkLayers = function(xt) {
            var Cn, as, cs = this.layers.length;
            for (this.completeLayers = !0,
            Cn = cs - 1; Cn >= 0; Cn -= 1)
                this.elements[Cn] || (as = this.layers[Cn]).ip - as.st <= xt - this.layers[Cn].st && as.op - as.st > xt - this.layers[Cn].st && this.buildItem(Cn),
                this.completeLayers = !!this.elements[Cn] && this.completeLayers;
            this.checkPendingElements()
        }
        ,
        BaseRenderer.prototype.createItem = function(xt) {
            switch (xt.ty) {
            case 2:
                return this.createImage(xt);
            case 0:
                return this.createComp(xt);
            case 1:
                return this.createSolid(xt);
            case 3:
            default:
                return this.createNull(xt);
            case 4:
                return this.createShape(xt);
            case 5:
                return this.createText(xt);
            case 6:
                return this.createAudio(xt);
            case 13:
                return this.createCamera(xt);
            case 15:
                return this.createFootage(xt)
            }
        }
        ,
        BaseRenderer.prototype.createCamera = function() {
            throw new Error("You're using a 3d camera. Try the html renderer.")
        }
        ,
        BaseRenderer.prototype.createAudio = function(xt) {
            return new AudioElement(xt,this.globalData,this)
        }
        ,
        BaseRenderer.prototype.createFootage = function(xt) {
            return new FootageElement(xt,this.globalData,this)
        }
        ,
        BaseRenderer.prototype.buildAllItems = function() {
            var xt, Cn = this.layers.length;
            for (xt = 0; xt < Cn; xt += 1)
                this.buildItem(xt);
            this.checkPendingElements()
        }
        ,
        BaseRenderer.prototype.includeLayers = function(xt) {
            var Cn;
            this.completeLayers = !1;
            var as, cs = xt.length, Cs = this.layers.length;
            for (Cn = 0; Cn < cs; Cn += 1)
                for (as = 0; as < Cs; ) {
                    if (this.layers[as].id === xt[Cn].id) {
                        this.layers[as] = xt[Cn];
                        break
                    }
                    as += 1
                }
        }
        ,
        BaseRenderer.prototype.setProjectInterface = function(xt) {
            this.globalData.projectInterface = xt
        }
        ,
        BaseRenderer.prototype.initItems = function() {
            this.globalData.progressiveLoad || this.buildAllItems()
        }
        ,
        BaseRenderer.prototype.buildElementParenting = function(xt, Cn, as) {
            for (var cs = this.elements, Cs = this.layers, Ls = 0, Vs = Cs.length; Ls < Vs; )
                Cs[Ls].ind == Cn && (cs[Ls] && cs[Ls] !== !0 ? (as.push(cs[Ls]),
                cs[Ls].setAsParent(),
                Cs[Ls].parent !== void 0 ? this.buildElementParenting(xt, Cs[Ls].parent, as) : xt.setHierarchy(as)) : (this.buildItem(Ls),
                this.addPendingElement(xt))),
                Ls += 1
        }
        ,
        BaseRenderer.prototype.addPendingElement = function(xt) {
            this.pendingElements.push(xt)
        }
        ,
        BaseRenderer.prototype.searchExtraCompositions = function(xt) {
            var Cn, as = xt.length;
            for (Cn = 0; Cn < as; Cn += 1)
                if (xt[Cn].xt) {
                    var cs = this.createComp(xt[Cn]);
                    cs.initExpressions(),
                    this.globalData.projectInterface.registerComposition(cs)
                }
        }
        ,
        BaseRenderer.prototype.getElementById = function(xt) {
            var Cn, as = this.elements.length;
            for (Cn = 0; Cn < as; Cn += 1)
                if (this.elements[Cn].data.ind === xt)
                    return this.elements[Cn];
            return null
        }
        ,
        BaseRenderer.prototype.getElementByPath = function(xt) {
            var Cn, as = xt.shift();
            if (typeof as == "number")
                Cn = this.elements[as];
            else {
                var cs, Cs = this.elements.length;
                for (cs = 0; cs < Cs; cs += 1)
                    if (this.elements[cs].data.nm === as) {
                        Cn = this.elements[cs];
                        break
                    }
            }
            return xt.length === 0 ? Cn : Cn.getElementByPath(xt)
        }
        ,
        BaseRenderer.prototype.setupGlobalData = function(xt, Cn) {
            this.globalData.fontManager = new FontManager,
            this.globalData.slotManager = slotFactory(xt),
            this.globalData.fontManager.addChars(xt.chars),
            this.globalData.fontManager.addFonts(xt.fonts, Cn),
            this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem),
            this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem),
            this.globalData.imageLoader = this.animationItem.imagePreloader,
            this.globalData.audioController = this.animationItem.audioController,
            this.globalData.frameId = 0,
            this.globalData.frameRate = xt.fr,
            this.globalData.nm = xt.nm,
            this.globalData.compSize = {
                w: xt.w,
                h: xt.h
            }
        }
        ;
        var effectTypes = {
            TRANSFORM_EFFECT: "transformEFfect"
        };
        function TransformElement() {}
        function MaskElement(xt, Cn, as) {
            this.data = xt,
            this.element = Cn,
            this.globalData = as,
            this.storedData = [],
            this.masksProperties = this.data.masksProperties || [],
            this.maskElement = null;
            var cs, Cs, Ls = this.globalData.defs, Vs = this.masksProperties ? this.masksProperties.length : 0;
            this.viewData = createSizedArray(Vs),
            this.solidPath = "";
            var Ws, Xs, ga, ba, yl, xl, wl = this.masksProperties, _l = 0, El = [], Cl = createElementID(), $l = "clipPath", Sl = "clip-path";
            for (cs = 0; cs < Vs; cs += 1)
                if ((wl[cs].mode !== "a" && wl[cs].mode !== "n" || wl[cs].inv || wl[cs].o.k !== 100 || wl[cs].o.x) && ($l = "mask",
                Sl = "mask"),
                wl[cs].mode !== "s" && wl[cs].mode !== "i" || _l !== 0 ? ga = null : ((ga = createNS("rect")).setAttribute("fill", "#ffffff"),
                ga.setAttribute("width", this.element.comp.data.w || 0),
                ga.setAttribute("height", this.element.comp.data.h || 0),
                El.push(ga)),
                Cs = createNS("path"),
                wl[cs].mode === "n")
                    this.viewData[cs] = {
                        op: PropertyFactory.getProp(this.element, wl[cs].o, 0, .01, this.element),
                        prop: ShapePropertyFactory.getShapeProp(this.element, wl[cs], 3),
                        elem: Cs,
                        lastPath: ""
                    },
                    Ls.appendChild(Cs);
                else {
                    var Tl;
                    if (_l += 1,
                    Cs.setAttribute("fill", wl[cs].mode === "s" ? "#000000" : "#ffffff"),
                    Cs.setAttribute("clip-rule", "nonzero"),
                    wl[cs].x.k !== 0 ? ($l = "mask",
                    Sl = "mask",
                    xl = PropertyFactory.getProp(this.element, wl[cs].x, 0, null, this.element),
                    Tl = createElementID(),
                    (ba = createNS("filter")).setAttribute("id", Tl),
                    (yl = createNS("feMorphology")).setAttribute("operator", "erode"),
                    yl.setAttribute("in", "SourceGraphic"),
                    yl.setAttribute("radius", "0"),
                    ba.appendChild(yl),
                    Ls.appendChild(ba),
                    Cs.setAttribute("stroke", wl[cs].mode === "s" ? "#000000" : "#ffffff")) : (yl = null,
                    xl = null),
                    this.storedData[cs] = {
                        elem: Cs,
                        x: xl,
                        expan: yl,
                        lastPath: "",
                        lastOperator: "",
                        filterId: Tl,
                        lastRadius: 0
                    },
                    wl[cs].mode === "i") {
                        Xs = El.length;
                        var Rl = createNS("g");
                        for (Ws = 0; Ws < Xs; Ws += 1)
                            Rl.appendChild(El[Ws]);
                        var Il = createNS("mask");
                        Il.setAttribute("mask-type", "alpha"),
                        Il.setAttribute("id", Cl + "_" + _l),
                        Il.appendChild(Cs),
                        Ls.appendChild(Il),
                        Rl.setAttribute("mask", "url(" + getLocationHref() + "#" + Cl + "_" + _l + ")"),
                        El.length = 0,
                        El.push(Rl)
                    } else
                        El.push(Cs);
                    wl[cs].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()),
                    this.viewData[cs] = {
                        elem: Cs,
                        lastPath: "",
                        op: PropertyFactory.getProp(this.element, wl[cs].o, 0, .01, this.element),
                        prop: ShapePropertyFactory.getShapeProp(this.element, wl[cs], 3),
                        invRect: ga
                    },
                    this.viewData[cs].prop.k || this.drawPath(wl[cs], this.viewData[cs].prop.v, this.viewData[cs])
                }
            for (this.maskElement = createNS($l),
            Vs = El.length,
            cs = 0; cs < Vs; cs += 1)
                this.maskElement.appendChild(El[cs]);
            _l > 0 && (this.maskElement.setAttribute("id", Cl),
            this.element.maskedElement.setAttribute(Sl, "url(" + getLocationHref() + "#" + Cl + ")"),
            Ls.appendChild(this.maskElement)),
            this.viewData.length && this.element.addRenderableComponent(this)
        }
        TransformElement.prototype = {
            initTransform: function() {
                var xt = new Matrix;
                this.finalTransform = {
                    mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
                        o: 0
                    },
                    _matMdf: !1,
                    _localMatMdf: !1,
                    _opMdf: !1,
                    mat: xt,
                    localMat: xt,
                    localOpacity: 1
                },
                this.data.ao && (this.finalTransform.mProp.autoOriented = !0),
                this.data.ty
            },
            renderTransform: function() {
                if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame,
                this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame,
                this.hierarchy) {
                    var xt, Cn = this.finalTransform.mat, as = 0, cs = this.hierarchy.length;
                    if (!this.finalTransform._matMdf)
                        for (; as < cs; ) {
                            if (this.hierarchy[as].finalTransform.mProp._mdf) {
                                this.finalTransform._matMdf = !0;
                                break
                            }
                            as += 1
                        }
                    if (this.finalTransform._matMdf)
                        for (xt = this.finalTransform.mProp.v.props,
                        Cn.cloneFromProps(xt),
                        as = 0; as < cs; as += 1)
                            Cn.multiply(this.hierarchy[as].finalTransform.mProp.v)
                }
                this.finalTransform._matMdf && (this.finalTransform._localMatMdf = this.finalTransform._matMdf),
                this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v)
            },
            renderLocalTransform: function() {
                if (this.localTransforms) {
                    var xt = 0
                      , Cn = this.localTransforms.length;
                    if (this.finalTransform._localMatMdf = this.finalTransform._matMdf,
                    !this.finalTransform._localMatMdf || !this.finalTransform._opMdf)
                        for (; xt < Cn; )
                            this.localTransforms[xt]._mdf && (this.finalTransform._localMatMdf = !0),
                            this.localTransforms[xt]._opMdf && !this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v,
                            this.finalTransform._opMdf = !0),
                            xt += 1;
                    if (this.finalTransform._localMatMdf) {
                        var as = this.finalTransform.localMat;
                        for (this.localTransforms[0].matrix.clone(as),
                        xt = 1; xt < Cn; xt += 1) {
                            var cs = this.localTransforms[xt].matrix;
                            as.multiply(cs)
                        }
                        as.multiply(this.finalTransform.mat)
                    }
                    if (this.finalTransform._opMdf) {
                        var Cs = this.finalTransform.localOpacity;
                        for (xt = 0; xt < Cn; xt += 1)
                            Cs *= .01 * this.localTransforms[xt].opacity;
                        this.finalTransform.localOpacity = Cs
                    }
                }
            },
            searchEffectTransforms: function() {
                if (this.renderableEffectsManager) {
                    var xt = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
                    if (xt.length) {
                        this.localTransforms = [],
                        this.finalTransform.localMat = new Matrix;
                        var Cn = 0
                          , as = xt.length;
                        for (Cn = 0; Cn < as; Cn += 1)
                            this.localTransforms.push(xt[Cn])
                    }
                }
            },
            globalToLocal: function(xt) {
                var Cn = [];
                Cn.push(this.finalTransform);
                for (var as, cs = !0, Cs = this.comp; cs; )
                    Cs.finalTransform ? (Cs.data.hasMask && Cn.splice(0, 0, Cs.finalTransform),
                    Cs = Cs.comp) : cs = !1;
                var Ls, Vs = Cn.length;
                for (as = 0; as < Vs; as += 1)
                    Ls = Cn[as].mat.applyToPointArray(0, 0, 0),
                    xt = [xt[0] - Ls[0], xt[1] - Ls[1], 0];
                return xt
            },
            mHelper: new Matrix
        },
        MaskElement.prototype.getMaskProperty = function(xt) {
            return this.viewData[xt].prop
        }
        ,
        MaskElement.prototype.renderFrame = function(xt) {
            var Cn, as = this.element.finalTransform.mat, cs = this.masksProperties.length;
            for (Cn = 0; Cn < cs; Cn += 1)
                if ((this.viewData[Cn].prop._mdf || xt) && this.drawPath(this.masksProperties[Cn], this.viewData[Cn].prop.v, this.viewData[Cn]),
                (this.viewData[Cn].op._mdf || xt) && this.viewData[Cn].elem.setAttribute("fill-opacity", this.viewData[Cn].op.v),
                this.masksProperties[Cn].mode !== "n" && (this.viewData[Cn].invRect && (this.element.finalTransform.mProp._mdf || xt) && this.viewData[Cn].invRect.setAttribute("transform", as.getInverseMatrix().to2dCSS()),
                this.storedData[Cn].x && (this.storedData[Cn].x._mdf || xt))) {
                    var Cs = this.storedData[Cn].expan;
                    this.storedData[Cn].x.v < 0 ? (this.storedData[Cn].lastOperator !== "erode" && (this.storedData[Cn].lastOperator = "erode",
                    this.storedData[Cn].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[Cn].filterId + ")")),
                    Cs.setAttribute("radius", -this.storedData[Cn].x.v)) : (this.storedData[Cn].lastOperator !== "dilate" && (this.storedData[Cn].lastOperator = "dilate",
                    this.storedData[Cn].elem.setAttribute("filter", null)),
                    this.storedData[Cn].elem.setAttribute("stroke-width", 2 * this.storedData[Cn].x.v))
                }
        }
        ,
        MaskElement.prototype.getMaskelement = function() {
            return this.maskElement
        }
        ,
        MaskElement.prototype.createLayerSolidPath = function() {
            var xt = "M0,0 ";
            return xt += " h" + this.globalData.compSize.w,
            xt += " v" + this.globalData.compSize.h,
            xt += " h-" + this.globalData.compSize.w,
            xt += " v-" + this.globalData.compSize.h + " "
        }
        ,
        MaskElement.prototype.drawPath = function(xt, Cn, as) {
            var cs, Cs, Ls = " M" + Cn.v[0][0] + "," + Cn.v[0][1];
            for (Cs = Cn._length,
            cs = 1; cs < Cs; cs += 1)
                Ls += " C" + Cn.o[cs - 1][0] + "," + Cn.o[cs - 1][1] + " " + Cn.i[cs][0] + "," + Cn.i[cs][1] + " " + Cn.v[cs][0] + "," + Cn.v[cs][1];
            if (Cn.c && Cs > 1 && (Ls += " C" + Cn.o[cs - 1][0] + "," + Cn.o[cs - 1][1] + " " + Cn.i[0][0] + "," + Cn.i[0][1] + " " + Cn.v[0][0] + "," + Cn.v[0][1]),
            as.lastPath !== Ls) {
                var Vs = "";
                as.elem && (Cn.c && (Vs = xt.inv ? this.solidPath + Ls : Ls),
                as.elem.setAttribute("d", Vs)),
                as.lastPath = Ls
            }
        }
        ,
        MaskElement.prototype.destroy = function() {
            this.element = null,
            this.globalData = null,
            this.maskElement = null,
            this.data = null,
            this.masksProperties = null
        }
        ;
        var filtersFactory = function() {
            var xt = {
                createFilter: function(Cn, as) {
                    var cs = createNS("filter");
                    return cs.setAttribute("id", Cn),
                    as !== !0 && (cs.setAttribute("filterUnits", "objectBoundingBox"),
                    cs.setAttribute("x", "0%"),
                    cs.setAttribute("y", "0%"),
                    cs.setAttribute("width", "100%"),
                    cs.setAttribute("height", "100%")),
                    cs
                },
                createAlphaToLuminanceFilter: function() {
                    var Cn = createNS("feColorMatrix");
                    return Cn.setAttribute("type", "matrix"),
                    Cn.setAttribute("color-interpolation-filters", "sRGB"),
                    Cn.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"),
                    Cn
                }
            };
            return xt
        }()
          , featureSupport = function() {
            var xt = {
                maskType: !0,
                svgLumaHidden: !0,
                offscreenCanvas: typeof OffscreenCanvas < "u"
            };
            return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (xt.maskType = !1),
            /firefox/i.test(navigator.userAgent) && (xt.svgLumaHidden = !1),
            xt
        }()
          , registeredEffects$1 = {}
          , idPrefix = "filter_result_";
        function SVGEffects(xt) {
            var Cn, as, cs = "SourceGraphic", Cs = xt.data.ef ? xt.data.ef.length : 0, Ls = createElementID(), Vs = filtersFactory.createFilter(Ls, !0), Ws = 0;
            for (this.filters = [],
            Cn = 0; Cn < Cs; Cn += 1) {
                as = null;
                var Xs = xt.data.ef[Cn].ty;
                registeredEffects$1[Xs] && (as = new registeredEffects$1[Xs].effect(Vs,xt.effectsManager.effectElements[Cn],xt,idPrefix + Ws,cs),
                cs = idPrefix + Ws,
                registeredEffects$1[Xs].countsAsEffect && (Ws += 1)),
                as && this.filters.push(as)
            }
            Ws && (xt.globalData.defs.appendChild(Vs),
            xt.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + Ls + ")")),
            this.filters.length && xt.addRenderableComponent(this)
        }
        function registerEffect$1(xt, Cn, as) {
            registeredEffects$1[xt] = {
                effect: Cn,
                countsAsEffect: as
            }
        }
        function SVGBaseElement() {}
        function HierarchyElement() {}
        function RenderableDOMElement() {}
        function IImageElement(xt, Cn, as) {
            this.assetData = Cn.getAssetData(xt.refId),
            this.assetData && this.assetData.sid && (this.assetData = Cn.slotManager.getProp(this.assetData)),
            this.initElement(xt, Cn, as),
            this.sourceRect = {
                top: 0,
                left: 0,
                width: this.assetData.w,
                height: this.assetData.h
            }
        }
        function ProcessedElement(xt, Cn) {
            this.elem = xt,
            this.pos = Cn
        }
        function IShapeElement() {}
        SVGEffects.prototype.renderFrame = function(xt) {
            var Cn, as = this.filters.length;
            for (Cn = 0; Cn < as; Cn += 1)
                this.filters[Cn].renderFrame(xt)
        }
        ,
        SVGEffects.prototype.getEffects = function(xt) {
            var Cn, as = this.filters.length, cs = [];
            for (Cn = 0; Cn < as; Cn += 1)
                this.filters[Cn].type === xt && cs.push(this.filters[Cn]);
            return cs
        }
        ,
        SVGBaseElement.prototype = {
            initRendererElement: function() {
                this.layerElement = createNS("g")
            },
            createContainerElements: function() {
                this.matteElement = createNS("g"),
                this.transformedElement = this.layerElement,
                this.maskedElement = this.layerElement,
                this._sizeChanged = !1;
                var xt = null;
                if (this.data.td) {
                    this.matteMasks = {};
                    var Cn = createNS("g");
                    Cn.setAttribute("id", this.layerId),
                    Cn.appendChild(this.layerElement),
                    xt = Cn,
                    this.globalData.defs.appendChild(Cn)
                } else
                    this.data.tt ? (this.matteElement.appendChild(this.layerElement),
                    xt = this.matteElement,
                    this.baseElement = this.matteElement) : this.baseElement = this.layerElement;
                if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
                this.data.cl && this.layerElement.setAttribute("class", this.data.cl),
                this.data.ty === 0 && !this.data.hd) {
                    var as = createNS("clipPath")
                      , cs = createNS("path");
                    cs.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
                    var Cs = createElementID();
                    if (as.setAttribute("id", Cs),
                    as.appendChild(cs),
                    this.globalData.defs.appendChild(as),
                    this.checkMasks()) {
                        var Ls = createNS("g");
                        Ls.setAttribute("clip-path", "url(" + getLocationHref() + "#" + Cs + ")"),
                        Ls.appendChild(this.layerElement),
                        this.transformedElement = Ls,
                        xt ? xt.appendChild(this.transformedElement) : this.baseElement = this.transformedElement
                    } else
                        this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + Cs + ")")
                }
                this.data.bm !== 0 && this.setBlendMode()
            },
            renderElement: function() {
                this.finalTransform._localMatMdf && this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS()),
                this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity)
            },
            destroyBaseElement: function() {
                this.layerElement = null,
                this.matteElement = null,
                this.maskManager.destroy()
            },
            getBaseElement: function() {
                return this.data.hd ? null : this.baseElement
            },
            createRenderableComponents: function() {
                this.maskManager = new MaskElement(this.data,this,this.globalData),
                this.renderableEffectsManager = new SVGEffects(this),
                this.searchEffectTransforms()
            },
            getMatte: function(xt) {
                if (this.matteMasks || (this.matteMasks = {}),
                !this.matteMasks[xt]) {
                    var Cn, as, cs, Cs, Ls = this.layerId + "_" + xt;
                    if (xt === 1 || xt === 3) {
                        var Vs = createNS("mask");
                        Vs.setAttribute("id", Ls),
                        Vs.setAttribute("mask-type", xt === 3 ? "luminance" : "alpha"),
                        (cs = createNS("use")).setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId),
                        Vs.appendChild(cs),
                        this.globalData.defs.appendChild(Vs),
                        featureSupport.maskType || xt !== 1 || (Vs.setAttribute("mask-type", "luminance"),
                        Cn = createElementID(),
                        as = filtersFactory.createFilter(Cn),
                        this.globalData.defs.appendChild(as),
                        as.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                        (Cs = createNS("g")).appendChild(cs),
                        Vs.appendChild(Cs),
                        Cs.setAttribute("filter", "url(" + getLocationHref() + "#" + Cn + ")"))
                    } else if (xt === 2) {
                        var Ws = createNS("mask");
                        Ws.setAttribute("id", Ls),
                        Ws.setAttribute("mask-type", "alpha");
                        var Xs = createNS("g");
                        Ws.appendChild(Xs),
                        Cn = createElementID(),
                        as = filtersFactory.createFilter(Cn);
                        var ga = createNS("feComponentTransfer");
                        ga.setAttribute("in", "SourceGraphic"),
                        as.appendChild(ga);
                        var ba = createNS("feFuncA");
                        ba.setAttribute("type", "table"),
                        ba.setAttribute("tableValues", "1.0 0.0"),
                        ga.appendChild(ba),
                        this.globalData.defs.appendChild(as);
                        var yl = createNS("rect");
                        yl.setAttribute("width", this.comp.data.w),
                        yl.setAttribute("height", this.comp.data.h),
                        yl.setAttribute("x", "0"),
                        yl.setAttribute("y", "0"),
                        yl.setAttribute("fill", "#ffffff"),
                        yl.setAttribute("opacity", "0"),
                        Xs.setAttribute("filter", "url(" + getLocationHref() + "#" + Cn + ")"),
                        Xs.appendChild(yl),
                        (cs = createNS("use")).setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId),
                        Xs.appendChild(cs),
                        featureSupport.maskType || (Ws.setAttribute("mask-type", "luminance"),
                        as.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                        Cs = createNS("g"),
                        Xs.appendChild(yl),
                        Cs.appendChild(this.layerElement),
                        Xs.appendChild(Cs)),
                        this.globalData.defs.appendChild(Ws)
                    }
                    this.matteMasks[xt] = Ls
                }
                return this.matteMasks[xt]
            },
            setMatte: function(xt) {
                this.matteElement && this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + xt + ")")
            }
        },
        HierarchyElement.prototype = {
            initHierarchy: function() {
                this.hierarchy = [],
                this._isParent = !1,
                this.checkParenting()
            },
            setHierarchy: function(xt) {
                this.hierarchy = xt
            },
            setAsParent: function() {
                this._isParent = !0
            },
            checkParenting: function() {
                this.data.parent !== void 0 && this.comp.buildElementParenting(this, this.data.parent, [])
            }
        },
        extendPrototype([RenderableElement, createProxyFunction({
            initElement: function(xt, Cn, as) {
                this.initFrame(),
                this.initBaseData(xt, Cn, as),
                this.initTransform(xt, Cn, as),
                this.initHierarchy(),
                this.initRenderable(),
                this.initRendererElement(),
                this.createContainerElements(),
                this.createRenderableComponents(),
                this.createContent(),
                this.hide()
            },
            hide: function() {
                this.hidden || this.isInRange && !this.isTransparent || ((this.baseElement || this.layerElement).style.display = "none",
                this.hidden = !0)
            },
            show: function() {
                this.isInRange && !this.isTransparent && (this.data.hd || ((this.baseElement || this.layerElement).style.display = "block"),
                this.hidden = !1,
                this._isFirstFrame = !0)
            },
            renderFrame: function() {
                this.data.hd || this.hidden || (this.renderTransform(),
                this.renderRenderable(),
                this.renderLocalTransform(),
                this.renderElement(),
                this.renderInnerContent(),
                this._isFirstFrame && (this._isFirstFrame = !1))
            },
            renderInnerContent: function() {},
            prepareFrame: function(xt) {
                this._mdf = !1,
                this.prepareRenderableFrame(xt),
                this.prepareProperties(xt, this.isInRange),
                this.checkTransparency()
            },
            destroy: function() {
                this.innerElem = null,
                this.destroyBaseElement()
            }
        })], RenderableDOMElement),
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement),
        IImageElement.prototype.createContent = function() {
            var xt = this.globalData.getAssetsPath(this.assetData);
            this.innerElem = createNS("image"),
            this.innerElem.setAttribute("width", this.assetData.w + "px"),
            this.innerElem.setAttribute("height", this.assetData.h + "px"),
            this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio),
            this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", xt),
            this.layerElement.appendChild(this.innerElem)
        }
        ,
        IImageElement.prototype.sourceRectAtTime = function() {
            return this.sourceRect
        }
        ,
        IShapeElement.prototype = {
            addShapeToModifiers: function(xt) {
                var Cn, as = this.shapeModifiers.length;
                for (Cn = 0; Cn < as; Cn += 1)
                    this.shapeModifiers[Cn].addShape(xt)
            },
            isShapeInAnimatedModifiers: function(xt) {
                for (var Cn = this.shapeModifiers.length; 0 < Cn; )
                    if (this.shapeModifiers[0].isAnimatedWithShape(xt))
                        return !0;
                return !1
            },
            renderModifiers: function() {
                if (this.shapeModifiers.length) {
                    var xt, Cn = this.shapes.length;
                    for (xt = 0; xt < Cn; xt += 1)
                        this.shapes[xt].sh.reset();
                    for (xt = (Cn = this.shapeModifiers.length) - 1; xt >= 0 && !this.shapeModifiers[xt].processShapes(this._isFirstFrame); xt -= 1)
                        ;
                }
            },
            searchProcessedElement: function(xt) {
                for (var Cn = this.processedElements, as = 0, cs = Cn.length; as < cs; ) {
                    if (Cn[as].elem === xt)
                        return Cn[as].pos;
                    as += 1
                }
                return 0
            },
            addProcessedElement: function(xt, Cn) {
                for (var as = this.processedElements, cs = as.length; cs; )
                    if (as[cs -= 1].elem === xt)
                        return void (as[cs].pos = Cn);
                as.push(new ProcessedElement(xt,Cn))
            },
            prepareFrame: function(xt) {
                this.prepareRenderableFrame(xt),
                this.prepareProperties(xt, this.isInRange)
            }
        };
        var lineCapEnum = {
            1: "butt",
            2: "round",
            3: "square"
        }
          , lineJoinEnum = {
            1: "miter",
            2: "round",
            3: "bevel"
        };
        function SVGShapeData(xt, Cn, as) {
            this.caches = [],
            this.styles = [],
            this.transformers = xt,
            this.lStr = "",
            this.sh = as,
            this.lvl = Cn,
            this._isAnimated = !!as.k;
            for (var cs = 0, Cs = xt.length; cs < Cs; ) {
                if (xt[cs].mProps.dynamicProperties.length) {
                    this._isAnimated = !0;
                    break
                }
                cs += 1
            }
        }
        function SVGStyleData(xt, Cn) {
            this.data = xt,
            this.type = xt.ty,
            this.d = "",
            this.lvl = Cn,
            this._mdf = !1,
            this.closed = xt.hd === !0,
            this.pElem = createNS("path"),
            this.msElem = null
        }
        function DashProperty(xt, Cn, as, cs) {
            var Cs;
            this.elem = xt,
            this.frameId = -1,
            this.dataProps = createSizedArray(Cn.length),
            this.renderer = as,
            this.k = !1,
            this.dashStr = "",
            this.dashArray = createTypedArray("float32", Cn.length ? Cn.length - 1 : 0),
            this.dashoffset = createTypedArray("float32", 1),
            this.initDynamicPropertyContainer(cs);
            var Ls, Vs = Cn.length || 0;
            for (Cs = 0; Cs < Vs; Cs += 1)
                Ls = PropertyFactory.getProp(xt, Cn[Cs].v, 0, 0, this),
                this.k = Ls.k || this.k,
                this.dataProps[Cs] = {
                    n: Cn[Cs].n,
                    p: Ls
                };
            this.k || this.getValue(!0),
            this._isAnimated = this.k
        }
        function SVGStrokeStyleData(xt, Cn, as) {
            this.initDynamicPropertyContainer(xt),
            this.getValue = this.iterateDynamicProperties,
            this.o = PropertyFactory.getProp(xt, Cn.o, 0, .01, this),
            this.w = PropertyFactory.getProp(xt, Cn.w, 0, null, this),
            this.d = new DashProperty(xt,Cn.d || {},"svg",this),
            this.c = PropertyFactory.getProp(xt, Cn.c, 1, 255, this),
            this.style = as,
            this._isAnimated = !!this._isAnimated
        }
        function SVGFillStyleData(xt, Cn, as) {
            this.initDynamicPropertyContainer(xt),
            this.getValue = this.iterateDynamicProperties,
            this.o = PropertyFactory.getProp(xt, Cn.o, 0, .01, this),
            this.c = PropertyFactory.getProp(xt, Cn.c, 1, 255, this),
            this.style = as
        }
        function SVGNoStyleData(xt, Cn, as) {
            this.initDynamicPropertyContainer(xt),
            this.getValue = this.iterateDynamicProperties,
            this.style = as
        }
        function GradientProperty(xt, Cn, as) {
            this.data = Cn,
            this.c = createTypedArray("uint8c", 4 * Cn.p);
            var cs = Cn.k.k[0].s ? Cn.k.k[0].s.length - 4 * Cn.p : Cn.k.k.length - 4 * Cn.p;
            this.o = createTypedArray("float32", cs),
            this._cmdf = !1,
            this._omdf = !1,
            this._collapsable = this.checkCollapsable(),
            this._hasOpacity = cs,
            this.initDynamicPropertyContainer(as),
            this.prop = PropertyFactory.getProp(xt, Cn.k, 1, null, this),
            this.k = this.prop.k,
            this.getValue(!0)
        }
        function SVGGradientFillStyleData(xt, Cn, as) {
            this.initDynamicPropertyContainer(xt),
            this.getValue = this.iterateDynamicProperties,
            this.initGradientData(xt, Cn, as)
        }
        function SVGGradientStrokeStyleData(xt, Cn, as) {
            this.initDynamicPropertyContainer(xt),
            this.getValue = this.iterateDynamicProperties,
            this.w = PropertyFactory.getProp(xt, Cn.w, 0, null, this),
            this.d = new DashProperty(xt,Cn.d || {},"svg",this),
            this.initGradientData(xt, Cn, as),
            this._isAnimated = !!this._isAnimated
        }
        function ShapeGroupData() {
            this.it = [],
            this.prevViewData = [],
            this.gr = createNS("g")
        }
        function SVGTransformData(xt, Cn, as) {
            this.transform = {
                mProps: xt,
                op: Cn,
                container: as
            },
            this.elements = [],
            this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length
        }
        SVGShapeData.prototype.setAsAnimated = function() {
            this._isAnimated = !0
        }
        ,
        SVGStyleData.prototype.reset = function() {
            this.d = "",
            this._mdf = !1
        }
        ,
        DashProperty.prototype.getValue = function(xt) {
            if ((this.elem.globalData.frameId !== this.frameId || xt) && (this.frameId = this.elem.globalData.frameId,
            this.iterateDynamicProperties(),
            this._mdf = this._mdf || xt,
            this._mdf)) {
                var Cn = 0
                  , as = this.dataProps.length;
                for (this.renderer === "svg" && (this.dashStr = ""),
                Cn = 0; Cn < as; Cn += 1)
                    this.dataProps[Cn].n !== "o" ? this.renderer === "svg" ? this.dashStr += " " + this.dataProps[Cn].p.v : this.dashArray[Cn] = this.dataProps[Cn].p.v : this.dashoffset[0] = this.dataProps[Cn].p.v
            }
        }
        ,
        extendPrototype([DynamicPropertyContainer], DashProperty),
        extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData),
        extendPrototype([DynamicPropertyContainer], SVGFillStyleData),
        extendPrototype([DynamicPropertyContainer], SVGNoStyleData),
        GradientProperty.prototype.comparePoints = function(xt, Cn) {
            for (var as = 0, cs = this.o.length / 2; as < cs; ) {
                if (Math.abs(xt[4 * as] - xt[4 * Cn + 2 * as]) > .01)
                    return !1;
                as += 1
            }
            return !0
        }
        ,
        GradientProperty.prototype.checkCollapsable = function() {
            if (this.o.length / 2 != this.c.length / 4)
                return !1;
            if (this.data.k.k[0].s)
                for (var xt = 0, Cn = this.data.k.k.length; xt < Cn; ) {
                    if (!this.comparePoints(this.data.k.k[xt].s, this.data.p))
                        return !1;
                    xt += 1
                }
            else if (!this.comparePoints(this.data.k.k, this.data.p))
                return !1;
            return !0
        }
        ,
        GradientProperty.prototype.getValue = function(xt) {
            if (this.prop.getValue(),
            this._mdf = !1,
            this._cmdf = !1,
            this._omdf = !1,
            this.prop._mdf || xt) {
                var Cn, as, cs, Cs = 4 * this.data.p;
                for (Cn = 0; Cn < Cs; Cn += 1)
                    as = Cn % 4 == 0 ? 100 : 255,
                    cs = Math.round(this.prop.v[Cn] * as),
                    this.c[Cn] !== cs && (this.c[Cn] = cs,
                    this._cmdf = !xt);
                if (this.o.length)
                    for (Cs = this.prop.v.length,
                    Cn = 4 * this.data.p; Cn < Cs; Cn += 1)
                        as = Cn % 2 == 0 ? 100 : 1,
                        cs = Cn % 2 == 0 ? Math.round(100 * this.prop.v[Cn]) : this.prop.v[Cn],
                        this.o[Cn - 4 * this.data.p] !== cs && (this.o[Cn - 4 * this.data.p] = cs,
                        this._omdf = !xt);
                this._mdf = !xt
            }
        }
        ,
        extendPrototype([DynamicPropertyContainer], GradientProperty),
        SVGGradientFillStyleData.prototype.initGradientData = function(xt, Cn, as) {
            this.o = PropertyFactory.getProp(xt, Cn.o, 0, .01, this),
            this.s = PropertyFactory.getProp(xt, Cn.s, 1, null, this),
            this.e = PropertyFactory.getProp(xt, Cn.e, 1, null, this),
            this.h = PropertyFactory.getProp(xt, Cn.h || {
                k: 0
            }, 0, .01, this),
            this.a = PropertyFactory.getProp(xt, Cn.a || {
                k: 0
            }, 0, degToRads, this),
            this.g = new GradientProperty(xt,Cn.g,this),
            this.style = as,
            this.stops = [],
            this.setGradientData(as.pElem, Cn),
            this.setGradientOpacity(Cn, as),
            this._isAnimated = !!this._isAnimated
        }
        ,
        SVGGradientFillStyleData.prototype.setGradientData = function(xt, Cn) {
            var as = createElementID()
              , cs = createNS(Cn.t === 1 ? "linearGradient" : "radialGradient");
            cs.setAttribute("id", as),
            cs.setAttribute("spreadMethod", "pad"),
            cs.setAttribute("gradientUnits", "userSpaceOnUse");
            var Cs, Ls, Vs, Ws = [];
            for (Vs = 4 * Cn.g.p,
            Ls = 0; Ls < Vs; Ls += 4)
                Cs = createNS("stop"),
                cs.appendChild(Cs),
                Ws.push(Cs);
            xt.setAttribute(Cn.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + as + ")"),
            this.gf = cs,
            this.cst = Ws
        }
        ,
        SVGGradientFillStyleData.prototype.setGradientOpacity = function(xt, Cn) {
            if (this.g._hasOpacity && !this.g._collapsable) {
                var as, cs, Cs, Ls = createNS("mask"), Vs = createNS("path");
                Ls.appendChild(Vs);
                var Ws = createElementID()
                  , Xs = createElementID();
                Ls.setAttribute("id", Xs);
                var ga = createNS(xt.t === 1 ? "linearGradient" : "radialGradient");
                ga.setAttribute("id", Ws),
                ga.setAttribute("spreadMethod", "pad"),
                ga.setAttribute("gradientUnits", "userSpaceOnUse"),
                Cs = xt.g.k.k[0].s ? xt.g.k.k[0].s.length : xt.g.k.k.length;
                var ba = this.stops;
                for (cs = 4 * xt.g.p; cs < Cs; cs += 2)
                    (as = createNS("stop")).setAttribute("stop-color", "rgb(255,255,255)"),
                    ga.appendChild(as),
                    ba.push(as);
                Vs.setAttribute(xt.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + Ws + ")"),
                xt.ty === "gs" && (Vs.setAttribute("stroke-linecap", lineCapEnum[xt.lc || 2]),
                Vs.setAttribute("stroke-linejoin", lineJoinEnum[xt.lj || 2]),
                xt.lj === 1 && Vs.setAttribute("stroke-miterlimit", xt.ml)),
                this.of = ga,
                this.ms = Ls,
                this.ost = ba,
                this.maskId = Xs,
                Cn.msElem = Vs
            }
        }
        ,
        extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData),
        extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
        var buildShapeString = function(xt, Cn, as, cs) {
            if (Cn === 0)
                return "";
            var Cs, Ls = xt.o, Vs = xt.i, Ws = xt.v, Xs = " M" + cs.applyToPointStringified(Ws[0][0], Ws[0][1]);
            for (Cs = 1; Cs < Cn; Cs += 1)
                Xs += " C" + cs.applyToPointStringified(Ls[Cs - 1][0], Ls[Cs - 1][1]) + " " + cs.applyToPointStringified(Vs[Cs][0], Vs[Cs][1]) + " " + cs.applyToPointStringified(Ws[Cs][0], Ws[Cs][1]);
            return as && Cn && (Xs += " C" + cs.applyToPointStringified(Ls[Cs - 1][0], Ls[Cs - 1][1]) + " " + cs.applyToPointStringified(Vs[0][0], Vs[0][1]) + " " + cs.applyToPointStringified(Ws[0][0], Ws[0][1]),
            Xs += "z"),
            Xs
        }
          , SVGElementsRenderer = function() {
            var xt = new Matrix
              , Cn = new Matrix;
            function as(ga, ba, yl) {
                (yl || ba.transform.op._mdf) && ba.transform.container.setAttribute("opacity", ba.transform.op.v),
                (yl || ba.transform.mProps._mdf) && ba.transform.container.setAttribute("transform", ba.transform.mProps.v.to2dCSS())
            }
            function cs() {}
            function Cs(ga, ba, yl) {
                var xl, wl, _l, El, Cl, $l, Sl, Tl, Rl, Il, Ml = ba.styles.length, Nl = ba.lvl;
                for ($l = 0; $l < Ml; $l += 1) {
                    if (El = ba.sh._mdf || yl,
                    ba.styles[$l].lvl < Nl) {
                        for (Tl = Cn.reset(),
                        Rl = Nl - ba.styles[$l].lvl,
                        Il = ba.transformers.length - 1; !El && Rl > 0; )
                            El = ba.transformers[Il].mProps._mdf || El,
                            Rl -= 1,
                            Il -= 1;
                        if (El)
                            for (Rl = Nl - ba.styles[$l].lvl,
                            Il = ba.transformers.length - 1; Rl > 0; )
                                Tl.multiply(ba.transformers[Il].mProps.v),
                                Rl -= 1,
                                Il -= 1
                    } else
                        Tl = xt;
                    if (wl = (Sl = ba.sh.paths)._length,
                    El) {
                        for (_l = "",
                        xl = 0; xl < wl; xl += 1)
                            (Cl = Sl.shapes[xl]) && Cl._length && (_l += buildShapeString(Cl, Cl._length, Cl.c, Tl));
                        ba.caches[$l] = _l
                    } else
                        _l = ba.caches[$l];
                    ba.styles[$l].d += ga.hd === !0 ? "" : _l,
                    ba.styles[$l]._mdf = El || ba.styles[$l]._mdf
                }
            }
            function Ls(ga, ba, yl) {
                var xl = ba.style;
                (ba.c._mdf || yl) && xl.pElem.setAttribute("fill", "rgb(" + bmFloor(ba.c.v[0]) + "," + bmFloor(ba.c.v[1]) + "," + bmFloor(ba.c.v[2]) + ")"),
                (ba.o._mdf || yl) && xl.pElem.setAttribute("fill-opacity", ba.o.v)
            }
            function Vs(ga, ba, yl) {
                Ws(ga, ba, yl),
                Xs(0, ba, yl)
            }
            function Ws(ga, ba, yl) {
                var xl, wl, _l, El, Cl, $l = ba.gf, Sl = ba.g._hasOpacity, Tl = ba.s.v, Rl = ba.e.v;
                if (ba.o._mdf || yl) {
                    var Il = ga.ty === "gf" ? "fill-opacity" : "stroke-opacity";
                    ba.style.pElem.setAttribute(Il, ba.o.v)
                }
                if (ba.s._mdf || yl) {
                    var Ml = ga.t === 1 ? "x1" : "cx"
                      , Nl = Ml === "x1" ? "y1" : "cy";
                    $l.setAttribute(Ml, Tl[0]),
                    $l.setAttribute(Nl, Tl[1]),
                    Sl && !ba.g._collapsable && (ba.of.setAttribute(Ml, Tl[0]),
                    ba.of.setAttribute(Nl, Tl[1]))
                }
                if (ba.g._cmdf || yl) {
                    xl = ba.cst;
                    var Ll = ba.g.c;
                    for (_l = xl.length,
                    wl = 0; wl < _l; wl += 1)
                        (El = xl[wl]).setAttribute("offset", Ll[4 * wl] + "%"),
                        El.setAttribute("stop-color", "rgb(" + Ll[4 * wl + 1] + "," + Ll[4 * wl + 2] + "," + Ll[4 * wl + 3] + ")")
                }
                if (Sl && (ba.g._omdf || yl)) {
                    var Fl = ba.g.o;
                    for (_l = (xl = ba.g._collapsable ? ba.cst : ba.ost).length,
                    wl = 0; wl < _l; wl += 1)
                        El = xl[wl],
                        ba.g._collapsable || El.setAttribute("offset", Fl[2 * wl] + "%"),
                        El.setAttribute("stop-opacity", Fl[2 * wl + 1])
                }
                if (ga.t === 1)
                    (ba.e._mdf || yl) && ($l.setAttribute("x2", Rl[0]),
                    $l.setAttribute("y2", Rl[1]),
                    Sl && !ba.g._collapsable && (ba.of.setAttribute("x2", Rl[0]),
                    ba.of.setAttribute("y2", Rl[1])));
                else if ((ba.s._mdf || ba.e._mdf || yl) && (Cl = Math.sqrt(Math.pow(Tl[0] - Rl[0], 2) + Math.pow(Tl[1] - Rl[1], 2)),
                $l.setAttribute("r", Cl),
                Sl && !ba.g._collapsable && ba.of.setAttribute("r", Cl)),
                ba.e._mdf || ba.h._mdf || ba.a._mdf || yl) {
                    Cl || (Cl = Math.sqrt(Math.pow(Tl[0] - Rl[0], 2) + Math.pow(Tl[1] - Rl[1], 2)));
                    var Ul = Math.atan2(Rl[1] - Tl[1], Rl[0] - Tl[0])
                      , Dl = ba.h.v;
                    Dl >= 1 ? Dl = .99 : Dl <= -1 && (Dl = -.99);
                    var Zl = Cl * Dl
                      , Gl = Math.cos(Ul + ba.a.v) * Zl + Tl[0]
                      , Wl = Math.sin(Ul + ba.a.v) * Zl + Tl[1];
                    $l.setAttribute("fx", Gl),
                    $l.setAttribute("fy", Wl),
                    Sl && !ba.g._collapsable && (ba.of.setAttribute("fx", Gl),
                    ba.of.setAttribute("fy", Wl))
                }
            }
            function Xs(ga, ba, yl) {
                var xl = ba.style
                  , wl = ba.d;
                wl && (wl._mdf || yl) && wl.dashStr && (xl.pElem.setAttribute("stroke-dasharray", wl.dashStr),
                xl.pElem.setAttribute("stroke-dashoffset", wl.dashoffset[0])),
                ba.c && (ba.c._mdf || yl) && xl.pElem.setAttribute("stroke", "rgb(" + bmFloor(ba.c.v[0]) + "," + bmFloor(ba.c.v[1]) + "," + bmFloor(ba.c.v[2]) + ")"),
                (ba.o._mdf || yl) && xl.pElem.setAttribute("stroke-opacity", ba.o.v),
                (ba.w._mdf || yl) && (xl.pElem.setAttribute("stroke-width", ba.w.v),
                xl.msElem && xl.msElem.setAttribute("stroke-width", ba.w.v))
            }
            return {
                createRenderFunction: function(ga) {
                    switch (ga.ty) {
                    case "fl":
                        return Ls;
                    case "gf":
                        return Ws;
                    case "gs":
                        return Vs;
                    case "st":
                        return Xs;
                    case "sh":
                    case "el":
                    case "rc":
                    case "sr":
                        return Cs;
                    case "tr":
                        return as;
                    case "no":
                        return cs;
                    default:
                        return null
                    }
                }
            }
        }();
        function SVGShapeElement(xt, Cn, as) {
            this.shapes = [],
            this.shapesData = xt.shapes,
            this.stylesList = [],
            this.shapeModifiers = [],
            this.itemsData = [],
            this.processedElements = [],
            this.animatedContents = [],
            this.initElement(xt, Cn, as),
            this.prevViewData = []
        }
        function LetterProps(xt, Cn, as, cs, Cs, Ls) {
            this.o = xt,
            this.sw = Cn,
            this.sc = as,
            this.fc = cs,
            this.m = Cs,
            this.p = Ls,
            this._mdf = {
                o: !0,
                sw: !!Cn,
                sc: !!as,
                fc: !!cs,
                m: !0,
                p: !0
            }
        }
        function TextProperty(xt, Cn) {
            this._frameId = initialDefaultFrame,
            this.pv = "",
            this.v = "",
            this.kf = !1,
            this._isFirstFrame = !0,
            this._mdf = !1,
            Cn.d && Cn.d.sid && (Cn.d = xt.globalData.slotManager.getProp(Cn.d)),
            this.data = Cn,
            this.elem = xt,
            this.comp = this.elem.comp,
            this.keysIndex = 0,
            this.canResize = !1,
            this.minimumFontSize = 1,
            this.effectsSequence = [],
            this.currentData = {
                ascent: 0,
                boxWidth: this.defaultBoxWidth,
                f: "",
                fStyle: "",
                fWeight: "",
                fc: "",
                j: "",
                justifyOffset: "",
                l: [],
                lh: 0,
                lineWidths: [],
                ls: "",
                of: "",
                s: "",
                sc: "",
                sw: 0,
                t: 0,
                tr: 0,
                sz: 0,
                ps: null,
                fillColorAnim: !1,
                strokeColorAnim: !1,
                strokeWidthAnim: !1,
                yOffset: 0,
                finalSize: 0,
                finalText: [],
                finalLineHeight: 0,
                __complete: !1
            },
            this.copyData(this.currentData, this.data.d.k[0].s),
            this.searchProperty() || this.completeTextData(this.currentData)
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement),
        SVGShapeElement.prototype.initSecondaryElement = function() {}
        ,
        SVGShapeElement.prototype.identityMatrix = new Matrix,
        SVGShapeElement.prototype.buildExpressionInterface = function() {}
        ,
        SVGShapeElement.prototype.createContent = function() {
            this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0),
            this.filterUniqueShapes()
        }
        ,
        SVGShapeElement.prototype.filterUniqueShapes = function() {
            var xt, Cn, as, cs, Cs = this.shapes.length, Ls = this.stylesList.length, Vs = [], Ws = !1;
            for (as = 0; as < Ls; as += 1) {
                for (cs = this.stylesList[as],
                Ws = !1,
                Vs.length = 0,
                xt = 0; xt < Cs; xt += 1)
                    (Cn = this.shapes[xt]).styles.indexOf(cs) !== -1 && (Vs.push(Cn),
                    Ws = Cn._isAnimated || Ws);
                Vs.length > 1 && Ws && this.setShapesAsAnimated(Vs)
            }
        }
        ,
        SVGShapeElement.prototype.setShapesAsAnimated = function(xt) {
            var Cn, as = xt.length;
            for (Cn = 0; Cn < as; Cn += 1)
                xt[Cn].setAsAnimated()
        }
        ,
        SVGShapeElement.prototype.createStyleElement = function(xt, Cn) {
            var as, cs = new SVGStyleData(xt,Cn), Cs = cs.pElem;
            return xt.ty === "st" ? as = new SVGStrokeStyleData(this,xt,cs) : xt.ty === "fl" ? as = new SVGFillStyleData(this,xt,cs) : xt.ty === "gf" || xt.ty === "gs" ? (as = new (xt.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData)(this,xt,cs),
            this.globalData.defs.appendChild(as.gf),
            as.maskId && (this.globalData.defs.appendChild(as.ms),
            this.globalData.defs.appendChild(as.of),
            Cs.setAttribute("mask", "url(" + getLocationHref() + "#" + as.maskId + ")"))) : xt.ty === "no" && (as = new SVGNoStyleData(this,xt,cs)),
            xt.ty !== "st" && xt.ty !== "gs" || (Cs.setAttribute("stroke-linecap", lineCapEnum[xt.lc || 2]),
            Cs.setAttribute("stroke-linejoin", lineJoinEnum[xt.lj || 2]),
            Cs.setAttribute("fill-opacity", "0"),
            xt.lj === 1 && Cs.setAttribute("stroke-miterlimit", xt.ml)),
            xt.r === 2 && Cs.setAttribute("fill-rule", "evenodd"),
            xt.ln && Cs.setAttribute("id", xt.ln),
            xt.cl && Cs.setAttribute("class", xt.cl),
            xt.bm && (Cs.style["mix-blend-mode"] = getBlendMode(xt.bm)),
            this.stylesList.push(cs),
            this.addToAnimatedContents(xt, as),
            as
        }
        ,
        SVGShapeElement.prototype.createGroupElement = function(xt) {
            var Cn = new ShapeGroupData;
            return xt.ln && Cn.gr.setAttribute("id", xt.ln),
            xt.cl && Cn.gr.setAttribute("class", xt.cl),
            xt.bm && (Cn.gr.style["mix-blend-mode"] = getBlendMode(xt.bm)),
            Cn
        }
        ,
        SVGShapeElement.prototype.createTransformElement = function(xt, Cn) {
            var as = TransformPropertyFactory.getTransformProperty(this, xt, this)
              , cs = new SVGTransformData(as,as.o,Cn);
            return this.addToAnimatedContents(xt, cs),
            cs
        }
        ,
        SVGShapeElement.prototype.createShapeElement = function(xt, Cn, as) {
            var cs = 4;
            xt.ty === "rc" ? cs = 5 : xt.ty === "el" ? cs = 6 : xt.ty === "sr" && (cs = 7);
            var Cs = new SVGShapeData(Cn,as,ShapePropertyFactory.getShapeProp(this, xt, cs, this));
            return this.shapes.push(Cs),
            this.addShapeToModifiers(Cs),
            this.addToAnimatedContents(xt, Cs),
            Cs
        }
        ,
        SVGShapeElement.prototype.addToAnimatedContents = function(xt, Cn) {
            for (var as = 0, cs = this.animatedContents.length; as < cs; ) {
                if (this.animatedContents[as].element === Cn)
                    return;
                as += 1
            }
            this.animatedContents.push({
                fn: SVGElementsRenderer.createRenderFunction(xt),
                element: Cn,
                data: xt
            })
        }
        ,
        SVGShapeElement.prototype.setElementStyles = function(xt) {
            var Cn, as = xt.styles, cs = this.stylesList.length;
            for (Cn = 0; Cn < cs; Cn += 1)
                this.stylesList[Cn].closed || as.push(this.stylesList[Cn])
        }
        ,
        SVGShapeElement.prototype.reloadShapes = function() {
            var xt;
            this._isFirstFrame = !0;
            var Cn = this.itemsData.length;
            for (xt = 0; xt < Cn; xt += 1)
                this.prevViewData[xt] = this.itemsData[xt];
            for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0),
            this.filterUniqueShapes(),
            Cn = this.dynamicProperties.length,
            xt = 0; xt < Cn; xt += 1)
                this.dynamicProperties[xt].getValue();
            this.renderModifiers()
        }
        ,
        SVGShapeElement.prototype.searchShapes = function(xt, Cn, as, cs, Cs, Ls, Vs) {
            var Ws, Xs, ga, ba, yl, xl, wl = [].concat(Ls), _l = xt.length - 1, El = [], Cl = [];
            for (Ws = _l; Ws >= 0; Ws -= 1) {
                if ((xl = this.searchProcessedElement(xt[Ws])) ? Cn[Ws] = as[xl - 1] : xt[Ws]._render = Vs,
                xt[Ws].ty === "fl" || xt[Ws].ty === "st" || xt[Ws].ty === "gf" || xt[Ws].ty === "gs" || xt[Ws].ty === "no")
                    xl ? Cn[Ws].style.closed = !1 : Cn[Ws] = this.createStyleElement(xt[Ws], Cs),
                    xt[Ws]._render && Cn[Ws].style.pElem.parentNode !== cs && cs.appendChild(Cn[Ws].style.pElem),
                    El.push(Cn[Ws].style);
                else if (xt[Ws].ty === "gr") {
                    if (xl)
                        for (ga = Cn[Ws].it.length,
                        Xs = 0; Xs < ga; Xs += 1)
                            Cn[Ws].prevViewData[Xs] = Cn[Ws].it[Xs];
                    else
                        Cn[Ws] = this.createGroupElement(xt[Ws]);
                    this.searchShapes(xt[Ws].it, Cn[Ws].it, Cn[Ws].prevViewData, Cn[Ws].gr, Cs + 1, wl, Vs),
                    xt[Ws]._render && Cn[Ws].gr.parentNode !== cs && cs.appendChild(Cn[Ws].gr)
                } else
                    xt[Ws].ty === "tr" ? (xl || (Cn[Ws] = this.createTransformElement(xt[Ws], cs)),
                    ba = Cn[Ws].transform,
                    wl.push(ba)) : xt[Ws].ty === "sh" || xt[Ws].ty === "rc" || xt[Ws].ty === "el" || xt[Ws].ty === "sr" ? (xl || (Cn[Ws] = this.createShapeElement(xt[Ws], wl, Cs)),
                    this.setElementStyles(Cn[Ws])) : xt[Ws].ty === "tm" || xt[Ws].ty === "rd" || xt[Ws].ty === "ms" || xt[Ws].ty === "pb" || xt[Ws].ty === "zz" || xt[Ws].ty === "op" ? (xl ? (yl = Cn[Ws]).closed = !1 : ((yl = ShapeModifiers.getModifier(xt[Ws].ty)).init(this, xt[Ws]),
                    Cn[Ws] = yl,
                    this.shapeModifiers.push(yl)),
                    Cl.push(yl)) : xt[Ws].ty === "rp" && (xl ? (yl = Cn[Ws]).closed = !0 : (yl = ShapeModifiers.getModifier(xt[Ws].ty),
                    Cn[Ws] = yl,
                    yl.init(this, xt, Ws, Cn),
                    this.shapeModifiers.push(yl),
                    Vs = !1),
                    Cl.push(yl));
                this.addProcessedElement(xt[Ws], Ws + 1)
            }
            for (_l = El.length,
            Ws = 0; Ws < _l; Ws += 1)
                El[Ws].closed = !0;
            for (_l = Cl.length,
            Ws = 0; Ws < _l; Ws += 1)
                Cl[Ws].closed = !0
        }
        ,
        SVGShapeElement.prototype.renderInnerContent = function() {
            var xt;
            this.renderModifiers();
            var Cn = this.stylesList.length;
            for (xt = 0; xt < Cn; xt += 1)
                this.stylesList[xt].reset();
            for (this.renderShape(),
            xt = 0; xt < Cn; xt += 1)
                (this.stylesList[xt]._mdf || this._isFirstFrame) && (this.stylesList[xt].msElem && (this.stylesList[xt].msElem.setAttribute("d", this.stylesList[xt].d),
                this.stylesList[xt].d = "M0 0" + this.stylesList[xt].d),
                this.stylesList[xt].pElem.setAttribute("d", this.stylesList[xt].d || "M0 0"))
        }
        ,
        SVGShapeElement.prototype.renderShape = function() {
            var xt, Cn, as = this.animatedContents.length;
            for (xt = 0; xt < as; xt += 1)
                Cn = this.animatedContents[xt],
                (this._isFirstFrame || Cn.element._isAnimated) && Cn.data !== !0 && Cn.fn(Cn.data, Cn.element, this._isFirstFrame)
        }
        ,
        SVGShapeElement.prototype.destroy = function() {
            this.destroyBaseElement(),
            this.shapesData = null,
            this.itemsData = null
        }
        ,
        LetterProps.prototype.update = function(xt, Cn, as, cs, Cs, Ls) {
            this._mdf.o = !1,
            this._mdf.sw = !1,
            this._mdf.sc = !1,
            this._mdf.fc = !1,
            this._mdf.m = !1,
            this._mdf.p = !1;
            var Vs = !1;
            return this.o !== xt && (this.o = xt,
            this._mdf.o = !0,
            Vs = !0),
            this.sw !== Cn && (this.sw = Cn,
            this._mdf.sw = !0,
            Vs = !0),
            this.sc !== as && (this.sc = as,
            this._mdf.sc = !0,
            Vs = !0),
            this.fc !== cs && (this.fc = cs,
            this._mdf.fc = !0,
            Vs = !0),
            this.m !== Cs && (this.m = Cs,
            this._mdf.m = !0,
            Vs = !0),
            !Ls.length || this.p[0] === Ls[0] && this.p[1] === Ls[1] && this.p[4] === Ls[4] && this.p[5] === Ls[5] && this.p[12] === Ls[12] && this.p[13] === Ls[13] || (this.p = Ls,
            this._mdf.p = !0,
            Vs = !0),
            Vs
        }
        ,
        TextProperty.prototype.defaultBoxWidth = [0, 0],
        TextProperty.prototype.copyData = function(xt, Cn) {
            for (var as in Cn)
                Object.prototype.hasOwnProperty.call(Cn, as) && (xt[as] = Cn[as]);
            return xt
        }
        ,
        TextProperty.prototype.setCurrentData = function(xt) {
            xt.__complete || this.completeTextData(xt),
            this.currentData = xt,
            this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth,
            this._mdf = !0
        }
        ,
        TextProperty.prototype.searchProperty = function() {
            return this.searchKeyframes()
        }
        ,
        TextProperty.prototype.searchKeyframes = function() {
            return this.kf = this.data.d.k.length > 1,
            this.kf && this.addEffect(this.getKeyframeValue.bind(this)),
            this.kf
        }
        ,
        TextProperty.prototype.addEffect = function(xt) {
            this.effectsSequence.push(xt),
            this.elem.addDynamicProperty(this)
        }
        ,
        TextProperty.prototype.getValue = function(xt) {
            if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length || xt) {
                this.currentData.t = this.data.d.k[this.keysIndex].s.t;
                var Cn = this.currentData
                  , as = this.keysIndex;
                if (this.lock)
                    this.setCurrentData(this.currentData);
                else {
                    var cs;
                    this.lock = !0,
                    this._mdf = !1;
                    var Cs = this.effectsSequence.length
                      , Ls = xt || this.data.d.k[this.keysIndex].s;
                    for (cs = 0; cs < Cs; cs += 1)
                        Ls = as !== this.keysIndex ? this.effectsSequence[cs](Ls, Ls.t) : this.effectsSequence[cs](this.currentData, Ls.t);
                    Cn !== Ls && this.setCurrentData(Ls),
                    this.v = this.currentData,
                    this.pv = this.v,
                    this.lock = !1,
                    this.frameId = this.elem.globalData.frameId
                }
            }
        }
        ,
        TextProperty.prototype.getKeyframeValue = function() {
            for (var xt = this.data.d.k, Cn = this.elem.comp.renderedFrame, as = 0, cs = xt.length; as <= cs - 1 && !(as === cs - 1 || xt[as + 1].t > Cn); )
                as += 1;
            return this.keysIndex !== as && (this.keysIndex = as),
            this.data.d.k[this.keysIndex].s
        }
        ,
        TextProperty.prototype.buildFinalText = function(xt) {
            for (var Cn, as, cs = [], Cs = 0, Ls = xt.length, Vs = !1, Ws = !1, Xs = ""; Cs < Ls; )
                Vs = Ws,
                Ws = !1,
                Cn = xt.charCodeAt(Cs),
                Xs = xt.charAt(Cs),
                FontManager.isCombinedCharacter(Cn) ? Vs = !0 : Cn >= 55296 && Cn <= 56319 ? FontManager.isRegionalFlag(xt, Cs) ? Xs = xt.substr(Cs, 14) : (as = xt.charCodeAt(Cs + 1)) >= 56320 && as <= 57343 && (FontManager.isModifier(Cn, as) ? (Xs = xt.substr(Cs, 2),
                Vs = !0) : Xs = FontManager.isFlagEmoji(xt.substr(Cs, 4)) ? xt.substr(Cs, 4) : xt.substr(Cs, 2)) : Cn > 56319 ? (as = xt.charCodeAt(Cs + 1),
                FontManager.isVariationSelector(Cn) && (Vs = !0)) : FontManager.isZeroWidthJoiner(Cn) && (Vs = !0,
                Ws = !0),
                Vs ? (cs[cs.length - 1] += Xs,
                Vs = !1) : cs.push(Xs),
                Cs += Xs.length;
            return cs
        }
        ,
        TextProperty.prototype.completeTextData = function(xt) {
            xt.__complete = !0;
            var Cn, as, cs, Cs, Ls, Vs, Ws, Xs = this.elem.globalData.fontManager, ga = this.data, ba = [], yl = 0, xl = ga.m.g, wl = 0, _l = 0, El = 0, Cl = [], $l = 0, Sl = 0, Tl = Xs.getFontByName(xt.f), Rl = 0, Il = getFontProperties(Tl);
            xt.fWeight = Il.weight,
            xt.fStyle = Il.style,
            xt.finalSize = xt.s,
            xt.finalText = this.buildFinalText(xt.t),
            as = xt.finalText.length,
            xt.finalLineHeight = xt.lh;
            var Ml, Nl = xt.tr / 1e3 * xt.finalSize;
            if (xt.sz)
                for (var Ll, Fl, Ul = !0, Dl = xt.sz[0], Zl = xt.sz[1]; Ul; ) {
                    Ll = 0,
                    $l = 0,
                    as = (Fl = this.buildFinalText(xt.t)).length,
                    Nl = xt.tr / 1e3 * xt.finalSize;
                    var Gl = -1;
                    for (Cn = 0; Cn < as; Cn += 1)
                        Ml = Fl[Cn].charCodeAt(0),
                        cs = !1,
                        Fl[Cn] === " " ? Gl = Cn : Ml !== 13 && Ml !== 3 || ($l = 0,
                        cs = !0,
                        Ll += xt.finalLineHeight || 1.2 * xt.finalSize),
                        Xs.chars ? (Ws = Xs.getCharData(Fl[Cn], Tl.fStyle, Tl.fFamily),
                        Rl = cs ? 0 : Ws.w * xt.finalSize / 100) : Rl = Xs.measureText(Fl[Cn], xt.f, xt.finalSize),
                        $l + Rl > Dl && Fl[Cn] !== " " ? (Gl === -1 ? as += 1 : Cn = Gl,
                        Ll += xt.finalLineHeight || 1.2 * xt.finalSize,
                        Fl.splice(Cn, Gl === Cn ? 1 : 0, "\r"),
                        Gl = -1,
                        $l = 0) : ($l += Rl,
                        $l += Nl);
                    Ll += Tl.ascent * xt.finalSize / 100,
                    this.canResize && xt.finalSize > this.minimumFontSize && Zl < Ll ? (xt.finalSize -= 1,
                    xt.finalLineHeight = xt.finalSize * xt.lh / xt.s) : (xt.finalText = Fl,
                    as = xt.finalText.length,
                    Ul = !1)
                }
            $l = -Nl,
            Rl = 0;
            var Wl, Ql = 0;
            for (Cn = 0; Cn < as; Cn += 1)
                if (cs = !1,
                (Ml = (Wl = xt.finalText[Cn]).charCodeAt(0)) === 13 || Ml === 3 ? (Ql = 0,
                Cl.push($l),
                Sl = $l > Sl ? $l : Sl,
                $l = -2 * Nl,
                Cs = "",
                cs = !0,
                El += 1) : Cs = Wl,
                Xs.chars ? (Ws = Xs.getCharData(Wl, Tl.fStyle, Xs.getFontByName(xt.f).fFamily),
                Rl = cs ? 0 : Ws.w * xt.finalSize / 100) : Rl = Xs.measureText(Cs, xt.f, xt.finalSize),
                Wl === " " ? Ql += Rl + Nl : ($l += Rl + Nl + Ql,
                Ql = 0),
                ba.push({
                    l: Rl,
                    an: Rl,
                    add: wl,
                    n: cs,
                    anIndexes: [],
                    val: Cs,
                    line: El,
                    animatorJustifyOffset: 0
                }),
                xl == 2) {
                    if (wl += Rl,
                    Cs === "" || Cs === " " || Cn === as - 1) {
                        for (Cs !== "" && Cs !== " " || (wl -= Rl); _l <= Cn; )
                            ba[_l].an = wl,
                            ba[_l].ind = yl,
                            ba[_l].extra = Rl,
                            _l += 1;
                        yl += 1,
                        wl = 0
                    }
                } else if (xl == 3) {
                    if (wl += Rl,
                    Cs === "" || Cn === as - 1) {
                        for (Cs === "" && (wl -= Rl); _l <= Cn; )
                            ba[_l].an = wl,
                            ba[_l].ind = yl,
                            ba[_l].extra = Rl,
                            _l += 1;
                        wl = 0,
                        yl += 1
                    }
                } else
                    ba[yl].ind = yl,
                    ba[yl].extra = 0,
                    yl += 1;
            if (xt.l = ba,
            Sl = $l > Sl ? $l : Sl,
            Cl.push($l),
            xt.sz)
                xt.boxWidth = xt.sz[0],
                xt.justifyOffset = 0;
            else
                switch (xt.boxWidth = Sl,
                xt.j) {
                case 1:
                    xt.justifyOffset = -xt.boxWidth;
                    break;
                case 2:
                    xt.justifyOffset = -xt.boxWidth / 2;
                    break;
                default:
                    xt.justifyOffset = 0
                }
            xt.lineWidths = Cl;
            var cu, pu, zl, Yl, lu = ga.a;
            Vs = lu.length;
            var mu = [];
            for (Ls = 0; Ls < Vs; Ls += 1) {
                for ((cu = lu[Ls]).a.sc && (xt.strokeColorAnim = !0),
                cu.a.sw && (xt.strokeWidthAnim = !0),
                (cu.a.fc || cu.a.fh || cu.a.fs || cu.a.fb) && (xt.fillColorAnim = !0),
                Yl = 0,
                zl = cu.s.b,
                Cn = 0; Cn < as; Cn += 1)
                    (pu = ba[Cn]).anIndexes[Ls] = Yl,
                    (zl == 1 && pu.val !== "" || zl == 2 && pu.val !== "" && pu.val !== " " || zl == 3 && (pu.n || pu.val == " " || Cn == as - 1) || zl == 4 && (pu.n || Cn == as - 1)) && (cu.s.rn === 1 && mu.push(Yl),
                    Yl += 1);
                ga.a[Ls].s.totalChars = Yl;
                var Cu, ju = -1;
                if (cu.s.rn === 1)
                    for (Cn = 0; Cn < as; Cn += 1)
                        ju != (pu = ba[Cn]).anIndexes[Ls] && (ju = pu.anIndexes[Ls],
                        Cu = mu.splice(Math.floor(Math.random() * mu.length), 1)[0]),
                        pu.anIndexes[Ls] = Cu
            }
            xt.yOffset = xt.finalLineHeight || 1.2 * xt.finalSize,
            xt.ls = xt.ls || 0,
            xt.ascent = Tl.ascent * xt.finalSize / 100
        }
        ,
        TextProperty.prototype.updateDocumentData = function(xt, Cn) {
            Cn = Cn === void 0 ? this.keysIndex : Cn;
            var as = this.copyData({}, this.data.d.k[Cn].s);
            as = this.copyData(as, xt),
            this.data.d.k[Cn].s = as,
            this.recalculate(Cn),
            this.setCurrentData(as),
            this.elem.addDynamicProperty(this)
        }
        ,
        TextProperty.prototype.recalculate = function(xt) {
            var Cn = this.data.d.k[xt].s;
            Cn.__complete = !1,
            this.keysIndex = 0,
            this._isFirstFrame = !0,
            this.getValue(Cn)
        }
        ,
        TextProperty.prototype.canResizeFont = function(xt) {
            this.canResize = xt,
            this.recalculate(this.keysIndex),
            this.elem.addDynamicProperty(this)
        }
        ,
        TextProperty.prototype.setMinimumFontSize = function(xt) {
            this.minimumFontSize = Math.floor(xt) || 1,
            this.recalculate(this.keysIndex),
            this.elem.addDynamicProperty(this)
        }
        ;
        var TextSelectorProp = function() {
            var xt = Math.max
              , Cn = Math.min
              , as = Math.floor;
            function cs(Cs, Ls) {
                this._currentTextLength = -1,
                this.k = !1,
                this.data = Ls,
                this.elem = Cs,
                this.comp = Cs.comp,
                this.finalS = 0,
                this.finalE = 0,
                this.initDynamicPropertyContainer(Cs),
                this.s = PropertyFactory.getProp(Cs, Ls.s || {
                    k: 0
                }, 0, 0, this),
                this.e = "e"in Ls ? PropertyFactory.getProp(Cs, Ls.e, 0, 0, this) : {
                    v: 100
                },
                this.o = PropertyFactory.getProp(Cs, Ls.o || {
                    k: 0
                }, 0, 0, this),
                this.xe = PropertyFactory.getProp(Cs, Ls.xe || {
                    k: 0
                }, 0, 0, this),
                this.ne = PropertyFactory.getProp(Cs, Ls.ne || {
                    k: 0
                }, 0, 0, this),
                this.sm = PropertyFactory.getProp(Cs, Ls.sm || {
                    k: 100
                }, 0, 0, this),
                this.a = PropertyFactory.getProp(Cs, Ls.a, 0, .01, this),
                this.dynamicProperties.length || this.getValue()
            }
            return cs.prototype = {
                getMult: function(Cs) {
                    this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue();
                    var Ls = 0
                      , Vs = 0
                      , Ws = 1
                      , Xs = 1;
                    this.ne.v > 0 ? Ls = this.ne.v / 100 : Vs = -this.ne.v / 100,
                    this.xe.v > 0 ? Ws = 1 - this.xe.v / 100 : Xs = 1 + this.xe.v / 100;
                    var ga = BezierFactory.getBezierEasing(Ls, Vs, Ws, Xs).get
                      , ba = 0
                      , yl = this.finalS
                      , xl = this.finalE
                      , wl = this.data.sh;
                    if (wl === 2)
                        ba = ga(ba = xl === yl ? Cs >= xl ? 1 : 0 : xt(0, Cn(.5 / (xl - yl) + (Cs - yl) / (xl - yl), 1)));
                    else if (wl === 3)
                        ba = ga(ba = xl === yl ? Cs >= xl ? 0 : 1 : 1 - xt(0, Cn(.5 / (xl - yl) + (Cs - yl) / (xl - yl), 1)));
                    else if (wl === 4)
                        xl === yl ? ba = 0 : (ba = xt(0, Cn(.5 / (xl - yl) + (Cs - yl) / (xl - yl), 1))) < .5 ? ba *= 2 : ba = 1 - 2 * (ba - .5),
                        ba = ga(ba);
                    else if (wl === 5) {
                        if (xl === yl)
                            ba = 0;
                        else {
                            var _l = xl - yl
                              , El = -_l / 2 + (Cs = Cn(xt(0, Cs + .5 - yl), xl - yl))
                              , Cl = _l / 2;
                            ba = Math.sqrt(1 - El * El / (Cl * Cl))
                        }
                        ba = ga(ba)
                    } else
                        wl === 6 ? (xl === yl ? ba = 0 : (Cs = Cn(xt(0, Cs + .5 - yl), xl - yl),
                        ba = (1 + Math.cos(Math.PI + 2 * Math.PI * Cs / (xl - yl))) / 2),
                        ba = ga(ba)) : (Cs >= as(yl) && (ba = xt(0, Cn(Cs - yl < 0 ? Cn(xl, 1) - (yl - Cs) : xl - Cs, 1))),
                        ba = ga(ba));
                    if (this.sm.v !== 100) {
                        var $l = .01 * this.sm.v;
                        $l === 0 && ($l = 1e-8);
                        var Sl = .5 - .5 * $l;
                        ba < Sl ? ba = 0 : (ba = (ba - Sl) / $l) > 1 && (ba = 1)
                    }
                    return ba * this.a.v
                },
                getValue: function(Cs) {
                    this.iterateDynamicProperties(),
                    this._mdf = Cs || this._mdf,
                    this._currentTextLength = this.elem.textProperty.currentData.l.length || 0,
                    Cs && this.data.r === 2 && (this.e.v = this._currentTextLength);
                    var Ls = this.data.r === 2 ? 1 : 100 / this.data.totalChars
                      , Vs = this.o.v / Ls
                      , Ws = this.s.v / Ls + Vs
                      , Xs = this.e.v / Ls + Vs;
                    if (Ws > Xs) {
                        var ga = Ws;
                        Ws = Xs,
                        Xs = ga
                    }
                    this.finalS = Ws,
                    this.finalE = Xs
                }
            },
            extendPrototype([DynamicPropertyContainer], cs),
            {
                getTextSelectorProp: function(Cs, Ls, Vs) {
                    return new cs(Cs,Ls)
                }
            }
        }();
        function TextAnimatorDataProperty(xt, Cn, as) {
            var cs = {
                propType: !1
            }
              , Cs = PropertyFactory.getProp
              , Ls = Cn.a;
            this.a = {
                r: Ls.r ? Cs(xt, Ls.r, 0, degToRads, as) : cs,
                rx: Ls.rx ? Cs(xt, Ls.rx, 0, degToRads, as) : cs,
                ry: Ls.ry ? Cs(xt, Ls.ry, 0, degToRads, as) : cs,
                sk: Ls.sk ? Cs(xt, Ls.sk, 0, degToRads, as) : cs,
                sa: Ls.sa ? Cs(xt, Ls.sa, 0, degToRads, as) : cs,
                s: Ls.s ? Cs(xt, Ls.s, 1, .01, as) : cs,
                a: Ls.a ? Cs(xt, Ls.a, 1, 0, as) : cs,
                o: Ls.o ? Cs(xt, Ls.o, 0, .01, as) : cs,
                p: Ls.p ? Cs(xt, Ls.p, 1, 0, as) : cs,
                sw: Ls.sw ? Cs(xt, Ls.sw, 0, 0, as) : cs,
                sc: Ls.sc ? Cs(xt, Ls.sc, 1, 0, as) : cs,
                fc: Ls.fc ? Cs(xt, Ls.fc, 1, 0, as) : cs,
                fh: Ls.fh ? Cs(xt, Ls.fh, 0, 0, as) : cs,
                fs: Ls.fs ? Cs(xt, Ls.fs, 0, .01, as) : cs,
                fb: Ls.fb ? Cs(xt, Ls.fb, 0, .01, as) : cs,
                t: Ls.t ? Cs(xt, Ls.t, 0, 0, as) : cs
            },
            this.s = TextSelectorProp.getTextSelectorProp(xt, Cn.s, as),
            this.s.t = Cn.s.t
        }
        function TextAnimatorProperty(xt, Cn, as) {
            this._isFirstFrame = !0,
            this._hasMaskedPath = !1,
            this._frameId = -1,
            this._textData = xt,
            this._renderType = Cn,
            this._elem = as,
            this._animatorsData = createSizedArray(this._textData.a.length),
            this._pathData = {},
            this._moreOptions = {
                alignment: {}
            },
            this.renderedLetters = [],
            this.lettersChangedFlag = !1,
            this.initDynamicPropertyContainer(as)
        }
        function ITextElement() {}
        TextAnimatorProperty.prototype.searchProperties = function() {
            var xt, Cn, as = this._textData.a.length, cs = PropertyFactory.getProp;
            for (xt = 0; xt < as; xt += 1)
                Cn = this._textData.a[xt],
                this._animatorsData[xt] = new TextAnimatorDataProperty(this._elem,Cn,this);
            this._textData.p && "m"in this._textData.p ? (this._pathData = {
                a: cs(this._elem, this._textData.p.a, 0, 0, this),
                f: cs(this._elem, this._textData.p.f, 0, 0, this),
                l: cs(this._elem, this._textData.p.l, 0, 0, this),
                r: cs(this._elem, this._textData.p.r, 0, 0, this),
                p: cs(this._elem, this._textData.p.p, 0, 0, this),
                m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
            },
            this._hasMaskedPath = !0) : this._hasMaskedPath = !1,
            this._moreOptions.alignment = cs(this._elem, this._textData.m.a, 1, 0, this)
        }
        ,
        TextAnimatorProperty.prototype.getMeasures = function(xt, Cn) {
            if (this.lettersChangedFlag = Cn,
            this._mdf || this._isFirstFrame || Cn || this._hasMaskedPath && this._pathData.m._mdf) {
                this._isFirstFrame = !1;
                var as, cs, Cs, Ls, Vs, Ws, Xs, ga, ba, yl, xl, wl, _l, El, Cl, $l, Sl, Tl, Rl, Il = this._moreOptions.alignment.v, Ml = this._animatorsData, Nl = this._textData, Ll = this.mHelper, Fl = this._renderType, Ul = this.renderedLetters.length, Dl = xt.l;
                if (this._hasMaskedPath) {
                    if (Rl = this._pathData.m,
                    !this._pathData.n || this._pathData._mdf) {
                        var Zl, Gl = Rl.v;
                        for (this._pathData.r.v && (Gl = Gl.reverse()),
                        Vs = {
                            tLength: 0,
                            segments: []
                        },
                        Ls = Gl._length - 1,
                        $l = 0,
                        Cs = 0; Cs < Ls; Cs += 1)
                            Zl = bez.buildBezierData(Gl.v[Cs], Gl.v[Cs + 1], [Gl.o[Cs][0] - Gl.v[Cs][0], Gl.o[Cs][1] - Gl.v[Cs][1]], [Gl.i[Cs + 1][0] - Gl.v[Cs + 1][0], Gl.i[Cs + 1][1] - Gl.v[Cs + 1][1]]),
                            Vs.tLength += Zl.segmentLength,
                            Vs.segments.push(Zl),
                            $l += Zl.segmentLength;
                        Cs = Ls,
                        Rl.v.c && (Zl = bez.buildBezierData(Gl.v[Cs], Gl.v[0], [Gl.o[Cs][0] - Gl.v[Cs][0], Gl.o[Cs][1] - Gl.v[Cs][1]], [Gl.i[0][0] - Gl.v[0][0], Gl.i[0][1] - Gl.v[0][1]]),
                        Vs.tLength += Zl.segmentLength,
                        Vs.segments.push(Zl),
                        $l += Zl.segmentLength),
                        this._pathData.pi = Vs
                    }
                    if (Vs = this._pathData.pi,
                    Ws = this._pathData.f.v,
                    xl = 0,
                    yl = 1,
                    ga = 0,
                    ba = !0,
                    El = Vs.segments,
                    Ws < 0 && Rl.v.c)
                        for (Vs.tLength < Math.abs(Ws) && (Ws = -Math.abs(Ws) % Vs.tLength),
                        yl = (_l = El[xl = El.length - 1].points).length - 1; Ws < 0; )
                            Ws += _l[yl].partialLength,
                            (yl -= 1) < 0 && (yl = (_l = El[xl -= 1].points).length - 1);
                    wl = (_l = El[xl].points)[yl - 1],
                    Cl = (Xs = _l[yl]).partialLength
                }
                Ls = Dl.length,
                as = 0,
                cs = 0;
                var Wl, Ql, cu, pu, zl, Yl = 1.2 * xt.finalSize * .714, lu = !0;
                cu = Ml.length;
                var mu, Cu, ju, Lu, Au, Du, Qu, fu, yu, vu, _u, xu, Ru = -1, Iu = Ws, Ku = xl, dp = yl, lp = -1, qu = "", hp = this.defaultPropsArray;
                if (xt.j === 2 || xt.j === 1) {
                    var fp = 0
                      , Lp = 0
                      , uu = xt.j === 2 ? -.5 : -1
                      , gu = 0
                      , Eu = !0;
                    for (Cs = 0; Cs < Ls; Cs += 1)
                        if (Dl[Cs].n) {
                            for (fp && (fp += Lp); gu < Cs; )
                                Dl[gu].animatorJustifyOffset = fp,
                                gu += 1;
                            fp = 0,
                            Eu = !0
                        } else {
                            for (Ql = 0; Ql < cu; Ql += 1)
                                (Wl = Ml[Ql].a).t.propType && (Eu && xt.j === 2 && (Lp += Wl.t.v * uu),
                                (zl = Ml[Ql].s.getMult(Dl[Cs].anIndexes[Ql], Nl.a[Ql].s.totalChars)).length ? fp += Wl.t.v * zl[0] * uu : fp += Wl.t.v * zl * uu);
                            Eu = !1
                        }
                    for (fp && (fp += Lp); gu < Cs; )
                        Dl[gu].animatorJustifyOffset = fp,
                        gu += 1
                }
                for (Cs = 0; Cs < Ls; Cs += 1) {
                    if (Ll.reset(),
                    Lu = 1,
                    Dl[Cs].n)
                        as = 0,
                        cs += xt.yOffset,
                        cs += lu ? 1 : 0,
                        Ws = Iu,
                        lu = !1,
                        this._hasMaskedPath && (yl = dp,
                        wl = (_l = El[xl = Ku].points)[yl - 1],
                        Cl = (Xs = _l[yl]).partialLength,
                        ga = 0),
                        qu = "",
                        _u = "",
                        yu = "",
                        xu = "",
                        hp = this.defaultPropsArray;
                    else {
                        if (this._hasMaskedPath) {
                            if (lp !== Dl[Cs].line) {
                                switch (xt.j) {
                                case 1:
                                    Ws += $l - xt.lineWidths[Dl[Cs].line];
                                    break;
                                case 2:
                                    Ws += ($l - xt.lineWidths[Dl[Cs].line]) / 2
                                }
                                lp = Dl[Cs].line
                            }
                            Ru !== Dl[Cs].ind && (Dl[Ru] && (Ws += Dl[Ru].extra),
                            Ws += Dl[Cs].an / 2,
                            Ru = Dl[Cs].ind),
                            Ws += Il[0] * Dl[Cs].an * .005;
                            var nu = 0;
                            for (Ql = 0; Ql < cu; Ql += 1)
                                (Wl = Ml[Ql].a).p.propType && ((zl = Ml[Ql].s.getMult(Dl[Cs].anIndexes[Ql], Nl.a[Ql].s.totalChars)).length ? nu += Wl.p.v[0] * zl[0] : nu += Wl.p.v[0] * zl),
                                Wl.a.propType && ((zl = Ml[Ql].s.getMult(Dl[Cs].anIndexes[Ql], Nl.a[Ql].s.totalChars)).length ? nu += Wl.a.v[0] * zl[0] : nu += Wl.a.v[0] * zl);
                            for (ba = !0,
                            this._pathData.a.v && (Ws = .5 * Dl[0].an + ($l - this._pathData.f.v - .5 * Dl[0].an - .5 * Dl[Dl.length - 1].an) * Ru / (Ls - 1),
                            Ws += this._pathData.f.v); ba; )
                                ga + Cl >= Ws + nu || !_l ? (Sl = (Ws + nu - ga) / Xs.partialLength,
                                Cu = wl.point[0] + (Xs.point[0] - wl.point[0]) * Sl,
                                ju = wl.point[1] + (Xs.point[1] - wl.point[1]) * Sl,
                                Ll.translate(-Il[0] * Dl[Cs].an * .005, -Il[1] * Yl * .01),
                                ba = !1) : _l && (ga += Xs.partialLength,
                                (yl += 1) >= _l.length && (yl = 0,
                                El[xl += 1] ? _l = El[xl].points : Rl.v.c ? (yl = 0,
                                _l = El[xl = 0].points) : (ga -= Xs.partialLength,
                                _l = null)),
                                _l && (wl = Xs,
                                Cl = (Xs = _l[yl]).partialLength));
                            mu = Dl[Cs].an / 2 - Dl[Cs].add,
                            Ll.translate(-mu, 0, 0)
                        } else
                            mu = Dl[Cs].an / 2 - Dl[Cs].add,
                            Ll.translate(-mu, 0, 0),
                            Ll.translate(-Il[0] * Dl[Cs].an * .005, -Il[1] * Yl * .01, 0);
                        for (Ql = 0; Ql < cu; Ql += 1)
                            (Wl = Ml[Ql].a).t.propType && (zl = Ml[Ql].s.getMult(Dl[Cs].anIndexes[Ql], Nl.a[Ql].s.totalChars),
                            as === 0 && xt.j === 0 || (this._hasMaskedPath ? zl.length ? Ws += Wl.t.v * zl[0] : Ws += Wl.t.v * zl : zl.length ? as += Wl.t.v * zl[0] : as += Wl.t.v * zl));
                        for (xt.strokeWidthAnim && (Du = xt.sw || 0),
                        xt.strokeColorAnim && (Au = xt.sc ? [xt.sc[0], xt.sc[1], xt.sc[2]] : [0, 0, 0]),
                        xt.fillColorAnim && xt.fc && (Qu = [xt.fc[0], xt.fc[1], xt.fc[2]]),
                        Ql = 0; Ql < cu; Ql += 1)
                            (Wl = Ml[Ql].a).a.propType && ((zl = Ml[Ql].s.getMult(Dl[Cs].anIndexes[Ql], Nl.a[Ql].s.totalChars)).length ? Ll.translate(-Wl.a.v[0] * zl[0], -Wl.a.v[1] * zl[1], Wl.a.v[2] * zl[2]) : Ll.translate(-Wl.a.v[0] * zl, -Wl.a.v[1] * zl, Wl.a.v[2] * zl));
                        for (Ql = 0; Ql < cu; Ql += 1)
                            (Wl = Ml[Ql].a).s.propType && ((zl = Ml[Ql].s.getMult(Dl[Cs].anIndexes[Ql], Nl.a[Ql].s.totalChars)).length ? Ll.scale(1 + (Wl.s.v[0] - 1) * zl[0], 1 + (Wl.s.v[1] - 1) * zl[1], 1) : Ll.scale(1 + (Wl.s.v[0] - 1) * zl, 1 + (Wl.s.v[1] - 1) * zl, 1));
                        for (Ql = 0; Ql < cu; Ql += 1) {
                            if (Wl = Ml[Ql].a,
                            zl = Ml[Ql].s.getMult(Dl[Cs].anIndexes[Ql], Nl.a[Ql].s.totalChars),
                            Wl.sk.propType && (zl.length ? Ll.skewFromAxis(-Wl.sk.v * zl[0], Wl.sa.v * zl[1]) : Ll.skewFromAxis(-Wl.sk.v * zl, Wl.sa.v * zl)),
                            Wl.r.propType && (zl.length ? Ll.rotateZ(-Wl.r.v * zl[2]) : Ll.rotateZ(-Wl.r.v * zl)),
                            Wl.ry.propType && (zl.length ? Ll.rotateY(Wl.ry.v * zl[1]) : Ll.rotateY(Wl.ry.v * zl)),
                            Wl.rx.propType && (zl.length ? Ll.rotateX(Wl.rx.v * zl[0]) : Ll.rotateX(Wl.rx.v * zl)),
                            Wl.o.propType && (zl.length ? Lu += (Wl.o.v * zl[0] - Lu) * zl[0] : Lu += (Wl.o.v * zl - Lu) * zl),
                            xt.strokeWidthAnim && Wl.sw.propType && (zl.length ? Du += Wl.sw.v * zl[0] : Du += Wl.sw.v * zl),
                            xt.strokeColorAnim && Wl.sc.propType)
                                for (fu = 0; fu < 3; fu += 1)
                                    zl.length ? Au[fu] += (Wl.sc.v[fu] - Au[fu]) * zl[0] : Au[fu] += (Wl.sc.v[fu] - Au[fu]) * zl;
                            if (xt.fillColorAnim && xt.fc) {
                                if (Wl.fc.propType)
                                    for (fu = 0; fu < 3; fu += 1)
                                        zl.length ? Qu[fu] += (Wl.fc.v[fu] - Qu[fu]) * zl[0] : Qu[fu] += (Wl.fc.v[fu] - Qu[fu]) * zl;
                                Wl.fh.propType && (Qu = zl.length ? addHueToRGB(Qu, Wl.fh.v * zl[0]) : addHueToRGB(Qu, Wl.fh.v * zl)),
                                Wl.fs.propType && (Qu = zl.length ? addSaturationToRGB(Qu, Wl.fs.v * zl[0]) : addSaturationToRGB(Qu, Wl.fs.v * zl)),
                                Wl.fb.propType && (Qu = zl.length ? addBrightnessToRGB(Qu, Wl.fb.v * zl[0]) : addBrightnessToRGB(Qu, Wl.fb.v * zl))
                            }
                        }
                        for (Ql = 0; Ql < cu; Ql += 1)
                            (Wl = Ml[Ql].a).p.propType && (zl = Ml[Ql].s.getMult(Dl[Cs].anIndexes[Ql], Nl.a[Ql].s.totalChars),
                            this._hasMaskedPath ? zl.length ? Ll.translate(0, Wl.p.v[1] * zl[0], -Wl.p.v[2] * zl[1]) : Ll.translate(0, Wl.p.v[1] * zl, -Wl.p.v[2] * zl) : zl.length ? Ll.translate(Wl.p.v[0] * zl[0], Wl.p.v[1] * zl[1], -Wl.p.v[2] * zl[2]) : Ll.translate(Wl.p.v[0] * zl, Wl.p.v[1] * zl, -Wl.p.v[2] * zl));
                        if (xt.strokeWidthAnim && (yu = Du < 0 ? 0 : Du),
                        xt.strokeColorAnim && (vu = "rgb(" + Math.round(255 * Au[0]) + "," + Math.round(255 * Au[1]) + "," + Math.round(255 * Au[2]) + ")"),
                        xt.fillColorAnim && xt.fc && (_u = "rgb(" + Math.round(255 * Qu[0]) + "," + Math.round(255 * Qu[1]) + "," + Math.round(255 * Qu[2]) + ")"),
                        this._hasMaskedPath) {
                            if (Ll.translate(0, -xt.ls),
                            Ll.translate(0, Il[1] * Yl * .01 + cs, 0),
                            this._pathData.p.v) {
                                Tl = (Xs.point[1] - wl.point[1]) / (Xs.point[0] - wl.point[0]);
                                var Kl = 180 * Math.atan(Tl) / Math.PI;
                                Xs.point[0] < wl.point[0] && (Kl += 180),
                                Ll.rotate(-Kl * Math.PI / 180)
                            }
                            Ll.translate(Cu, ju, 0),
                            Ws -= Il[0] * Dl[Cs].an * .005,
                            Dl[Cs + 1] && Ru !== Dl[Cs + 1].ind && (Ws += Dl[Cs].an / 2,
                            Ws += .001 * xt.tr * xt.finalSize)
                        } else {
                            switch (Ll.translate(as, cs, 0),
                            xt.ps && Ll.translate(xt.ps[0], xt.ps[1] + xt.ascent, 0),
                            xt.j) {
                            case 1:
                                Ll.translate(Dl[Cs].animatorJustifyOffset + xt.justifyOffset + (xt.boxWidth - xt.lineWidths[Dl[Cs].line]), 0, 0);
                                break;
                            case 2:
                                Ll.translate(Dl[Cs].animatorJustifyOffset + xt.justifyOffset + (xt.boxWidth - xt.lineWidths[Dl[Cs].line]) / 2, 0, 0)
                            }
                            Ll.translate(0, -xt.ls),
                            Ll.translate(mu, 0, 0),
                            Ll.translate(Il[0] * Dl[Cs].an * .005, Il[1] * Yl * .01, 0),
                            as += Dl[Cs].l + .001 * xt.tr * xt.finalSize
                        }
                        Fl === "html" ? qu = Ll.toCSS() : Fl === "svg" ? qu = Ll.to2dCSS() : hp = [Ll.props[0], Ll.props[1], Ll.props[2], Ll.props[3], Ll.props[4], Ll.props[5], Ll.props[6], Ll.props[7], Ll.props[8], Ll.props[9], Ll.props[10], Ll.props[11], Ll.props[12], Ll.props[13], Ll.props[14], Ll.props[15]],
                        xu = Lu
                    }
                    Ul <= Cs ? (pu = new LetterProps(xu,yu,vu,_u,qu,hp),
                    this.renderedLetters.push(pu),
                    Ul += 1,
                    this.lettersChangedFlag = !0) : (pu = this.renderedLetters[Cs],
                    this.lettersChangedFlag = pu.update(xu, yu, vu, _u, qu, hp) || this.lettersChangedFlag)
                }
            }
        }
        ,
        TextAnimatorProperty.prototype.getValue = function() {
            this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId,
            this.iterateDynamicProperties())
        }
        ,
        TextAnimatorProperty.prototype.mHelper = new Matrix,
        TextAnimatorProperty.prototype.defaultPropsArray = [],
        extendPrototype([DynamicPropertyContainer], TextAnimatorProperty),
        ITextElement.prototype.initElement = function(xt, Cn, as) {
            this.lettersChangedFlag = !0,
            this.initFrame(),
            this.initBaseData(xt, Cn, as),
            this.textProperty = new TextProperty(this,xt.t,this.dynamicProperties),
            this.textAnimator = new TextAnimatorProperty(xt.t,this.renderType,this),
            this.initTransform(xt, Cn, as),
            this.initHierarchy(),
            this.initRenderable(),
            this.initRendererElement(),
            this.createContainerElements(),
            this.createRenderableComponents(),
            this.createContent(),
            this.hide(),
            this.textAnimator.searchProperties(this.dynamicProperties)
        }
        ,
        ITextElement.prototype.prepareFrame = function(xt) {
            this._mdf = !1,
            this.prepareRenderableFrame(xt),
            this.prepareProperties(xt, this.isInRange)
        }
        ,
        ITextElement.prototype.createPathShape = function(xt, Cn) {
            var as, cs, Cs = Cn.length, Ls = "";
            for (as = 0; as < Cs; as += 1)
                Cn[as].ty === "sh" && (cs = Cn[as].ks.k,
                Ls += buildShapeString(cs, cs.i.length, !0, xt));
            return Ls
        }
        ,
        ITextElement.prototype.updateDocumentData = function(xt, Cn) {
            this.textProperty.updateDocumentData(xt, Cn)
        }
        ,
        ITextElement.prototype.canResizeFont = function(xt) {
            this.textProperty.canResizeFont(xt)
        }
        ,
        ITextElement.prototype.setMinimumFontSize = function(xt) {
            this.textProperty.setMinimumFontSize(xt)
        }
        ,
        ITextElement.prototype.applyTextPropertiesToMatrix = function(xt, Cn, as, cs, Cs) {
            switch (xt.ps && Cn.translate(xt.ps[0], xt.ps[1] + xt.ascent, 0),
            Cn.translate(0, -xt.ls, 0),
            xt.j) {
            case 1:
                Cn.translate(xt.justifyOffset + (xt.boxWidth - xt.lineWidths[as]), 0, 0);
                break;
            case 2:
                Cn.translate(xt.justifyOffset + (xt.boxWidth - xt.lineWidths[as]) / 2, 0, 0)
            }
            Cn.translate(cs, Cs, 0)
        }
        ,
        ITextElement.prototype.buildColor = function(xt) {
            return "rgb(" + Math.round(255 * xt[0]) + "," + Math.round(255 * xt[1]) + "," + Math.round(255 * xt[2]) + ")"
        }
        ,
        ITextElement.prototype.emptyProp = new LetterProps,
        ITextElement.prototype.destroy = function() {}
        ,
        ITextElement.prototype.validateText = function() {
            (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(),
            this.textProperty._isFirstFrame = !1,
            this.textProperty._mdf = !1)
        }
        ;
        var emptyShapeData = {
            shapes: []
        };
        function SVGTextLottieElement(xt, Cn, as) {
            this.textSpans = [],
            this.renderType = "svg",
            this.initElement(xt, Cn, as)
        }
        function ISolidElement(xt, Cn, as) {
            this.initElement(xt, Cn, as)
        }
        function NullElement(xt, Cn, as) {
            this.initFrame(),
            this.initBaseData(xt, Cn, as),
            this.initFrame(),
            this.initTransform(xt, Cn, as),
            this.initHierarchy()
        }
        function SVGRendererBase() {}
        function ICompElement() {}
        function SVGCompElement(xt, Cn, as) {
            this.layers = xt.layers,
            this.supports3d = !0,
            this.completeLayers = !1,
            this.pendingElements = [],
            this.elements = this.layers ? createSizedArray(this.layers.length) : [],
            this.initElement(xt, Cn, as),
            this.tm = xt.tm ? PropertyFactory.getProp(this, xt.tm, 0, Cn.frameRate, this) : {
                _placeholder: !0
            }
        }
        function SVGRenderer(xt, Cn) {
            this.animationItem = xt,
            this.layers = null,
            this.renderedFrame = -1,
            this.svgElement = createNS("svg");
            var as = "";
            if (Cn && Cn.title) {
                var cs = createNS("title")
                  , Cs = createElementID();
                cs.setAttribute("id", Cs),
                cs.textContent = Cn.title,
                this.svgElement.appendChild(cs),
                as += Cs
            }
            if (Cn && Cn.description) {
                var Ls = createNS("desc")
                  , Vs = createElementID();
                Ls.setAttribute("id", Vs),
                Ls.textContent = Cn.description,
                this.svgElement.appendChild(Ls),
                as += " " + Vs
            }
            as && this.svgElement.setAttribute("aria-labelledby", as);
            var Ws = createNS("defs");
            this.svgElement.appendChild(Ws);
            var Xs = createNS("g");
            this.svgElement.appendChild(Xs),
            this.layerElement = Xs,
            this.renderConfig = {
                preserveAspectRatio: Cn && Cn.preserveAspectRatio || "xMidYMid meet",
                imagePreserveAspectRatio: Cn && Cn.imagePreserveAspectRatio || "xMidYMid slice",
                contentVisibility: Cn && Cn.contentVisibility || "visible",
                progressiveLoad: Cn && Cn.progressiveLoad || !1,
                hideOnTransparent: !(Cn && Cn.hideOnTransparent === !1),
                viewBoxOnly: Cn && Cn.viewBoxOnly || !1,
                viewBoxSize: Cn && Cn.viewBoxSize || !1,
                className: Cn && Cn.className || "",
                id: Cn && Cn.id || "",
                focusable: Cn && Cn.focusable,
                filterSize: {
                    width: Cn && Cn.filterSize && Cn.filterSize.width || "100%",
                    height: Cn && Cn.filterSize && Cn.filterSize.height || "100%",
                    x: Cn && Cn.filterSize && Cn.filterSize.x || "0%",
                    y: Cn && Cn.filterSize && Cn.filterSize.y || "0%"
                },
                width: Cn && Cn.width,
                height: Cn && Cn.height,
                runExpressions: !Cn || Cn.runExpressions === void 0 || Cn.runExpressions
            },
            this.globalData = {
                _mdf: !1,
                frameNum: -1,
                defs: Ws,
                renderConfig: this.renderConfig
            },
            this.elements = [],
            this.pendingElements = [],
            this.destroyed = !1,
            this.rendererType = "svg"
        }
        function ShapeTransformManager() {
            this.sequences = {},
            this.sequenceList = [],
            this.transform_key_count = 0
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement),
        SVGTextLottieElement.prototype.createContent = function() {
            this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text"))
        }
        ,
        SVGTextLottieElement.prototype.buildTextContents = function(xt) {
            for (var Cn = 0, as = xt.length, cs = [], Cs = ""; Cn < as; )
                xt[Cn] === "\r" || xt[Cn] === "" ? (cs.push(Cs),
                Cs = "") : Cs += xt[Cn],
                Cn += 1;
            return cs.push(Cs),
            cs
        }
        ,
        SVGTextLottieElement.prototype.buildShapeData = function(xt, Cn) {
            if (xt.shapes && xt.shapes.length) {
                var as = xt.shapes[0];
                if (as.it) {
                    var cs = as.it[as.it.length - 1];
                    cs.s && (cs.s.k[0] = Cn,
                    cs.s.k[1] = Cn)
                }
            }
            return xt
        }
        ,
        SVGTextLottieElement.prototype.buildNewText = function() {
            var xt, Cn;
            this.addDynamicProperty(this);
            var as = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(as ? as.l.length : 0),
            as.fc ? this.layerElement.setAttribute("fill", this.buildColor(as.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"),
            as.sc && (this.layerElement.setAttribute("stroke", this.buildColor(as.sc)),
            this.layerElement.setAttribute("stroke-width", as.sw)),
            this.layerElement.setAttribute("font-size", as.finalSize);
            var cs = this.globalData.fontManager.getFontByName(as.f);
            if (cs.fClass)
                this.layerElement.setAttribute("class", cs.fClass);
            else {
                this.layerElement.setAttribute("font-family", cs.fFamily);
                var Cs = as.fWeight
                  , Ls = as.fStyle;
                this.layerElement.setAttribute("font-style", Ls),
                this.layerElement.setAttribute("font-weight", Cs)
            }
            this.layerElement.setAttribute("aria-label", as.t);
            var Vs, Ws = as.l || [], Xs = !!this.globalData.fontManager.chars;
            Cn = Ws.length;
            var ga = this.mHelper
              , ba = this.data.singleShape
              , yl = 0
              , xl = 0
              , wl = !0
              , _l = .001 * as.tr * as.finalSize;
            if (!ba || Xs || as.sz) {
                var El, Cl = this.textSpans.length;
                for (xt = 0; xt < Cn; xt += 1) {
                    if (this.textSpans[xt] || (this.textSpans[xt] = {
                        span: null,
                        childSpan: null,
                        glyph: null
                    }),
                    !Xs || !ba || xt === 0) {
                        if (Vs = Cl > xt ? this.textSpans[xt].span : createNS(Xs ? "g" : "text"),
                        Cl <= xt) {
                            if (Vs.setAttribute("stroke-linecap", "butt"),
                            Vs.setAttribute("stroke-linejoin", "round"),
                            Vs.setAttribute("stroke-miterlimit", "4"),
                            this.textSpans[xt].span = Vs,
                            Xs) {
                                var $l = createNS("g");
                                Vs.appendChild($l),
                                this.textSpans[xt].childSpan = $l
                            }
                            this.textSpans[xt].span = Vs,
                            this.layerElement.appendChild(Vs)
                        }
                        Vs.style.display = "inherit"
                    }
                    if (ga.reset(),
                    ba && (Ws[xt].n && (yl = -_l,
                    xl += as.yOffset,
                    xl += wl ? 1 : 0,
                    wl = !1),
                    this.applyTextPropertiesToMatrix(as, ga, Ws[xt].line, yl, xl),
                    yl += Ws[xt].l || 0,
                    yl += _l),
                    Xs) {
                        var Sl;
                        if ((El = this.globalData.fontManager.getCharData(as.finalText[xt], cs.fStyle, this.globalData.fontManager.getFontByName(as.f).fFamily)).t === 1)
                            Sl = new SVGCompElement(El.data,this.globalData,this);
                        else {
                            var Tl = emptyShapeData;
                            El.data && El.data.shapes && (Tl = this.buildShapeData(El.data, as.finalSize)),
                            Sl = new SVGShapeElement(Tl,this.globalData,this)
                        }
                        if (this.textSpans[xt].glyph) {
                            var Rl = this.textSpans[xt].glyph;
                            this.textSpans[xt].childSpan.removeChild(Rl.layerElement),
                            Rl.destroy()
                        }
                        this.textSpans[xt].glyph = Sl,
                        Sl._debug = !0,
                        Sl.prepareFrame(0),
                        Sl.renderFrame(),
                        this.textSpans[xt].childSpan.appendChild(Sl.layerElement),
                        El.t === 1 && this.textSpans[xt].childSpan.setAttribute("transform", "scale(" + as.finalSize / 100 + "," + as.finalSize / 100 + ")")
                    } else
                        ba && Vs.setAttribute("transform", "translate(" + ga.props[12] + "," + ga.props[13] + ")"),
                        Vs.textContent = Ws[xt].val,
                        Vs.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve")
                }
                ba && Vs && Vs.setAttribute("d", "")
            } else {
                var Il = this.textContainer
                  , Ml = "start";
                switch (as.j) {
                case 1:
                    Ml = "end";
                    break;
                case 2:
                    Ml = "middle";
                    break;
                default:
                    Ml = "start"
                }
                Il.setAttribute("text-anchor", Ml),
                Il.setAttribute("letter-spacing", _l);
                var Nl = this.buildTextContents(as.finalText);
                for (Cn = Nl.length,
                xl = as.ps ? as.ps[1] + as.ascent : 0,
                xt = 0; xt < Cn; xt += 1)
                    (Vs = this.textSpans[xt].span || createNS("tspan")).textContent = Nl[xt],
                    Vs.setAttribute("x", 0),
                    Vs.setAttribute("y", xl),
                    Vs.style.display = "inherit",
                    Il.appendChild(Vs),
                    this.textSpans[xt] || (this.textSpans[xt] = {
                        span: null,
                        glyph: null
                    }),
                    this.textSpans[xt].span = Vs,
                    xl += as.finalLineHeight;
                this.layerElement.appendChild(Il)
            }
            for (; xt < this.textSpans.length; )
                this.textSpans[xt].span.style.display = "none",
                xt += 1;
            this._sizeChanged = !0
        }
        ,
        SVGTextLottieElement.prototype.sourceRectAtTime = function() {
            if (this.prepareFrame(this.comp.renderedFrame - this.data.st),
            this.renderInnerContent(),
            this._sizeChanged) {
                this._sizeChanged = !1;
                var xt = this.layerElement.getBBox();
                this.bbox = {
                    top: xt.y,
                    left: xt.x,
                    width: xt.width,
                    height: xt.height
                }
            }
            return this.bbox
        }
        ,
        SVGTextLottieElement.prototype.getValue = function() {
            var xt, Cn, as = this.textSpans.length;
            for (this.renderedFrame = this.comp.renderedFrame,
            xt = 0; xt < as; xt += 1)
                (Cn = this.textSpans[xt].glyph) && (Cn.prepareFrame(this.comp.renderedFrame - this.data.st),
                Cn._mdf && (this._mdf = !0))
        }
        ,
        SVGTextLottieElement.prototype.renderInnerContent = function() {
            if (this.validateText(),
            (!this.data.singleShape || this._mdf) && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag),
            this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) {
                var xt, Cn;
                this._sizeChanged = !0;
                var as, cs, Cs, Ls = this.textAnimator.renderedLetters, Vs = this.textProperty.currentData.l;
                for (Cn = Vs.length,
                xt = 0; xt < Cn; xt += 1)
                    Vs[xt].n || (as = Ls[xt],
                    cs = this.textSpans[xt].span,
                    (Cs = this.textSpans[xt].glyph) && Cs.renderFrame(),
                    as._mdf.m && cs.setAttribute("transform", as.m),
                    as._mdf.o && cs.setAttribute("opacity", as.o),
                    as._mdf.sw && cs.setAttribute("stroke-width", as.sw),
                    as._mdf.sc && cs.setAttribute("stroke", as.sc),
                    as._mdf.fc && cs.setAttribute("fill", as.fc))
            }
        }
        ,
        extendPrototype([IImageElement], ISolidElement),
        ISolidElement.prototype.createContent = function() {
            var xt = createNS("rect");
            xt.setAttribute("width", this.data.sw),
            xt.setAttribute("height", this.data.sh),
            xt.setAttribute("fill", this.data.sc),
            this.layerElement.appendChild(xt)
        }
        ,
        NullElement.prototype.prepareFrame = function(xt) {
            this.prepareProperties(xt, !0)
        }
        ,
        NullElement.prototype.renderFrame = function() {}
        ,
        NullElement.prototype.getBaseElement = function() {
            return null
        }
        ,
        NullElement.prototype.destroy = function() {}
        ,
        NullElement.prototype.sourceRectAtTime = function() {}
        ,
        NullElement.prototype.hide = function() {}
        ,
        extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement),
        extendPrototype([BaseRenderer], SVGRendererBase),
        SVGRendererBase.prototype.createNull = function(xt) {
            return new NullElement(xt,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.createShape = function(xt) {
            return new SVGShapeElement(xt,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.createText = function(xt) {
            return new SVGTextLottieElement(xt,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.createImage = function(xt) {
            return new IImageElement(xt,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.createSolid = function(xt) {
            return new ISolidElement(xt,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.configAnimation = function(xt) {
            this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"),
            this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"),
            this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + xt.w + " " + xt.h),
            this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", xt.w),
            this.svgElement.setAttribute("height", xt.h),
            this.svgElement.style.width = "100%",
            this.svgElement.style.height = "100%",
            this.svgElement.style.transform = "translate3d(0,0,0)",
            this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility),
            this.renderConfig.width && this.svgElement.setAttribute("width", this.renderConfig.width),
            this.renderConfig.height && this.svgElement.setAttribute("height", this.renderConfig.height),
            this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className),
            this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id),
            this.renderConfig.focusable !== void 0 && this.svgElement.setAttribute("focusable", this.renderConfig.focusable),
            this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio),
            this.animationItem.wrapper.appendChild(this.svgElement);
            var Cn = this.globalData.defs;
            this.setupGlobalData(xt, Cn),
            this.globalData.progressiveLoad = this.renderConfig.progressiveLoad,
            this.data = xt;
            var as = createNS("clipPath")
              , cs = createNS("rect");
            cs.setAttribute("width", xt.w),
            cs.setAttribute("height", xt.h),
            cs.setAttribute("x", 0),
            cs.setAttribute("y", 0);
            var Cs = createElementID();
            as.setAttribute("id", Cs),
            as.appendChild(cs),
            this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + Cs + ")"),
            Cn.appendChild(as),
            this.layers = xt.layers,
            this.elements = createSizedArray(xt.layers.length)
        }
        ,
        SVGRendererBase.prototype.destroy = function() {
            var xt;
            this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""),
            this.layerElement = null,
            this.globalData.defs = null;
            var Cn = this.layers ? this.layers.length : 0;
            for (xt = 0; xt < Cn; xt += 1)
                this.elements[xt] && this.elements[xt].destroy && this.elements[xt].destroy();
            this.elements.length = 0,
            this.destroyed = !0,
            this.animationItem = null
        }
        ,
        SVGRendererBase.prototype.updateContainerSize = function() {}
        ,
        SVGRendererBase.prototype.findIndexByInd = function(xt) {
            var Cn = 0
              , as = this.layers.length;
            for (Cn = 0; Cn < as; Cn += 1)
                if (this.layers[Cn].ind === xt)
                    return Cn;
            return -1
        }
        ,
        SVGRendererBase.prototype.buildItem = function(xt) {
            var Cn = this.elements;
            if (!Cn[xt] && this.layers[xt].ty !== 99) {
                Cn[xt] = !0;
                var as = this.createItem(this.layers[xt]);
                if (Cn[xt] = as,
                getExpressionsPlugin() && (this.layers[xt].ty === 0 && this.globalData.projectInterface.registerComposition(as),
                as.initExpressions()),
                this.appendElementInPos(as, xt),
                this.layers[xt].tt) {
                    var cs = "tp"in this.layers[xt] ? this.findIndexByInd(this.layers[xt].tp) : xt - 1;
                    if (cs === -1)
                        return;
                    if (this.elements[cs] && this.elements[cs] !== !0) {
                        var Cs = Cn[cs].getMatte(this.layers[xt].tt);
                        as.setMatte(Cs)
                    } else
                        this.buildItem(cs),
                        this.addPendingElement(as)
                }
            }
        }
        ,
        SVGRendererBase.prototype.checkPendingElements = function() {
            for (; this.pendingElements.length; ) {
                var xt = this.pendingElements.pop();
                if (xt.checkParenting(),
                xt.data.tt)
                    for (var Cn = 0, as = this.elements.length; Cn < as; ) {
                        if (this.elements[Cn] === xt) {
                            var cs = "tp"in xt.data ? this.findIndexByInd(xt.data.tp) : Cn - 1
                              , Cs = this.elements[cs].getMatte(this.layers[Cn].tt);
                            xt.setMatte(Cs);
                            break
                        }
                        Cn += 1
                    }
            }
        }
        ,
        SVGRendererBase.prototype.renderFrame = function(xt) {
            if (this.renderedFrame !== xt && !this.destroyed) {
                var Cn;
                xt === null ? xt = this.renderedFrame : this.renderedFrame = xt,
                this.globalData.frameNum = xt,
                this.globalData.frameId += 1,
                this.globalData.projectInterface.currentFrame = xt,
                this.globalData._mdf = !1;
                var as = this.layers.length;
                for (this.completeLayers || this.checkLayers(xt),
                Cn = as - 1; Cn >= 0; Cn -= 1)
                    (this.completeLayers || this.elements[Cn]) && this.elements[Cn].prepareFrame(xt - this.layers[Cn].st);
                if (this.globalData._mdf)
                    for (Cn = 0; Cn < as; Cn += 1)
                        (this.completeLayers || this.elements[Cn]) && this.elements[Cn].renderFrame()
            }
        }
        ,
        SVGRendererBase.prototype.appendElementInPos = function(xt, Cn) {
            var as = xt.getBaseElement();
            if (as) {
                for (var cs, Cs = 0; Cs < Cn; )
                    this.elements[Cs] && this.elements[Cs] !== !0 && this.elements[Cs].getBaseElement() && (cs = this.elements[Cs].getBaseElement()),
                    Cs += 1;
                cs ? this.layerElement.insertBefore(as, cs) : this.layerElement.appendChild(as)
            }
        }
        ,
        SVGRendererBase.prototype.hide = function() {
            this.layerElement.style.display = "none"
        }
        ,
        SVGRendererBase.prototype.show = function() {
            this.layerElement.style.display = "block"
        }
        ,
        extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement),
        ICompElement.prototype.initElement = function(xt, Cn, as) {
            this.initFrame(),
            this.initBaseData(xt, Cn, as),
            this.initTransform(xt, Cn, as),
            this.initRenderable(),
            this.initHierarchy(),
            this.initRendererElement(),
            this.createContainerElements(),
            this.createRenderableComponents(),
            !this.data.xt && Cn.progressiveLoad || this.buildAllItems(),
            this.hide()
        }
        ,
        ICompElement.prototype.prepareFrame = function(xt) {
            if (this._mdf = !1,
            this.prepareRenderableFrame(xt),
            this.prepareProperties(xt, this.isInRange),
            this.isInRange || this.data.xt) {
                if (this.tm._placeholder)
                    this.renderedFrame = xt / this.data.sr;
                else {
                    var Cn = this.tm.v;
                    Cn === this.data.op && (Cn = this.data.op - 1),
                    this.renderedFrame = Cn
                }
                var as, cs = this.elements.length;
                for (this.completeLayers || this.checkLayers(this.renderedFrame),
                as = cs - 1; as >= 0; as -= 1)
                    (this.completeLayers || this.elements[as]) && (this.elements[as].prepareFrame(this.renderedFrame - this.layers[as].st),
                    this.elements[as]._mdf && (this._mdf = !0))
            }
        }
        ,
        ICompElement.prototype.renderInnerContent = function() {
            var xt, Cn = this.layers.length;
            for (xt = 0; xt < Cn; xt += 1)
                (this.completeLayers || this.elements[xt]) && this.elements[xt].renderFrame()
        }
        ,
        ICompElement.prototype.setElements = function(xt) {
            this.elements = xt
        }
        ,
        ICompElement.prototype.getElements = function() {
            return this.elements
        }
        ,
        ICompElement.prototype.destroyElements = function() {
            var xt, Cn = this.layers.length;
            for (xt = 0; xt < Cn; xt += 1)
                this.elements[xt] && this.elements[xt].destroy()
        }
        ,
        ICompElement.prototype.destroy = function() {
            this.destroyElements(),
            this.destroyBaseElement()
        }
        ,
        extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement),
        SVGCompElement.prototype.createComp = function(xt) {
            return new SVGCompElement(xt,this.globalData,this)
        }
        ,
        extendPrototype([SVGRendererBase], SVGRenderer),
        SVGRenderer.prototype.createComp = function(xt) {
            return new SVGCompElement(xt,this.globalData,this)
        }
        ,
        ShapeTransformManager.prototype = {
            addTransformSequence: function(xt) {
                var Cn, as = xt.length, cs = "_";
                for (Cn = 0; Cn < as; Cn += 1)
                    cs += xt[Cn].transform.key + "_";
                var Cs = this.sequences[cs];
                return Cs || (Cs = {
                    transforms: [].concat(xt),
                    finalTransform: new Matrix,
                    _mdf: !1
                },
                this.sequences[cs] = Cs,
                this.sequenceList.push(Cs)),
                Cs
            },
            processSequence: function(xt, Cn) {
                for (var as = 0, cs = xt.transforms.length, Cs = Cn; as < cs && !Cn; ) {
                    if (xt.transforms[as].transform.mProps._mdf) {
                        Cs = !0;
                        break
                    }
                    as += 1
                }
                if (Cs)
                    for (xt.finalTransform.reset(),
                    as = cs - 1; as >= 0; as -= 1)
                        xt.finalTransform.multiply(xt.transforms[as].transform.mProps.v);
                xt._mdf = Cs
            },
            processSequences: function(xt) {
                var Cn, as = this.sequenceList.length;
                for (Cn = 0; Cn < as; Cn += 1)
                    this.processSequence(this.sequenceList[Cn], xt)
            },
            getNewKey: function() {
                return this.transform_key_count += 1,
                "_" + this.transform_key_count
            }
        };
        var lumaLoader = function() {
            var xt = "__lottie_element_luma_buffer"
              , Cn = null
              , as = null
              , cs = null;
            function Cs() {
                var Ls, Vs, Ws;
                Cn || (Ls = createNS("svg"),
                Vs = createNS("filter"),
                Ws = createNS("feColorMatrix"),
                Vs.setAttribute("id", xt),
                Ws.setAttribute("type", "matrix"),
                Ws.setAttribute("color-interpolation-filters", "sRGB"),
                Ws.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"),
                Vs.appendChild(Ws),
                Ls.appendChild(Vs),
                Ls.setAttribute("id", xt + "_svg"),
                featureSupport.svgLumaHidden && (Ls.style.display = "none"),
                cs = Ls,
                document.body.appendChild(cs),
                Cn = createTag("canvas"),
                (as = Cn.getContext("2d")).filter = "url(#" + xt + ")",
                as.fillStyle = "rgba(0,0,0,0)",
                as.fillRect(0, 0, 1, 1))
            }
            return {
                load: Cs,
                get: function(Ls) {
                    return Cn || Cs(),
                    Cn.width = Ls.width,
                    Cn.height = Ls.height,
                    as.filter = "url(#" + xt + ")",
                    Cn
                }
            }
        };
        function createCanvas(xt, Cn) {
            if (featureSupport.offscreenCanvas)
                return new OffscreenCanvas(xt,Cn);
            var as = createTag("canvas");
            return as.width = xt,
            as.height = Cn,
            as
        }
        var assetLoader = {
            loadLumaCanvas: lumaLoader.load,
            getLumaCanvas: lumaLoader.get,
            createCanvas
        }
          , registeredEffects = {};
        function CVEffects(xt) {
            var Cn, as, cs = xt.data.ef ? xt.data.ef.length : 0;
            for (this.filters = [],
            Cn = 0; Cn < cs; Cn += 1) {
                as = null;
                var Cs = xt.data.ef[Cn].ty;
                registeredEffects[Cs] && (as = new registeredEffects[Cs].effect(xt.effectsManager.effectElements[Cn],xt)),
                as && this.filters.push(as)
            }
            this.filters.length && xt.addRenderableComponent(this)
        }
        function registerEffect(xt, Cn) {
            registeredEffects[xt] = {
                effect: Cn
            }
        }
        function CVMaskElement(xt, Cn) {
            var as;
            this.data = xt,
            this.element = Cn,
            this.masksProperties = this.data.masksProperties || [],
            this.viewData = createSizedArray(this.masksProperties.length);
            var cs = this.masksProperties.length
              , Cs = !1;
            for (as = 0; as < cs; as += 1)
                this.masksProperties[as].mode !== "n" && (Cs = !0),
                this.viewData[as] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[as], 3);
            this.hasMasks = Cs,
            Cs && this.element.addRenderableComponent(this)
        }
        function CVBaseElement() {}
        CVEffects.prototype.renderFrame = function(xt) {
            var Cn, as = this.filters.length;
            for (Cn = 0; Cn < as; Cn += 1)
                this.filters[Cn].renderFrame(xt)
        }
        ,
        CVEffects.prototype.getEffects = function(xt) {
            var Cn, as = this.filters.length, cs = [];
            for (Cn = 0; Cn < as; Cn += 1)
                this.filters[Cn].type === xt && cs.push(this.filters[Cn]);
            return cs
        }
        ,
        CVMaskElement.prototype.renderFrame = function() {
            if (this.hasMasks) {
                var xt, Cn, as, cs, Cs = this.element.finalTransform.mat, Ls = this.element.canvasContext, Vs = this.masksProperties.length;
                for (Ls.beginPath(),
                xt = 0; xt < Vs; xt += 1)
                    if (this.masksProperties[xt].mode !== "n") {
                        var Ws;
                        this.masksProperties[xt].inv && (Ls.moveTo(0, 0),
                        Ls.lineTo(this.element.globalData.compSize.w, 0),
                        Ls.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h),
                        Ls.lineTo(0, this.element.globalData.compSize.h),
                        Ls.lineTo(0, 0)),
                        cs = this.viewData[xt].v,
                        Cn = Cs.applyToPointArray(cs.v[0][0], cs.v[0][1], 0),
                        Ls.moveTo(Cn[0], Cn[1]);
                        var Xs = cs._length;
                        for (Ws = 1; Ws < Xs; Ws += 1)
                            as = Cs.applyToTriplePoints(cs.o[Ws - 1], cs.i[Ws], cs.v[Ws]),
                            Ls.bezierCurveTo(as[0], as[1], as[2], as[3], as[4], as[5]);
                        as = Cs.applyToTriplePoints(cs.o[Ws - 1], cs.i[0], cs.v[0]),
                        Ls.bezierCurveTo(as[0], as[1], as[2], as[3], as[4], as[5])
                    }
                this.element.globalData.renderer.save(!0),
                Ls.clip()
            }
        }
        ,
        CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty,
        CVMaskElement.prototype.destroy = function() {
            this.element = null
        }
        ;
        var operationsMap = {
            1: "source-in",
            2: "source-out",
            3: "source-in",
            4: "source-out"
        };
        function CVShapeData(xt, Cn, as, cs) {
            this.styledShapes = [],
            this.tr = [0, 0, 0, 0, 0, 0];
            var Cs, Ls = 4;
            Cn.ty === "rc" ? Ls = 5 : Cn.ty === "el" ? Ls = 6 : Cn.ty === "sr" && (Ls = 7),
            this.sh = ShapePropertyFactory.getShapeProp(xt, Cn, Ls, xt);
            var Vs, Ws = as.length;
            for (Cs = 0; Cs < Ws; Cs += 1)
                as[Cs].closed || (Vs = {
                    transforms: cs.addTransformSequence(as[Cs].transforms),
                    trNodes: []
                },
                this.styledShapes.push(Vs),
                as[Cs].elements.push(Vs))
        }
        function CVShapeElement(xt, Cn, as) {
            this.shapes = [],
            this.shapesData = xt.shapes,
            this.stylesList = [],
            this.itemsData = [],
            this.prevViewData = [],
            this.shapeModifiers = [],
            this.processedElements = [],
            this.transformsManager = new ShapeTransformManager,
            this.initElement(xt, Cn, as)
        }
        function CVTextElement(xt, Cn, as) {
            this.textSpans = [],
            this.yOffset = 0,
            this.fillColorAnim = !1,
            this.strokeColorAnim = !1,
            this.strokeWidthAnim = !1,
            this.stroke = !1,
            this.fill = !1,
            this.justifyOffset = 0,
            this.currentRender = null,
            this.renderType = "canvas",
            this.values = {
                fill: "rgba(0,0,0,0)",
                stroke: "rgba(0,0,0,0)",
                sWidth: 0,
                fValue: ""
            },
            this.initElement(xt, Cn, as)
        }
        function CVImageElement(xt, Cn, as) {
            this.assetData = Cn.getAssetData(xt.refId),
            this.img = Cn.imageLoader.getAsset(this.assetData),
            this.initElement(xt, Cn, as)
        }
        function CVSolidElement(xt, Cn, as) {
            this.initElement(xt, Cn, as)
        }
        function CanvasRendererBase() {}
        function CanvasContext() {
            this.opacity = -1,
            this.transform = createTypedArray("float32", 16),
            this.fillStyle = "",
            this.strokeStyle = "",
            this.lineWidth = "",
            this.lineCap = "",
            this.lineJoin = "",
            this.miterLimit = "",
            this.id = Math.random()
        }
        function CVContextData() {
            var xt;
            for (this.stack = [],
            this.cArrPos = 0,
            this.cTr = new Matrix,
            xt = 0; xt < 15; xt += 1) {
                var Cn = new CanvasContext;
                this.stack[xt] = Cn
            }
            this._length = 15,
            this.nativeContext = null,
            this.transformMat = new Matrix,
            this.currentOpacity = 1,
            this.currentFillStyle = "",
            this.appliedFillStyle = "",
            this.currentStrokeStyle = "",
            this.appliedStrokeStyle = "",
            this.currentLineWidth = "",
            this.appliedLineWidth = "",
            this.currentLineCap = "",
            this.appliedLineCap = "",
            this.currentLineJoin = "",
            this.appliedLineJoin = "",
            this.appliedMiterLimit = "",
            this.currentMiterLimit = ""
        }
        function CVCompElement(xt, Cn, as) {
            this.completeLayers = !1,
            this.layers = xt.layers,
            this.pendingElements = [],
            this.elements = createSizedArray(this.layers.length),
            this.initElement(xt, Cn, as),
            this.tm = xt.tm ? PropertyFactory.getProp(this, xt.tm, 0, Cn.frameRate, this) : {
                _placeholder: !0
            }
        }
        function CanvasRenderer(xt, Cn) {
            this.animationItem = xt,
            this.renderConfig = {
                clearCanvas: !Cn || Cn.clearCanvas === void 0 || Cn.clearCanvas,
                context: Cn && Cn.context || null,
                progressiveLoad: Cn && Cn.progressiveLoad || !1,
                preserveAspectRatio: Cn && Cn.preserveAspectRatio || "xMidYMid meet",
                imagePreserveAspectRatio: Cn && Cn.imagePreserveAspectRatio || "xMidYMid slice",
                contentVisibility: Cn && Cn.contentVisibility || "visible",
                className: Cn && Cn.className || "",
                id: Cn && Cn.id || "",
                runExpressions: !Cn || Cn.runExpressions === void 0 || Cn.runExpressions
            },
            this.renderConfig.dpr = Cn && Cn.dpr || 1,
            this.animationItem.wrapper && (this.renderConfig.dpr = Cn && Cn.dpr || window.devicePixelRatio || 1),
            this.renderedFrame = -1,
            this.globalData = {
                frameNum: -1,
                _mdf: !1,
                renderConfig: this.renderConfig,
                currentGlobalAlpha: -1
            },
            this.contextData = new CVContextData,
            this.elements = [],
            this.pendingElements = [],
            this.transformMat = new Matrix,
            this.completeLayers = !1,
            this.rendererType = "canvas",
            this.renderConfig.clearCanvas && (this.ctxTransform = this.contextData.transform.bind(this.contextData),
            this.ctxOpacity = this.contextData.opacity.bind(this.contextData),
            this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData),
            this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData),
            this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData),
            this.ctxLineCap = this.contextData.lineCap.bind(this.contextData),
            this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData),
            this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData),
            this.ctxFill = this.contextData.fill.bind(this.contextData),
            this.ctxFillRect = this.contextData.fillRect.bind(this.contextData),
            this.ctxStroke = this.contextData.stroke.bind(this.contextData),
            this.save = this.contextData.save.bind(this.contextData))
        }
        function HBaseElement() {}
        function HSolidElement(xt, Cn, as) {
            this.initElement(xt, Cn, as)
        }
        function HShapeElement(xt, Cn, as) {
            this.shapes = [],
            this.shapesData = xt.shapes,
            this.stylesList = [],
            this.shapeModifiers = [],
            this.itemsData = [],
            this.processedElements = [],
            this.animatedContents = [],
            this.shapesContainer = createNS("g"),
            this.initElement(xt, Cn, as),
            this.prevViewData = [],
            this.currentBBox = {
                x: 999999,
                y: -999999,
                h: 0,
                w: 0
            }
        }
        function HTextElement(xt, Cn, as) {
            this.textSpans = [],
            this.textPaths = [],
            this.currentBBox = {
                x: 999999,
                y: -999999,
                h: 0,
                w: 0
            },
            this.renderType = "svg",
            this.isMasked = !1,
            this.initElement(xt, Cn, as)
        }
        function HCameraElement(xt, Cn, as) {
            this.initFrame(),
            this.initBaseData(xt, Cn, as),
            this.initHierarchy();
            var cs = PropertyFactory.getProp;
            if (this.pe = cs(this, xt.pe, 0, 0, this),
            xt.ks.p.s ? (this.px = cs(this, xt.ks.p.x, 1, 0, this),
            this.py = cs(this, xt.ks.p.y, 1, 0, this),
            this.pz = cs(this, xt.ks.p.z, 1, 0, this)) : this.p = cs(this, xt.ks.p, 1, 0, this),
            xt.ks.a && (this.a = cs(this, xt.ks.a, 1, 0, this)),
            xt.ks.or.k.length && xt.ks.or.k[0].to) {
                var Cs, Ls = xt.ks.or.k.length;
                for (Cs = 0; Cs < Ls; Cs += 1)
                    xt.ks.or.k[Cs].to = null,
                    xt.ks.or.k[Cs].ti = null
            }
            this.or = cs(this, xt.ks.or, 1, degToRads, this),
            this.or.sh = !0,
            this.rx = cs(this, xt.ks.rx, 0, degToRads, this),
            this.ry = cs(this, xt.ks.ry, 0, degToRads, this),
            this.rz = cs(this, xt.ks.rz, 0, degToRads, this),
            this.mat = new Matrix,
            this._prevMat = new Matrix,
            this._isFirstFrame = !0,
            this.finalTransform = {
                mProp: this
            }
        }
        function HImageElement(xt, Cn, as) {
            this.assetData = Cn.getAssetData(xt.refId),
            this.initElement(xt, Cn, as)
        }
        function HybridRendererBase(xt, Cn) {
            this.animationItem = xt,
            this.layers = null,
            this.renderedFrame = -1,
            this.renderConfig = {
                className: Cn && Cn.className || "",
                imagePreserveAspectRatio: Cn && Cn.imagePreserveAspectRatio || "xMidYMid slice",
                hideOnTransparent: !(Cn && Cn.hideOnTransparent === !1),
                filterSize: {
                    width: Cn && Cn.filterSize && Cn.filterSize.width || "400%",
                    height: Cn && Cn.filterSize && Cn.filterSize.height || "400%",
                    x: Cn && Cn.filterSize && Cn.filterSize.x || "-100%",
                    y: Cn && Cn.filterSize && Cn.filterSize.y || "-100%"
                }
            },
            this.globalData = {
                _mdf: !1,
                frameNum: -1,
                renderConfig: this.renderConfig
            },
            this.pendingElements = [],
            this.elements = [],
            this.threeDElements = [],
            this.destroyed = !1,
            this.camera = null,
            this.supports3d = !0,
            this.rendererType = "html"
        }
        function HCompElement(xt, Cn, as) {
            this.layers = xt.layers,
            this.supports3d = !xt.hasMask,
            this.completeLayers = !1,
            this.pendingElements = [],
            this.elements = this.layers ? createSizedArray(this.layers.length) : [],
            this.initElement(xt, Cn, as),
            this.tm = xt.tm ? PropertyFactory.getProp(this, xt.tm, 0, Cn.frameRate, this) : {
                _placeholder: !0
            }
        }
        function HybridRenderer(xt, Cn) {
            this.animationItem = xt,
            this.layers = null,
            this.renderedFrame = -1,
            this.renderConfig = {
                className: Cn && Cn.className || "",
                imagePreserveAspectRatio: Cn && Cn.imagePreserveAspectRatio || "xMidYMid slice",
                hideOnTransparent: !(Cn && Cn.hideOnTransparent === !1),
                filterSize: {
                    width: Cn && Cn.filterSize && Cn.filterSize.width || "400%",
                    height: Cn && Cn.filterSize && Cn.filterSize.height || "400%",
                    x: Cn && Cn.filterSize && Cn.filterSize.x || "-100%",
                    y: Cn && Cn.filterSize && Cn.filterSize.y || "-100%"
                },
                runExpressions: !Cn || Cn.runExpressions === void 0 || Cn.runExpressions
            },
            this.globalData = {
                _mdf: !1,
                frameNum: -1,
                renderConfig: this.renderConfig
            },
            this.pendingElements = [],
            this.elements = [],
            this.threeDElements = [],
            this.destroyed = !1,
            this.camera = null,
            this.supports3d = !0,
            this.rendererType = "html"
        }
        CVBaseElement.prototype = {
            createElements: function() {},
            initRendererElement: function() {},
            createContainerElements: function() {
                if (this.data.tt >= 1) {
                    this.buffers = [];
                    var xt = this.globalData.canvasContext
                      , Cn = assetLoader.createCanvas(xt.canvas.width, xt.canvas.height);
                    this.buffers.push(Cn);
                    var as = assetLoader.createCanvas(xt.canvas.width, xt.canvas.height);
                    this.buffers.push(as),
                    this.data.tt >= 3 && !document._isProxy && assetLoader.loadLumaCanvas()
                }
                this.canvasContext = this.globalData.canvasContext,
                this.transformCanvas = this.globalData.transformCanvas,
                this.renderableEffectsManager = new CVEffects(this),
                this.searchEffectTransforms()
            },
            createContent: function() {},
            setBlendMode: function() {
                var xt = this.globalData;
                if (xt.blendMode !== this.data.bm) {
                    xt.blendMode = this.data.bm;
                    var Cn = getBlendMode(this.data.bm);
                    xt.canvasContext.globalCompositeOperation = Cn
                }
            },
            createRenderableComponents: function() {
                this.maskManager = new CVMaskElement(this.data,this),
                this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT)
            },
            hideElement: function() {
                this.hidden || this.isInRange && !this.isTransparent || (this.hidden = !0)
            },
            showElement: function() {
                this.isInRange && !this.isTransparent && (this.hidden = !1,
                this._isFirstFrame = !0,
                this.maskManager._isFirstFrame = !0)
            },
            clearCanvas: function(xt) {
                xt.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy)
            },
            prepareLayer: function() {
                if (this.data.tt >= 1) {
                    var xt = this.buffers[0].getContext("2d");
                    this.clearCanvas(xt),
                    xt.drawImage(this.canvasContext.canvas, 0, 0),
                    this.currentTransform = this.canvasContext.getTransform(),
                    this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
                    this.clearCanvas(this.canvasContext),
                    this.canvasContext.setTransform(this.currentTransform)
                }
            },
            exitLayer: function() {
                if (this.data.tt >= 1) {
                    var xt = this.buffers[1]
                      , Cn = xt.getContext("2d");
                    if (this.clearCanvas(Cn),
                    Cn.drawImage(this.canvasContext.canvas, 0, 0),
                    this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
                    this.clearCanvas(this.canvasContext),
                    this.canvasContext.setTransform(this.currentTransform),
                    this.comp.getElementById("tp"in this.data ? this.data.tp : this.data.ind - 1).renderFrame(!0),
                    this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
                    this.data.tt >= 3 && !document._isProxy) {
                        var as = assetLoader.getLumaCanvas(this.canvasContext.canvas);
                        as.getContext("2d").drawImage(this.canvasContext.canvas, 0, 0),
                        this.clearCanvas(this.canvasContext),
                        this.canvasContext.drawImage(as, 0, 0)
                    }
                    this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt],
                    this.canvasContext.drawImage(xt, 0, 0),
                    this.canvasContext.globalCompositeOperation = "destination-over",
                    this.canvasContext.drawImage(this.buffers[0], 0, 0),
                    this.canvasContext.setTransform(this.currentTransform),
                    this.canvasContext.globalCompositeOperation = "source-over"
                }
            },
            renderFrame: function(xt) {
                if (!this.hidden && !this.data.hd && (this.data.td !== 1 || xt)) {
                    this.renderTransform(),
                    this.renderRenderable(),
                    this.renderLocalTransform(),
                    this.setBlendMode();
                    var Cn = this.data.ty === 0;
                    this.prepareLayer(),
                    this.globalData.renderer.save(Cn),
                    this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props),
                    this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity),
                    this.renderInnerContent(),
                    this.globalData.renderer.restore(Cn),
                    this.exitLayer(),
                    this.maskManager.hasMasks && this.globalData.renderer.restore(!0),
                    this._isFirstFrame && (this._isFirstFrame = !1)
                }
            },
            destroy: function() {
                this.canvasContext = null,
                this.data = null,
                this.globalData = null,
                this.maskManager.destroy()
            },
            mHelper: new Matrix
        },
        CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement,
        CVBaseElement.prototype.show = CVBaseElement.prototype.showElement,
        CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated,
        extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement),
        CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement,
        CVShapeElement.prototype.transformHelper = {
            opacity: 1,
            _opMdf: !1
        },
        CVShapeElement.prototype.dashResetter = [],
        CVShapeElement.prototype.createContent = function() {
            this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, [])
        }
        ,
        CVShapeElement.prototype.createStyleElement = function(xt, Cn) {
            var as = {
                data: xt,
                type: xt.ty,
                preTransforms: this.transformsManager.addTransformSequence(Cn),
                transforms: [],
                elements: [],
                closed: xt.hd === !0
            }
              , cs = {};
            if (xt.ty === "fl" || xt.ty === "st" ? (cs.c = PropertyFactory.getProp(this, xt.c, 1, 255, this),
            cs.c.k || (as.co = "rgb(" + bmFloor(cs.c.v[0]) + "," + bmFloor(cs.c.v[1]) + "," + bmFloor(cs.c.v[2]) + ")")) : xt.ty !== "gf" && xt.ty !== "gs" || (cs.s = PropertyFactory.getProp(this, xt.s, 1, null, this),
            cs.e = PropertyFactory.getProp(this, xt.e, 1, null, this),
            cs.h = PropertyFactory.getProp(this, xt.h || {
                k: 0
            }, 0, .01, this),
            cs.a = PropertyFactory.getProp(this, xt.a || {
                k: 0
            }, 0, degToRads, this),
            cs.g = new GradientProperty(this,xt.g,this)),
            cs.o = PropertyFactory.getProp(this, xt.o, 0, .01, this),
            xt.ty === "st" || xt.ty === "gs") {
                if (as.lc = lineCapEnum[xt.lc || 2],
                as.lj = lineJoinEnum[xt.lj || 2],
                xt.lj == 1 && (as.ml = xt.ml),
                cs.w = PropertyFactory.getProp(this, xt.w, 0, null, this),
                cs.w.k || (as.wi = cs.w.v),
                xt.d) {
                    var Cs = new DashProperty(this,xt.d,"canvas",this);
                    cs.d = Cs,
                    cs.d.k || (as.da = cs.d.dashArray,
                    as.do = cs.d.dashoffset[0])
                }
            } else
                as.r = xt.r === 2 ? "evenodd" : "nonzero";
            return this.stylesList.push(as),
            cs.style = as,
            cs
        }
        ,
        CVShapeElement.prototype.createGroupElement = function() {
            return {
                it: [],
                prevViewData: []
            }
        }
        ,
        CVShapeElement.prototype.createTransformElement = function(xt) {
            return {
                transform: {
                    opacity: 1,
                    _opMdf: !1,
                    key: this.transformsManager.getNewKey(),
                    op: PropertyFactory.getProp(this, xt.o, 0, .01, this),
                    mProps: TransformPropertyFactory.getTransformProperty(this, xt, this)
                }
            }
        }
        ,
        CVShapeElement.prototype.createShapeElement = function(xt) {
            var Cn = new CVShapeData(this,xt,this.stylesList,this.transformsManager);
            return this.shapes.push(Cn),
            this.addShapeToModifiers(Cn),
            Cn
        }
        ,
        CVShapeElement.prototype.reloadShapes = function() {
            var xt;
            this._isFirstFrame = !0;
            var Cn = this.itemsData.length;
            for (xt = 0; xt < Cn; xt += 1)
                this.prevViewData[xt] = this.itemsData[xt];
            for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []),
            Cn = this.dynamicProperties.length,
            xt = 0; xt < Cn; xt += 1)
                this.dynamicProperties[xt].getValue();
            this.renderModifiers(),
            this.transformsManager.processSequences(this._isFirstFrame)
        }
        ,
        CVShapeElement.prototype.addTransformToStyleList = function(xt) {
            var Cn, as = this.stylesList.length;
            for (Cn = 0; Cn < as; Cn += 1)
                this.stylesList[Cn].closed || this.stylesList[Cn].transforms.push(xt)
        }
        ,
        CVShapeElement.prototype.removeTransformFromStyleList = function() {
            var xt, Cn = this.stylesList.length;
            for (xt = 0; xt < Cn; xt += 1)
                this.stylesList[xt].closed || this.stylesList[xt].transforms.pop()
        }
        ,
        CVShapeElement.prototype.closeStyles = function(xt) {
            var Cn, as = xt.length;
            for (Cn = 0; Cn < as; Cn += 1)
                xt[Cn].closed = !0
        }
        ,
        CVShapeElement.prototype.searchShapes = function(xt, Cn, as, cs, Cs) {
            var Ls, Vs, Ws, Xs, ga, ba, yl = xt.length - 1, xl = [], wl = [], _l = [].concat(Cs);
            for (Ls = yl; Ls >= 0; Ls -= 1) {
                if ((Xs = this.searchProcessedElement(xt[Ls])) ? Cn[Ls] = as[Xs - 1] : xt[Ls]._shouldRender = cs,
                xt[Ls].ty === "fl" || xt[Ls].ty === "st" || xt[Ls].ty === "gf" || xt[Ls].ty === "gs")
                    Xs ? Cn[Ls].style.closed = !1 : Cn[Ls] = this.createStyleElement(xt[Ls], _l),
                    xl.push(Cn[Ls].style);
                else if (xt[Ls].ty === "gr") {
                    if (Xs)
                        for (Ws = Cn[Ls].it.length,
                        Vs = 0; Vs < Ws; Vs += 1)
                            Cn[Ls].prevViewData[Vs] = Cn[Ls].it[Vs];
                    else
                        Cn[Ls] = this.createGroupElement(xt[Ls]);
                    this.searchShapes(xt[Ls].it, Cn[Ls].it, Cn[Ls].prevViewData, cs, _l)
                } else
                    xt[Ls].ty === "tr" ? (Xs || (ba = this.createTransformElement(xt[Ls]),
                    Cn[Ls] = ba),
                    _l.push(Cn[Ls]),
                    this.addTransformToStyleList(Cn[Ls])) : xt[Ls].ty === "sh" || xt[Ls].ty === "rc" || xt[Ls].ty === "el" || xt[Ls].ty === "sr" ? Xs || (Cn[Ls] = this.createShapeElement(xt[Ls])) : xt[Ls].ty === "tm" || xt[Ls].ty === "rd" || xt[Ls].ty === "pb" || xt[Ls].ty === "zz" || xt[Ls].ty === "op" ? (Xs ? (ga = Cn[Ls]).closed = !1 : ((ga = ShapeModifiers.getModifier(xt[Ls].ty)).init(this, xt[Ls]),
                    Cn[Ls] = ga,
                    this.shapeModifiers.push(ga)),
                    wl.push(ga)) : xt[Ls].ty === "rp" && (Xs ? (ga = Cn[Ls]).closed = !0 : (ga = ShapeModifiers.getModifier(xt[Ls].ty),
                    Cn[Ls] = ga,
                    ga.init(this, xt, Ls, Cn),
                    this.shapeModifiers.push(ga),
                    cs = !1),
                    wl.push(ga));
                this.addProcessedElement(xt[Ls], Ls + 1)
            }
            for (this.removeTransformFromStyleList(),
            this.closeStyles(xl),
            yl = wl.length,
            Ls = 0; Ls < yl; Ls += 1)
                wl[Ls].closed = !0
        }
        ,
        CVShapeElement.prototype.renderInnerContent = function() {
            this.transformHelper.opacity = 1,
            this.transformHelper._opMdf = !1,
            this.renderModifiers(),
            this.transformsManager.processSequences(this._isFirstFrame),
            this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0)
        }
        ,
        CVShapeElement.prototype.renderShapeTransform = function(xt, Cn) {
            (xt._opMdf || Cn.op._mdf || this._isFirstFrame) && (Cn.opacity = xt.opacity,
            Cn.opacity *= Cn.op.v,
            Cn._opMdf = !0)
        }
        ,
        CVShapeElement.prototype.drawLayer = function() {
            var xt, Cn, as, cs, Cs, Ls, Vs, Ws, Xs, ga = this.stylesList.length, ba = this.globalData.renderer, yl = this.globalData.canvasContext;
            for (xt = 0; xt < ga; xt += 1)
                if (((Ws = (Xs = this.stylesList[xt]).type) !== "st" && Ws !== "gs" || Xs.wi !== 0) && Xs.data._shouldRender && Xs.coOp !== 0 && this.globalData.currentGlobalAlpha !== 0) {
                    for (ba.save(),
                    Ls = Xs.elements,
                    Ws === "st" || Ws === "gs" ? (ba.ctxStrokeStyle(Ws === "st" ? Xs.co : Xs.grd),
                    ba.ctxLineWidth(Xs.wi),
                    ba.ctxLineCap(Xs.lc),
                    ba.ctxLineJoin(Xs.lj),
                    ba.ctxMiterLimit(Xs.ml || 0)) : ba.ctxFillStyle(Ws === "fl" ? Xs.co : Xs.grd),
                    ba.ctxOpacity(Xs.coOp),
                    Ws !== "st" && Ws !== "gs" && yl.beginPath(),
                    ba.ctxTransform(Xs.preTransforms.finalTransform.props),
                    as = Ls.length,
                    Cn = 0; Cn < as; Cn += 1) {
                        for (Ws !== "st" && Ws !== "gs" || (yl.beginPath(),
                        Xs.da && (yl.setLineDash(Xs.da),
                        yl.lineDashOffset = Xs.do)),
                        Cs = (Vs = Ls[Cn].trNodes).length,
                        cs = 0; cs < Cs; cs += 1)
                            Vs[cs].t === "m" ? yl.moveTo(Vs[cs].p[0], Vs[cs].p[1]) : Vs[cs].t === "c" ? yl.bezierCurveTo(Vs[cs].pts[0], Vs[cs].pts[1], Vs[cs].pts[2], Vs[cs].pts[3], Vs[cs].pts[4], Vs[cs].pts[5]) : yl.closePath();
                        Ws !== "st" && Ws !== "gs" || (ba.ctxStroke(),
                        Xs.da && yl.setLineDash(this.dashResetter))
                    }
                    Ws !== "st" && Ws !== "gs" && this.globalData.renderer.ctxFill(Xs.r),
                    ba.restore()
                }
        }
        ,
        CVShapeElement.prototype.renderShape = function(xt, Cn, as, cs) {
            var Cs, Ls;
            for (Ls = xt,
            Cs = Cn.length - 1; Cs >= 0; Cs -= 1)
                Cn[Cs].ty === "tr" ? (Ls = as[Cs].transform,
                this.renderShapeTransform(xt, Ls)) : Cn[Cs].ty === "sh" || Cn[Cs].ty === "el" || Cn[Cs].ty === "rc" || Cn[Cs].ty === "sr" ? this.renderPath(Cn[Cs], as[Cs]) : Cn[Cs].ty === "fl" ? this.renderFill(Cn[Cs], as[Cs], Ls) : Cn[Cs].ty === "st" ? this.renderStroke(Cn[Cs], as[Cs], Ls) : Cn[Cs].ty === "gf" || Cn[Cs].ty === "gs" ? this.renderGradientFill(Cn[Cs], as[Cs], Ls) : Cn[Cs].ty === "gr" ? this.renderShape(Ls, Cn[Cs].it, as[Cs].it) : Cn[Cs].ty;
            cs && this.drawLayer()
        }
        ,
        CVShapeElement.prototype.renderStyledShape = function(xt, Cn) {
            if (this._isFirstFrame || Cn._mdf || xt.transforms._mdf) {
                var as, cs, Cs, Ls = xt.trNodes, Vs = Cn.paths, Ws = Vs._length;
                Ls.length = 0;
                var Xs = xt.transforms.finalTransform;
                for (Cs = 0; Cs < Ws; Cs += 1) {
                    var ga = Vs.shapes[Cs];
                    if (ga && ga.v) {
                        for (cs = ga._length,
                        as = 1; as < cs; as += 1)
                            as === 1 && Ls.push({
                                t: "m",
                                p: Xs.applyToPointArray(ga.v[0][0], ga.v[0][1], 0)
                            }),
                            Ls.push({
                                t: "c",
                                pts: Xs.applyToTriplePoints(ga.o[as - 1], ga.i[as], ga.v[as])
                            });
                        cs === 1 && Ls.push({
                            t: "m",
                            p: Xs.applyToPointArray(ga.v[0][0], ga.v[0][1], 0)
                        }),
                        ga.c && cs && (Ls.push({
                            t: "c",
                            pts: Xs.applyToTriplePoints(ga.o[as - 1], ga.i[0], ga.v[0])
                        }),
                        Ls.push({
                            t: "z"
                        }))
                    }
                }
                xt.trNodes = Ls
            }
        }
        ,
        CVShapeElement.prototype.renderPath = function(xt, Cn) {
            if (xt.hd !== !0 && xt._shouldRender) {
                var as, cs = Cn.styledShapes.length;
                for (as = 0; as < cs; as += 1)
                    this.renderStyledShape(Cn.styledShapes[as], Cn.sh)
            }
        }
        ,
        CVShapeElement.prototype.renderFill = function(xt, Cn, as) {
            var cs = Cn.style;
            (Cn.c._mdf || this._isFirstFrame) && (cs.co = "rgb(" + bmFloor(Cn.c.v[0]) + "," + bmFloor(Cn.c.v[1]) + "," + bmFloor(Cn.c.v[2]) + ")"),
            (Cn.o._mdf || as._opMdf || this._isFirstFrame) && (cs.coOp = Cn.o.v * as.opacity)
        }
        ,
        CVShapeElement.prototype.renderGradientFill = function(xt, Cn, as) {
            var cs, Cs = Cn.style;
            if (!Cs.grd || Cn.g._mdf || Cn.s._mdf || Cn.e._mdf || xt.t !== 1 && (Cn.h._mdf || Cn.a._mdf)) {
                var Ls, Vs = this.globalData.canvasContext, Ws = Cn.s.v, Xs = Cn.e.v;
                if (xt.t === 1)
                    cs = Vs.createLinearGradient(Ws[0], Ws[1], Xs[0], Xs[1]);
                else {
                    var ga = Math.sqrt(Math.pow(Ws[0] - Xs[0], 2) + Math.pow(Ws[1] - Xs[1], 2))
                      , ba = Math.atan2(Xs[1] - Ws[1], Xs[0] - Ws[0])
                      , yl = Cn.h.v;
                    yl >= 1 ? yl = .99 : yl <= -1 && (yl = -.99);
                    var xl = ga * yl
                      , wl = Math.cos(ba + Cn.a.v) * xl + Ws[0]
                      , _l = Math.sin(ba + Cn.a.v) * xl + Ws[1];
                    cs = Vs.createRadialGradient(wl, _l, 0, Ws[0], Ws[1], ga)
                }
                var El = xt.g.p
                  , Cl = Cn.g.c
                  , $l = 1;
                for (Ls = 0; Ls < El; Ls += 1)
                    Cn.g._hasOpacity && Cn.g._collapsable && ($l = Cn.g.o[2 * Ls + 1]),
                    cs.addColorStop(Cl[4 * Ls] / 100, "rgba(" + Cl[4 * Ls + 1] + "," + Cl[4 * Ls + 2] + "," + Cl[4 * Ls + 3] + "," + $l + ")");
                Cs.grd = cs
            }
            Cs.coOp = Cn.o.v * as.opacity
        }
        ,
        CVShapeElement.prototype.renderStroke = function(xt, Cn, as) {
            var cs = Cn.style
              , Cs = Cn.d;
            Cs && (Cs._mdf || this._isFirstFrame) && (cs.da = Cs.dashArray,
            cs.do = Cs.dashoffset[0]),
            (Cn.c._mdf || this._isFirstFrame) && (cs.co = "rgb(" + bmFloor(Cn.c.v[0]) + "," + bmFloor(Cn.c.v[1]) + "," + bmFloor(Cn.c.v[2]) + ")"),
            (Cn.o._mdf || as._opMdf || this._isFirstFrame) && (cs.coOp = Cn.o.v * as.opacity),
            (Cn.w._mdf || this._isFirstFrame) && (cs.wi = Cn.w.v)
        }
        ,
        CVShapeElement.prototype.destroy = function() {
            this.shapesData = null,
            this.globalData = null,
            this.canvasContext = null,
            this.stylesList.length = 0,
            this.itemsData.length = 0
        }
        ,
        extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement),
        CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"),
        CVTextElement.prototype.buildNewText = function() {
            var xt = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(xt.l ? xt.l.length : 0);
            var Cn = !1;
            xt.fc ? (Cn = !0,
            this.values.fill = this.buildColor(xt.fc)) : this.values.fill = "rgba(0,0,0,0)",
            this.fill = Cn;
            var as = !1;
            xt.sc && (as = !0,
            this.values.stroke = this.buildColor(xt.sc),
            this.values.sWidth = xt.sw);
            var cs, Cs, Ls, Vs, Ws, Xs, ga, ba, yl, xl, wl, _l, El = this.globalData.fontManager.getFontByName(xt.f), Cl = xt.l, $l = this.mHelper;
            this.stroke = as,
            this.values.fValue = xt.finalSize + "px " + this.globalData.fontManager.getFontByName(xt.f).fFamily,
            Cs = xt.finalText.length;
            var Sl = this.data.singleShape
              , Tl = .001 * xt.tr * xt.finalSize
              , Rl = 0
              , Il = 0
              , Ml = !0
              , Nl = 0;
            for (cs = 0; cs < Cs; cs += 1) {
                Vs = (Ls = this.globalData.fontManager.getCharData(xt.finalText[cs], El.fStyle, this.globalData.fontManager.getFontByName(xt.f).fFamily)) && Ls.data || {},
                $l.reset(),
                Sl && Cl[cs].n && (Rl = -Tl,
                Il += xt.yOffset,
                Il += Ml ? 1 : 0,
                Ml = !1),
                yl = (ga = Vs.shapes ? Vs.shapes[0].it : []).length,
                $l.scale(xt.finalSize / 100, xt.finalSize / 100),
                Sl && this.applyTextPropertiesToMatrix(xt, $l, Cl[cs].line, Rl, Il),
                wl = createSizedArray(yl - 1);
                var Ll = 0;
                for (ba = 0; ba < yl; ba += 1)
                    if (ga[ba].ty === "sh") {
                        for (Xs = ga[ba].ks.k.i.length,
                        xl = ga[ba].ks.k,
                        _l = [],
                        Ws = 1; Ws < Xs; Ws += 1)
                            Ws === 1 && _l.push($l.applyToX(xl.v[0][0], xl.v[0][1], 0), $l.applyToY(xl.v[0][0], xl.v[0][1], 0)),
                            _l.push($l.applyToX(xl.o[Ws - 1][0], xl.o[Ws - 1][1], 0), $l.applyToY(xl.o[Ws - 1][0], xl.o[Ws - 1][1], 0), $l.applyToX(xl.i[Ws][0], xl.i[Ws][1], 0), $l.applyToY(xl.i[Ws][0], xl.i[Ws][1], 0), $l.applyToX(xl.v[Ws][0], xl.v[Ws][1], 0), $l.applyToY(xl.v[Ws][0], xl.v[Ws][1], 0));
                        _l.push($l.applyToX(xl.o[Ws - 1][0], xl.o[Ws - 1][1], 0), $l.applyToY(xl.o[Ws - 1][0], xl.o[Ws - 1][1], 0), $l.applyToX(xl.i[0][0], xl.i[0][1], 0), $l.applyToY(xl.i[0][0], xl.i[0][1], 0), $l.applyToX(xl.v[0][0], xl.v[0][1], 0), $l.applyToY(xl.v[0][0], xl.v[0][1], 0)),
                        wl[Ll] = _l,
                        Ll += 1
                    }
                Sl && (Rl += Cl[cs].l,
                Rl += Tl),
                this.textSpans[Nl] ? this.textSpans[Nl].elem = wl : this.textSpans[Nl] = {
                    elem: wl
                },
                Nl += 1
            }
        }
        ,
        CVTextElement.prototype.renderInnerContent = function() {
            var xt, Cn, as, cs, Cs, Ls;
            this.validateText(),
            this.canvasContext.font = this.values.fValue,
            this.globalData.renderer.ctxLineCap("butt"),
            this.globalData.renderer.ctxLineJoin("miter"),
            this.globalData.renderer.ctxMiterLimit(4),
            this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
            var Vs, Ws = this.textAnimator.renderedLetters, Xs = this.textProperty.currentData.l;
            Cn = Xs.length;
            var ga, ba, yl = null, xl = null, wl = null, _l = this.globalData.renderer;
            for (xt = 0; xt < Cn; xt += 1)
                if (!Xs[xt].n) {
                    if ((Vs = Ws[xt]) && (_l.save(),
                    _l.ctxTransform(Vs.p),
                    _l.ctxOpacity(Vs.o)),
                    this.fill) {
                        for (Vs && Vs.fc ? yl !== Vs.fc && (_l.ctxFillStyle(Vs.fc),
                        yl = Vs.fc) : yl !== this.values.fill && (yl = this.values.fill,
                        _l.ctxFillStyle(this.values.fill)),
                        cs = (ga = this.textSpans[xt].elem).length,
                        this.globalData.canvasContext.beginPath(),
                        as = 0; as < cs; as += 1)
                            for (Ls = (ba = ga[as]).length,
                            this.globalData.canvasContext.moveTo(ba[0], ba[1]),
                            Cs = 2; Cs < Ls; Cs += 6)
                                this.globalData.canvasContext.bezierCurveTo(ba[Cs], ba[Cs + 1], ba[Cs + 2], ba[Cs + 3], ba[Cs + 4], ba[Cs + 5]);
                        this.globalData.canvasContext.closePath(),
                        _l.ctxFill()
                    }
                    if (this.stroke) {
                        for (Vs && Vs.sw ? wl !== Vs.sw && (wl = Vs.sw,
                        _l.ctxLineWidth(Vs.sw)) : wl !== this.values.sWidth && (wl = this.values.sWidth,
                        _l.ctxLineWidth(this.values.sWidth)),
                        Vs && Vs.sc ? xl !== Vs.sc && (xl = Vs.sc,
                        _l.ctxStrokeStyle(Vs.sc)) : xl !== this.values.stroke && (xl = this.values.stroke,
                        _l.ctxStrokeStyle(this.values.stroke)),
                        cs = (ga = this.textSpans[xt].elem).length,
                        this.globalData.canvasContext.beginPath(),
                        as = 0; as < cs; as += 1)
                            for (Ls = (ba = ga[as]).length,
                            this.globalData.canvasContext.moveTo(ba[0], ba[1]),
                            Cs = 2; Cs < Ls; Cs += 6)
                                this.globalData.canvasContext.bezierCurveTo(ba[Cs], ba[Cs + 1], ba[Cs + 2], ba[Cs + 3], ba[Cs + 4], ba[Cs + 5]);
                        this.globalData.canvasContext.closePath(),
                        _l.ctxStroke()
                    }
                    Vs && this.globalData.renderer.restore()
                }
        }
        ,
        extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement),
        CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement,
        CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame,
        CVImageElement.prototype.createContent = function() {
            if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
                var xt = createTag("canvas");
                xt.width = this.assetData.w,
                xt.height = this.assetData.h;
                var Cn, as, cs = xt.getContext("2d"), Cs = this.img.width, Ls = this.img.height, Vs = Cs / Ls, Ws = this.assetData.w / this.assetData.h, Xs = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
                Vs > Ws && Xs === "xMidYMid slice" || Vs < Ws && Xs !== "xMidYMid slice" ? Cn = (as = Ls) * Ws : as = (Cn = Cs) / Ws,
                cs.drawImage(this.img, (Cs - Cn) / 2, (Ls - as) / 2, Cn, as, 0, 0, this.assetData.w, this.assetData.h),
                this.img = xt
            }
        }
        ,
        CVImageElement.prototype.renderInnerContent = function() {
            this.canvasContext.drawImage(this.img, 0, 0)
        }
        ,
        CVImageElement.prototype.destroy = function() {
            this.img = null
        }
        ,
        extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement),
        CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement,
        CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame,
        CVSolidElement.prototype.renderInnerContent = function() {
            this.globalData.renderer.ctxFillStyle(this.data.sc),
            this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh)
        }
        ,
        extendPrototype([BaseRenderer], CanvasRendererBase),
        CanvasRendererBase.prototype.createShape = function(xt) {
            return new CVShapeElement(xt,this.globalData,this)
        }
        ,
        CanvasRendererBase.prototype.createText = function(xt) {
            return new CVTextElement(xt,this.globalData,this)
        }
        ,
        CanvasRendererBase.prototype.createImage = function(xt) {
            return new CVImageElement(xt,this.globalData,this)
        }
        ,
        CanvasRendererBase.prototype.createSolid = function(xt) {
            return new CVSolidElement(xt,this.globalData,this)
        }
        ,
        CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull,
        CanvasRendererBase.prototype.ctxTransform = function(xt) {
            xt[0] === 1 && xt[1] === 0 && xt[4] === 0 && xt[5] === 1 && xt[12] === 0 && xt[13] === 0 || this.canvasContext.transform(xt[0], xt[1], xt[4], xt[5], xt[12], xt[13])
        }
        ,
        CanvasRendererBase.prototype.ctxOpacity = function(xt) {
            this.canvasContext.globalAlpha *= xt < 0 ? 0 : xt
        }
        ,
        CanvasRendererBase.prototype.ctxFillStyle = function(xt) {
            this.canvasContext.fillStyle = xt
        }
        ,
        CanvasRendererBase.prototype.ctxStrokeStyle = function(xt) {
            this.canvasContext.strokeStyle = xt
        }
        ,
        CanvasRendererBase.prototype.ctxLineWidth = function(xt) {
            this.canvasContext.lineWidth = xt
        }
        ,
        CanvasRendererBase.prototype.ctxLineCap = function(xt) {
            this.canvasContext.lineCap = xt
        }
        ,
        CanvasRendererBase.prototype.ctxLineJoin = function(xt) {
            this.canvasContext.lineJoin = xt
        }
        ,
        CanvasRendererBase.prototype.ctxMiterLimit = function(xt) {
            this.canvasContext.miterLimit = xt
        }
        ,
        CanvasRendererBase.prototype.ctxFill = function(xt) {
            this.canvasContext.fill(xt)
        }
        ,
        CanvasRendererBase.prototype.ctxFillRect = function(xt, Cn, as, cs) {
            this.canvasContext.fillRect(xt, Cn, as, cs)
        }
        ,
        CanvasRendererBase.prototype.ctxStroke = function() {
            this.canvasContext.stroke()
        }
        ,
        CanvasRendererBase.prototype.reset = function() {
            this.renderConfig.clearCanvas ? this.contextData.reset() : this.canvasContext.restore()
        }
        ,
        CanvasRendererBase.prototype.save = function() {
            this.canvasContext.save()
        }
        ,
        CanvasRendererBase.prototype.restore = function(xt) {
            this.renderConfig.clearCanvas ? (xt && (this.globalData.blendMode = "source-over"),
            this.contextData.restore(xt)) : this.canvasContext.restore()
        }
        ,
        CanvasRendererBase.prototype.configAnimation = function(xt) {
            if (this.animationItem.wrapper) {
                this.animationItem.container = createTag("canvas");
                var Cn = this.animationItem.container.style;
                Cn.width = "100%",
                Cn.height = "100%";
                var as = "0px 0px 0px";
                Cn.transformOrigin = as,
                Cn.mozTransformOrigin = as,
                Cn.webkitTransformOrigin = as,
                Cn["-webkit-transform"] = as,
                Cn.contentVisibility = this.renderConfig.contentVisibility,
                this.animationItem.wrapper.appendChild(this.animationItem.container),
                this.canvasContext = this.animationItem.container.getContext("2d"),
                this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className),
                this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id)
            } else
                this.canvasContext = this.renderConfig.context;
            this.contextData.setContext(this.canvasContext),
            this.data = xt,
            this.layers = xt.layers,
            this.transformCanvas = {
                w: xt.w,
                h: xt.h,
                sx: 0,
                sy: 0,
                tx: 0,
                ty: 0
            },
            this.setupGlobalData(xt, document.body),
            this.globalData.canvasContext = this.canvasContext,
            this.globalData.renderer = this,
            this.globalData.isDashed = !1,
            this.globalData.progressiveLoad = this.renderConfig.progressiveLoad,
            this.globalData.transformCanvas = this.transformCanvas,
            this.elements = createSizedArray(xt.layers.length),
            this.updateContainerSize()
        }
        ,
        CanvasRendererBase.prototype.updateContainerSize = function(xt, Cn) {
            var as, cs, Cs, Ls;
            if (this.reset(),
            xt ? (as = xt,
            cs = Cn,
            this.canvasContext.canvas.width = as,
            this.canvasContext.canvas.height = cs) : (this.animationItem.wrapper && this.animationItem.container ? (as = this.animationItem.wrapper.offsetWidth,
            cs = this.animationItem.wrapper.offsetHeight) : (as = this.canvasContext.canvas.width,
            cs = this.canvasContext.canvas.height),
            this.canvasContext.canvas.width = as * this.renderConfig.dpr,
            this.canvasContext.canvas.height = cs * this.renderConfig.dpr),
            this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) {
                var Vs = this.renderConfig.preserveAspectRatio.split(" ")
                  , Ws = Vs[1] || "meet"
                  , Xs = Vs[0] || "xMidYMid"
                  , ga = Xs.substr(0, 4)
                  , ba = Xs.substr(4);
                Cs = as / cs,
                (Ls = this.transformCanvas.w / this.transformCanvas.h) > Cs && Ws === "meet" || Ls < Cs && Ws === "slice" ? (this.transformCanvas.sx = as / (this.transformCanvas.w / this.renderConfig.dpr),
                this.transformCanvas.sy = as / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = cs / (this.transformCanvas.h / this.renderConfig.dpr),
                this.transformCanvas.sy = cs / (this.transformCanvas.h / this.renderConfig.dpr)),
                this.transformCanvas.tx = ga === "xMid" && (Ls < Cs && Ws === "meet" || Ls > Cs && Ws === "slice") ? (as - this.transformCanvas.w * (cs / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : ga === "xMax" && (Ls < Cs && Ws === "meet" || Ls > Cs && Ws === "slice") ? (as - this.transformCanvas.w * (cs / this.transformCanvas.h)) * this.renderConfig.dpr : 0,
                this.transformCanvas.ty = ba === "YMid" && (Ls > Cs && Ws === "meet" || Ls < Cs && Ws === "slice") ? (cs - this.transformCanvas.h * (as / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : ba === "YMax" && (Ls > Cs && Ws === "meet" || Ls < Cs && Ws === "slice") ? (cs - this.transformCanvas.h * (as / this.transformCanvas.w)) * this.renderConfig.dpr : 0
            } else
                this.renderConfig.preserveAspectRatio === "none" ? (this.transformCanvas.sx = as / (this.transformCanvas.w / this.renderConfig.dpr),
                this.transformCanvas.sy = cs / (this.transformCanvas.h / this.renderConfig.dpr),
                this.transformCanvas.tx = 0,
                this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr,
                this.transformCanvas.sy = this.renderConfig.dpr,
                this.transformCanvas.tx = 0,
                this.transformCanvas.ty = 0);
            this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1],
            this.ctxTransform(this.transformCanvas.props),
            this.canvasContext.beginPath(),
            this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h),
            this.canvasContext.closePath(),
            this.canvasContext.clip(),
            this.renderFrame(this.renderedFrame, !0)
        }
        ,
        CanvasRendererBase.prototype.destroy = function() {
            var xt;
            for (this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""),
            xt = (this.layers ? this.layers.length : 0) - 1; xt >= 0; xt -= 1)
                this.elements[xt] && this.elements[xt].destroy && this.elements[xt].destroy();
            this.elements.length = 0,
            this.globalData.canvasContext = null,
            this.animationItem.container = null,
            this.destroyed = !0
        }
        ,
        CanvasRendererBase.prototype.renderFrame = function(xt, Cn) {
            if ((this.renderedFrame !== xt || this.renderConfig.clearCanvas !== !0 || Cn) && !this.destroyed && xt !== -1) {
                var as;
                this.renderedFrame = xt,
                this.globalData.frameNum = xt - this.animationItem._isFirstFrame,
                this.globalData.frameId += 1,
                this.globalData._mdf = !this.renderConfig.clearCanvas || Cn,
                this.globalData.projectInterface.currentFrame = xt;
                var cs = this.layers.length;
                for (this.completeLayers || this.checkLayers(xt),
                as = cs - 1; as >= 0; as -= 1)
                    (this.completeLayers || this.elements[as]) && this.elements[as].prepareFrame(xt - this.layers[as].st);
                if (this.globalData._mdf) {
                    for (this.renderConfig.clearCanvas === !0 ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(),
                    as = cs - 1; as >= 0; as -= 1)
                        (this.completeLayers || this.elements[as]) && this.elements[as].renderFrame();
                    this.renderConfig.clearCanvas !== !0 && this.restore()
                }
            }
        }
        ,
        CanvasRendererBase.prototype.buildItem = function(xt) {
            var Cn = this.elements;
            if (!Cn[xt] && this.layers[xt].ty !== 99) {
                var as = this.createItem(this.layers[xt], this, this.globalData);
                Cn[xt] = as,
                as.initExpressions()
            }
        }
        ,
        CanvasRendererBase.prototype.checkPendingElements = function() {
            for (; this.pendingElements.length; )
                this.pendingElements.pop().checkParenting()
        }
        ,
        CanvasRendererBase.prototype.hide = function() {
            this.animationItem.container.style.display = "none"
        }
        ,
        CanvasRendererBase.prototype.show = function() {
            this.animationItem.container.style.display = "block"
        }
        ,
        CVContextData.prototype.duplicate = function() {
            var xt = 2 * this._length
              , Cn = 0;
            for (Cn = this._length; Cn < xt; Cn += 1)
                this.stack[Cn] = new CanvasContext;
            this._length = xt
        }
        ,
        CVContextData.prototype.reset = function() {
            this.cArrPos = 0,
            this.cTr.reset(),
            this.stack[this.cArrPos].opacity = 1
        }
        ,
        CVContextData.prototype.restore = function(xt) {
            this.cArrPos -= 1;
            var Cn, as = this.stack[this.cArrPos], cs = as.transform, Cs = this.cTr.props;
            for (Cn = 0; Cn < 16; Cn += 1)
                Cs[Cn] = cs[Cn];
            if (xt) {
                this.nativeContext.restore();
                var Ls = this.stack[this.cArrPos + 1];
                this.appliedFillStyle = Ls.fillStyle,
                this.appliedStrokeStyle = Ls.strokeStyle,
                this.appliedLineWidth = Ls.lineWidth,
                this.appliedLineCap = Ls.lineCap,
                this.appliedLineJoin = Ls.lineJoin,
                this.appliedMiterLimit = Ls.miterLimit
            }
            this.nativeContext.setTransform(cs[0], cs[1], cs[4], cs[5], cs[12], cs[13]),
            (xt || as.opacity !== -1 && this.currentOpacity !== as.opacity) && (this.nativeContext.globalAlpha = as.opacity,
            this.currentOpacity = as.opacity),
            this.currentFillStyle = as.fillStyle,
            this.currentStrokeStyle = as.strokeStyle,
            this.currentLineWidth = as.lineWidth,
            this.currentLineCap = as.lineCap,
            this.currentLineJoin = as.lineJoin,
            this.currentMiterLimit = as.miterLimit
        }
        ,
        CVContextData.prototype.save = function(xt) {
            xt && this.nativeContext.save();
            var Cn = this.cTr.props;
            this._length <= this.cArrPos && this.duplicate();
            var as, cs = this.stack[this.cArrPos];
            for (as = 0; as < 16; as += 1)
                cs.transform[as] = Cn[as];
            this.cArrPos += 1;
            var Cs = this.stack[this.cArrPos];
            Cs.opacity = cs.opacity,
            Cs.fillStyle = cs.fillStyle,
            Cs.strokeStyle = cs.strokeStyle,
            Cs.lineWidth = cs.lineWidth,
            Cs.lineCap = cs.lineCap,
            Cs.lineJoin = cs.lineJoin,
            Cs.miterLimit = cs.miterLimit
        }
        ,
        CVContextData.prototype.setOpacity = function(xt) {
            this.stack[this.cArrPos].opacity = xt
        }
        ,
        CVContextData.prototype.setContext = function(xt) {
            this.nativeContext = xt
        }
        ,
        CVContextData.prototype.fillStyle = function(xt) {
            this.stack[this.cArrPos].fillStyle !== xt && (this.currentFillStyle = xt,
            this.stack[this.cArrPos].fillStyle = xt)
        }
        ,
        CVContextData.prototype.strokeStyle = function(xt) {
            this.stack[this.cArrPos].strokeStyle !== xt && (this.currentStrokeStyle = xt,
            this.stack[this.cArrPos].strokeStyle = xt)
        }
        ,
        CVContextData.prototype.lineWidth = function(xt) {
            this.stack[this.cArrPos].lineWidth !== xt && (this.currentLineWidth = xt,
            this.stack[this.cArrPos].lineWidth = xt)
        }
        ,
        CVContextData.prototype.lineCap = function(xt) {
            this.stack[this.cArrPos].lineCap !== xt && (this.currentLineCap = xt,
            this.stack[this.cArrPos].lineCap = xt)
        }
        ,
        CVContextData.prototype.lineJoin = function(xt) {
            this.stack[this.cArrPos].lineJoin !== xt && (this.currentLineJoin = xt,
            this.stack[this.cArrPos].lineJoin = xt)
        }
        ,
        CVContextData.prototype.miterLimit = function(xt) {
            this.stack[this.cArrPos].miterLimit !== xt && (this.currentMiterLimit = xt,
            this.stack[this.cArrPos].miterLimit = xt)
        }
        ,
        CVContextData.prototype.transform = function(xt) {
            this.transformMat.cloneFromProps(xt);
            var Cn = this.cTr;
            this.transformMat.multiply(Cn),
            Cn.cloneFromProps(this.transformMat.props);
            var as = Cn.props;
            this.nativeContext.setTransform(as[0], as[1], as[4], as[5], as[12], as[13])
        }
        ,
        CVContextData.prototype.opacity = function(xt) {
            var Cn = this.stack[this.cArrPos].opacity;
            Cn *= xt < 0 ? 0 : xt,
            this.stack[this.cArrPos].opacity !== Cn && (this.currentOpacity !== xt && (this.nativeContext.globalAlpha = xt,
            this.currentOpacity = xt),
            this.stack[this.cArrPos].opacity = Cn)
        }
        ,
        CVContextData.prototype.fill = function(xt) {
            this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle,
            this.nativeContext.fillStyle = this.appliedFillStyle),
            this.nativeContext.fill(xt)
        }
        ,
        CVContextData.prototype.fillRect = function(xt, Cn, as, cs) {
            this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle,
            this.nativeContext.fillStyle = this.appliedFillStyle),
            this.nativeContext.fillRect(xt, Cn, as, cs)
        }
        ,
        CVContextData.prototype.stroke = function() {
            this.appliedStrokeStyle !== this.currentStrokeStyle && (this.appliedStrokeStyle = this.currentStrokeStyle,
            this.nativeContext.strokeStyle = this.appliedStrokeStyle),
            this.appliedLineWidth !== this.currentLineWidth && (this.appliedLineWidth = this.currentLineWidth,
            this.nativeContext.lineWidth = this.appliedLineWidth),
            this.appliedLineCap !== this.currentLineCap && (this.appliedLineCap = this.currentLineCap,
            this.nativeContext.lineCap = this.appliedLineCap),
            this.appliedLineJoin !== this.currentLineJoin && (this.appliedLineJoin = this.currentLineJoin,
            this.nativeContext.lineJoin = this.appliedLineJoin),
            this.appliedMiterLimit !== this.currentMiterLimit && (this.appliedMiterLimit = this.currentMiterLimit,
            this.nativeContext.miterLimit = this.appliedMiterLimit),
            this.nativeContext.stroke()
        }
        ,
        extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement),
        CVCompElement.prototype.renderInnerContent = function() {
            var xt, Cn = this.canvasContext;
            for (Cn.beginPath(),
            Cn.moveTo(0, 0),
            Cn.lineTo(this.data.w, 0),
            Cn.lineTo(this.data.w, this.data.h),
            Cn.lineTo(0, this.data.h),
            Cn.lineTo(0, 0),
            Cn.clip(),
            xt = this.layers.length - 1; xt >= 0; xt -= 1)
                (this.completeLayers || this.elements[xt]) && this.elements[xt].renderFrame()
        }
        ,
        CVCompElement.prototype.destroy = function() {
            var xt;
            for (xt = this.layers.length - 1; xt >= 0; xt -= 1)
                this.elements[xt] && this.elements[xt].destroy();
            this.layers = null,
            this.elements = null
        }
        ,
        CVCompElement.prototype.createComp = function(xt) {
            return new CVCompElement(xt,this.globalData,this)
        }
        ,
        extendPrototype([CanvasRendererBase], CanvasRenderer),
        CanvasRenderer.prototype.createComp = function(xt) {
            return new CVCompElement(xt,this.globalData,this)
        }
        ,
        HBaseElement.prototype = {
            checkBlendMode: function() {},
            initRendererElement: function() {
                this.baseElement = createTag(this.data.tg || "div"),
                this.data.hasMask ? (this.svgElement = createNS("svg"),
                this.layerElement = createNS("g"),
                this.maskedElement = this.layerElement,
                this.svgElement.appendChild(this.layerElement),
                this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement,
                styleDiv(this.baseElement)
            },
            createContainerElements: function() {
                this.renderableEffectsManager = new CVEffects(this),
                this.transformedElement = this.baseElement,
                this.maskedElement = this.layerElement,
                this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
                this.data.cl && this.layerElement.setAttribute("class", this.data.cl),
                this.data.bm !== 0 && this.setBlendMode()
            },
            renderElement: function() {
                var xt = this.transformedElement ? this.transformedElement.style : {};
                if (this.finalTransform._matMdf) {
                    var Cn = this.finalTransform.mat.toCSS();
                    xt.transform = Cn,
                    xt.webkitTransform = Cn
                }
                this.finalTransform._opMdf && (xt.opacity = this.finalTransform.mProp.o.v)
            },
            renderFrame: function() {
                this.data.hd || this.hidden || (this.renderTransform(),
                this.renderRenderable(),
                this.renderElement(),
                this.renderInnerContent(),
                this._isFirstFrame && (this._isFirstFrame = !1))
            },
            destroy: function() {
                this.layerElement = null,
                this.transformedElement = null,
                this.matteElement && (this.matteElement = null),
                this.maskManager && (this.maskManager.destroy(),
                this.maskManager = null)
            },
            createRenderableComponents: function() {
                this.maskManager = new MaskElement(this.data,this,this.globalData)
            },
            addEffects: function() {},
            setMatte: function() {}
        },
        HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement,
        HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy,
        HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting,
        extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement),
        HSolidElement.prototype.createContent = function() {
            var xt;
            this.data.hasMask ? ((xt = createNS("rect")).setAttribute("width", this.data.sw),
            xt.setAttribute("height", this.data.sh),
            xt.setAttribute("fill", this.data.sc),
            this.svgElement.setAttribute("width", this.data.sw),
            this.svgElement.setAttribute("height", this.data.sh)) : ((xt = createTag("div")).style.width = this.data.sw + "px",
            xt.style.height = this.data.sh + "px",
            xt.style.backgroundColor = this.data.sc),
            this.layerElement.appendChild(xt)
        }
        ,
        extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement),
        HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent,
        HShapeElement.prototype.createContent = function() {
            var xt;
            if (this.baseElement.style.fontSize = 0,
            this.data.hasMask)
                this.layerElement.appendChild(this.shapesContainer),
                xt = this.svgElement;
            else {
                xt = createNS("svg");
                var Cn = this.comp.data ? this.comp.data : this.globalData.compSize;
                xt.setAttribute("width", Cn.w),
                xt.setAttribute("height", Cn.h),
                xt.appendChild(this.shapesContainer),
                this.layerElement.appendChild(xt)
            }
            this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0),
            this.filterUniqueShapes(),
            this.shapeCont = xt
        }
        ,
        HShapeElement.prototype.getTransformedPoint = function(xt, Cn) {
            var as, cs = xt.length;
            for (as = 0; as < cs; as += 1)
                Cn = xt[as].mProps.v.applyToPointArray(Cn[0], Cn[1], 0);
            return Cn
        }
        ,
        HShapeElement.prototype.calculateShapeBoundingBox = function(xt, Cn) {
            var as, cs, Cs, Ls, Vs, Ws = xt.sh.v, Xs = xt.transformers, ga = Ws._length;
            if (!(ga <= 1)) {
                for (as = 0; as < ga - 1; as += 1)
                    cs = this.getTransformedPoint(Xs, Ws.v[as]),
                    Cs = this.getTransformedPoint(Xs, Ws.o[as]),
                    Ls = this.getTransformedPoint(Xs, Ws.i[as + 1]),
                    Vs = this.getTransformedPoint(Xs, Ws.v[as + 1]),
                    this.checkBounds(cs, Cs, Ls, Vs, Cn);
                Ws.c && (cs = this.getTransformedPoint(Xs, Ws.v[as]),
                Cs = this.getTransformedPoint(Xs, Ws.o[as]),
                Ls = this.getTransformedPoint(Xs, Ws.i[0]),
                Vs = this.getTransformedPoint(Xs, Ws.v[0]),
                this.checkBounds(cs, Cs, Ls, Vs, Cn))
            }
        }
        ,
        HShapeElement.prototype.checkBounds = function(xt, Cn, as, cs, Cs) {
            this.getBoundsOfCurve(xt, Cn, as, cs);
            var Ls = this.shapeBoundingBox;
            Cs.x = bmMin(Ls.left, Cs.x),
            Cs.xMax = bmMax(Ls.right, Cs.xMax),
            Cs.y = bmMin(Ls.top, Cs.y),
            Cs.yMax = bmMax(Ls.bottom, Cs.yMax)
        }
        ,
        HShapeElement.prototype.shapeBoundingBox = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        },
        HShapeElement.prototype.tempBoundingBox = {
            x: 0,
            xMax: 0,
            y: 0,
            yMax: 0,
            width: 0,
            height: 0
        },
        HShapeElement.prototype.getBoundsOfCurve = function(xt, Cn, as, cs) {
            for (var Cs, Ls, Vs, Ws, Xs, ga, ba, yl = [[xt[0], cs[0]], [xt[1], cs[1]]], xl = 0; xl < 2; ++xl)
                Ls = 6 * xt[xl] - 12 * Cn[xl] + 6 * as[xl],
                Cs = -3 * xt[xl] + 9 * Cn[xl] - 9 * as[xl] + 3 * cs[xl],
                Vs = 3 * Cn[xl] - 3 * xt[xl],
                Ls |= 0,
                Vs |= 0,
                (Cs |= 0) == 0 && Ls === 0 || (Cs === 0 ? (Ws = -Vs / Ls) > 0 && Ws < 1 && yl[xl].push(this.calculateF(Ws, xt, Cn, as, cs, xl)) : (Xs = Ls * Ls - 4 * Vs * Cs) >= 0 && ((ga = (-Ls + bmSqrt(Xs)) / (2 * Cs)) > 0 && ga < 1 && yl[xl].push(this.calculateF(ga, xt, Cn, as, cs, xl)),
                (ba = (-Ls - bmSqrt(Xs)) / (2 * Cs)) > 0 && ba < 1 && yl[xl].push(this.calculateF(ba, xt, Cn, as, cs, xl))));
            this.shapeBoundingBox.left = bmMin.apply(null, yl[0]),
            this.shapeBoundingBox.top = bmMin.apply(null, yl[1]),
            this.shapeBoundingBox.right = bmMax.apply(null, yl[0]),
            this.shapeBoundingBox.bottom = bmMax.apply(null, yl[1])
        }
        ,
        HShapeElement.prototype.calculateF = function(xt, Cn, as, cs, Cs, Ls) {
            return bmPow(1 - xt, 3) * Cn[Ls] + 3 * bmPow(1 - xt, 2) * xt * as[Ls] + 3 * (1 - xt) * bmPow(xt, 2) * cs[Ls] + bmPow(xt, 3) * Cs[Ls]
        }
        ,
        HShapeElement.prototype.calculateBoundingBox = function(xt, Cn) {
            var as, cs = xt.length;
            for (as = 0; as < cs; as += 1)
                xt[as] && xt[as].sh ? this.calculateShapeBoundingBox(xt[as], Cn) : xt[as] && xt[as].it ? this.calculateBoundingBox(xt[as].it, Cn) : xt[as] && xt[as].style && xt[as].w && this.expandStrokeBoundingBox(xt[as].w, Cn)
        }
        ,
        HShapeElement.prototype.expandStrokeBoundingBox = function(xt, Cn) {
            var as = 0;
            if (xt.keyframes) {
                for (var cs = 0; cs < xt.keyframes.length; cs += 1) {
                    var Cs = xt.keyframes[cs].s;
                    Cs > as && (as = Cs)
                }
                as *= xt.mult
            } else
                as = xt.v * xt.mult;
            Cn.x -= as,
            Cn.xMax += as,
            Cn.y -= as,
            Cn.yMax += as
        }
        ,
        HShapeElement.prototype.currentBoxContains = function(xt) {
            return this.currentBBox.x <= xt.x && this.currentBBox.y <= xt.y && this.currentBBox.width + this.currentBBox.x >= xt.x + xt.width && this.currentBBox.height + this.currentBBox.y >= xt.y + xt.height
        }
        ,
        HShapeElement.prototype.renderInnerContent = function() {
            if (this._renderShapeFrame(),
            !this.hidden && (this._isFirstFrame || this._mdf)) {
                var xt = this.tempBoundingBox
                  , Cn = 999999;
                if (xt.x = Cn,
                xt.xMax = -Cn,
                xt.y = Cn,
                xt.yMax = -Cn,
                this.calculateBoundingBox(this.itemsData, xt),
                xt.width = xt.xMax < xt.x ? 0 : xt.xMax - xt.x,
                xt.height = xt.yMax < xt.y ? 0 : xt.yMax - xt.y,
                this.currentBoxContains(xt))
                    return;
                var as = !1;
                if (this.currentBBox.w !== xt.width && (this.currentBBox.w = xt.width,
                this.shapeCont.setAttribute("width", xt.width),
                as = !0),
                this.currentBBox.h !== xt.height && (this.currentBBox.h = xt.height,
                this.shapeCont.setAttribute("height", xt.height),
                as = !0),
                as || this.currentBBox.x !== xt.x || this.currentBBox.y !== xt.y) {
                    this.currentBBox.w = xt.width,
                    this.currentBBox.h = xt.height,
                    this.currentBBox.x = xt.x,
                    this.currentBBox.y = xt.y,
                    this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
                    var cs = this.shapeCont.style
                      , Cs = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                    cs.transform = Cs,
                    cs.webkitTransform = Cs
                }
            }
        }
        ,
        extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement),
        HTextElement.prototype.createContent = function() {
            if (this.isMasked = this.checkMasks(),
            this.isMasked) {
                this.renderType = "svg",
                this.compW = this.comp.data.w,
                this.compH = this.comp.data.h,
                this.svgElement.setAttribute("width", this.compW),
                this.svgElement.setAttribute("height", this.compH);
                var xt = createNS("g");
                this.maskedElement.appendChild(xt),
                this.innerElem = xt
            } else
                this.renderType = "html",
                this.innerElem = this.layerElement;
            this.checkParenting()
        }
        ,
        HTextElement.prototype.buildNewText = function() {
            var xt = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(xt.l ? xt.l.length : 0);
            var Cn = this.innerElem.style
              , as = xt.fc ? this.buildColor(xt.fc) : "rgba(0,0,0,0)";
            Cn.fill = as,
            Cn.color = as,
            xt.sc && (Cn.stroke = this.buildColor(xt.sc),
            Cn.strokeWidth = xt.sw + "px");
            var cs, Cs, Ls = this.globalData.fontManager.getFontByName(xt.f);
            if (!this.globalData.fontManager.chars)
                if (Cn.fontSize = xt.finalSize + "px",
                Cn.lineHeight = xt.finalSize + "px",
                Ls.fClass)
                    this.innerElem.className = Ls.fClass;
                else {
                    Cn.fontFamily = Ls.fFamily;
                    var Vs = xt.fWeight
                      , Ws = xt.fStyle;
                    Cn.fontStyle = Ws,
                    Cn.fontWeight = Vs
                }
            var Xs, ga, ba, yl = xt.l;
            Cs = yl.length;
            var xl, wl = this.mHelper, _l = "", El = 0;
            for (cs = 0; cs < Cs; cs += 1) {
                if (this.globalData.fontManager.chars ? (this.textPaths[El] ? Xs = this.textPaths[El] : ((Xs = createNS("path")).setAttribute("stroke-linecap", lineCapEnum[1]),
                Xs.setAttribute("stroke-linejoin", lineJoinEnum[2]),
                Xs.setAttribute("stroke-miterlimit", "4")),
                this.isMasked || (this.textSpans[El] ? ba = (ga = this.textSpans[El]).children[0] : ((ga = createTag("div")).style.lineHeight = 0,
                (ba = createNS("svg")).appendChild(Xs),
                styleDiv(ga)))) : this.isMasked ? Xs = this.textPaths[El] ? this.textPaths[El] : createNS("text") : this.textSpans[El] ? (ga = this.textSpans[El],
                Xs = this.textPaths[El]) : (styleDiv(ga = createTag("span")),
                styleDiv(Xs = createTag("span")),
                ga.appendChild(Xs)),
                this.globalData.fontManager.chars) {
                    var Cl, $l = this.globalData.fontManager.getCharData(xt.finalText[cs], Ls.fStyle, this.globalData.fontManager.getFontByName(xt.f).fFamily);
                    if (Cl = $l ? $l.data : null,
                    wl.reset(),
                    Cl && Cl.shapes && Cl.shapes.length && (xl = Cl.shapes[0].it,
                    wl.scale(xt.finalSize / 100, xt.finalSize / 100),
                    _l = this.createPathShape(wl, xl),
                    Xs.setAttribute("d", _l)),
                    this.isMasked)
                        this.innerElem.appendChild(Xs);
                    else {
                        if (this.innerElem.appendChild(ga),
                        Cl && Cl.shapes) {
                            document.body.appendChild(ba);
                            var Sl = ba.getBBox();
                            ba.setAttribute("width", Sl.width + 2),
                            ba.setAttribute("height", Sl.height + 2),
                            ba.setAttribute("viewBox", Sl.x - 1 + " " + (Sl.y - 1) + " " + (Sl.width + 2) + " " + (Sl.height + 2));
                            var Tl = ba.style
                              , Rl = "translate(" + (Sl.x - 1) + "px," + (Sl.y - 1) + "px)";
                            Tl.transform = Rl,
                            Tl.webkitTransform = Rl,
                            yl[cs].yOffset = Sl.y - 1
                        } else
                            ba.setAttribute("width", 1),
                            ba.setAttribute("height", 1);
                        ga.appendChild(ba)
                    }
                } else if (Xs.textContent = yl[cs].val,
                Xs.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"),
                this.isMasked)
                    this.innerElem.appendChild(Xs);
                else {
                    this.innerElem.appendChild(ga);
                    var Il = Xs.style
                      , Ml = "translate3d(0," + -xt.finalSize / 1.2 + "px,0)";
                    Il.transform = Ml,
                    Il.webkitTransform = Ml
                }
                this.isMasked ? this.textSpans[El] = Xs : this.textSpans[El] = ga,
                this.textSpans[El].style.display = "block",
                this.textPaths[El] = Xs,
                El += 1
            }
            for (; El < this.textSpans.length; )
                this.textSpans[El].style.display = "none",
                El += 1
        }
        ,
        HTextElement.prototype.renderInnerContent = function() {
            var xt;
            if (this.validateText(),
            this.data.singleShape) {
                if (!this._isFirstFrame && !this.lettersChangedFlag)
                    return;
                if (this.isMasked && this.finalTransform._matMdf) {
                    this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH),
                    xt = this.svgElement.style;
                    var Cn = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
                    xt.transform = Cn,
                    xt.webkitTransform = Cn
                }
            }
            if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag),
            this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
                var as, cs, Cs, Ls, Vs, Ws = 0, Xs = this.textAnimator.renderedLetters, ga = this.textProperty.currentData.l;
                for (cs = ga.length,
                as = 0; as < cs; as += 1)
                    ga[as].n ? Ws += 1 : (Ls = this.textSpans[as],
                    Vs = this.textPaths[as],
                    Cs = Xs[Ws],
                    Ws += 1,
                    Cs._mdf.m && (this.isMasked ? Ls.setAttribute("transform", Cs.m) : (Ls.style.webkitTransform = Cs.m,
                    Ls.style.transform = Cs.m)),
                    Ls.style.opacity = Cs.o,
                    Cs.sw && Cs._mdf.sw && Vs.setAttribute("stroke-width", Cs.sw),
                    Cs.sc && Cs._mdf.sc && Vs.setAttribute("stroke", Cs.sc),
                    Cs.fc && Cs._mdf.fc && (Vs.setAttribute("fill", Cs.fc),
                    Vs.style.color = Cs.fc));
                if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
                    var ba = this.innerElem.getBBox();
                    if (this.currentBBox.w !== ba.width && (this.currentBBox.w = ba.width,
                    this.svgElement.setAttribute("width", ba.width)),
                    this.currentBBox.h !== ba.height && (this.currentBBox.h = ba.height,
                    this.svgElement.setAttribute("height", ba.height)),
                    this.currentBBox.w !== ba.width + 2 || this.currentBBox.h !== ba.height + 2 || this.currentBBox.x !== ba.x - 1 || this.currentBBox.y !== ba.y - 1) {
                        this.currentBBox.w = ba.width + 2,
                        this.currentBBox.h = ba.height + 2,
                        this.currentBBox.x = ba.x - 1,
                        this.currentBBox.y = ba.y - 1,
                        this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h),
                        xt = this.svgElement.style;
                        var yl = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                        xt.transform = yl,
                        xt.webkitTransform = yl
                    }
                }
            }
        }
        ,
        extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement),
        HCameraElement.prototype.setup = function() {
            var xt, Cn, as, cs, Cs = this.comp.threeDElements.length;
            for (xt = 0; xt < Cs; xt += 1)
                if ((Cn = this.comp.threeDElements[xt]).type === "3d") {
                    as = Cn.perspectiveElem.style,
                    cs = Cn.container.style;
                    var Ls = this.pe.v + "px"
                      , Vs = "0px 0px 0px"
                      , Ws = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                    as.perspective = Ls,
                    as.webkitPerspective = Ls,
                    cs.transformOrigin = Vs,
                    cs.mozTransformOrigin = Vs,
                    cs.webkitTransformOrigin = Vs,
                    as.transform = Ws,
                    as.webkitTransform = Ws
                }
        }
        ,
        HCameraElement.prototype.createElements = function() {}
        ,
        HCameraElement.prototype.hide = function() {}
        ,
        HCameraElement.prototype.renderFrame = function() {
            var xt, Cn, as = this._isFirstFrame;
            if (this.hierarchy)
                for (Cn = this.hierarchy.length,
                xt = 0; xt < Cn; xt += 1)
                    as = this.hierarchy[xt].finalTransform.mProp._mdf || as;
            if (as || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
                if (this.mat.reset(),
                this.hierarchy)
                    for (xt = Cn = this.hierarchy.length - 1; xt >= 0; xt -= 1) {
                        var cs = this.hierarchy[xt].finalTransform.mProp;
                        this.mat.translate(-cs.p.v[0], -cs.p.v[1], cs.p.v[2]),
                        this.mat.rotateX(-cs.or.v[0]).rotateY(-cs.or.v[1]).rotateZ(cs.or.v[2]),
                        this.mat.rotateX(-cs.rx.v).rotateY(-cs.ry.v).rotateZ(cs.rz.v),
                        this.mat.scale(1 / cs.s.v[0], 1 / cs.s.v[1], 1 / cs.s.v[2]),
                        this.mat.translate(cs.a.v[0], cs.a.v[1], cs.a.v[2])
                    }
                if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v),
                this.a) {
                    var Cs;
                    Cs = this.p ? [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
                    var Ls = Math.sqrt(Math.pow(Cs[0], 2) + Math.pow(Cs[1], 2) + Math.pow(Cs[2], 2))
                      , Vs = [Cs[0] / Ls, Cs[1] / Ls, Cs[2] / Ls]
                      , Ws = Math.sqrt(Vs[2] * Vs[2] + Vs[0] * Vs[0])
                      , Xs = Math.atan2(Vs[1], Ws)
                      , ga = Math.atan2(Vs[0], -Vs[2]);
                    this.mat.rotateY(ga).rotateX(-Xs)
                }
                this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v),
                this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]),
                this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0),
                this.mat.translate(0, 0, this.pe.v);
                var ba = !this._prevMat.equals(this.mat);
                if ((ba || this.pe._mdf) && this.comp.threeDElements) {
                    var yl, xl, wl;
                    for (Cn = this.comp.threeDElements.length,
                    xt = 0; xt < Cn; xt += 1)
                        if ((yl = this.comp.threeDElements[xt]).type === "3d") {
                            if (ba) {
                                var _l = this.mat.toCSS();
                                (wl = yl.container.style).transform = _l,
                                wl.webkitTransform = _l
                            }
                            this.pe._mdf && ((xl = yl.perspectiveElem.style).perspective = this.pe.v + "px",
                            xl.webkitPerspective = this.pe.v + "px")
                        }
                    this.mat.clone(this._prevMat)
                }
            }
            this._isFirstFrame = !1
        }
        ,
        HCameraElement.prototype.prepareFrame = function(xt) {
            this.prepareProperties(xt, !0)
        }
        ,
        HCameraElement.prototype.destroy = function() {}
        ,
        HCameraElement.prototype.getBaseElement = function() {
            return null
        }
        ,
        extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement),
        HImageElement.prototype.createContent = function() {
            var xt = this.globalData.getAssetsPath(this.assetData)
              , Cn = new Image;
            this.data.hasMask ? (this.imageElem = createNS("image"),
            this.imageElem.setAttribute("width", this.assetData.w + "px"),
            this.imageElem.setAttribute("height", this.assetData.h + "px"),
            this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", xt),
            this.layerElement.appendChild(this.imageElem),
            this.baseElement.setAttribute("width", this.assetData.w),
            this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(Cn),
            Cn.crossOrigin = "anonymous",
            Cn.src = xt,
            this.data.ln && this.baseElement.setAttribute("id", this.data.ln)
        }
        ,
        extendPrototype([BaseRenderer], HybridRendererBase),
        HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem,
        HybridRendererBase.prototype.checkPendingElements = function() {
            for (; this.pendingElements.length; )
                this.pendingElements.pop().checkParenting()
        }
        ,
        HybridRendererBase.prototype.appendElementInPos = function(xt, Cn) {
            var as = xt.getBaseElement();
            if (as) {
                var cs = this.layers[Cn];
                if (cs.ddd && this.supports3d)
                    this.addTo3dContainer(as, Cn);
                else if (this.threeDElements)
                    this.addTo3dContainer(as, Cn);
                else {
                    for (var Cs, Ls, Vs = 0; Vs < Cn; )
                        this.elements[Vs] && this.elements[Vs] !== !0 && this.elements[Vs].getBaseElement && (Ls = this.elements[Vs],
                        Cs = (this.layers[Vs].ddd ? this.getThreeDContainerByPos(Vs) : Ls.getBaseElement()) || Cs),
                        Vs += 1;
                    Cs ? cs.ddd && this.supports3d || this.layerElement.insertBefore(as, Cs) : cs.ddd && this.supports3d || this.layerElement.appendChild(as)
                }
            }
        }
        ,
        HybridRendererBase.prototype.createShape = function(xt) {
            return this.supports3d ? new HShapeElement(xt,this.globalData,this) : new SVGShapeElement(xt,this.globalData,this)
        }
        ,
        HybridRendererBase.prototype.createText = function(xt) {
            return this.supports3d ? new HTextElement(xt,this.globalData,this) : new SVGTextLottieElement(xt,this.globalData,this)
        }
        ,
        HybridRendererBase.prototype.createCamera = function(xt) {
            return this.camera = new HCameraElement(xt,this.globalData,this),
            this.camera
        }
        ,
        HybridRendererBase.prototype.createImage = function(xt) {
            return this.supports3d ? new HImageElement(xt,this.globalData,this) : new IImageElement(xt,this.globalData,this)
        }
        ,
        HybridRendererBase.prototype.createSolid = function(xt) {
            return this.supports3d ? new HSolidElement(xt,this.globalData,this) : new ISolidElement(xt,this.globalData,this)
        }
        ,
        HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull,
        HybridRendererBase.prototype.getThreeDContainerByPos = function(xt) {
            for (var Cn = 0, as = this.threeDElements.length; Cn < as; ) {
                if (this.threeDElements[Cn].startPos <= xt && this.threeDElements[Cn].endPos >= xt)
                    return this.threeDElements[Cn].perspectiveElem;
                Cn += 1
            }
            return null
        }
        ,
        HybridRendererBase.prototype.createThreeDContainer = function(xt, Cn) {
            var as, cs, Cs = createTag("div");
            styleDiv(Cs);
            var Ls = createTag("div");
            if (styleDiv(Ls),
            Cn === "3d") {
                (as = Cs.style).width = this.globalData.compSize.w + "px",
                as.height = this.globalData.compSize.h + "px";
                var Vs = "50% 50%";
                as.webkitTransformOrigin = Vs,
                as.mozTransformOrigin = Vs,
                as.transformOrigin = Vs;
                var Ws = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                (cs = Ls.style).transform = Ws,
                cs.webkitTransform = Ws
            }
            Cs.appendChild(Ls);
            var Xs = {
                container: Ls,
                perspectiveElem: Cs,
                startPos: xt,
                endPos: xt,
                type: Cn
            };
            return this.threeDElements.push(Xs),
            Xs
        }
        ,
        HybridRendererBase.prototype.build3dContainers = function() {
            var xt, Cn, as = this.layers.length, cs = "";
            for (xt = 0; xt < as; xt += 1)
                this.layers[xt].ddd && this.layers[xt].ty !== 3 ? (cs !== "3d" && (cs = "3d",
                Cn = this.createThreeDContainer(xt, "3d")),
                Cn.endPos = Math.max(Cn.endPos, xt)) : (cs !== "2d" && (cs = "2d",
                Cn = this.createThreeDContainer(xt, "2d")),
                Cn.endPos = Math.max(Cn.endPos, xt));
            for (xt = (as = this.threeDElements.length) - 1; xt >= 0; xt -= 1)
                this.resizerElem.appendChild(this.threeDElements[xt].perspectiveElem)
        }
        ,
        HybridRendererBase.prototype.addTo3dContainer = function(xt, Cn) {
            for (var as = 0, cs = this.threeDElements.length; as < cs; ) {
                if (Cn <= this.threeDElements[as].endPos) {
                    for (var Cs, Ls = this.threeDElements[as].startPos; Ls < Cn; )
                        this.elements[Ls] && this.elements[Ls].getBaseElement && (Cs = this.elements[Ls].getBaseElement()),
                        Ls += 1;
                    Cs ? this.threeDElements[as].container.insertBefore(xt, Cs) : this.threeDElements[as].container.appendChild(xt);
                    break
                }
                as += 1
            }
        }
        ,
        HybridRendererBase.prototype.configAnimation = function(xt) {
            var Cn = createTag("div")
              , as = this.animationItem.wrapper
              , cs = Cn.style;
            cs.width = xt.w + "px",
            cs.height = xt.h + "px",
            this.resizerElem = Cn,
            styleDiv(Cn),
            cs.transformStyle = "flat",
            cs.mozTransformStyle = "flat",
            cs.webkitTransformStyle = "flat",
            this.renderConfig.className && Cn.setAttribute("class", this.renderConfig.className),
            as.appendChild(Cn),
            cs.overflow = "hidden";
            var Cs = createNS("svg");
            Cs.setAttribute("width", "1"),
            Cs.setAttribute("height", "1"),
            styleDiv(Cs),
            this.resizerElem.appendChild(Cs);
            var Ls = createNS("defs");
            Cs.appendChild(Ls),
            this.data = xt,
            this.setupGlobalData(xt, Cs),
            this.globalData.defs = Ls,
            this.layers = xt.layers,
            this.layerElement = this.resizerElem,
            this.build3dContainers(),
            this.updateContainerSize()
        }
        ,
        HybridRendererBase.prototype.destroy = function() {
            var xt;
            this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""),
            this.animationItem.container = null,
            this.globalData.defs = null;
            var Cn = this.layers ? this.layers.length : 0;
            for (xt = 0; xt < Cn; xt += 1)
                this.elements[xt] && this.elements[xt].destroy && this.elements[xt].destroy();
            this.elements.length = 0,
            this.destroyed = !0,
            this.animationItem = null
        }
        ,
        HybridRendererBase.prototype.updateContainerSize = function() {
            var xt, Cn, as, cs, Cs = this.animationItem.wrapper.offsetWidth, Ls = this.animationItem.wrapper.offsetHeight, Vs = Cs / Ls;
            this.globalData.compSize.w / this.globalData.compSize.h > Vs ? (xt = Cs / this.globalData.compSize.w,
            Cn = Cs / this.globalData.compSize.w,
            as = 0,
            cs = (Ls - this.globalData.compSize.h * (Cs / this.globalData.compSize.w)) / 2) : (xt = Ls / this.globalData.compSize.h,
            Cn = Ls / this.globalData.compSize.h,
            as = (Cs - this.globalData.compSize.w * (Ls / this.globalData.compSize.h)) / 2,
            cs = 0);
            var Ws = this.resizerElem.style;
            Ws.webkitTransform = "matrix3d(" + xt + ",0,0,0,0," + Cn + ",0,0,0,0,1,0," + as + "," + cs + ",0,1)",
            Ws.transform = Ws.webkitTransform
        }
        ,
        HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame,
        HybridRendererBase.prototype.hide = function() {
            this.resizerElem.style.display = "none"
        }
        ,
        HybridRendererBase.prototype.show = function() {
            this.resizerElem.style.display = "block"
        }
        ,
        HybridRendererBase.prototype.initItems = function() {
            if (this.buildAllItems(),
            this.camera)
                this.camera.setup();
            else {
                var xt, Cn = this.globalData.compSize.w, as = this.globalData.compSize.h, cs = this.threeDElements.length;
                for (xt = 0; xt < cs; xt += 1) {
                    var Cs = this.threeDElements[xt].perspectiveElem.style;
                    Cs.webkitPerspective = Math.sqrt(Math.pow(Cn, 2) + Math.pow(as, 2)) + "px",
                    Cs.perspective = Cs.webkitPerspective
                }
            }
        }
        ,
        HybridRendererBase.prototype.searchExtraCompositions = function(xt) {
            var Cn, as = xt.length, cs = createTag("div");
            for (Cn = 0; Cn < as; Cn += 1)
                if (xt[Cn].xt) {
                    var Cs = this.createComp(xt[Cn], cs, this.globalData.comp, null);
                    Cs.initExpressions(),
                    this.globalData.projectInterface.registerComposition(Cs)
                }
        }
        ,
        extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement),
        HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements,
        HCompElement.prototype.createContainerElements = function() {
            this._createBaseContainerElements(),
            this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w),
            this.svgElement.setAttribute("height", this.data.h),
            this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement
        }
        ,
        HCompElement.prototype.addTo3dContainer = function(xt, Cn) {
            for (var as, cs = 0; cs < Cn; )
                this.elements[cs] && this.elements[cs].getBaseElement && (as = this.elements[cs].getBaseElement()),
                cs += 1;
            as ? this.layerElement.insertBefore(xt, as) : this.layerElement.appendChild(xt)
        }
        ,
        HCompElement.prototype.createComp = function(xt) {
            return this.supports3d ? new HCompElement(xt,this.globalData,this) : new SVGCompElement(xt,this.globalData,this)
        }
        ,
        extendPrototype([HybridRendererBase], HybridRenderer),
        HybridRenderer.prototype.createComp = function(xt) {
            return this.supports3d ? new HCompElement(xt,this.globalData,this) : new SVGCompElement(xt,this.globalData,this)
        }
        ;
        var CompExpressionInterface = function(xt) {
            function Cn(as) {
                for (var cs = 0, Cs = xt.layers.length; cs < Cs; ) {
                    if (xt.layers[cs].nm === as || xt.layers[cs].ind === as)
                        return xt.elements[cs].layerInterface;
                    cs += 1
                }
                return null
            }
            return Object.defineProperty(Cn, "_name", {
                value: xt.data.nm
            }),
            Cn.layer = Cn,
            Cn.pixelAspect = 1,
            Cn.height = xt.data.h || xt.globalData.compSize.h,
            Cn.width = xt.data.w || xt.globalData.compSize.w,
            Cn.pixelAspect = 1,
            Cn.frameDuration = 1 / xt.globalData.frameRate,
            Cn.displayStartTime = 0,
            Cn.numLayers = xt.layers.length,
            Cn
        };
        function _typeof$2(xt) {
            return _typeof$2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Cn) {
                return typeof Cn
            }
            : function(Cn) {
                return Cn && typeof Symbol == "function" && Cn.constructor === Symbol && Cn !== Symbol.prototype ? "symbol" : typeof Cn
            }
            ,
            _typeof$2(xt)
        }
        function seedRandom(xt, Cn) {
            var as = this
              , cs = 256
              , Cs = Cn.pow(cs, 6)
              , Ls = Cn.pow(2, 52)
              , Vs = 2 * Ls
              , Ws = 255;
            function Xs(wl) {
                var _l, El = wl.length, Cl = this, $l = 0, Sl = Cl.i = Cl.j = 0, Tl = Cl.S = [];
                for (El || (wl = [El++]); $l < cs; )
                    Tl[$l] = $l++;
                for ($l = 0; $l < cs; $l++)
                    Tl[$l] = Tl[Sl = Ws & Sl + wl[$l % El] + (_l = Tl[$l])],
                    Tl[Sl] = _l;
                Cl.g = function(Rl) {
                    for (var Il, Ml = 0, Nl = Cl.i, Ll = Cl.j, Fl = Cl.S; Rl--; )
                        Il = Fl[Nl = Ws & Nl + 1],
                        Ml = Ml * cs + Fl[Ws & (Fl[Nl] = Fl[Ll = Ws & Ll + Il]) + (Fl[Ll] = Il)];
                    return Cl.i = Nl,
                    Cl.j = Ll,
                    Ml
                }
            }
            function ga(wl, _l) {
                return _l.i = wl.i,
                _l.j = wl.j,
                _l.S = wl.S.slice(),
                _l
            }
            function ba(wl, _l) {
                var El, Cl = [], $l = _typeof$2(wl);
                if (_l && $l == "object")
                    for (El in wl)
                        try {
                            Cl.push(ba(wl[El], _l - 1))
                        } catch {}
                return Cl.length ? Cl : $l == "string" ? wl : wl + "\0"
            }
            function yl(wl, _l) {
                for (var El, Cl = wl + "", $l = 0; $l < Cl.length; )
                    _l[Ws & $l] = Ws & (El ^= 19 * _l[Ws & $l]) + Cl.charCodeAt($l++);
                return xl(_l)
            }
            function xl(wl) {
                return String.fromCharCode.apply(0, wl)
            }
            Cn.seedrandom = function(wl, _l, El) {
                var Cl = []
                  , $l = yl(ba((_l = _l === !0 ? {
                    entropy: !0
                } : _l || {}).entropy ? [wl, xl(xt)] : wl === null ? function() {
                    try {
                        var Rl = new Uint8Array(cs);
                        return (as.crypto || as.msCrypto).getRandomValues(Rl),
                        xl(Rl)
                    } catch {
                        var Il = as.navigator
                          , Ml = Il && Il.plugins;
                        return [+new Date, as, Ml, as.screen, xl(xt)]
                    }
                }() : wl, 3), Cl)
                  , Sl = new Xs(Cl)
                  , Tl = function() {
                    for (var Rl = Sl.g(6), Il = Cs, Ml = 0; Rl < Ls; )
                        Rl = (Rl + Ml) * cs,
                        Il *= cs,
                        Ml = Sl.g(1);
                    for (; Rl >= Vs; )
                        Rl /= 2,
                        Il /= 2,
                        Ml >>>= 1;
                    return (Rl + Ml) / Il
                };
                return Tl.int32 = function() {
                    return 0 | Sl.g(4)
                }
                ,
                Tl.quick = function() {
                    return Sl.g(4) / 4294967296
                }
                ,
                Tl.double = Tl,
                yl(xl(Sl.S), xt),
                (_l.pass || El || function(Rl, Il, Ml, Nl) {
                    return Nl && (Nl.S && ga(Nl, Sl),
                    Rl.state = function() {
                        return ga(Sl, {})
                    }
                    ),
                    Ml ? (Cn.random = Rl,
                    Il) : Rl
                }
                )(Tl, $l, "global"in _l ? _l.global : this == Cn, _l.state)
            }
            ,
            yl(Cn.random(), xt)
        }
        function initialize$2(xt) {
            seedRandom([], xt)
        }
        var propTypes = {
            SHAPE: "shape"
        };
        function _typeof$1(xt) {
            return _typeof$1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Cn) {
                return typeof Cn
            }
            : function(Cn) {
                return Cn && typeof Symbol == "function" && Cn.constructor === Symbol && Cn !== Symbol.prototype ? "symbol" : typeof Cn
            }
            ,
            _typeof$1(xt)
        }
        var ExpressionManager = function() {
            var ob = {}
              , Math = BMMath
              , window = null
              , document = null
              , XMLHttpRequest = null
              , fetch = null
              , frames = null
              , _lottieGlobal = {};
            function resetFrame() {
                _lottieGlobal = {}
            }
            function $bm_isInstanceOfArray(xt) {
                return xt.constructor === Array || xt.constructor === Float32Array
            }
            function isNumerable(xt, Cn) {
                return xt === "number" || Cn instanceof Number || xt === "boolean" || xt === "string"
            }
            function $bm_neg(xt) {
                var Cn = _typeof$1(xt);
                if (Cn === "number" || xt instanceof Number || Cn === "boolean")
                    return -xt;
                if ($bm_isInstanceOfArray(xt)) {
                    var as, cs = xt.length, Cs = [];
                    for (as = 0; as < cs; as += 1)
                        Cs[as] = -xt[as];
                    return Cs
                }
                return xt.propType ? xt.v : -xt
            }
            initialize$2(BMMath);
            var easeInBez = BezierFactory.getBezierEasing(.333, 0, .833, .833, "easeIn").get
              , easeOutBez = BezierFactory.getBezierEasing(.167, .167, .667, 1, "easeOut").get
              , easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, "easeInOut").get;
            function sum(xt, Cn) {
                var as = _typeof$1(xt)
                  , cs = _typeof$1(Cn);
                if (isNumerable(as, xt) && isNumerable(cs, Cn) || as === "string" || cs === "string")
                    return xt + Cn;
                if ($bm_isInstanceOfArray(xt) && isNumerable(cs, Cn))
                    return (xt = xt.slice(0))[0] += Cn,
                    xt;
                if (isNumerable(as, xt) && $bm_isInstanceOfArray(Cn))
                    return (Cn = Cn.slice(0))[0] = xt + Cn[0],
                    Cn;
                if ($bm_isInstanceOfArray(xt) && $bm_isInstanceOfArray(Cn)) {
                    for (var Cs = 0, Ls = xt.length, Vs = Cn.length, Ws = []; Cs < Ls || Cs < Vs; )
                        (typeof xt[Cs] == "number" || xt[Cs]instanceof Number) && (typeof Cn[Cs] == "number" || Cn[Cs]instanceof Number) ? Ws[Cs] = xt[Cs] + Cn[Cs] : Ws[Cs] = Cn[Cs] === void 0 ? xt[Cs] : xt[Cs] || Cn[Cs],
                        Cs += 1;
                    return Ws
                }
                return 0
            }
            var add = sum;
            function sub(xt, Cn) {
                var as = _typeof$1(xt)
                  , cs = _typeof$1(Cn);
                if (isNumerable(as, xt) && isNumerable(cs, Cn))
                    return as === "string" && (xt = parseInt(xt, 10)),
                    cs === "string" && (Cn = parseInt(Cn, 10)),
                    xt - Cn;
                if ($bm_isInstanceOfArray(xt) && isNumerable(cs, Cn))
                    return (xt = xt.slice(0))[0] -= Cn,
                    xt;
                if (isNumerable(as, xt) && $bm_isInstanceOfArray(Cn))
                    return (Cn = Cn.slice(0))[0] = xt - Cn[0],
                    Cn;
                if ($bm_isInstanceOfArray(xt) && $bm_isInstanceOfArray(Cn)) {
                    for (var Cs = 0, Ls = xt.length, Vs = Cn.length, Ws = []; Cs < Ls || Cs < Vs; )
                        (typeof xt[Cs] == "number" || xt[Cs]instanceof Number) && (typeof Cn[Cs] == "number" || Cn[Cs]instanceof Number) ? Ws[Cs] = xt[Cs] - Cn[Cs] : Ws[Cs] = Cn[Cs] === void 0 ? xt[Cs] : xt[Cs] || Cn[Cs],
                        Cs += 1;
                    return Ws
                }
                return 0
            }
            function mul(xt, Cn) {
                var as, cs, Cs, Ls = _typeof$1(xt), Vs = _typeof$1(Cn);
                if (isNumerable(Ls, xt) && isNumerable(Vs, Cn))
                    return xt * Cn;
                if ($bm_isInstanceOfArray(xt) && isNumerable(Vs, Cn)) {
                    for (Cs = xt.length,
                    as = createTypedArray("float32", Cs),
                    cs = 0; cs < Cs; cs += 1)
                        as[cs] = xt[cs] * Cn;
                    return as
                }
                if (isNumerable(Ls, xt) && $bm_isInstanceOfArray(Cn)) {
                    for (Cs = Cn.length,
                    as = createTypedArray("float32", Cs),
                    cs = 0; cs < Cs; cs += 1)
                        as[cs] = xt * Cn[cs];
                    return as
                }
                return 0
            }
            function div(xt, Cn) {
                var as, cs, Cs, Ls = _typeof$1(xt), Vs = _typeof$1(Cn);
                if (isNumerable(Ls, xt) && isNumerable(Vs, Cn))
                    return xt / Cn;
                if ($bm_isInstanceOfArray(xt) && isNumerable(Vs, Cn)) {
                    for (Cs = xt.length,
                    as = createTypedArray("float32", Cs),
                    cs = 0; cs < Cs; cs += 1)
                        as[cs] = xt[cs] / Cn;
                    return as
                }
                if (isNumerable(Ls, xt) && $bm_isInstanceOfArray(Cn)) {
                    for (Cs = Cn.length,
                    as = createTypedArray("float32", Cs),
                    cs = 0; cs < Cs; cs += 1)
                        as[cs] = xt / Cn[cs];
                    return as
                }
                return 0
            }
            function mod(xt, Cn) {
                return typeof xt == "string" && (xt = parseInt(xt, 10)),
                typeof Cn == "string" && (Cn = parseInt(Cn, 10)),
                xt % Cn
            }
            var $bm_sum = sum
              , $bm_sub = sub
              , $bm_mul = mul
              , $bm_div = div
              , $bm_mod = mod;
            function clamp(xt, Cn, as) {
                if (Cn > as) {
                    var cs = as;
                    as = Cn,
                    Cn = cs
                }
                return Math.min(Math.max(xt, Cn), as)
            }
            function radiansToDegrees(xt) {
                return xt / degToRads
            }
            var radians_to_degrees = radiansToDegrees;
            function degreesToRadians(xt) {
                return xt * degToRads
            }
            var degrees_to_radians = radiansToDegrees
              , helperLengthArray = [0, 0, 0, 0, 0, 0];
            function length(xt, Cn) {
                if (typeof xt == "number" || xt instanceof Number)
                    return Cn = Cn || 0,
                    Math.abs(xt - Cn);
                var as;
                Cn || (Cn = helperLengthArray);
                var cs = Math.min(xt.length, Cn.length)
                  , Cs = 0;
                for (as = 0; as < cs; as += 1)
                    Cs += Math.pow(Cn[as] - xt[as], 2);
                return Math.sqrt(Cs)
            }
            function normalize(xt) {
                return div(xt, length(xt))
            }
            function rgbToHsl(xt) {
                var Cn, as, cs = xt[0], Cs = xt[1], Ls = xt[2], Vs = Math.max(cs, Cs, Ls), Ws = Math.min(cs, Cs, Ls), Xs = (Vs + Ws) / 2;
                if (Vs === Ws)
                    Cn = 0,
                    as = 0;
                else {
                    var ga = Vs - Ws;
                    switch (as = Xs > .5 ? ga / (2 - Vs - Ws) : ga / (Vs + Ws),
                    Vs) {
                    case cs:
                        Cn = (Cs - Ls) / ga + (Cs < Ls ? 6 : 0);
                        break;
                    case Cs:
                        Cn = (Ls - cs) / ga + 2;
                        break;
                    case Ls:
                        Cn = (cs - Cs) / ga + 4
                    }
                    Cn /= 6
                }
                return [Cn, as, Xs, xt[3]]
            }
            function hue2rgb(xt, Cn, as) {
                return as < 0 && (as += 1),
                as > 1 && (as -= 1),
                as < 1 / 6 ? xt + 6 * (Cn - xt) * as : as < .5 ? Cn : as < 2 / 3 ? xt + (Cn - xt) * (2 / 3 - as) * 6 : xt
            }
            function hslToRgb(xt) {
                var Cn, as, cs, Cs = xt[0], Ls = xt[1], Vs = xt[2];
                if (Ls === 0)
                    Cn = Vs,
                    cs = Vs,
                    as = Vs;
                else {
                    var Ws = Vs < .5 ? Vs * (1 + Ls) : Vs + Ls - Vs * Ls
                      , Xs = 2 * Vs - Ws;
                    Cn = hue2rgb(Xs, Ws, Cs + 1 / 3),
                    as = hue2rgb(Xs, Ws, Cs),
                    cs = hue2rgb(Xs, Ws, Cs - 1 / 3)
                }
                return [Cn, as, cs, xt[3]]
            }
            function linear(xt, Cn, as, cs, Cs) {
                if (cs !== void 0 && Cs !== void 0 || (cs = Cn,
                Cs = as,
                Cn = 0,
                as = 1),
                as < Cn) {
                    var Ls = as;
                    as = Cn,
                    Cn = Ls
                }
                if (xt <= Cn)
                    return cs;
                if (xt >= as)
                    return Cs;
                var Vs, Ws = as === Cn ? 0 : (xt - Cn) / (as - Cn);
                if (!cs.length)
                    return cs + (Cs - cs) * Ws;
                var Xs = cs.length
                  , ga = createTypedArray("float32", Xs);
                for (Vs = 0; Vs < Xs; Vs += 1)
                    ga[Vs] = cs[Vs] + (Cs[Vs] - cs[Vs]) * Ws;
                return ga
            }
            function random(xt, Cn) {
                if (Cn === void 0 && (xt === void 0 ? (xt = 0,
                Cn = 1) : (Cn = xt,
                xt = void 0)),
                Cn.length) {
                    var as, cs = Cn.length;
                    xt || (xt = createTypedArray("float32", cs));
                    var Cs = createTypedArray("float32", cs)
                      , Ls = BMMath.random();
                    for (as = 0; as < cs; as += 1)
                        Cs[as] = xt[as] + Ls * (Cn[as] - xt[as]);
                    return Cs
                }
                return xt === void 0 && (xt = 0),
                xt + BMMath.random() * (Cn - xt)
            }
            function createPath(xt, Cn, as, cs) {
                var Cs, Ls = xt.length, Vs = shapePool.newElement();
                Vs.setPathData(!!cs, Ls);
                var Ws, Xs, ga = [0, 0];
                for (Cs = 0; Cs < Ls; Cs += 1)
                    Ws = Cn && Cn[Cs] ? Cn[Cs] : ga,
                    Xs = as && as[Cs] ? as[Cs] : ga,
                    Vs.setTripleAt(xt[Cs][0], xt[Cs][1], Xs[0] + xt[Cs][0], Xs[1] + xt[Cs][1], Ws[0] + xt[Cs][0], Ws[1] + xt[Cs][1], Cs, !0);
                return Vs
            }
            function initiateExpression(elem, data, property) {
                function noOp(xt) {
                    return xt
                }
                if (!elem.globalData.renderConfig.runExpressions)
                    return noOp;
                var val = data.x, needsVelocity = /velocity(?![\w\d])/.test(val), _needsRandom = val.indexOf("random") !== -1, elemType = elem.data.ty, transform, $bm_transform, content, effect, thisProperty = property;
                thisProperty.valueAtTime = thisProperty.getValueAtTime,
                Object.defineProperty(thisProperty, "value", {
                    get: function() {
                        return thisProperty.v
                    }
                }),
                elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate,
                elem.comp.displayStartTime = 0;
                var inPoint = elem.data.ip / elem.comp.globalData.frameRate, outPoint = elem.data.op / elem.comp.globalData.frameRate, width = elem.data.sw ? elem.data.sw : 0, height = elem.data.sh ? elem.data.sh : 0, name = elem.data.nm, loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, scoped_bm_rt, expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0], numKeys = property.kf ? data.k.length : 0, active = !this.data || this.data.hd !== !0, wiggle = (function(xt, Cn) {
                    var as, cs, Cs = this.pv.length ? this.pv.length : 1, Ls = createTypedArray("float32", Cs), Vs = Math.floor(5 * time);
                    for (as = 0,
                    cs = 0; as < Vs; ) {
                        for (cs = 0; cs < Cs; cs += 1)
                            Ls[cs] += -Cn + 2 * Cn * BMMath.random();
                        as += 1
                    }
                    var Ws = 5 * time
                      , Xs = Ws - Math.floor(Ws)
                      , ga = createTypedArray("float32", Cs);
                    if (Cs > 1) {
                        for (cs = 0; cs < Cs; cs += 1)
                            ga[cs] = this.pv[cs] + Ls[cs] + (-Cn + 2 * Cn * BMMath.random()) * Xs;
                        return ga
                    }
                    return this.pv + Ls[0] + (-Cn + 2 * Cn * BMMath.random()) * Xs
                }
                ).bind(this);
                function loopInDuration(xt, Cn) {
                    return loopIn(xt, Cn, !0)
                }
                function loopOutDuration(xt, Cn) {
                    return loopOut(xt, Cn, !0)
                }
                thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty),
                loop_in = loopIn),
                thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty),
                loop_out = loopOut),
                thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty)),
                this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)),
                this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this));
                var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface), time, velocity, value, text, textIndex, textTotal, selectorValue;
                function lookAt(xt, Cn) {
                    var as = [Cn[0] - xt[0], Cn[1] - xt[1], Cn[2] - xt[2]]
                      , cs = Math.atan2(as[0], Math.sqrt(as[1] * as[1] + as[2] * as[2])) / degToRads;
                    return [-Math.atan2(as[1], as[2]) / degToRads, cs, 0]
                }
                function easeOut(xt, Cn, as, cs, Cs) {
                    return applyEase(easeOutBez, xt, Cn, as, cs, Cs)
                }
                function easeIn(xt, Cn, as, cs, Cs) {
                    return applyEase(easeInBez, xt, Cn, as, cs, Cs)
                }
                function ease(xt, Cn, as, cs, Cs) {
                    return applyEase(easeInOutBez, xt, Cn, as, cs, Cs)
                }
                function applyEase(xt, Cn, as, cs, Cs, Ls) {
                    Cs === void 0 ? (Cs = as,
                    Ls = cs) : Cn = (Cn - as) / (cs - as),
                    Cn > 1 ? Cn = 1 : Cn < 0 && (Cn = 0);
                    var Vs = xt(Cn);
                    if ($bm_isInstanceOfArray(Cs)) {
                        var Ws, Xs = Cs.length, ga = createTypedArray("float32", Xs);
                        for (Ws = 0; Ws < Xs; Ws += 1)
                            ga[Ws] = (Ls[Ws] - Cs[Ws]) * Vs + Cs[Ws];
                        return ga
                    }
                    return (Ls - Cs) * Vs + Cs
                }
                function nearestKey(xt) {
                    var Cn, as, cs, Cs = data.k.length;
                    if (data.k.length && typeof data.k[0] != "number")
                        if (as = -1,
                        (xt *= elem.comp.globalData.frameRate) < data.k[0].t)
                            as = 1,
                            cs = data.k[0].t;
                        else {
                            for (Cn = 0; Cn < Cs - 1; Cn += 1) {
                                if (xt === data.k[Cn].t) {
                                    as = Cn + 1,
                                    cs = data.k[Cn].t;
                                    break
                                }
                                if (xt > data.k[Cn].t && xt < data.k[Cn + 1].t) {
                                    xt - data.k[Cn].t > data.k[Cn + 1].t - xt ? (as = Cn + 2,
                                    cs = data.k[Cn + 1].t) : (as = Cn + 1,
                                    cs = data.k[Cn].t);
                                    break
                                }
                            }
                            as === -1 && (as = Cn + 1,
                            cs = data.k[Cn].t)
                        }
                    else
                        as = 0,
                        cs = 0;
                    var Ls = {};
                    return Ls.index = as,
                    Ls.time = cs / elem.comp.globalData.frameRate,
                    Ls
                }
                function key(xt) {
                    var Cn, as, cs;
                    if (!data.k.length || typeof data.k[0] == "number")
                        throw new Error("The property has no keyframe at index " + xt);
                    xt -= 1,
                    Cn = {
                        time: data.k[xt].t / elem.comp.globalData.frameRate,
                        value: []
                    };
                    var Cs = Object.prototype.hasOwnProperty.call(data.k[xt], "s") ? data.k[xt].s : data.k[xt - 1].e;
                    for (cs = Cs.length,
                    as = 0; as < cs; as += 1)
                        Cn[as] = Cs[as],
                        Cn.value[as] = Cs[as];
                    return Cn
                }
                function framesToTime(xt, Cn) {
                    return Cn || (Cn = elem.comp.globalData.frameRate),
                    xt / Cn
                }
                function timeToFrames(xt, Cn) {
                    return xt || xt === 0 || (xt = time),
                    Cn || (Cn = elem.comp.globalData.frameRate),
                    xt * Cn
                }
                function seedRandom(xt) {
                    BMMath.seedrandom(randSeed + xt)
                }
                function sourceRectAtTime() {
                    return elem.sourceRectAtTime()
                }
                function substring(xt, Cn) {
                    return typeof value == "string" ? Cn === void 0 ? value.substring(xt) : value.substring(xt, Cn) : ""
                }
                function substr(xt, Cn) {
                    return typeof value == "string" ? Cn === void 0 ? value.substr(xt) : value.substr(xt, Cn) : ""
                }
                function posterizeTime(xt) {
                    time = xt === 0 ? 0 : Math.floor(time * xt) / xt,
                    value = valueAtTime(time)
                }
                var index = elem.data.ind;
                !elem.hierarchy || elem.hierarchy.length;
                var parent, randSeed = Math.floor(1e6 * Math.random()), globalData = elem.globalData;
                function executeExpression(xt) {
                    return value = xt,
                    this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector" ? value : (this.propType === "textSelector" && (textIndex = this.textIndex,
                    textTotal = this.textTotal,
                    selectorValue = this.selectorValue),
                    thisLayer || (text = elem.layerInterface.text,
                    thisLayer = elem.layerInterface,
                    thisComp = elem.comp.compInterface,
                    toWorld = thisLayer.toWorld.bind(thisLayer),
                    fromWorld = thisLayer.fromWorld.bind(thisLayer),
                    fromComp = thisLayer.fromComp.bind(thisLayer),
                    toComp = thisLayer.toComp.bind(thisLayer),
                    mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null,
                    fromCompToSurface = fromComp),
                    transform || (transform = elem.layerInterface("ADBE Transform Group"),
                    $bm_transform = transform,
                    transform && (anchorPoint = transform.anchorPoint)),
                    elemType !== 4 || content || (content = thisLayer("ADBE Root Vectors Group")),
                    effect || (effect = thisLayer(4)),
                    !(!elem.hierarchy || !elem.hierarchy.length) && !parent && (parent = elem.hierarchy[0].layerInterface),
                    time = this.comp.renderedFrame / this.comp.globalData.frameRate,
                    _needsRandom && seedRandom(randSeed + time),
                    needsVelocity && (velocity = velocityAtTime(time)),
                    expression_function(),
                    this.frameExpressionId = elem.globalData.frameId,
                    scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt)
                }
                return executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData],
                executeExpression
            }
            return ob.initiateExpression = initiateExpression,
            ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal],
            ob.resetFrame = resetFrame,
            ob
        }()
          , Expressions = function() {
            var xt = {
                initExpressions: function(Cn) {
                    var as = 0
                      , cs = [];
                    Cn.renderer.compInterface = CompExpressionInterface(Cn.renderer),
                    Cn.renderer.globalData.projectInterface.registerComposition(Cn.renderer),
                    Cn.renderer.globalData.pushExpression = function() {
                        as += 1
                    }
                    ,
                    Cn.renderer.globalData.popExpression = function() {
                        (as -= 1) == 0 && function() {
                            var Cs, Ls = cs.length;
                            for (Cs = 0; Cs < Ls; Cs += 1)
                                cs[Cs].release();
                            cs.length = 0
                        }()
                    }
                    ,
                    Cn.renderer.globalData.registerExpressionProperty = function(Cs) {
                        cs.indexOf(Cs) === -1 && cs.push(Cs)
                    }
                }
            };
            return xt.resetFrame = ExpressionManager.resetFrame,
            xt
        }()
          , MaskManagerInterface = function() {
            function xt(Cn, as) {
                this._mask = Cn,
                this._data = as
            }
            return Object.defineProperty(xt.prototype, "maskPath", {
                get: function() {
                    return this._mask.prop.k && this._mask.prop.getValue(),
                    this._mask.prop
                }
            }),
            Object.defineProperty(xt.prototype, "maskOpacity", {
                get: function() {
                    return this._mask.op.k && this._mask.op.getValue(),
                    100 * this._mask.op.v
                }
            }),
            function(Cn) {
                var as, cs = createSizedArray(Cn.viewData.length), Cs = Cn.viewData.length;
                for (as = 0; as < Cs; as += 1)
                    cs[as] = new xt(Cn.viewData[as],Cn.masksProperties[as]);
                return function(Ls) {
                    for (as = 0; as < Cs; ) {
                        if (Cn.masksProperties[as].nm === Ls)
                            return cs[as];
                        as += 1
                    }
                    return null
                }
            }
        }()
          , ExpressionPropertyInterface = function() {
            var xt = {
                pv: 0,
                v: 0,
                mult: 1
            }
              , Cn = {
                pv: [0, 0, 0],
                v: [0, 0, 0],
                mult: 1
            };
            function as(Cs, Ls, Vs) {
                Object.defineProperty(Cs, "velocity", {
                    get: function() {
                        return Ls.getVelocityAtTime(Ls.comp.currentFrame)
                    }
                }),
                Cs.numKeys = Ls.keyframes ? Ls.keyframes.length : 0,
                Cs.key = function(Ws) {
                    if (!Cs.numKeys)
                        return 0;
                    var Xs = "";
                    Xs = "s"in Ls.keyframes[Ws - 1] ? Ls.keyframes[Ws - 1].s : "e"in Ls.keyframes[Ws - 2] ? Ls.keyframes[Ws - 2].e : Ls.keyframes[Ws - 2].s;
                    var ga = Vs === "unidimensional" ? new Number(Xs) : Object.assign({}, Xs);
                    return ga.time = Ls.keyframes[Ws - 1].t / Ls.elem.comp.globalData.frameRate,
                    ga.value = Vs === "unidimensional" ? Xs[0] : Xs,
                    ga
                }
                ,
                Cs.valueAtTime = Ls.getValueAtTime,
                Cs.speedAtTime = Ls.getSpeedAtTime,
                Cs.velocityAtTime = Ls.getVelocityAtTime,
                Cs.propertyGroup = Ls.propertyGroup
            }
            function cs() {
                return xt
            }
            return function(Cs) {
                return Cs ? Cs.propType === "unidimensional" ? function(Ls) {
                    Ls && "pv"in Ls || (Ls = xt);
                    var Vs = 1 / Ls.mult
                      , Ws = Ls.pv * Vs
                      , Xs = new Number(Ws);
                    return Xs.value = Ws,
                    as(Xs, Ls, "unidimensional"),
                    function() {
                        return Ls.k && Ls.getValue(),
                        Ws = Ls.v * Vs,
                        Xs.value !== Ws && ((Xs = new Number(Ws)).value = Ws,
                        as(Xs, Ls, "unidimensional")),
                        Xs
                    }
                }(Cs) : function(Ls) {
                    Ls && "pv"in Ls || (Ls = Cn);
                    var Vs = 1 / Ls.mult
                      , Ws = Ls.data && Ls.data.l || Ls.pv.length
                      , Xs = createTypedArray("float32", Ws)
                      , ga = createTypedArray("float32", Ws);
                    return Xs.value = ga,
                    as(Xs, Ls, "multidimensional"),
                    function() {
                        Ls.k && Ls.getValue();
                        for (var ba = 0; ba < Ws; ba += 1)
                            ga[ba] = Ls.v[ba] * Vs,
                            Xs[ba] = ga[ba];
                        return Xs
                    }
                }(Cs) : cs
            }
        }()
          , TransformExpressionInterface = function(xt) {
            function Cn(Vs) {
                switch (Vs) {
                case "scale":
                case "Scale":
                case "ADBE Scale":
                case 6:
                    return Cn.scale;
                case "rotation":
                case "Rotation":
                case "ADBE Rotation":
                case "ADBE Rotate Z":
                case 10:
                    return Cn.rotation;
                case "ADBE Rotate X":
                    return Cn.xRotation;
                case "ADBE Rotate Y":
                    return Cn.yRotation;
                case "position":
                case "Position":
                case "ADBE Position":
                case 2:
                    return Cn.position;
                case "ADBE Position_0":
                    return Cn.xPosition;
                case "ADBE Position_1":
                    return Cn.yPosition;
                case "ADBE Position_2":
                    return Cn.zPosition;
                case "anchorPoint":
                case "AnchorPoint":
                case "Anchor Point":
                case "ADBE AnchorPoint":
                case 1:
                    return Cn.anchorPoint;
                case "opacity":
                case "Opacity":
                case 11:
                    return Cn.opacity;
                default:
                    return null
                }
            }
            var as, cs, Cs, Ls;
            return Object.defineProperty(Cn, "rotation", {
                get: ExpressionPropertyInterface(xt.r || xt.rz)
            }),
            Object.defineProperty(Cn, "zRotation", {
                get: ExpressionPropertyInterface(xt.rz || xt.r)
            }),
            Object.defineProperty(Cn, "xRotation", {
                get: ExpressionPropertyInterface(xt.rx)
            }),
            Object.defineProperty(Cn, "yRotation", {
                get: ExpressionPropertyInterface(xt.ry)
            }),
            Object.defineProperty(Cn, "scale", {
                get: ExpressionPropertyInterface(xt.s)
            }),
            xt.p ? Ls = ExpressionPropertyInterface(xt.p) : (as = ExpressionPropertyInterface(xt.px),
            cs = ExpressionPropertyInterface(xt.py),
            xt.pz && (Cs = ExpressionPropertyInterface(xt.pz))),
            Object.defineProperty(Cn, "position", {
                get: function() {
                    return xt.p ? Ls() : [as(), cs(), Cs ? Cs() : 0]
                }
            }),
            Object.defineProperty(Cn, "xPosition", {
                get: ExpressionPropertyInterface(xt.px)
            }),
            Object.defineProperty(Cn, "yPosition", {
                get: ExpressionPropertyInterface(xt.py)
            }),
            Object.defineProperty(Cn, "zPosition", {
                get: ExpressionPropertyInterface(xt.pz)
            }),
            Object.defineProperty(Cn, "anchorPoint", {
                get: ExpressionPropertyInterface(xt.a)
            }),
            Object.defineProperty(Cn, "opacity", {
                get: ExpressionPropertyInterface(xt.o)
            }),
            Object.defineProperty(Cn, "skew", {
                get: ExpressionPropertyInterface(xt.sk)
            }),
            Object.defineProperty(Cn, "skewAxis", {
                get: ExpressionPropertyInterface(xt.sa)
            }),
            Object.defineProperty(Cn, "orientation", {
                get: ExpressionPropertyInterface(xt.or)
            }),
            Cn
        }
          , LayerExpressionInterface = function() {
            function xt(ga) {
                var ba = new Matrix;
                return ga !== void 0 ? this._elem.finalTransform.mProp.getValueAtTime(ga).clone(ba) : this._elem.finalTransform.mProp.applyToMatrix(ba),
                ba
            }
            function Cn(ga, ba) {
                var yl = this.getMatrix(ba);
                return yl.props[12] = 0,
                yl.props[13] = 0,
                yl.props[14] = 0,
                this.applyPoint(yl, ga)
            }
            function as(ga, ba) {
                var yl = this.getMatrix(ba);
                return this.applyPoint(yl, ga)
            }
            function cs(ga, ba) {
                var yl = this.getMatrix(ba);
                return yl.props[12] = 0,
                yl.props[13] = 0,
                yl.props[14] = 0,
                this.invertPoint(yl, ga)
            }
            function Cs(ga, ba) {
                var yl = this.getMatrix(ba);
                return this.invertPoint(yl, ga)
            }
            function Ls(ga, ba) {
                if (this._elem.hierarchy && this._elem.hierarchy.length) {
                    var yl, xl = this._elem.hierarchy.length;
                    for (yl = 0; yl < xl; yl += 1)
                        this._elem.hierarchy[yl].finalTransform.mProp.applyToMatrix(ga)
                }
                return ga.applyToPointArray(ba[0], ba[1], ba[2] || 0)
            }
            function Vs(ga, ba) {
                if (this._elem.hierarchy && this._elem.hierarchy.length) {
                    var yl, xl = this._elem.hierarchy.length;
                    for (yl = 0; yl < xl; yl += 1)
                        this._elem.hierarchy[yl].finalTransform.mProp.applyToMatrix(ga)
                }
                return ga.inversePoint(ba)
            }
            function Ws(ga) {
                var ba = new Matrix;
                if (ba.reset(),
                this._elem.finalTransform.mProp.applyToMatrix(ba),
                this._elem.hierarchy && this._elem.hierarchy.length) {
                    var yl, xl = this._elem.hierarchy.length;
                    for (yl = 0; yl < xl; yl += 1)
                        this._elem.hierarchy[yl].finalTransform.mProp.applyToMatrix(ba);
                    return ba.inversePoint(ga)
                }
                return ba.inversePoint(ga)
            }
            function Xs() {
                return [1, 1, 1, 1]
            }
            return function(ga) {
                var ba;
                function yl(wl) {
                    switch (wl) {
                    case "ADBE Root Vectors Group":
                    case "Contents":
                    case 2:
                        return yl.shapeInterface;
                    case 1:
                    case 6:
                    case "Transform":
                    case "transform":
                    case "ADBE Transform Group":
                        return ba;
                    case 4:
                    case "ADBE Effect Parade":
                    case "effects":
                    case "Effects":
                        return yl.effect;
                    case "ADBE Text Properties":
                        return yl.textInterface;
                    default:
                        return null
                    }
                }
                yl.getMatrix = xt,
                yl.invertPoint = Vs,
                yl.applyPoint = Ls,
                yl.toWorld = as,
                yl.toWorldVec = Cn,
                yl.fromWorld = Cs,
                yl.fromWorldVec = cs,
                yl.toComp = as,
                yl.fromComp = Ws,
                yl.sampleImage = Xs,
                yl.sourceRectAtTime = ga.sourceRectAtTime.bind(ga),
                yl._elem = ga;
                var xl = getDescriptor(ba = TransformExpressionInterface(ga.finalTransform.mProp), "anchorPoint");
                return Object.defineProperties(yl, {
                    hasParent: {
                        get: function() {
                            return ga.hierarchy.length
                        }
                    },
                    parent: {
                        get: function() {
                            return ga.hierarchy[0].layerInterface
                        }
                    },
                    rotation: getDescriptor(ba, "rotation"),
                    scale: getDescriptor(ba, "scale"),
                    position: getDescriptor(ba, "position"),
                    opacity: getDescriptor(ba, "opacity"),
                    anchorPoint: xl,
                    anchor_point: xl,
                    transform: {
                        get: function() {
                            return ba
                        }
                    },
                    active: {
                        get: function() {
                            return ga.isInRange
                        }
                    }
                }),
                yl.startTime = ga.data.st,
                yl.index = ga.data.ind,
                yl.source = ga.data.refId,
                yl.height = ga.data.ty === 0 ? ga.data.h : 100,
                yl.width = ga.data.ty === 0 ? ga.data.w : 100,
                yl.inPoint = ga.data.ip / ga.comp.globalData.frameRate,
                yl.outPoint = ga.data.op / ga.comp.globalData.frameRate,
                yl._name = ga.data.nm,
                yl.registerMaskInterface = function(wl) {
                    yl.mask = new MaskManagerInterface(wl,ga)
                }
                ,
                yl.registerEffectsInterface = function(wl) {
                    yl.effect = wl
                }
                ,
                yl
            }
        }()
          , propertyGroupFactory = function(xt, Cn) {
            return function(as) {
                return (as = as === void 0 ? 1 : as) <= 0 ? xt : Cn(as - 1)
            }
        }
          , PropertyInterface = function(xt, Cn) {
            var as = {
                _name: xt
            };
            return function(cs) {
                return (cs = cs === void 0 ? 1 : cs) <= 0 ? as : Cn(cs - 1)
            }
        }
          , EffectsExpressionInterface = function() {
            var xt = {
                createEffectsInterface: function(cs, Cs) {
                    if (cs.effectsManager) {
                        var Ls, Vs = [], Ws = cs.data.ef, Xs = cs.effectsManager.effectElements.length;
                        for (Ls = 0; Ls < Xs; Ls += 1)
                            Vs.push(Cn(Ws[Ls], cs.effectsManager.effectElements[Ls], Cs, cs));
                        var ga = cs.data.ef || []
                          , ba = function(yl) {
                            for (Ls = 0,
                            Xs = ga.length; Ls < Xs; ) {
                                if (yl === ga[Ls].nm || yl === ga[Ls].mn || yl === ga[Ls].ix)
                                    return Vs[Ls];
                                Ls += 1
                            }
                            return null
                        };
                        return Object.defineProperty(ba, "numProperties", {
                            get: function() {
                                return ga.length
                            }
                        }),
                        ba
                    }
                    return null
                }
            };
            function Cn(cs, Cs, Ls, Vs) {
                function Ws(xl) {
                    for (var wl = cs.ef, _l = 0, El = wl.length; _l < El; ) {
                        if (xl === wl[_l].nm || xl === wl[_l].mn || xl === wl[_l].ix)
                            return wl[_l].ty === 5 ? ba[_l] : ba[_l]();
                        _l += 1
                    }
                    throw new Error
                }
                var Xs, ga = propertyGroupFactory(Ws, Ls), ba = [], yl = cs.ef.length;
                for (Xs = 0; Xs < yl; Xs += 1)
                    cs.ef[Xs].ty === 5 ? ba.push(Cn(cs.ef[Xs], Cs.effectElements[Xs], Cs.effectElements[Xs].propertyGroup, Vs)) : ba.push(as(Cs.effectElements[Xs], cs.ef[Xs].ty, Vs, ga));
                return cs.mn === "ADBE Color Control" && Object.defineProperty(Ws, "color", {
                    get: function() {
                        return ba[0]()
                    }
                }),
                Object.defineProperties(Ws, {
                    numProperties: {
                        get: function() {
                            return cs.np
                        }
                    },
                    _name: {
                        value: cs.nm
                    },
                    propertyGroup: {
                        value: ga
                    }
                }),
                Ws.enabled = cs.en !== 0,
                Ws.active = Ws.enabled,
                Ws
            }
            function as(cs, Cs, Ls, Vs) {
                var Ws = ExpressionPropertyInterface(cs.p);
                return cs.p.setGroupProperty && cs.p.setGroupProperty(PropertyInterface("", Vs)),
                function() {
                    return Cs === 10 ? Ls.comp.compInterface(cs.p.v) : Ws()
                }
            }
            return xt
        }()
          , ShapePathInterface = function(xt, Cn, as) {
            var cs = Cn.sh;
            function Cs(Vs) {
                return Vs === "Shape" || Vs === "shape" || Vs === "Path" || Vs === "path" || Vs === "ADBE Vector Shape" || Vs === 2 ? Cs.path : null
            }
            var Ls = propertyGroupFactory(Cs, as);
            return cs.setGroupProperty(PropertyInterface("Path", Ls)),
            Object.defineProperties(Cs, {
                path: {
                    get: function() {
                        return cs.k && cs.getValue(),
                        cs
                    }
                },
                shape: {
                    get: function() {
                        return cs.k && cs.getValue(),
                        cs
                    }
                },
                _name: {
                    value: xt.nm
                },
                ix: {
                    value: xt.ix
                },
                propertyIndex: {
                    value: xt.ix
                },
                mn: {
                    value: xt.mn
                },
                propertyGroup: {
                    value: as
                }
            }),
            Cs
        }
          , ShapeExpressionInterface = function() {
            function xt(xl, wl, _l) {
                var El, Cl = [], $l = xl ? xl.length : 0;
                for (El = 0; El < $l; El += 1)
                    xl[El].ty === "gr" ? Cl.push(Cn(xl[El], wl[El], _l)) : xl[El].ty === "fl" ? Cl.push(as(xl[El], wl[El], _l)) : xl[El].ty === "st" ? Cl.push(Cs(xl[El], wl[El], _l)) : xl[El].ty === "tm" ? Cl.push(Ls(xl[El], wl[El], _l)) : xl[El].ty === "tr" || (xl[El].ty === "el" ? Cl.push(Ws(xl[El], wl[El], _l)) : xl[El].ty === "sr" ? Cl.push(Xs(xl[El], wl[El], _l)) : xl[El].ty === "sh" ? Cl.push(ShapePathInterface(xl[El], wl[El], _l)) : xl[El].ty === "rc" ? Cl.push(ga(xl[El], wl[El], _l)) : xl[El].ty === "rd" ? Cl.push(ba(xl[El], wl[El], _l)) : xl[El].ty === "rp" ? Cl.push(yl(xl[El], wl[El], _l)) : xl[El].ty === "gf" ? Cl.push(cs(xl[El], wl[El], _l)) : Cl.push((xl[El],
                    wl[El],
                    function() {
                        return null
                    }
                    )));
                return Cl
            }
            function Cn(xl, wl, _l) {
                var El = function(Sl) {
                    switch (Sl) {
                    case "ADBE Vectors Group":
                    case "Contents":
                    case 2:
                        return El.content;
                    default:
                        return El.transform
                    }
                };
                El.propertyGroup = propertyGroupFactory(El, _l);
                var Cl = function(Sl, Tl, Rl) {
                    var Il, Ml = function(Ll) {
                        for (var Fl = 0, Ul = Il.length; Fl < Ul; ) {
                            if (Il[Fl]._name === Ll || Il[Fl].mn === Ll || Il[Fl].propertyIndex === Ll || Il[Fl].ix === Ll || Il[Fl].ind === Ll)
                                return Il[Fl];
                            Fl += 1
                        }
                        return typeof Ll == "number" ? Il[Ll - 1] : null
                    };
                    Ml.propertyGroup = propertyGroupFactory(Ml, Rl),
                    Il = xt(Sl.it, Tl.it, Ml.propertyGroup),
                    Ml.numProperties = Il.length;
                    var Nl = Vs(Sl.it[Sl.it.length - 1], Tl.it[Tl.it.length - 1], Ml.propertyGroup);
                    return Ml.transform = Nl,
                    Ml.propertyIndex = Sl.cix,
                    Ml._name = Sl.nm,
                    Ml
                }(xl, wl, El.propertyGroup)
                  , $l = Vs(xl.it[xl.it.length - 1], wl.it[wl.it.length - 1], El.propertyGroup);
                return El.content = Cl,
                El.transform = $l,
                Object.defineProperty(El, "_name", {
                    get: function() {
                        return xl.nm
                    }
                }),
                El.numProperties = xl.np,
                El.propertyIndex = xl.ix,
                El.nm = xl.nm,
                El.mn = xl.mn,
                El
            }
            function as(xl, wl, _l) {
                function El(Cl) {
                    return Cl === "Color" || Cl === "color" ? El.color : Cl === "Opacity" || Cl === "opacity" ? El.opacity : null
                }
                return Object.defineProperties(El, {
                    color: {
                        get: ExpressionPropertyInterface(wl.c)
                    },
                    opacity: {
                        get: ExpressionPropertyInterface(wl.o)
                    },
                    _name: {
                        value: xl.nm
                    },
                    mn: {
                        value: xl.mn
                    }
                }),
                wl.c.setGroupProperty(PropertyInterface("Color", _l)),
                wl.o.setGroupProperty(PropertyInterface("Opacity", _l)),
                El
            }
            function cs(xl, wl, _l) {
                function El(Cl) {
                    return Cl === "Start Point" || Cl === "start point" ? El.startPoint : Cl === "End Point" || Cl === "end point" ? El.endPoint : Cl === "Opacity" || Cl === "opacity" ? El.opacity : null
                }
                return Object.defineProperties(El, {
                    startPoint: {
                        get: ExpressionPropertyInterface(wl.s)
                    },
                    endPoint: {
                        get: ExpressionPropertyInterface(wl.e)
                    },
                    opacity: {
                        get: ExpressionPropertyInterface(wl.o)
                    },
                    type: {
                        get: function() {
                            return "a"
                        }
                    },
                    _name: {
                        value: xl.nm
                    },
                    mn: {
                        value: xl.mn
                    }
                }),
                wl.s.setGroupProperty(PropertyInterface("Start Point", _l)),
                wl.e.setGroupProperty(PropertyInterface("End Point", _l)),
                wl.o.setGroupProperty(PropertyInterface("Opacity", _l)),
                El
            }
            function Cs(xl, wl, _l) {
                var El, Cl = propertyGroupFactory(Il, _l), $l = propertyGroupFactory(Rl, Cl);
                function Sl(Ml) {
                    Object.defineProperty(Rl, xl.d[Ml].nm, {
                        get: ExpressionPropertyInterface(wl.d.dataProps[Ml].p)
                    })
                }
                var Tl = xl.d ? xl.d.length : 0
                  , Rl = {};
                for (El = 0; El < Tl; El += 1)
                    Sl(El),
                    wl.d.dataProps[El].p.setGroupProperty($l);
                function Il(Ml) {
                    return Ml === "Color" || Ml === "color" ? Il.color : Ml === "Opacity" || Ml === "opacity" ? Il.opacity : Ml === "Stroke Width" || Ml === "stroke width" ? Il.strokeWidth : null
                }
                return Object.defineProperties(Il, {
                    color: {
                        get: ExpressionPropertyInterface(wl.c)
                    },
                    opacity: {
                        get: ExpressionPropertyInterface(wl.o)
                    },
                    strokeWidth: {
                        get: ExpressionPropertyInterface(wl.w)
                    },
                    dash: {
                        get: function() {
                            return Rl
                        }
                    },
                    _name: {
                        value: xl.nm
                    },
                    mn: {
                        value: xl.mn
                    }
                }),
                wl.c.setGroupProperty(PropertyInterface("Color", Cl)),
                wl.o.setGroupProperty(PropertyInterface("Opacity", Cl)),
                wl.w.setGroupProperty(PropertyInterface("Stroke Width", Cl)),
                Il
            }
            function Ls(xl, wl, _l) {
                function El($l) {
                    return $l === xl.e.ix || $l === "End" || $l === "end" ? El.end : $l === xl.s.ix ? El.start : $l === xl.o.ix ? El.offset : null
                }
                var Cl = propertyGroupFactory(El, _l);
                return El.propertyIndex = xl.ix,
                wl.s.setGroupProperty(PropertyInterface("Start", Cl)),
                wl.e.setGroupProperty(PropertyInterface("End", Cl)),
                wl.o.setGroupProperty(PropertyInterface("Offset", Cl)),
                El.propertyIndex = xl.ix,
                El.propertyGroup = _l,
                Object.defineProperties(El, {
                    start: {
                        get: ExpressionPropertyInterface(wl.s)
                    },
                    end: {
                        get: ExpressionPropertyInterface(wl.e)
                    },
                    offset: {
                        get: ExpressionPropertyInterface(wl.o)
                    },
                    _name: {
                        value: xl.nm
                    }
                }),
                El.mn = xl.mn,
                El
            }
            function Vs(xl, wl, _l) {
                function El($l) {
                    return xl.a.ix === $l || $l === "Anchor Point" ? El.anchorPoint : xl.o.ix === $l || $l === "Opacity" ? El.opacity : xl.p.ix === $l || $l === "Position" ? El.position : xl.r.ix === $l || $l === "Rotation" || $l === "ADBE Vector Rotation" ? El.rotation : xl.s.ix === $l || $l === "Scale" ? El.scale : xl.sk && xl.sk.ix === $l || $l === "Skew" ? El.skew : xl.sa && xl.sa.ix === $l || $l === "Skew Axis" ? El.skewAxis : null
                }
                var Cl = propertyGroupFactory(El, _l);
                return wl.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", Cl)),
                wl.transform.mProps.p.setGroupProperty(PropertyInterface("Position", Cl)),
                wl.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", Cl)),
                wl.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", Cl)),
                wl.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", Cl)),
                wl.transform.mProps.sk && (wl.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", Cl)),
                wl.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", Cl))),
                wl.transform.op.setGroupProperty(PropertyInterface("Opacity", Cl)),
                Object.defineProperties(El, {
                    opacity: {
                        get: ExpressionPropertyInterface(wl.transform.mProps.o)
                    },
                    position: {
                        get: ExpressionPropertyInterface(wl.transform.mProps.p)
                    },
                    anchorPoint: {
                        get: ExpressionPropertyInterface(wl.transform.mProps.a)
                    },
                    scale: {
                        get: ExpressionPropertyInterface(wl.transform.mProps.s)
                    },
                    rotation: {
                        get: ExpressionPropertyInterface(wl.transform.mProps.r)
                    },
                    skew: {
                        get: ExpressionPropertyInterface(wl.transform.mProps.sk)
                    },
                    skewAxis: {
                        get: ExpressionPropertyInterface(wl.transform.mProps.sa)
                    },
                    _name: {
                        value: xl.nm
                    }
                }),
                El.ty = "tr",
                El.mn = xl.mn,
                El.propertyGroup = _l,
                El
            }
            function Ws(xl, wl, _l) {
                function El(Sl) {
                    return xl.p.ix === Sl ? El.position : xl.s.ix === Sl ? El.size : null
                }
                var Cl = propertyGroupFactory(El, _l);
                El.propertyIndex = xl.ix;
                var $l = wl.sh.ty === "tm" ? wl.sh.prop : wl.sh;
                return $l.s.setGroupProperty(PropertyInterface("Size", Cl)),
                $l.p.setGroupProperty(PropertyInterface("Position", Cl)),
                Object.defineProperties(El, {
                    size: {
                        get: ExpressionPropertyInterface($l.s)
                    },
                    position: {
                        get: ExpressionPropertyInterface($l.p)
                    },
                    _name: {
                        value: xl.nm
                    }
                }),
                El.mn = xl.mn,
                El
            }
            function Xs(xl, wl, _l) {
                function El(Sl) {
                    return xl.p.ix === Sl ? El.position : xl.r.ix === Sl ? El.rotation : xl.pt.ix === Sl ? El.points : xl.or.ix === Sl || Sl === "ADBE Vector Star Outer Radius" ? El.outerRadius : xl.os.ix === Sl ? El.outerRoundness : !xl.ir || xl.ir.ix !== Sl && Sl !== "ADBE Vector Star Inner Radius" ? xl.is && xl.is.ix === Sl ? El.innerRoundness : null : El.innerRadius
                }
                var Cl = propertyGroupFactory(El, _l)
                  , $l = wl.sh.ty === "tm" ? wl.sh.prop : wl.sh;
                return El.propertyIndex = xl.ix,
                $l.or.setGroupProperty(PropertyInterface("Outer Radius", Cl)),
                $l.os.setGroupProperty(PropertyInterface("Outer Roundness", Cl)),
                $l.pt.setGroupProperty(PropertyInterface("Points", Cl)),
                $l.p.setGroupProperty(PropertyInterface("Position", Cl)),
                $l.r.setGroupProperty(PropertyInterface("Rotation", Cl)),
                xl.ir && ($l.ir.setGroupProperty(PropertyInterface("Inner Radius", Cl)),
                $l.is.setGroupProperty(PropertyInterface("Inner Roundness", Cl))),
                Object.defineProperties(El, {
                    position: {
                        get: ExpressionPropertyInterface($l.p)
                    },
                    rotation: {
                        get: ExpressionPropertyInterface($l.r)
                    },
                    points: {
                        get: ExpressionPropertyInterface($l.pt)
                    },
                    outerRadius: {
                        get: ExpressionPropertyInterface($l.or)
                    },
                    outerRoundness: {
                        get: ExpressionPropertyInterface($l.os)
                    },
                    innerRadius: {
                        get: ExpressionPropertyInterface($l.ir)
                    },
                    innerRoundness: {
                        get: ExpressionPropertyInterface($l.is)
                    },
                    _name: {
                        value: xl.nm
                    }
                }),
                El.mn = xl.mn,
                El
            }
            function ga(xl, wl, _l) {
                function El(Sl) {
                    return xl.p.ix === Sl ? El.position : xl.r.ix === Sl ? El.roundness : xl.s.ix === Sl || Sl === "Size" || Sl === "ADBE Vector Rect Size" ? El.size : null
                }
                var Cl = propertyGroupFactory(El, _l)
                  , $l = wl.sh.ty === "tm" ? wl.sh.prop : wl.sh;
                return El.propertyIndex = xl.ix,
                $l.p.setGroupProperty(PropertyInterface("Position", Cl)),
                $l.s.setGroupProperty(PropertyInterface("Size", Cl)),
                $l.r.setGroupProperty(PropertyInterface("Rotation", Cl)),
                Object.defineProperties(El, {
                    position: {
                        get: ExpressionPropertyInterface($l.p)
                    },
                    roundness: {
                        get: ExpressionPropertyInterface($l.r)
                    },
                    size: {
                        get: ExpressionPropertyInterface($l.s)
                    },
                    _name: {
                        value: xl.nm
                    }
                }),
                El.mn = xl.mn,
                El
            }
            function ba(xl, wl, _l) {
                function El(Sl) {
                    return xl.r.ix === Sl || Sl === "Round Corners 1" ? El.radius : null
                }
                var Cl = propertyGroupFactory(El, _l)
                  , $l = wl;
                return El.propertyIndex = xl.ix,
                $l.rd.setGroupProperty(PropertyInterface("Radius", Cl)),
                Object.defineProperties(El, {
                    radius: {
                        get: ExpressionPropertyInterface($l.rd)
                    },
                    _name: {
                        value: xl.nm
                    }
                }),
                El.mn = xl.mn,
                El
            }
            function yl(xl, wl, _l) {
                function El(Sl) {
                    return xl.c.ix === Sl || Sl === "Copies" ? El.copies : xl.o.ix === Sl || Sl === "Offset" ? El.offset : null
                }
                var Cl = propertyGroupFactory(El, _l)
                  , $l = wl;
                return El.propertyIndex = xl.ix,
                $l.c.setGroupProperty(PropertyInterface("Copies", Cl)),
                $l.o.setGroupProperty(PropertyInterface("Offset", Cl)),
                Object.defineProperties(El, {
                    copies: {
                        get: ExpressionPropertyInterface($l.c)
                    },
                    offset: {
                        get: ExpressionPropertyInterface($l.o)
                    },
                    _name: {
                        value: xl.nm
                    }
                }),
                El.mn = xl.mn,
                El
            }
            return function(xl, wl, _l) {
                var El;
                function Cl($l) {
                    if (typeof $l == "number")
                        return ($l = $l === void 0 ? 1 : $l) === 0 ? _l : El[$l - 1];
                    for (var Sl = 0, Tl = El.length; Sl < Tl; ) {
                        if (El[Sl]._name === $l)
                            return El[Sl];
                        Sl += 1
                    }
                    return null
                }
                return Cl.propertyGroup = propertyGroupFactory(Cl, function() {
                    return _l
                }),
                El = xt(xl, wl, Cl.propertyGroup),
                Cl.numProperties = El.length,
                Cl._name = "Contents",
                Cl
            }
        }()
          , TextExpressionInterface = function(xt) {
            var Cn;
            function as(cs) {
                return cs === "ADBE Text Document" ? as.sourceText : null
            }
            return Object.defineProperty(as, "sourceText", {
                get: function() {
                    xt.textProperty.getValue();
                    var cs = xt.textProperty.currentData.t;
                    return Cn && cs === Cn.value || ((Cn = new String(cs)).value = cs || new String(cs),
                    Object.defineProperty(Cn, "style", {
                        get: function() {
                            return {
                                fillColor: xt.textProperty.currentData.fc
                            }
                        }
                    })),
                    Cn
                }
            }),
            as
        };
        function _typeof(xt) {
            return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Cn) {
                return typeof Cn
            }
            : function(Cn) {
                return Cn && typeof Symbol == "function" && Cn.constructor === Symbol && Cn !== Symbol.prototype ? "symbol" : typeof Cn
            }
            ,
            _typeof(xt)
        }
        var FootageInterface = (dataInterfaceFactory = function(xt) {
            function Cn(as) {
                return as === "Outline" ? Cn.outlineInterface() : null
            }
            return Cn._name = "Outline",
            Cn.outlineInterface = function(as) {
                var cs = ""
                  , Cs = as.getFootageData();
                function Ls(Vs) {
                    if (Cs[Vs])
                        return cs = Vs,
                        _typeof(Cs = Cs[Vs]) === "object" ? Ls : Cs;
                    var Ws = Vs.indexOf(cs);
                    if (Ws !== -1) {
                        var Xs = parseInt(Vs.substr(Ws + cs.length), 10);
                        return _typeof(Cs = Cs[Xs]) === "object" ? Ls : Cs
                    }
                    return ""
                }
                return function() {
                    return cs = "",
                    Cs = as.getFootageData(),
                    Ls
                }
            }(xt),
            Cn
        }
        ,
        function(xt) {
            function Cn(as) {
                return as === "Data" ? Cn.dataInterface : null
            }
            return Cn._name = "Data",
            Cn.dataInterface = dataInterfaceFactory(xt),
            Cn
        }
        ), dataInterfaceFactory, interfaces = {
            layer: LayerExpressionInterface,
            effects: EffectsExpressionInterface,
            comp: CompExpressionInterface,
            shape: ShapeExpressionInterface,
            text: TextExpressionInterface,
            footage: FootageInterface
        };
        function getInterface(xt) {
            return interfaces[xt] || null
        }
        var expressionHelpers = {
            searchExpressions: function(xt, Cn, as) {
                Cn.x && (as.k = !0,
                as.x = !0,
                as.initiateExpression = ExpressionManager.initiateExpression,
                as.effectsSequence.push(as.initiateExpression(xt, Cn, as).bind(as)))
            },
            getSpeedAtTime: function(xt) {
                var Cn = this.getValueAtTime(xt)
                  , as = this.getValueAtTime(xt + -.01)
                  , cs = 0;
                if (Cn.length) {
                    var Cs;
                    for (Cs = 0; Cs < Cn.length; Cs += 1)
                        cs += Math.pow(as[Cs] - Cn[Cs], 2);
                    cs = 100 * Math.sqrt(cs)
                } else
                    cs = 0;
                return cs
            },
            getVelocityAtTime: function(xt) {
                if (this.vel !== void 0)
                    return this.vel;
                var Cn, as, cs = -.001, Cs = this.getValueAtTime(xt), Ls = this.getValueAtTime(xt + cs);
                if (Cs.length)
                    for (Cn = createTypedArray("float32", Cs.length),
                    as = 0; as < Cs.length; as += 1)
                        Cn[as] = (Ls[as] - Cs[as]) / cs;
                else
                    Cn = (Ls - Cs) / cs;
                return Cn
            },
            getValueAtTime: function(xt) {
                return xt *= this.elem.globalData.frameRate,
                (xt -= this.offsetTime) !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < xt ? this._cachingAtTime.lastIndex : 0,
                this._cachingAtTime.value = this.interpolateValue(xt, this._cachingAtTime),
                this._cachingAtTime.lastFrame = xt),
                this._cachingAtTime.value
            },
            getStaticValueAtTime: function() {
                return this.pv
            },
            setGroupProperty: function(xt) {
                this.propertyGroup = xt
            }
        };
        function addPropertyDecorator() {
            function xt(yl, xl, wl) {
                if (!this.k || !this.keyframes)
                    return this.pv;
                yl = yl ? yl.toLowerCase() : "";
                var _l, El, Cl, $l, Sl, Tl = this.comp.renderedFrame, Rl = this.keyframes, Il = Rl[Rl.length - 1].t;
                if (Tl <= Il)
                    return this.pv;
                if (wl ? El = Il - (_l = xl ? Math.abs(Il - this.elem.comp.globalData.frameRate * xl) : Math.max(0, Il - this.elem.data.ip)) : ((!xl || xl > Rl.length - 1) && (xl = Rl.length - 1),
                _l = Il - (El = Rl[Rl.length - 1 - xl].t)),
                yl === "pingpong") {
                    if (Math.floor((Tl - El) / _l) % 2 != 0)
                        return this.getValueAtTime((_l - (Tl - El) % _l + El) / this.comp.globalData.frameRate, 0)
                } else {
                    if (yl === "offset") {
                        var Ml = this.getValueAtTime(El / this.comp.globalData.frameRate, 0)
                          , Nl = this.getValueAtTime(Il / this.comp.globalData.frameRate, 0)
                          , Ll = this.getValueAtTime(((Tl - El) % _l + El) / this.comp.globalData.frameRate, 0)
                          , Fl = Math.floor((Tl - El) / _l);
                        if (this.pv.length) {
                            for ($l = (Sl = new Array(Ml.length)).length,
                            Cl = 0; Cl < $l; Cl += 1)
                                Sl[Cl] = (Nl[Cl] - Ml[Cl]) * Fl + Ll[Cl];
                            return Sl
                        }
                        return (Nl - Ml) * Fl + Ll
                    }
                    if (yl === "continue") {
                        var Ul = this.getValueAtTime(Il / this.comp.globalData.frameRate, 0)
                          , Dl = this.getValueAtTime((Il - .001) / this.comp.globalData.frameRate, 0);
                        if (this.pv.length) {
                            for ($l = (Sl = new Array(Ul.length)).length,
                            Cl = 0; Cl < $l; Cl += 1)
                                Sl[Cl] = Ul[Cl] + (Ul[Cl] - Dl[Cl]) * ((Tl - Il) / this.comp.globalData.frameRate) / 5e-4;
                            return Sl
                        }
                        return Ul + (Tl - Il) / .001 * (Ul - Dl)
                    }
                }
                return this.getValueAtTime(((Tl - El) % _l + El) / this.comp.globalData.frameRate, 0)
            }
            function Cn(yl, xl, wl) {
                if (!this.k)
                    return this.pv;
                yl = yl ? yl.toLowerCase() : "";
                var _l, El, Cl, $l, Sl, Tl = this.comp.renderedFrame, Rl = this.keyframes, Il = Rl[0].t;
                if (Tl >= Il)
                    return this.pv;
                if (wl ? El = Il + (_l = xl ? Math.abs(this.elem.comp.globalData.frameRate * xl) : Math.max(0, this.elem.data.op - Il)) : ((!xl || xl > Rl.length - 1) && (xl = Rl.length - 1),
                _l = (El = Rl[xl].t) - Il),
                yl === "pingpong") {
                    if (Math.floor((Il - Tl) / _l) % 2 == 0)
                        return this.getValueAtTime(((Il - Tl) % _l + Il) / this.comp.globalData.frameRate, 0)
                } else {
                    if (yl === "offset") {
                        var Ml = this.getValueAtTime(Il / this.comp.globalData.frameRate, 0)
                          , Nl = this.getValueAtTime(El / this.comp.globalData.frameRate, 0)
                          , Ll = this.getValueAtTime((_l - (Il - Tl) % _l + Il) / this.comp.globalData.frameRate, 0)
                          , Fl = Math.floor((Il - Tl) / _l) + 1;
                        if (this.pv.length) {
                            for ($l = (Sl = new Array(Ml.length)).length,
                            Cl = 0; Cl < $l; Cl += 1)
                                Sl[Cl] = Ll[Cl] - (Nl[Cl] - Ml[Cl]) * Fl;
                            return Sl
                        }
                        return Ll - (Nl - Ml) * Fl
                    }
                    if (yl === "continue") {
                        var Ul = this.getValueAtTime(Il / this.comp.globalData.frameRate, 0)
                          , Dl = this.getValueAtTime((Il + .001) / this.comp.globalData.frameRate, 0);
                        if (this.pv.length) {
                            for ($l = (Sl = new Array(Ul.length)).length,
                            Cl = 0; Cl < $l; Cl += 1)
                                Sl[Cl] = Ul[Cl] + (Ul[Cl] - Dl[Cl]) * (Il - Tl) / .001;
                            return Sl
                        }
                        return Ul + (Ul - Dl) * (Il - Tl) / .001
                    }
                }
                return this.getValueAtTime((_l - ((Il - Tl) % _l + Il)) / this.comp.globalData.frameRate, 0)
            }
            function as(yl, xl) {
                if (!this.k)
                    return this.pv;
                if (yl = .5 * (yl || .4),
                (xl = Math.floor(xl || 5)) <= 1)
                    return this.pv;
                var wl, _l, El = this.comp.renderedFrame / this.comp.globalData.frameRate, Cl = El - yl, $l = xl > 1 ? (El + yl - Cl) / (xl - 1) : 1, Sl = 0, Tl = 0;
                for (wl = this.pv.length ? createTypedArray("float32", this.pv.length) : 0; Sl < xl; ) {
                    if (_l = this.getValueAtTime(Cl + Sl * $l),
                    this.pv.length)
                        for (Tl = 0; Tl < this.pv.length; Tl += 1)
                            wl[Tl] += _l[Tl];
                    else
                        wl += _l;
                    Sl += 1
                }
                if (this.pv.length)
                    for (Tl = 0; Tl < this.pv.length; Tl += 1)
                        wl[Tl] /= xl;
                else
                    wl /= xl;
                return wl
            }
            function cs(yl) {
                this._transformCachingAtTime || (this._transformCachingAtTime = {
                    v: new Matrix
                });
                var xl = this._transformCachingAtTime.v;
                if (xl.cloneFromProps(this.pre.props),
                this.appliedTransformations < 1) {
                    var wl = this.a.getValueAtTime(yl);
                    xl.translate(-wl[0] * this.a.mult, -wl[1] * this.a.mult, wl[2] * this.a.mult)
                }
                if (this.appliedTransformations < 2) {
                    var _l = this.s.getValueAtTime(yl);
                    xl.scale(_l[0] * this.s.mult, _l[1] * this.s.mult, _l[2] * this.s.mult)
                }
                if (this.sk && this.appliedTransformations < 3) {
                    var El = this.sk.getValueAtTime(yl)
                      , Cl = this.sa.getValueAtTime(yl);
                    xl.skewFromAxis(-El * this.sk.mult, Cl * this.sa.mult)
                }
                if (this.r && this.appliedTransformations < 4) {
                    var $l = this.r.getValueAtTime(yl);
                    xl.rotate(-$l * this.r.mult)
                } else if (!this.r && this.appliedTransformations < 4) {
                    var Sl = this.rz.getValueAtTime(yl)
                      , Tl = this.ry.getValueAtTime(yl)
                      , Rl = this.rx.getValueAtTime(yl)
                      , Il = this.or.getValueAtTime(yl);
                    xl.rotateZ(-Sl * this.rz.mult).rotateY(Tl * this.ry.mult).rotateX(Rl * this.rx.mult).rotateZ(-Il[2] * this.or.mult).rotateY(Il[1] * this.or.mult).rotateX(Il[0] * this.or.mult)
                }
                if (this.data.p && this.data.p.s) {
                    var Ml = this.px.getValueAtTime(yl)
                      , Nl = this.py.getValueAtTime(yl);
                    if (this.data.p.z) {
                        var Ll = this.pz.getValueAtTime(yl);
                        xl.translate(Ml * this.px.mult, Nl * this.py.mult, -Ll * this.pz.mult)
                    } else
                        xl.translate(Ml * this.px.mult, Nl * this.py.mult, 0)
                } else {
                    var Fl = this.p.getValueAtTime(yl);
                    xl.translate(Fl[0] * this.p.mult, Fl[1] * this.p.mult, -Fl[2] * this.p.mult)
                }
                return xl
            }
            function Cs() {
                return this.v.clone(new Matrix)
            }
            var Ls = TransformPropertyFactory.getTransformProperty;
            TransformPropertyFactory.getTransformProperty = function(yl, xl, wl) {
                var _l = Ls(yl, xl, wl);
                return _l.dynamicProperties.length ? _l.getValueAtTime = cs.bind(_l) : _l.getValueAtTime = Cs.bind(_l),
                _l.setGroupProperty = expressionHelpers.setGroupProperty,
                _l
            }
            ;
            var Vs = PropertyFactory.getProp;
            PropertyFactory.getProp = function(yl, xl, wl, _l, El) {
                var Cl = Vs(yl, xl, wl, _l, El);
                Cl.kf ? Cl.getValueAtTime = expressionHelpers.getValueAtTime.bind(Cl) : Cl.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(Cl),
                Cl.setGroupProperty = expressionHelpers.setGroupProperty,
                Cl.loopOut = xt,
                Cl.loopIn = Cn,
                Cl.smooth = as,
                Cl.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(Cl),
                Cl.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(Cl),
                Cl.numKeys = xl.a === 1 ? xl.k.length : 0,
                Cl.propertyIndex = xl.ix;
                var $l = 0;
                return wl !== 0 && ($l = createTypedArray("float32", xl.a === 1 ? xl.k[0].s.length : xl.k.length)),
                Cl._cachingAtTime = {
                    lastFrame: initialDefaultFrame,
                    lastIndex: 0,
                    value: $l
                },
                expressionHelpers.searchExpressions(yl, xl, Cl),
                Cl.k && El.addDynamicProperty(Cl),
                Cl
            }
            ;
            var Ws = ShapePropertyFactory.getConstructorFunction()
              , Xs = ShapePropertyFactory.getKeyframedConstructorFunction();
            function ga() {}
            ga.prototype = {
                vertices: function(yl, xl) {
                    this.k && this.getValue();
                    var wl, _l = this.v;
                    xl !== void 0 && (_l = this.getValueAtTime(xl, 0));
                    var El = _l._length
                      , Cl = _l[yl]
                      , $l = _l.v
                      , Sl = createSizedArray(El);
                    for (wl = 0; wl < El; wl += 1)
                        Sl[wl] = yl === "i" || yl === "o" ? [Cl[wl][0] - $l[wl][0], Cl[wl][1] - $l[wl][1]] : [Cl[wl][0], Cl[wl][1]];
                    return Sl
                },
                points: function(yl) {
                    return this.vertices("v", yl)
                },
                inTangents: function(yl) {
                    return this.vertices("i", yl)
                },
                outTangents: function(yl) {
                    return this.vertices("o", yl)
                },
                isClosed: function() {
                    return this.v.c
                },
                pointOnPath: function(yl, xl) {
                    var wl = this.v;
                    xl !== void 0 && (wl = this.getValueAtTime(xl, 0)),
                    this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(wl));
                    for (var _l, El = this._segmentsLength, Cl = El.lengths, $l = El.totalLength * yl, Sl = 0, Tl = Cl.length, Rl = 0; Sl < Tl; ) {
                        if (Rl + Cl[Sl].addedLength > $l) {
                            var Il = Sl
                              , Ml = wl.c && Sl === Tl - 1 ? 0 : Sl + 1
                              , Nl = ($l - Rl) / Cl[Sl].addedLength;
                            _l = bez.getPointInSegment(wl.v[Il], wl.v[Ml], wl.o[Il], wl.i[Ml], Nl, Cl[Sl]);
                            break
                        }
                        Rl += Cl[Sl].addedLength,
                        Sl += 1
                    }
                    return _l || (_l = wl.c ? [wl.v[0][0], wl.v[0][1]] : [wl.v[wl._length - 1][0], wl.v[wl._length - 1][1]]),
                    _l
                },
                vectorOnPath: function(yl, xl, wl) {
                    yl == 1 ? yl = this.v.c : yl == 0 && (yl = .999);
                    var _l = this.pointOnPath(yl, xl)
                      , El = this.pointOnPath(yl + .001, xl)
                      , Cl = El[0] - _l[0]
                      , $l = El[1] - _l[1]
                      , Sl = Math.sqrt(Math.pow(Cl, 2) + Math.pow($l, 2));
                    return Sl === 0 ? [0, 0] : wl === "tangent" ? [Cl / Sl, $l / Sl] : [-$l / Sl, Cl / Sl]
                },
                tangentOnPath: function(yl, xl) {
                    return this.vectorOnPath(yl, xl, "tangent")
                },
                normalOnPath: function(yl, xl) {
                    return this.vectorOnPath(yl, xl, "normal")
                },
                setGroupProperty: expressionHelpers.setGroupProperty,
                getValueAtTime: expressionHelpers.getStaticValueAtTime
            },
            extendPrototype([ga], Ws),
            extendPrototype([ga], Xs),
            Xs.prototype.getValueAtTime = function(yl) {
                return this._cachingAtTime || (this._cachingAtTime = {
                    shapeValue: shapePool.clone(this.pv),
                    lastIndex: 0,
                    lastTime: initialDefaultFrame
                }),
                yl *= this.elem.globalData.frameRate,
                (yl -= this.offsetTime) !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < yl ? this._caching.lastIndex : 0,
                this._cachingAtTime.lastTime = yl,
                this.interpolateShape(yl, this._cachingAtTime.shapeValue, this._cachingAtTime)),
                this._cachingAtTime.shapeValue
            }
            ,
            Xs.prototype.initiateExpression = ExpressionManager.initiateExpression;
            var ba = ShapePropertyFactory.getShapeProp;
            ShapePropertyFactory.getShapeProp = function(yl, xl, wl, _l, El) {
                var Cl = ba(yl, xl, wl, _l, El);
                return Cl.propertyIndex = xl.ix,
                Cl.lock = !1,
                wl === 3 ? expressionHelpers.searchExpressions(yl, xl.pt, Cl) : wl === 4 && expressionHelpers.searchExpressions(yl, xl.ks, Cl),
                Cl.k && yl.addDynamicProperty(Cl),
                Cl
            }
        }
        function initialize$1() {
            addPropertyDecorator()
        }
        function addDecorator() {
            TextProperty.prototype.getExpressionValue = function(xt, Cn) {
                var as = this.calculateExpression(Cn);
                if (xt.t !== as) {
                    var cs = {};
                    return this.copyData(cs, xt),
                    cs.t = as.toString(),
                    cs.__complete = !1,
                    cs
                }
                return xt
            }
            ,
            TextProperty.prototype.searchProperty = function() {
                var xt = this.searchKeyframes()
                  , Cn = this.searchExpressions();
                return this.kf = xt || Cn,
                this.kf
            }
            ,
            TextProperty.prototype.searchExpressions = function() {
                return this.data.d.x ? (this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this),
                this.addEffect(this.getExpressionValue.bind(this)),
                !0) : null
            }
        }
        function initialize() {
            addDecorator()
        }
        function SVGComposableEffect() {}
        SVGComposableEffect.prototype = {
            createMergeNode: function(xt, Cn) {
                var as, cs, Cs = createNS("feMerge");
                for (Cs.setAttribute("result", xt),
                cs = 0; cs < Cn.length; cs += 1)
                    (as = createNS("feMergeNode")).setAttribute("in", Cn[cs]),
                    Cs.appendChild(as),
                    Cs.appendChild(as);
                return Cs
            }
        };
        var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
        function SVGTintFilter(xt, Cn, as, cs, Cs) {
            this.filterManager = Cn;
            var Ls = createNS("feColorMatrix");
            Ls.setAttribute("type", "matrix"),
            Ls.setAttribute("color-interpolation-filters", "linearRGB"),
            Ls.setAttribute("values", linearFilterValue + " 1 0"),
            this.linearFilter = Ls,
            Ls.setAttribute("result", cs + "_tint_1"),
            xt.appendChild(Ls),
            (Ls = createNS("feColorMatrix")).setAttribute("type", "matrix"),
            Ls.setAttribute("color-interpolation-filters", "sRGB"),
            Ls.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
            Ls.setAttribute("result", cs + "_tint_2"),
            xt.appendChild(Ls),
            this.matrixFilter = Ls;
            var Vs = this.createMergeNode(cs, [Cs, cs + "_tint_1", cs + "_tint_2"]);
            xt.appendChild(Vs)
        }
        function SVGFillFilter(xt, Cn, as, cs) {
            this.filterManager = Cn;
            var Cs = createNS("feColorMatrix");
            Cs.setAttribute("type", "matrix"),
            Cs.setAttribute("color-interpolation-filters", "sRGB"),
            Cs.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
            Cs.setAttribute("result", cs),
            xt.appendChild(Cs),
            this.matrixFilter = Cs
        }
        function SVGStrokeEffect(xt, Cn, as) {
            this.initialized = !1,
            this.filterManager = Cn,
            this.elem = as,
            this.paths = []
        }
        function SVGTritoneFilter(xt, Cn, as, cs) {
            this.filterManager = Cn;
            var Cs = createNS("feColorMatrix");
            Cs.setAttribute("type", "matrix"),
            Cs.setAttribute("color-interpolation-filters", "linearRGB"),
            Cs.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"),
            xt.appendChild(Cs);
            var Ls = createNS("feComponentTransfer");
            Ls.setAttribute("color-interpolation-filters", "sRGB"),
            Ls.setAttribute("result", cs),
            this.matrixFilter = Ls;
            var Vs = createNS("feFuncR");
            Vs.setAttribute("type", "table"),
            Ls.appendChild(Vs),
            this.feFuncR = Vs;
            var Ws = createNS("feFuncG");
            Ws.setAttribute("type", "table"),
            Ls.appendChild(Ws),
            this.feFuncG = Ws;
            var Xs = createNS("feFuncB");
            Xs.setAttribute("type", "table"),
            Ls.appendChild(Xs),
            this.feFuncB = Xs,
            xt.appendChild(Ls)
        }
        function SVGProLevelsFilter(xt, Cn, as, cs) {
            this.filterManager = Cn;
            var Cs = this.filterManager.effectElements
              , Ls = createNS("feComponentTransfer");
            (Cs[10].p.k || Cs[10].p.v !== 0 || Cs[11].p.k || Cs[11].p.v !== 1 || Cs[12].p.k || Cs[12].p.v !== 1 || Cs[13].p.k || Cs[13].p.v !== 0 || Cs[14].p.k || Cs[14].p.v !== 1) && (this.feFuncR = this.createFeFunc("feFuncR", Ls)),
            (Cs[17].p.k || Cs[17].p.v !== 0 || Cs[18].p.k || Cs[18].p.v !== 1 || Cs[19].p.k || Cs[19].p.v !== 1 || Cs[20].p.k || Cs[20].p.v !== 0 || Cs[21].p.k || Cs[21].p.v !== 1) && (this.feFuncG = this.createFeFunc("feFuncG", Ls)),
            (Cs[24].p.k || Cs[24].p.v !== 0 || Cs[25].p.k || Cs[25].p.v !== 1 || Cs[26].p.k || Cs[26].p.v !== 1 || Cs[27].p.k || Cs[27].p.v !== 0 || Cs[28].p.k || Cs[28].p.v !== 1) && (this.feFuncB = this.createFeFunc("feFuncB", Ls)),
            (Cs[31].p.k || Cs[31].p.v !== 0 || Cs[32].p.k || Cs[32].p.v !== 1 || Cs[33].p.k || Cs[33].p.v !== 1 || Cs[34].p.k || Cs[34].p.v !== 0 || Cs[35].p.k || Cs[35].p.v !== 1) && (this.feFuncA = this.createFeFunc("feFuncA", Ls)),
            (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (Ls.setAttribute("color-interpolation-filters", "sRGB"),
            xt.appendChild(Ls)),
            (Cs[3].p.k || Cs[3].p.v !== 0 || Cs[4].p.k || Cs[4].p.v !== 1 || Cs[5].p.k || Cs[5].p.v !== 1 || Cs[6].p.k || Cs[6].p.v !== 0 || Cs[7].p.k || Cs[7].p.v !== 1) && ((Ls = createNS("feComponentTransfer")).setAttribute("color-interpolation-filters", "sRGB"),
            Ls.setAttribute("result", cs),
            xt.appendChild(Ls),
            this.feFuncRComposed = this.createFeFunc("feFuncR", Ls),
            this.feFuncGComposed = this.createFeFunc("feFuncG", Ls),
            this.feFuncBComposed = this.createFeFunc("feFuncB", Ls))
        }
        function SVGDropShadowEffect(xt, Cn, as, cs, Cs) {
            var Ls = Cn.container.globalData.renderConfig.filterSize
              , Vs = Cn.data.fs || Ls;
            xt.setAttribute("x", Vs.x || Ls.x),
            xt.setAttribute("y", Vs.y || Ls.y),
            xt.setAttribute("width", Vs.width || Ls.width),
            xt.setAttribute("height", Vs.height || Ls.height),
            this.filterManager = Cn;
            var Ws = createNS("feGaussianBlur");
            Ws.setAttribute("in", "SourceAlpha"),
            Ws.setAttribute("result", cs + "_drop_shadow_1"),
            Ws.setAttribute("stdDeviation", "0"),
            this.feGaussianBlur = Ws,
            xt.appendChild(Ws);
            var Xs = createNS("feOffset");
            Xs.setAttribute("dx", "25"),
            Xs.setAttribute("dy", "0"),
            Xs.setAttribute("in", cs + "_drop_shadow_1"),
            Xs.setAttribute("result", cs + "_drop_shadow_2"),
            this.feOffset = Xs,
            xt.appendChild(Xs);
            var ga = createNS("feFlood");
            ga.setAttribute("flood-color", "#00ff00"),
            ga.setAttribute("flood-opacity", "1"),
            ga.setAttribute("result", cs + "_drop_shadow_3"),
            this.feFlood = ga,
            xt.appendChild(ga);
            var ba = createNS("feComposite");
            ba.setAttribute("in", cs + "_drop_shadow_3"),
            ba.setAttribute("in2", cs + "_drop_shadow_2"),
            ba.setAttribute("operator", "in"),
            ba.setAttribute("result", cs + "_drop_shadow_4"),
            xt.appendChild(ba);
            var yl = this.createMergeNode(cs, [cs + "_drop_shadow_4", Cs]);
            xt.appendChild(yl)
        }
        extendPrototype([SVGComposableEffect], SVGTintFilter),
        SVGTintFilter.prototype.renderFrame = function(xt) {
            if (xt || this.filterManager._mdf) {
                var Cn = this.filterManager.effectElements[0].p.v
                  , as = this.filterManager.effectElements[1].p.v
                  , cs = this.filterManager.effectElements[2].p.v / 100;
                this.linearFilter.setAttribute("values", linearFilterValue + " " + cs + " 0"),
                this.matrixFilter.setAttribute("values", as[0] - Cn[0] + " 0 0 0 " + Cn[0] + " " + (as[1] - Cn[1]) + " 0 0 0 " + Cn[1] + " " + (as[2] - Cn[2]) + " 0 0 0 " + Cn[2] + " 0 0 0 1 0")
            }
        }
        ,
        SVGFillFilter.prototype.renderFrame = function(xt) {
            if (xt || this.filterManager._mdf) {
                var Cn = this.filterManager.effectElements[2].p.v
                  , as = this.filterManager.effectElements[6].p.v;
                this.matrixFilter.setAttribute("values", "0 0 0 0 " + Cn[0] + " 0 0 0 0 " + Cn[1] + " 0 0 0 0 " + Cn[2] + " 0 0 0 " + as + " 0")
            }
        }
        ,
        SVGStrokeEffect.prototype.initialize = function() {
            var xt, Cn, as, cs, Cs = this.elem.layerElement.children || this.elem.layerElement.childNodes;
            for (this.filterManager.effectElements[1].p.v === 1 ? (cs = this.elem.maskManager.masksProperties.length,
            as = 0) : cs = 1 + (as = this.filterManager.effectElements[0].p.v - 1),
            (Cn = createNS("g")).setAttribute("fill", "none"),
            Cn.setAttribute("stroke-linecap", "round"),
            Cn.setAttribute("stroke-dashoffset", 1); as < cs; as += 1)
                xt = createNS("path"),
                Cn.appendChild(xt),
                this.paths.push({
                    p: xt,
                    m: as
                });
            if (this.filterManager.effectElements[10].p.v === 3) {
                var Ls = createNS("mask")
                  , Vs = createElementID();
                Ls.setAttribute("id", Vs),
                Ls.setAttribute("mask-type", "alpha"),
                Ls.appendChild(Cn),
                this.elem.globalData.defs.appendChild(Ls);
                var Ws = createNS("g");
                for (Ws.setAttribute("mask", "url(" + getLocationHref() + "#" + Vs + ")"); Cs[0]; )
                    Ws.appendChild(Cs[0]);
                this.elem.layerElement.appendChild(Ws),
                this.masker = Ls,
                Cn.setAttribute("stroke", "#fff")
            } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
                if (this.filterManager.effectElements[10].p.v === 2)
                    for (Cs = this.elem.layerElement.children || this.elem.layerElement.childNodes; Cs.length; )
                        this.elem.layerElement.removeChild(Cs[0]);
                this.elem.layerElement.appendChild(Cn),
                this.elem.layerElement.removeAttribute("mask"),
                Cn.setAttribute("stroke", "#fff")
            }
            this.initialized = !0,
            this.pathMasker = Cn
        }
        ,
        SVGStrokeEffect.prototype.renderFrame = function(xt) {
            var Cn;
            this.initialized || this.initialize();
            var as, cs, Cs = this.paths.length;
            for (Cn = 0; Cn < Cs; Cn += 1)
                if (this.paths[Cn].m !== -1 && (as = this.elem.maskManager.viewData[this.paths[Cn].m],
                cs = this.paths[Cn].p,
                (xt || this.filterManager._mdf || as.prop._mdf) && cs.setAttribute("d", as.lastPath),
                xt || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || as.prop._mdf)) {
                    var Ls;
                    if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
                        var Vs = .01 * Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v)
                          , Ws = .01 * Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v)
                          , Xs = cs.getTotalLength();
                        Ls = "0 0 0 " + Xs * Vs + " ";
                        var ga, ba = Xs * (Ws - Vs), yl = 1 + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01, xl = Math.floor(ba / yl);
                        for (ga = 0; ga < xl; ga += 1)
                            Ls += "1 " + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01 + " ";
                        Ls += "0 " + 10 * Xs + " 0 0"
                    } else
                        Ls = "1 " + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01;
                    cs.setAttribute("stroke-dasharray", Ls)
                }
            if ((xt || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", 2 * this.filterManager.effectElements[4].p.v),
            (xt || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v),
            (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) && (xt || this.filterManager.effectElements[3].p._mdf)) {
                var wl = this.filterManager.effectElements[3].p.v;
                this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(255 * wl[0]) + "," + bmFloor(255 * wl[1]) + "," + bmFloor(255 * wl[2]) + ")")
            }
        }
        ,
        SVGTritoneFilter.prototype.renderFrame = function(xt) {
            if (xt || this.filterManager._mdf) {
                var Cn = this.filterManager.effectElements[0].p.v
                  , as = this.filterManager.effectElements[1].p.v
                  , cs = this.filterManager.effectElements[2].p.v
                  , Cs = cs[0] + " " + as[0] + " " + Cn[0]
                  , Ls = cs[1] + " " + as[1] + " " + Cn[1]
                  , Vs = cs[2] + " " + as[2] + " " + Cn[2];
                this.feFuncR.setAttribute("tableValues", Cs),
                this.feFuncG.setAttribute("tableValues", Ls),
                this.feFuncB.setAttribute("tableValues", Vs)
            }
        }
        ,
        SVGProLevelsFilter.prototype.createFeFunc = function(xt, Cn) {
            var as = createNS(xt);
            return as.setAttribute("type", "table"),
            Cn.appendChild(as),
            as
        }
        ,
        SVGProLevelsFilter.prototype.getTableValue = function(xt, Cn, as, cs, Cs) {
            for (var Ls, Vs, Ws = 0, Xs = Math.min(xt, Cn), ga = Math.max(xt, Cn), ba = Array.call(null, {
                length: 256
            }), yl = 0, xl = Cs - cs, wl = Cn - xt; Ws <= 256; )
                Vs = (Ls = Ws / 256) <= Xs ? wl < 0 ? Cs : cs : Ls >= ga ? wl < 0 ? cs : Cs : cs + xl * Math.pow((Ls - xt) / wl, 1 / as),
                ba[yl] = Vs,
                yl += 1,
                Ws += 256 / 255;
            return ba.join(" ")
        }
        ,
        SVGProLevelsFilter.prototype.renderFrame = function(xt) {
            if (xt || this.filterManager._mdf) {
                var Cn, as = this.filterManager.effectElements;
                this.feFuncRComposed && (xt || as[3].p._mdf || as[4].p._mdf || as[5].p._mdf || as[6].p._mdf || as[7].p._mdf) && (Cn = this.getTableValue(as[3].p.v, as[4].p.v, as[5].p.v, as[6].p.v, as[7].p.v),
                this.feFuncRComposed.setAttribute("tableValues", Cn),
                this.feFuncGComposed.setAttribute("tableValues", Cn),
                this.feFuncBComposed.setAttribute("tableValues", Cn)),
                this.feFuncR && (xt || as[10].p._mdf || as[11].p._mdf || as[12].p._mdf || as[13].p._mdf || as[14].p._mdf) && (Cn = this.getTableValue(as[10].p.v, as[11].p.v, as[12].p.v, as[13].p.v, as[14].p.v),
                this.feFuncR.setAttribute("tableValues", Cn)),
                this.feFuncG && (xt || as[17].p._mdf || as[18].p._mdf || as[19].p._mdf || as[20].p._mdf || as[21].p._mdf) && (Cn = this.getTableValue(as[17].p.v, as[18].p.v, as[19].p.v, as[20].p.v, as[21].p.v),
                this.feFuncG.setAttribute("tableValues", Cn)),
                this.feFuncB && (xt || as[24].p._mdf || as[25].p._mdf || as[26].p._mdf || as[27].p._mdf || as[28].p._mdf) && (Cn = this.getTableValue(as[24].p.v, as[25].p.v, as[26].p.v, as[27].p.v, as[28].p.v),
                this.feFuncB.setAttribute("tableValues", Cn)),
                this.feFuncA && (xt || as[31].p._mdf || as[32].p._mdf || as[33].p._mdf || as[34].p._mdf || as[35].p._mdf) && (Cn = this.getTableValue(as[31].p.v, as[32].p.v, as[33].p.v, as[34].p.v, as[35].p.v),
                this.feFuncA.setAttribute("tableValues", Cn))
            }
        }
        ,
        extendPrototype([SVGComposableEffect], SVGDropShadowEffect),
        SVGDropShadowEffect.prototype.renderFrame = function(xt) {
            if (xt || this.filterManager._mdf) {
                if ((xt || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4),
                xt || this.filterManager.effectElements[0].p._mdf) {
                    var Cn = this.filterManager.effectElements[0].p.v;
                    this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(255 * Cn[0]), Math.round(255 * Cn[1]), Math.round(255 * Cn[2])))
                }
                if ((xt || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255),
                xt || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
                    var as = this.filterManager.effectElements[3].p.v
                      , cs = (this.filterManager.effectElements[2].p.v - 90) * degToRads
                      , Cs = as * Math.cos(cs)
                      , Ls = as * Math.sin(cs);
                    this.feOffset.setAttribute("dx", Cs),
                    this.feOffset.setAttribute("dy", Ls)
                }
            }
        }
        ;
        var _svgMatteSymbols = [];
        function SVGMatte3Effect(xt, Cn, as) {
            this.initialized = !1,
            this.filterManager = Cn,
            this.filterElem = xt,
            this.elem = as,
            as.matteElement = createNS("g"),
            as.matteElement.appendChild(as.layerElement),
            as.matteElement.appendChild(as.transformedElement),
            as.baseElement = as.matteElement
        }
        function SVGGaussianBlurEffect(xt, Cn, as, cs) {
            xt.setAttribute("x", "-100%"),
            xt.setAttribute("y", "-100%"),
            xt.setAttribute("width", "300%"),
            xt.setAttribute("height", "300%"),
            this.filterManager = Cn;
            var Cs = createNS("feGaussianBlur");
            Cs.setAttribute("result", cs),
            xt.appendChild(Cs),
            this.feGaussianBlur = Cs
        }
        function TransformEffect() {}
        function SVGTransformEffect(xt, Cn) {
            this.init(Cn)
        }
        function CVTransformEffect(xt) {
            this.init(xt)
        }
        return SVGMatte3Effect.prototype.findSymbol = function(xt) {
            for (var Cn = 0, as = _svgMatteSymbols.length; Cn < as; ) {
                if (_svgMatteSymbols[Cn] === xt)
                    return _svgMatteSymbols[Cn];
                Cn += 1
            }
            return null
        }
        ,
        SVGMatte3Effect.prototype.replaceInParent = function(xt, Cn) {
            var as = xt.layerElement.parentNode;
            if (as) {
                for (var cs, Cs = as.children, Ls = 0, Vs = Cs.length; Ls < Vs && Cs[Ls] !== xt.layerElement; )
                    Ls += 1;
                Ls <= Vs - 2 && (cs = Cs[Ls + 1]);
                var Ws = createNS("use");
                Ws.setAttribute("href", "#" + Cn),
                cs ? as.insertBefore(Ws, cs) : as.appendChild(Ws)
            }
        }
        ,
        SVGMatte3Effect.prototype.setElementAsMask = function(xt, Cn) {
            if (!this.findSymbol(Cn)) {
                var as = createElementID()
                  , cs = createNS("mask");
                cs.setAttribute("id", Cn.layerId),
                cs.setAttribute("mask-type", "alpha"),
                _svgMatteSymbols.push(Cn);
                var Cs = xt.globalData.defs;
                Cs.appendChild(cs);
                var Ls = createNS("symbol");
                Ls.setAttribute("id", as),
                this.replaceInParent(Cn, as),
                Ls.appendChild(Cn.layerElement),
                Cs.appendChild(Ls);
                var Vs = createNS("use");
                Vs.setAttribute("href", "#" + as),
                cs.appendChild(Vs),
                Cn.data.hd = !1,
                Cn.show()
            }
            xt.setMatte(Cn.layerId)
        }
        ,
        SVGMatte3Effect.prototype.initialize = function() {
            for (var xt = this.filterManager.effectElements[0].p.v, Cn = this.elem.comp.elements, as = 0, cs = Cn.length; as < cs; )
                Cn[as] && Cn[as].data.ind === xt && this.setElementAsMask(this.elem, Cn[as]),
                as += 1;
            this.initialized = !0
        }
        ,
        SVGMatte3Effect.prototype.renderFrame = function() {
            this.initialized || this.initialize()
        }
        ,
        SVGGaussianBlurEffect.prototype.renderFrame = function(xt) {
            if (xt || this.filterManager._mdf) {
                var Cn = .3 * this.filterManager.effectElements[0].p.v
                  , as = this.filterManager.effectElements[1].p.v
                  , cs = as == 3 ? 0 : Cn
                  , Cs = as == 2 ? 0 : Cn;
                this.feGaussianBlur.setAttribute("stdDeviation", cs + " " + Cs);
                var Ls = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
                this.feGaussianBlur.setAttribute("edgeMode", Ls)
            }
        }
        ,
        TransformEffect.prototype.init = function(xt) {
            this.effectsManager = xt,
            this.type = effectTypes.TRANSFORM_EFFECT,
            this.matrix = new Matrix,
            this.opacity = -1,
            this._mdf = !1,
            this._opMdf = !1
        }
        ,
        TransformEffect.prototype.renderFrame = function(xt) {
            if (this._opMdf = !1,
            this._mdf = !1,
            xt || this.effectsManager._mdf) {
                var Cn = this.effectsManager.effectElements
                  , as = Cn[0].p.v
                  , cs = Cn[1].p.v
                  , Cs = Cn[2].p.v === 1
                  , Ls = Cn[3].p.v
                  , Vs = Cs ? Ls : Cn[4].p.v
                  , Ws = Cn[5].p.v
                  , Xs = Cn[6].p.v
                  , ga = Cn[7].p.v;
                this.matrix.reset(),
                this.matrix.translate(-as[0], -as[1], as[2]),
                this.matrix.scale(.01 * Vs, .01 * Ls, 1),
                this.matrix.rotate(-ga * degToRads),
                this.matrix.skewFromAxis(-Ws * degToRads, (Xs + 90) * degToRads),
                this.matrix.translate(cs[0], cs[1], 0),
                this._mdf = !0,
                this.opacity !== Cn[8].p.v && (this.opacity = Cn[8].p.v,
                this._opMdf = !0)
            }
        }
        ,
        extendPrototype([TransformEffect], SVGTransformEffect),
        extendPrototype([TransformEffect], CVTransformEffect),
        registerRenderer("canvas", CanvasRenderer),
        registerRenderer("html", HybridRenderer),
        registerRenderer("svg", SVGRenderer),
        ShapeModifiers.registerModifier("tm", TrimModifier),
        ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier),
        ShapeModifiers.registerModifier("rp", RepeaterModifier),
        ShapeModifiers.registerModifier("rd", RoundCornersModifier),
        ShapeModifiers.registerModifier("zz", ZigZagModifier),
        ShapeModifiers.registerModifier("op", OffsetPathModifier),
        setExpressionsPlugin(Expressions),
        setExpressionInterfaces(getInterface),
        initialize$1(),
        initialize(),
        registerEffect$1(20, SVGTintFilter, !0),
        registerEffect$1(21, SVGFillFilter, !0),
        registerEffect$1(22, SVGStrokeEffect, !1),
        registerEffect$1(23, SVGTritoneFilter, !0),
        registerEffect$1(24, SVGProLevelsFilter, !0),
        registerEffect$1(25, SVGDropShadowEffect, !0),
        registerEffect$1(28, SVGMatte3Effect, !1),
        registerEffect$1(29, SVGGaussianBlurEffect, !0),
        registerEffect$1(35, SVGTransformEffect, !1),
        registerEffect(35, CVTransformEffect),
        lottie
    }
    ,
    module.exports = factory())
}
)(lottie$1, lottie$1.exports);
var _templateObject$1, styles$1e = r$3$1(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral([`
  * {
    box-sizing: border-box;
  }

  :host {
    --lottie-player-toolbar-height: 35px;
    --lottie-player-toolbar-background-color: transparent;
    --lottie-player-toolbar-icon-color: #999;
    --lottie-player-toolbar-icon-hover-color: #222;
    --lottie-player-toolbar-icon-active-color: #555;
    --lottie-player-seeker-track-color: #ccc;
    --lottie-player-seeker-thumb-color: rgba(0, 107, 120, 0.8);
    --lottie-player-seeker-display: block;

    display: block;
    width: 100%;
    height: 100%;
  }

  .main {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
  }

  .animation {
    width: 100%;
    height: 100%;
    display: flex;
  }
  .animation.controls {
    height: calc(100% - 35px);
  }

  .toolbar {
    display: flex;
    align-items: center;
    justify-items: center;
    background-color: var(--lottie-player-toolbar-background-color);
    margin: 0 5px;
    height: 35px;
  }

  .toolbar button {
    cursor: pointer;
    fill: var(--lottie-player-toolbar-icon-color);
    display: flex;
    background: none;
    border: 0;
    padding: 0;
    outline: none;
    height: 100%;
  }

  .toolbar button:hover {
    fill: var(--lottie-player-toolbar-icon-hover-color);
  }

  .toolbar button.active {
    fill: var(--lottie-player-toolbar-icon-active-color);
  }

  .toolbar button.active:hover {
    fill: var(--lottie-player-toolbar-icon-hover-color);
  }

  .toolbar button:focus {
    outline: 1px dotted var(--lottie-player-toolbar-icon-active-color);
  }

  .toolbar button svg {
  }

  .toolbar button.disabled svg {
    display: none;
  }

  .seeker {
    -webkit-appearance: none;
    width: 95%;
    outline: none;
    background-color: var(--lottie-player-toolbar-background-color);
    display: var(--lottie-player-seeker-display);
  }

  .seeker::-webkit-slider-runnable-track {
    width: 100%;
    height: 5px;
    cursor: pointer;
    background: var(--lottie-player-seeker-track-color);
    border-radius: 3px;
  }
  .seeker::-webkit-slider-thumb {
    height: 15px;
    width: 15px;
    border-radius: 50%;
    background: var(--lottie-player-seeker-thumb-color);
    cursor: pointer;
    -webkit-appearance: none;
    margin-top: -5px;
  }
  .seeker:focus::-webkit-slider-runnable-track {
    background: #999;
  }
  .seeker::-moz-range-track {
    width: 100%;
    height: 5px;
    cursor: pointer;
    background: var(--lottie-player-seeker-track-color);
    border-radius: 3px;
  }
  .seeker::-moz-range-thumb {
    height: 15px;
    width: 15px;
    border-radius: 50%;
    background: var(--lottie-player-seeker-thumb-color);
    cursor: pointer;
  }
  .seeker::-ms-track {
    width: 100%;
    height: 5px;
    cursor: pointer;
    background: transparent;
    border-color: transparent;
    color: transparent;
  }
  .seeker::-ms-fill-lower {
    background: var(--lottie-player-seeker-track-color);
    border-radius: 3px;
  }
  .seeker::-ms-fill-upper {
    background: var(--lottie-player-seeker-track-color);
    border-radius: 3px;
  }
  .seeker::-ms-thumb {
    border: 0;
    height: 15px;
    width: 15px;
    border-radius: 50%;
    background: var(--lottie-player-seeker-thumb-color);
    cursor: pointer;
  }
  .seeker:focus::-ms-fill-lower {
    background: var(--lottie-player-seeker-track-color);
  }
  .seeker:focus::-ms-fill-upper {
    background: var(--lottie-player-seeker-track-color);
  }

  .error {
    display: flex;
    justify-content: center;
    height: 100%;
    align-items: center;
  }
`]))), version = "2.0.12", dependencies = {
    "lottie-web": "^5.12.2"
}, _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, PlayerState, PlayMode, PlayerEvents;
function parseSrc(xt) {
    if (typeof xt == "object")
        return xt;
    try {
        return JSON.parse(xt)
    } catch {
        return new URL(xt,window.location.href).toString()
    }
}
function isLottie(xt) {
    return ["v", "ip", "op", "layers", "fr", "w", "h"].every(Cn => Object.prototype.hasOwnProperty.call(xt, Cn))
}
function fromURL(xt) {
    return _fromURL.apply(this, arguments)
}
function _fromURL() {
    return (_fromURL = _asyncToGenerator(function*(xt) {
        if (typeof xt != "string")
            throw new Error("The url value must be a string");
        var Cn;
        try {
            var as = new URL(xt)
              , cs = yield fetch(as.toString());
            Cn = yield cs.json()
        } catch {
            throw new Error("An error occurred while trying to load the Lottie file from URL")
        }
        return Cn
    })).apply(this, arguments)
}
(function(xt) {
    xt.Destroyed = "destroyed",
    xt.Error = "error",
    xt.Frozen = "frozen",
    xt.Loading = "loading",
    xt.Paused = "paused",
    xt.Playing = "playing",
    xt.Stopped = "stopped"
}
)(PlayerState || (PlayerState = {})),
function(xt) {
    xt.Bounce = "bounce",
    xt.Normal = "normal"
}(PlayMode || (PlayMode = {})),
function(xt) {
    xt.Complete = "complete",
    xt.Destroyed = "destroyed",
    xt.Error = "error",
    xt.Frame = "frame",
    xt.Freeze = "freeze",
    xt.Load = "load",
    xt.Loop = "loop",
    xt.Pause = "pause",
    xt.Play = "play",
    xt.Ready = "ready",
    xt.Rendered = "rendered",
    xt.Stop = "stop"
}(PlayerEvents || (PlayerEvents = {}));
var LottiePlayer = class extends s$a {
    constructor() {
        super(...arguments),
        this.autoplay = !1,
        this.background = "transparent",
        this.controls = !1,
        this.currentState = PlayerState.Loading,
        this.description = "Lottie animation",
        this.direction = 1,
        this.disableCheck = !1,
        this.disableShadowDOM = !1,
        this.hover = !1,
        this.intermission = 1,
        this.loop = !1,
        this.mode = PlayMode.Normal,
        this.preserveAspectRatio = "xMidYMid meet",
        this.renderer = "svg",
        this.speed = 1,
        this._io = void 0,
        this._counter = 1,
        this._onVisibilityChange = () => {
            document.hidden === !0 && this.currentState === PlayerState.Playing ? this.freeze() : this.currentState === PlayerState.Frozen && this.play()
        }
    }
    load(xt) {
        var Cn = this;
        return _asyncToGenerator(function*() {
            var as = {
                container: Cn.container,
                loop: !1,
                autoplay: !1,
                renderer: Cn.renderer,
                rendererSettings: Object.assign({
                    preserveAspectRatio: Cn.preserveAspectRatio,
                    clearCanvas: !1,
                    progressiveLoad: !0,
                    hideOnTransparent: !0
                }, Cn.viewBoxSize && {
                    viewBoxSize: Cn.viewBoxSize
                })
            };
            try {
                var cs = parseSrc(xt)
                  , Cs = {}
                  , Ls = typeof cs == "string" ? "path" : "animationData";
                Cn._lottie && Cn._lottie.destroy(),
                Cn.webworkers && lottie$1.exports.useWebWorker(!0),
                Cn._lottie = lottie$1.exports.loadAnimation(Object.assign(Object.assign({}, as), {
                    [Ls]: cs
                })),
                Cn._attachEventListeners(),
                Cn.disableCheck || (Ls === "path" ? (Cs = yield fromURL(cs),
                Ls = "animationData") : Cs = cs,
                isLottie(Cs) || (Cn.currentState = PlayerState.Error,
                Cn.dispatchEvent(new CustomEvent(PlayerEvents.Error))))
            } catch {
                Cn.currentState = PlayerState.Error,
                Cn.dispatchEvent(new CustomEvent(PlayerEvents.Error))
            }
        })()
    }
    getLottie() {
        return this._lottie
    }
    getVersions() {
        return {
            lottieWebVersion: dependencies["lottie-web"],
            lottiePlayerVersion: version
        }
    }
    play() {
        this._lottie && (this._lottie.play(),
        this.currentState = PlayerState.Playing,
        this.dispatchEvent(new CustomEvent(PlayerEvents.Play)))
    }
    pause() {
        this._lottie && (this._lottie.pause(),
        this.currentState = PlayerState.Paused,
        this.dispatchEvent(new CustomEvent(PlayerEvents.Pause)))
    }
    stop() {
        this._lottie && (this._counter = 1,
        this._lottie.stop(),
        this.currentState = PlayerState.Stopped,
        this.dispatchEvent(new CustomEvent(PlayerEvents.Stop)))
    }
    destroy() {
        this._lottie && (this._lottie.destroy(),
        this._lottie = null,
        this.currentState = PlayerState.Destroyed,
        this.dispatchEvent(new CustomEvent(PlayerEvents.Destroyed)),
        this.remove())
    }
    seek(xt) {
        if (this._lottie) {
            var Cn = /^(\d+)(%?)$/.exec(xt.toString());
            if (Cn) {
                var as = Cn[2] === "%" ? this._lottie.totalFrames * Number(Cn[1]) / 100 : Number(Cn[1]);
                this.seeker = as,
                this.currentState === PlayerState.Playing ? this._lottie.goToAndPlay(as, !0) : (this._lottie.goToAndStop(as, !0),
                this._lottie.pause())
            }
        }
    }
    snapshot() {
        var xt = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0];
        if (this.shadowRoot) {
            var Cn = this.shadowRoot.querySelector(".animation svg")
              , as = new XMLSerializer().serializeToString(Cn);
            if (xt) {
                var cs = document.createElement("a");
                cs.href = "data:image/svg+xml;charset=utf-8,".concat(encodeURIComponent(as)),
                cs.download = "download_".concat(this.seeker, ".svg"),
                document.body.appendChild(cs),
                cs.click(),
                document.body.removeChild(cs)
            }
            return as
        }
    }
    setSpeed() {
        var xt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        this._lottie && this._lottie.setSpeed(xt)
    }
    setDirection(xt) {
        this._lottie && this._lottie.setDirection(xt)
    }
    setLooping(xt) {
        this._lottie && (this.loop = xt,
        this._lottie.loop = xt)
    }
    togglePlay() {
        return this.currentState === PlayerState.Playing ? this.pause() : this.play()
    }
    toggleLooping() {
        this.setLooping(!this.loop)
    }
    resize() {
        this._lottie && this._lottie.resize()
    }
    static get styles() {
        return styles$1e
    }
    disconnectedCallback() {
        this.isConnected || (this._io && (this._io.disconnect(),
        this._io = void 0),
        document.removeEventListener("visibilitychange", this._onVisibilityChange),
        this.destroy())
    }
    render() {
        var xt = this.controls ? "main controls" : "main"
          , Cn = this.controls ? "animation controls" : "animation";
        return $$2(_templateObject || (_templateObject = _taggedTemplateLiteral([` <div
      id="animation-container"
      class=`, `
      lang="en"
      aria-label=`, `
      role="img"
    >
      <div
        id="animation"
        class=`, `
        style="background:`, `;"
      >
        `, `
      </div>
      `, `
    </div>`])), xt, this.description, Cn, this.background, this.currentState === PlayerState.Error ? $$2(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(['<div class="error"></div>']))) : void 0, this.controls && !this.disableShadowDOM ? this.renderControls() : void 0)
    }
    createRenderRoot() {
        return this.disableShadowDOM && (this.style.display = "block"),
        this.disableShadowDOM ? this : super.createRenderRoot()
    }
    firstUpdated() {
        "IntersectionObserver"in window && (this._io = new IntersectionObserver(xt => {
            xt[0].isIntersecting ? this.currentState === PlayerState.Frozen && this.play() : this.currentState === PlayerState.Playing && this.freeze()
        }
        ),
        this._io.observe(this.container)),
        document.hidden !== void 0 && document.addEventListener("visibilitychange", this._onVisibilityChange),
        this.src && this.load(this.src),
        this.dispatchEvent(new CustomEvent(PlayerEvents.Rendered))
    }
    renderControls() {
        var xt = this.currentState === PlayerState.Playing
          , Cn = this.currentState === PlayerState.Paused
          , as = this.currentState === PlayerState.Stopped;
        return $$2(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([`
      <div
        id="lottie-controls"
        aria-label="lottie-animation-controls"
        class="toolbar"
      >
        <button
          id="lottie-play-button"
          @click=`, `
          class=`, `
          style="align-items:center;"
          tabindex="0"
          aria-label="play-pause"
        >
          `, `
        </button>
        <button
          id="lottie-stop-button"
          @click=`, `
          class=`, `
          style="align-items:center;"
          tabindex="0"
          aria-label="stop"
        >
          <svg width="24" height="24" aria-hidden="true" focusable="false">
            <path d="M6 6h12v12H6V6z" />
          </svg>
        </button>
        <input
          id="lottie-seeker-input"
          class="seeker"
          type="range"
          min="0"
          step="1"
          max="100"
          .value=`, `
          @input=`, `
          @mousedown=`, `
          @mouseup=`, `
          aria-valuemin="1"
          aria-valuemax="100"
          role="slider"
          aria-valuenow=`, `
          tabindex="0"
          aria-label="lottie-seek-input"
        />
        <button
          id="lottie-loop-toggle"
          @click=`, `
          class=`, `
          style="align-items:center;"
          tabindex="0"
          aria-label="loop-toggle"
        >
          <svg width="24" height="24" aria-hidden="true" focusable="false">
            <path
              d="M17.016 17.016v-4.031h1.969v6h-12v3l-3.984-3.984 3.984-3.984v3h10.031zM6.984 6.984v4.031H5.015v-6h12v-3l3.984 3.984-3.984 3.984v-3H6.984z"
            />
          </svg>
        </button>
      </div>
    `])), this.togglePlay, xt || Cn ? "active" : "", $$2(xt ? _templateObject4 || (_templateObject4 = _taggedTemplateLiteral([`<svg
                width="24"
                height="24"
                aria-hidden="true"
                focusable="false"
              >
                <path
                  d="M14.016 5.016H18v13.969h-3.984V5.016zM6 18.984V5.015h3.984v13.969H6z"
                />
              </svg>`])) : _templateObject5 || (_templateObject5 = _taggedTemplateLiteral([`<svg
                width="24"
                height="24"
                aria-hidden="true"
                focusable="false"
              >
                <path d="M8.016 5.016L18.985 12 8.016 18.984V5.015z" />
              </svg>`]))), this.stop, as ? "active" : "", this.seeker, this._handleSeekChange, () => {
            this._prevState = this.currentState,
            this.freeze()
        }
        , () => {
            this._prevState === PlayerState.Playing && this.play()
        }
        , this.seeker, this.toggleLooping, this.loop ? "active" : "")
    }
    _handleSeekChange(xt) {
        if (this._lottie && !isNaN(xt.target.value)) {
            var Cn = xt.target.value / 100 * this._lottie.totalFrames;
            this.seek(Cn)
        }
    }
    _attachEventListeners() {
        this._lottie.addEventListener("enterFrame", () => {
            this.seeker = this._lottie.currentFrame / this._lottie.totalFrames * 100,
            this.dispatchEvent(new CustomEvent(PlayerEvents.Frame,{
                detail: {
                    frame: this._lottie.currentFrame,
                    seeker: this.seeker
                }
            }))
        }
        ),
        this._lottie.addEventListener("complete", () => {
            if (this.currentState === PlayerState.Playing) {
                if ((!this.loop || this.count && this._counter >= this.count) && (this.dispatchEvent(new CustomEvent(PlayerEvents.Complete)),
                this.mode !== PlayMode.Bounce || this._lottie.currentFrame === 0))
                    return;
                this.mode === PlayMode.Bounce ? (this.count && (this._counter += .5),
                setTimeout( () => {
                    this.dispatchEvent(new CustomEvent(PlayerEvents.Loop)),
                    this.currentState === PlayerState.Playing && (this._lottie.setDirection(-1 * this._lottie.playDirection),
                    this._lottie.play())
                }
                , this.intermission)) : (this.count && (this._counter += 1),
                window.setTimeout( () => {
                    this.dispatchEvent(new CustomEvent(PlayerEvents.Loop)),
                    this.currentState === PlayerState.Playing && (this.direction === -1 ? (this.seek("99%"),
                    this.play()) : (this._lottie.stop(),
                    this._lottie.play()))
                }
                , this.intermission))
            } else
                this.dispatchEvent(new CustomEvent(PlayerEvents.Complete))
        }
        ),
        this._lottie.addEventListener("DOMLoaded", () => {
            this.setSpeed(this.speed),
            this.setDirection(this.direction),
            this.autoplay && (this.direction === -1 && this.seek("100%"),
            this.play()),
            this.dispatchEvent(new CustomEvent(PlayerEvents.Ready))
        }
        ),
        this._lottie.addEventListener("data_ready", () => {
            this.dispatchEvent(new CustomEvent(PlayerEvents.Load))
        }
        ),
        this._lottie.addEventListener("data_failed", () => {
            this.currentState = PlayerState.Error,
            this.dispatchEvent(new CustomEvent(PlayerEvents.Error))
        }
        ),
        this.container.addEventListener("mouseenter", () => {
            this.hover && this.currentState !== PlayerState.Playing && this.play()
        }
        ),
        this.container.addEventListener("mouseleave", () => {
            this.hover && this.currentState === PlayerState.Playing && this.stop()
        }
        )
    }
    freeze() {
        this._lottie && (this._lottie.pause(),
        this.currentState = PlayerState.Frozen,
        this.dispatchEvent(new CustomEvent(PlayerEvents.Freeze)))
    }
}
;
__decorate([e$5$1({
    type: Boolean
})], LottiePlayer.prototype, "autoplay", void 0),
__decorate([e$5$1({
    type: String,
    reflect: !0
})], LottiePlayer.prototype, "background", void 0),
__decorate([e$5$1({
    type: Boolean
})], LottiePlayer.prototype, "controls", void 0),
__decorate([e$5$1({
    type: Number
})], LottiePlayer.prototype, "count", void 0),
__decorate([e$5$1({
    type: String
})], LottiePlayer.prototype, "currentState", void 0),
__decorate([e$5$1({
    type: String
})], LottiePlayer.prototype, "description", void 0),
__decorate([e$5$1({
    type: Number
})], LottiePlayer.prototype, "direction", void 0),
__decorate([e$5$1({
    type: Boolean
})], LottiePlayer.prototype, "disableCheck", void 0),
__decorate([e$5$1({
    type: Boolean
})], LottiePlayer.prototype, "disableShadowDOM", void 0),
__decorate([e$5$1({
    type: Boolean
})], LottiePlayer.prototype, "hover", void 0),
__decorate([e$5$1()], LottiePlayer.prototype, "intermission", void 0),
__decorate([e$5$1({
    type: Boolean,
    reflect: !0
})], LottiePlayer.prototype, "loop", void 0),
__decorate([e$5$1()], LottiePlayer.prototype, "mode", void 0),
__decorate([e$5$1({
    type: String
})], LottiePlayer.prototype, "preserveAspectRatio", void 0),
__decorate([e$5$1({
    type: String
})], LottiePlayer.prototype, "renderer", void 0),
__decorate([e$5$1({
    type: String
})], LottiePlayer.prototype, "viewBoxSize", void 0),
__decorate([e$5$1()], LottiePlayer.prototype, "seeker", void 0),
__decorate([e$5$1({
    type: Number
})], LottiePlayer.prototype, "speed", void 0),
__decorate([e$5$1({
    type: String
})], LottiePlayer.prototype, "src", void 0),
__decorate([e$5$1({
    type: Boolean
})], LottiePlayer.prototype, "webworkers", void 0),
__decorate([i$6(".animation")], LottiePlayer.prototype, "container", void 0),
LottiePlayer = __decorate([n$1$1("lottie-player")], LottiePlayer);
const MIN_ICON_WIDTH_FOR_CHIP = 100
  , GiftIconComponent = ({gift: xt, width: Cn, height: as, isLottie: cs=!0, clicksAvailable: Cs=!0, showMine: Ls=!1}) => {
    const {t: Vs} = useTranslation()
      , Ws = reactExports.useRef(null)
      , [Xs,ga] = reactExports.useState(!1)
      , ba = reactExports.useRef(null)
      , {multipleMode: yl, setSelectedGiftForOverview: xl, addModal: wl} = useStorage(El => ({
        multipleMode: El.myGifts.multipleMode,
        setSelectedGiftForOverview: El.gifts.setSelectedGiftForOverview,
        addModal: El.modal.addModal
    }))
      , _l = () => {
        !yl && Cs && (xl(xt),
        wl(ModalNames.GIFT_OVERVIEW))
    }
    ;
    return reactExports.useEffect( () => {
        if (!cs)
            return;
        const El = new IntersectionObserver(Cl => {
            Cl.forEach($l => {
                ga($l.isIntersecting)
            }
            )
        }
        ,{
            threshold: .5
        });
        return ba.current && El.observe(ba.current),
        () => {
            ba.current && El.unobserve(ba.current)
        }
    }
    , [cs]),
    reactExports.useEffect( () => {
        if (!cs || !Ws.current || !Ws.current.getLottie)
            return;
        const El = Ws.current.getLottie();
        El && (Xs ? El.goToAndPlay(0, !0) : El.stop())
    }
    , [cs, Xs]),
    jsxRuntimeExports.jsxs("div", {
        className: styles$1f.giftItem,
        style: {
            width: Cn,
            height: as
        },
        onClick: _l,
        ref: ba,
        children: [jsxRuntimeExports.jsxs("div", {
            className: styles$1f.giftItemChipsContainer,
            children: [xt.isMine && Ls && jsxRuntimeExports.jsx("div", {
                className: styles$1f.giftItemMyGiftChip,
                children: Vs("tag_your_gift")
            }), xt.isGiveawayReceived && xt.isMine && !xt.isOnSale && Number(Cn) > MIN_ICON_WIDTH_FOR_CHIP && jsxRuntimeExports.jsx("div", {
                className: styles$1f.giftItemGiveawayChip,
                children: Vs("giveaway_gifts_tag_free_withdraw")
            })]
        }), jsxRuntimeExports.jsxs("svg", {
            width: "100%",
            height: "100%",
            viewBox: "0 0 420 420",
            version: "1.1",
            xmlns: "http://www.w3.org/2000/svg",
            preserveAspectRatio: "xMidYMid slice",
            style: {
                width: Cn,
                height: as
            },
            children: [jsxRuntimeExports.jsxs("defs", {
                children: [jsxRuntimeExports.jsxs("radialGradient", {
                    id: `giftGradient${xt.id}`,
                    cx: "50%",
                    cy: "50%",
                    fx: "50%",
                    fy: "50%",
                    r: "69.65%",
                    gradientTransform: "translate(0.5, 0.5), scale(0.6667, 1), rotate(90), translate(-0.5, -0.5)",
                    children: [jsxRuntimeExports.jsx("stop", {
                        stopColor: `#${xt.backdropColorsCenterColor.toString(16).padStart(6, "0")}`,
                        offset: "0%"
                    }), jsxRuntimeExports.jsx("stop", {
                        stopColor: `#${xt.backdropColorsEdgeColor.toString(16).padStart(6, "0")}`,
                        offset: "100%"
                    })]
                }), jsxRuntimeExports.jsxs("filter", {
                    id: "patternColorFilter",
                    children: [jsxRuntimeExports.jsx("feFlood", {
                        id: "giftGradienPatternColor",
                        floodColor: `#${xt.backdropColorsSymbolColor.toString(16).padStart(6, "0")}`
                    }), jsxRuntimeExports.jsx("feComposite", {
                        in2: "SourceGraphic",
                        operator: "in"
                    })]
                }), jsxRuntimeExports.jsxs("g", {
                    id: `fullPattern${xt.id}`,
                    transform: "translate(-40) scale(1.2, 1.2)",
                    children: [jsxRuntimeExports.jsx("g", {
                        opacity: "0.212890625",
                        transform: "translate(140.5761, 50)",
                        children: jsxRuntimeExports.jsx("use", {
                            xlinkHref: `#giftPattern${xt.id}`,
                            transform: "scale(0.3)"
                        })
                    }), jsxRuntimeExports.jsx("g", {
                        opacity: "0.212890625",
                        transform: "translate(249.465, 50)",
                        children: jsxRuntimeExports.jsx("use", {
                            xlinkHref: `#giftPattern${xt.id}`,
                            transform: "scale(0.3)"
                        })
                    }), jsxRuntimeExports.jsx("g", {
                        opacity: "0.223865327",
                        transform: "translate(291.8539, 150)",
                        children: jsxRuntimeExports.jsx("use", {
                            xlinkHref: `#giftPattern${xt.id}`,
                            transform: "scale(0.3)"
                        })
                    }), jsxRuntimeExports.jsx("g", {
                        opacity: "0.223865327",
                        transform: "translate(98.1872, 150)",
                        children: jsxRuntimeExports.jsx("use", {
                            xlinkHref: `#giftPattern${xt.id}`,
                            transform: "scale(0.3)"
                        })
                    }), jsxRuntimeExports.jsx("g", {
                        opacity: "0.221633185",
                        transform: "translate(276.2551, 250)",
                        children: jsxRuntimeExports.jsx("use", {
                            xlinkHref: `#giftPattern${xt.id}`,
                            transform: "scale(0.277)"
                        })
                    }), jsxRuntimeExports.jsx("g", {
                        opacity: "0.123046875",
                        transform: "translate(196.144, 270)",
                        children: jsxRuntimeExports.jsx("use", {
                            xlinkHref: `#giftPattern${xt.id}`,
                            transform: "scale(0.277)"
                        })
                    }), jsxRuntimeExports.jsx("g", {
                        opacity: "0.221633185",
                        transform: "translate(116.0329, 250)",
                        children: jsxRuntimeExports.jsx("use", {
                            xlinkHref: `#giftPattern${xt.id}`,
                            transform: "scale(0.277)"
                        })
                    }), jsxRuntimeExports.jsx("g", {
                        opacity: "0.189569382",
                        transform: "translate(355.0988, 120)",
                        children: jsxRuntimeExports.jsx("use", {
                            xlinkHref: `#giftPattern${xt.id}`,
                            transform: "scale(0.2247)"
                        })
                    }), jsxRuntimeExports.jsx("g", {
                        opacity: "0.260904948",
                        transform: "translate(292.0988, 80)",
                        children: jsxRuntimeExports.jsx("use", {
                            xlinkHref: `#giftPattern${xt.id}`,
                            transform: "scale(0.2247)"
                        })
                    }), jsxRuntimeExports.jsx("g", {
                        opacity: "0.146437872",
                        transform: "translate(334.0988, 30)",
                        children: jsxRuntimeExports.jsx("use", {
                            xlinkHref: `#giftPattern${xt.id}`,
                            transform: "scale(0.2247)"
                        })
                    }), jsxRuntimeExports.jsx("g", {
                        opacity: "0.153087798",
                        transform: "translate(198.7654, 10)",
                        children: jsxRuntimeExports.jsx("use", {
                            xlinkHref: `#giftPattern${xt.id}`,
                            transform: "scale(0.2247)"
                        })
                    }), jsxRuntimeExports.jsx("g", {
                        opacity: "0.145321801",
                        transform: "translate(63.4321, 30)",
                        children: jsxRuntimeExports.jsx("use", {
                            xlinkHref: `#giftPattern${xt.id}`,
                            transform: "scale(0.2247)"
                        })
                    }), jsxRuntimeExports.jsx("g", {
                        opacity: "0.260904948",
                        transform: "translate(105.4321, 80)",
                        children: jsxRuntimeExports.jsx("use", {
                            xlinkHref: `#giftPattern${xt.id}`,
                            transform: "scale(0.2247)"
                        })
                    }), jsxRuntimeExports.jsx("g", {
                        opacity: "0.165899368",
                        transform: "translate(42.4321, 120)",
                        children: jsxRuntimeExports.jsx("use", {
                            xlinkHref: `#giftPattern${xt.id}`,
                            transform: "scale(0.2247)"
                        })
                    }), jsxRuntimeExports.jsx("g", {
                        opacity: "0.165899368",
                        transform: "translate(72.7654, 220)",
                        children: jsxRuntimeExports.jsx("use", {
                            xlinkHref: `#giftPattern${xt.id}`,
                            transform: "scale(0.2247)"
                        })
                    }), jsxRuntimeExports.jsx("g", {
                        opacity: "0.10500372",
                        transform: "translate(49.4321, 300)",
                        children: jsxRuntimeExports.jsx("use", {
                            xlinkHref: `#giftPattern${xt.id}`,
                            transform: "scale(0.2247)"
                        })
                    }), jsxRuntimeExports.jsx("g", {
                        opacity: "0.10500372",
                        transform: "translate(344.2099, 300)",
                        children: jsxRuntimeExports.jsx("use", {
                            xlinkHref: `#giftPattern${xt.id}`,
                            transform: "scale(0.2247)"
                        })
                    }), jsxRuntimeExports.jsx("g", {
                        opacity: "0.152669271",
                        transform: "translate(337.2099, 220)",
                        children: jsxRuntimeExports.jsx("use", {
                            xlinkHref: `#giftPattern${xt.id}`,
                            transform: "scale(0.2247)"
                        })
                    })]
                }), jsxRuntimeExports.jsx("image", {
                    id: `giftPattern${xt.id}`,
                    x: "0",
                    y: "0",
                    width: "100",
                    height: "100",
                    xlinkHref: xt.symbolStickerKey
                })]
            }), jsxRuntimeExports.jsxs("g", {
                stroke: "none",
                strokeWidth: "1",
                fill: "none",
                fillRule: "evenodd",
                children: [jsxRuntimeExports.jsx("rect", {
                    x: "0",
                    y: "0",
                    width: "420",
                    height: "420",
                    fill: `url(#giftGradient${xt.id})`
                }), jsxRuntimeExports.jsx("use", {
                    xlinkHref: `#fullPattern${xt.id}`,
                    filter: "url(#patternColorFilter)"
                })]
            })]
        }), cs ? jsxRuntimeExports.jsx("lottie-player", {
            ref: Ws,
            mode: "normal",
            src: xt.modelStickerKey,
            className: styles$1f.giftThumbnail,
            style: {
                position: "absolute",
                maxWidth: "80%",
                maxHeight: "80%"
            }
        }) : jsxRuntimeExports.jsx("img", {
            className: styles$1f.giftThumbnail,
            src: xt.modelStickerThumbnailKey
        })]
    })
}
  , GiftIcon = reactExports.memo(GiftIconComponent, (xt, Cn) => xt.gift.id === Cn.gift.id && xt.width === Cn.width && xt.height === Cn.height && xt.isLottie === Cn.isLottie && xt.clicksAvailable === Cn.clicksAvailable && xt.showMine === Cn.showMine)
  , GiveawayItemButton = reactExports.memo( ({giveaway: xt, isGiveawayEnded: Cn}) => {
    const {t: as} = useTranslation()
      , {addModal: cs, setSelectedGiveaway: Cs} = useStorage(Xs => ({
        addModal: Xs.modal.addModal,
        setSelectedGiveaway: Xs.giveaways.setSelectedGiveaway
    }))
      , Ls = reactExports.useMemo( () => {
        const Xs = xt.isMine && xt.validationStatus === "Validated"
          , ga = xt.validationStatus === "Validated" && Cn;
        return !(Xs || ga)
    }
    , [xt.isMine, xt.validationStatus, Cn])
      , Vs = reactExports.useMemo( () => xt.isMine ? xt.validationStatus === "Validating" ? jsxRuntimeExports.jsx("span", {
        className: styles$1g.secondaryButtonText,
        children: as("On Moderation")
    }) : xt.validationStatus === "Validated" ? Cn ? jsxRuntimeExports.jsx("span", {
        className: styles$1g.secondaryButtonText,
        children: as("text_ended")
    }) : jsxRuntimeExports.jsx("span", {
        className: styles$1g.secondaryButtonText,
        children: as("text_your_giveaway")
    }) : jsxRuntimeExports.jsx("span", {
        className: styles$1g.errorButtonText,
        children: as("Moderation Failed")
    }) : Cn ? jsxRuntimeExports.jsx("span", {
        className: styles$1g.secondaryButtonText,
        children: as("text_ended")
    }) : xt.myTicketsCount > 0 ? xt.ticketPriceNanoTons > 0 ? as("text_buy_another_ticket") : jsxRuntimeExports.jsx("span", {
        className: styles$1g.secondaryButtonText,
        children: as("button_you_are_in")
    }) : (xt.ticketPriceNanoTons > 0,
    as("button_enter_giveaway")), [xt.isMine, xt.validationStatus, xt.myTicketsCount, xt.ticketPriceNanoTons, Cn])
      , Ws = reactExports.useCallback( () => {
        xt.isMine || xt.ticketPriceNanoTons === 0 && xt.myTicketsCount || (Cs(xt),
        cs(ModalNames.GA_PARTISIPATION, 10))
    }
    , [xt, Cs, cs]);
    return jsxRuntimeExports.jsx(Button, {
        disabled: !Ls,
        className: styles$1g.buyButton,
        onClick: Ws,
        children: Vs
    })
}
)
  , timerContainer = "_timerContainer_yl712_1"
  , timerIcon = "_timerIcon_yl712_14"
  , timerText = "_timerText_yl712_21"
  , finishedText = "_finishedText_yl712_28"
  , styles$1d = {
    timerContainer,
    timerIcon,
    timerText,
    finishedText
}
  , SvgTimer = xt => reactExports.createElement("svg", {
    width: 13,
    height: 12,
    viewBox: "0 0 13 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M6.5 11.5C9.53757 11.5 12 9.03757 12 6C12 2.96243 9.53757 0.5 6.5 0.5C3.46243 0.5 1 2.96243 1 6C1 9.03757 3.46243 11.5 6.5 11.5Z",
    stroke: "#F7F7F8",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M6.5 3.88452V5.99991L8.64923 8.50452",
    stroke: "#F7F7F8",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))
  , formatTime = xt => {
    let Cn = Math.floor(xt / 1e3);
    Cn %= 86400;
    const as = Math.floor(Cn / 3600);
    Cn %= 3600;
    const cs = Math.floor(Cn / 60)
      , Cs = Cn % 60
      , Ls = as.toString().padStart(2, "0")
      , Vs = cs.toString().padStart(2, "0")
      , Ws = Cs.toString().padStart(2, "0");
    return `${Ls}:${Vs}:${Ws}`
}
  , Timer$1 = ({timeLeft: xt}) => {
    const {t: Cn} = useTranslation();
    return xt <= 0 ? jsxRuntimeExports.jsx("div", {
        className: styles$1d.timerContainer,
        children: jsxRuntimeExports.jsx("span", {
            className: styles$1d.finishedText,
            children: Cn("text_giveaway_finished")
        })
    }) : jsxRuntimeExports.jsxs("div", {
        className: styles$1d.timerContainer,
        children: [jsxRuntimeExports.jsx(SvgTimer, {
            className: styles$1d.timerIcon
        }), jsxRuntimeExports.jsx("span", {
            className: styles$1d.timerText,
            children: formatTime(xt)
        })]
    })
}
  , GiveawayItem = ({giveaway: xt, isInModal: Cn=!1, withButton: as=!0, winningTickets: cs}) => {
    const {t: Cs} = useTranslation()
      , Ls = () => {
        const ba = new Date(xt.endAt).getTime()
          , yl = Date.now();
        return Math.max(ba - yl, 0)
    }
      , [Vs,Ws] = reactExports.useState(Ls())
      , [Xs,ga] = reactExports.useState(Ls() === 0);
    return reactExports.useEffect( () => {
        ga(Ls() === 0),
        Ws(Ls());
        const ba = setInterval( () => {
            const yl = Ls();
            Ws(yl),
            ga(yl === 0)
        }
        , 1e3);
        return () => clearInterval(ba)
    }
    , [xt.endAt, xt.id]),
    jsxRuntimeExports.jsxs("div", {
        className: styles$1g.item,
        style: {
            padding: Cn ? 0 : "16px"
        },
        children: [jsxRuntimeExports.jsxs("div", {
            className: styles$1g.header,
            children: [jsxRuntimeExports.jsx("span", {
                className: styles$1g.giveawayByText,
                children: Cs("text_giveaway_by")
            }), jsxRuntimeExports.jsxs("span", {
                className: styles$1g.channelName,
                onClick: () => Oc(`https://t.me/${xt.chanels[0]}`),
                children: ["@", xt.chanels[0]]
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$1g.content,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$1g.imageContainer,
                children: jsxRuntimeExports.jsx(GiftIcon, {
                    gift: xt.previewGift,
                    width: 100,
                    height: 100,
                    clicksAvailable: !1
                })
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$1g.info,
                children: [jsxRuntimeExports.jsxs("div", {
                    className: styles$1g.infoRow,
                    children: [jsxRuntimeExports.jsxs("span", {
                        className: styles$1g.infoLabel,
                        children: [Cs(typeof cs == "number" ? "giveaway_plate_your_winning_tickets" : "text_your_tickets"), ":"]
                    }), jsxRuntimeExports.jsx("div", {
                        className: styles$1g.currencyContainer,
                        children: jsxRuntimeExports.jsx("span", {
                            className: styles$1g.infoValue,
                            children: cs ?? xt.myTicketsCount
                        })
                    })]
                }), jsxRuntimeExports.jsxs("div", {
                    className: styles$1g.infoRow,
                    children: [jsxRuntimeExports.jsxs("span", {
                        className: styles$1g.infoLabel,
                        children: [Cs("text_participants"), ":"]
                    }), jsxRuntimeExports.jsx("span", {
                        className: styles$1g.infoValue,
                        children: xt.participantsCount
                    })]
                }), jsxRuntimeExports.jsxs("div", {
                    className: styles$1g.infoRow,
                    children: [jsxRuntimeExports.jsxs("span", {
                        className: styles$1g.infoLabel,
                        children: [Cs("text_gifts_volume"), ":"]
                    }), jsxRuntimeExports.jsx("span", {
                        className: styles$1g.infoValue,
                        children: xt.giftsCount
                    })]
                }), jsxRuntimeExports.jsxs("div", {
                    className: styles$1g.infoRowSpaceBetween,
                    children: [jsxRuntimeExports.jsxs("div", {
                        className: styles$1g.currencyContainer,
                        children: [jsxRuntimeExports.jsxs("span", {
                            className: styles$1g.infoLabel,
                            children: [Cs("text_price"), ":"]
                        }), xt.ticketPriceNanoTons ? jsxRuntimeExports.jsxs("div", {
                            className: styles$1g.currencyContainer,
                            children: [jsxRuntimeExports.jsx(SvgTonIcon, {
                                className: styles$1g.iconTon
                            }), jsxRuntimeExports.jsx("span", {
                                className: styles$1g.tonAmount,
                                children: formatNanotons(xt.ticketPriceNanoTons)
                            })]
                        }) : jsxRuntimeExports.jsx("div", {
                            className: styles$1g.currencyContainer,
                            children: jsxRuntimeExports.jsx("span", {
                                className: styles$1g.freeText,
                                children: Cs("tab_free")
                            })
                        })]
                    }), xt.validationStatus === "Validated" && jsxRuntimeExports.jsx(Timer$1, {
                        timeLeft: Vs
                    })]
                })]
            })]
        }), Cn && as && jsxRuntimeExports.jsx("div", {
            className: styles$1g.devider
        }), as && jsxRuntimeExports.jsx(GiveawayItemButton, {
            giveaway: xt,
            isGiveawayEnded: Xs
        })]
    })
}
  , giveawaysListContainer = "_giveawaysListContainer_1ygxk_1"
  , virtuosoGrid$2 = "_virtuosoGrid_1ygxk_9"
  , virtuosoItem$2 = "_virtuosoItem_1ygxk_15"
  , virtualizer$2 = "_virtualizer_1ygxk_21"
  , spinnerWrapper$2 = "_spinnerWrapper_1ygxk_28"
  , styles$1c = {
    giveawaysListContainer,
    virtuosoGrid: virtuosoGrid$2,
    virtuosoItem: virtuosoItem$2,
    virtualizer: virtualizer$2,
    spinnerWrapper: spinnerWrapper$2
}
  , we$1 = 0
  , zt = 1
  , qt = 2
  , En = 4;
function ln(xt) {
    return () => xt
}
function lo(xt) {
    xt()
}
function ne(xt, Cn) {
    return as => xt(Cn(as))
}
function cn(xt, Cn) {
    return () => xt(Cn)
}
function co(xt, Cn) {
    return as => xt(Cn, as)
}
function Me$2(xt) {
    return xt !== void 0
}
function uo(...xt) {
    return () => {
        xt.map(lo)
    }
}
function Yt() {}
function ve(xt, Cn) {
    return Cn(xt),
    xt
}
function ao(xt, Cn) {
    return Cn(xt)
}
function X$3(...xt) {
    return xt
}
function K$2(xt, Cn) {
    return xt(zt, Cn)
}
function W$1(xt, Cn) {
    xt(we$1, Cn)
}
function We$1(xt) {
    xt(qt)
}
function lt(xt) {
    return xt(En)
}
function F$3(xt, Cn) {
    return K$2(xt, co(Cn, we$1))
}
function bt(xt, Cn) {
    const as = xt(zt, cs => {
        as(),
        Cn(cs)
    }
    );
    return as
}
function un(xt) {
    let Cn, as;
    return cs => Cs => {
        Cn = Cs,
        as && clearTimeout(as),
        as = setTimeout( () => {
            cs(Cn)
        }
        , xt)
    }
}
function Bn(xt, Cn) {
    return xt === Cn
}
function Y$1(xt=Bn) {
    let Cn;
    return as => cs => {
        xt(Cn, cs) || (Cn = cs,
        as(cs))
    }
}
function P$4(xt) {
    return Cn => as => {
        xt(as) && Cn(as)
    }
}
function E$2(xt) {
    return Cn => ne(Cn, xt)
}
function yt(xt) {
    return Cn => () => {
        Cn(xt)
    }
}
function x$2(xt, ...Cn) {
    const as = fo(...Cn);
    return (cs, Cs) => {
        switch (cs) {
        case qt:
            We$1(xt);
            return;
        case zt:
            return K$2(xt, as(Cs))
        }
    }
}
function Rt$1(xt, Cn) {
    return as => cs => {
        as(Cn = xt(Cn, cs))
    }
}
function jt(xt) {
    return Cn => as => {
        xt > 0 ? xt-- : Cn(as)
    }
}
function Lt$1(xt) {
    let Cn = null, as;
    return cs => Cs => {
        Cn = Cs,
        !as && (as = setTimeout( () => {
            as = void 0,
            cs(Cn)
        }
        , xt))
    }
}
function G$1(...xt) {
    const Cn = new Array(xt.length);
    let as = 0
      , cs = null;
    const Cs = Math.pow(2, xt.length) - 1;
    return xt.forEach( (Ls, Vs) => {
        const Ws = Math.pow(2, Vs);
        K$2(Ls, Xs => {
            const ga = as;
            as = as | Ws,
            Cn[Vs] = Xs,
            ga !== Cs && as === Cs && cs && (cs(),
            cs = null)
        }
        )
    }
    ),
    Ls => Vs => {
        const Ws = () => {
            Ls([Vs].concat(Cn))
        }
        ;
        as === Cs ? Ws() : cs = Ws
    }
}
function fo(...xt) {
    return Cn => xt.reduceRight(ao, Cn)
}
function mo(xt) {
    let Cn, as;
    const cs = () => Cn == null ? void 0 : Cn();
    return function(Cs, Ls) {
        switch (Cs) {
        case zt:
            return Ls ? as === Ls ? void 0 : (cs(),
            as = Ls,
            Cn = K$2(xt, Ls),
            Cn) : (cs(),
            Yt);
        case qt:
            cs(),
            as = null;
            return
        }
    }
}
function v(xt) {
    let Cn = xt;
    const as = $$1();
    return (cs, Cs) => {
        switch (cs) {
        case we$1:
            Cn = Cs;
            break;
        case zt:
            {
                Cs(Cn);
                break
            }
        case En:
            return Cn
        }
        return as(cs, Cs)
    }
}
function ct(xt, Cn) {
    return ve(v(Cn), as => F$3(xt, as))
}
function $$1() {
    const xt = [];
    return (Cn, as) => {
        switch (Cn) {
        case we$1:
            xt.slice().forEach(cs => {
                cs(as)
            }
            );
            return;
        case qt:
            xt.splice(0, xt.length);
            return;
        case zt:
            return xt.push(as),
            () => {
                const cs = xt.indexOf(as);
                cs > -1 && xt.splice(cs, 1)
            }
        }
    }
}
function pt(xt) {
    return ve($$1(), Cn => F$3(xt, Cn))
}
function U$3(xt, Cn=[], {singleton: as}={
    singleton: !0
}) {
    return {
        constructor: xt,
        dependencies: Cn,
        id: po(),
        singleton: as
    }
}
const po = () => Symbol();
function ho(xt) {
    const Cn = new Map
      , as = ({constructor: cs, dependencies: Cs, id: Ls, singleton: Vs}) => {
        if (Vs && Cn.has(Ls))
            return Cn.get(Ls);
        const Ws = cs(Cs.map(Xs => as(Xs)));
        return Vs && Cn.set(Ls, Ws),
        Ws
    }
    ;
    return as(xt)
}
function rt(...xt) {
    const Cn = $$1()
      , as = new Array(xt.length);
    let cs = 0;
    const Cs = Math.pow(2, xt.length) - 1;
    return xt.forEach( (Ls, Vs) => {
        const Ws = Math.pow(2, Vs);
        K$2(Ls, Xs => {
            as[Vs] = Xs,
            cs = cs | Ws,
            cs === Cs && W$1(Cn, as)
        }
        )
    }
    ),
    function(Ls, Vs) {
        switch (Ls) {
        case qt:
            {
                We$1(Cn);
                return
            }
        case zt:
            return cs === Cs && Vs(as),
            K$2(Cn, Vs)
        }
    }
}
function A$2(xt, Cn=Bn) {
    return x$2(xt, Y$1(Cn))
}
function an(...xt) {
    return function(Cn, as) {
        switch (Cn) {
        case qt:
            return;
        case zt:
            return uo(...xt.map(cs => K$2(cs, as)))
        }
    }
}
var ht$1 = (xt => (xt[xt.DEBUG = 0] = "DEBUG",
xt[xt.INFO = 1] = "INFO",
xt[xt.WARN = 2] = "WARN",
xt[xt.ERROR = 3] = "ERROR",
xt))(ht$1 || {});
const go = {
    0: "debug",
    3: "error",
    1: "log",
    2: "warn"
}
  , Io = () => typeof globalThis > "u" ? window : globalThis
  , Vt$1 = U$3( () => {
    const xt = v(3);
    return {
        log: v( (Cn, as, cs=1) => {
            var Cs;
            const Ls = (Cs = Io().VIRTUOSO_LOG_LEVEL) != null ? Cs : lt(xt);
            cs >= Ls && console[go[cs]]("%creact-virtuoso: %c%s %o", "color: #0253b3; font-weight: bold", "color: initial", Cn, as)
        }
        ),
        logLevel: xt
    }
}
, [], {
    singleton: !0
});
function Ht$1(xt, Cn, as) {
    return _e(xt, Cn, as).callbackRef
}
function _e(xt, Cn, as) {
    const cs = React__default.useRef(null);
    let Cs = Vs => {}
    ;
    const Ls = React__default.useMemo( () => typeof ResizeObserver < "u" ? new ResizeObserver(Vs => {
        const Ws = () => {
            const Xs = Vs[0].target;
            Xs.offsetParent !== null && xt(Xs)
        }
        ;
        as ? Ws() : requestAnimationFrame(Ws)
    }
    ) : null, [xt, as]);
    return Cs = Vs => {
        Vs && Cn ? (Ls == null || Ls.observe(Vs),
        cs.current = Vs) : (cs.current && (Ls == null || Ls.unobserve(cs.current)),
        cs.current = null)
    }
    ,
    {
        callbackRef: Cs,
        ref: cs
    }
}
function kn(xt, Cn, as, cs, Cs, Ls, Vs, Ws, Xs) {
    const ga = React__default.useCallback(ba => {
        const yl = So(ba.children, Cn, Ws ? "offsetWidth" : "offsetHeight", Cs);
        let xl = ba.parentElement;
        for (; !xl.dataset.virtuosoScroller; )
            xl = xl.parentElement;
        const wl = xl.lastElementChild.dataset.viewportType === "window";
        let _l;
        wl && (_l = xl.ownerDocument.defaultView);
        const El = Vs ? Ws ? Vs.scrollLeft : Vs.scrollTop : wl ? Ws ? _l.scrollX || _l.document.documentElement.scrollLeft : _l.scrollY || _l.document.documentElement.scrollTop : Ws ? xl.scrollLeft : xl.scrollTop
          , Cl = Vs ? Ws ? Vs.scrollWidth : Vs.scrollHeight : wl ? Ws ? _l.document.documentElement.scrollWidth : _l.document.documentElement.scrollHeight : Ws ? xl.scrollWidth : xl.scrollHeight
          , $l = Vs ? Ws ? Vs.offsetWidth : Vs.offsetHeight : wl ? Ws ? _l.innerWidth : _l.innerHeight : Ws ? xl.offsetWidth : xl.offsetHeight;
        cs({
            scrollHeight: Cl,
            scrollTop: Math.max(El, 0),
            viewportHeight: $l
        }),
        Ls == null || Ls(Ws ? dn("column-gap", getComputedStyle(ba).columnGap, Cs) : dn("row-gap", getComputedStyle(ba).rowGap, Cs)),
        yl !== null && xt(yl)
    }
    , [xt, Cn, Cs, Ls, Vs, cs, Ws]);
    return _e(ga, as, Xs)
}
function So(xt, Cn, as, cs) {
    const Cs = xt.length;
    if (Cs === 0)
        return null;
    const Ls = [];
    for (let Vs = 0; Vs < Cs; Vs++) {
        const Ws = xt.item(Vs);
        if (Ws.dataset.index === void 0)
            continue;
        const Xs = parseInt(Ws.dataset.index)
          , ga = parseFloat(Ws.dataset.knownSize)
          , ba = Cn(Ws, as);
        if (ba === 0 && cs("Zero-sized element, this should not happen", {
            child: Ws
        }, ht$1.ERROR),
        ba === ga)
            continue;
        const yl = Ls[Ls.length - 1];
        Ls.length === 0 || yl.size !== ba || yl.endIndex !== Xs - 1 ? Ls.push({
            endIndex: Xs,
            size: ba,
            startIndex: Xs
        }) : Ls[Ls.length - 1].endIndex++
    }
    return Ls
}
function dn(xt, Cn, as) {
    return Cn !== "normal" && !(Cn != null && Cn.endsWith("px")) && as(`${xt} was not resolved to pixel value correctly`, Cn, ht$1.WARN),
    Cn === "normal" ? 0 : parseInt(Cn ?? "0", 10)
}
function Ge(xt, Cn, as) {
    const cs = React__default.useRef(null)
      , Cs = React__default.useCallback(Xs => {
        if (!(Xs != null && Xs.offsetParent))
            return;
        const ga = Xs.getBoundingClientRect()
          , ba = ga.width;
        let yl, xl;
        if (Cn) {
            const wl = Cn.getBoundingClientRect()
              , _l = ga.top - wl.top;
            xl = wl.height - Math.max(0, _l),
            yl = _l + Cn.scrollTop
        } else {
            const wl = Vs.current.ownerDocument.defaultView;
            xl = wl.innerHeight - Math.max(0, ga.top),
            yl = ga.top + wl.scrollY
        }
        cs.current = {
            offsetTop: yl,
            visibleHeight: xl,
            visibleWidth: ba
        },
        xt(cs.current)
    }
    , [xt, Cn])
      , {callbackRef: Ls, ref: Vs} = _e(Cs, !0, as)
      , Ws = React__default.useCallback( () => {
        Cs(Vs.current)
    }
    , [Cs, Vs]);
    return React__default.useEffect( () => {
        var Xs;
        if (Cn) {
            Cn.addEventListener("scroll", Ws);
            const ga = new ResizeObserver( () => {
                requestAnimationFrame(Ws)
            }
            );
            return ga.observe(Cn),
            () => {
                Cn.removeEventListener("scroll", Ws),
                ga.unobserve(Cn)
            }
        } else {
            const ga = (Xs = Vs.current) == null ? void 0 : Xs.ownerDocument.defaultView;
            return ga == null || ga.addEventListener("scroll", Ws),
            ga == null || ga.addEventListener("resize", Ws),
            () => {
                ga == null || ga.removeEventListener("scroll", Ws),
                ga == null || ga.removeEventListener("resize", Ws)
            }
        }
    }
    , [Ws, Cn, Vs]),
    Ls
}
const at = U$3( () => {
    const xt = $$1()
      , Cn = $$1()
      , as = v(0)
      , cs = $$1()
      , Cs = v(0)
      , Ls = $$1()
      , Vs = $$1()
      , Ws = v(0)
      , Xs = v(0)
      , ga = v(0)
      , ba = v(0)
      , yl = $$1()
      , xl = $$1()
      , wl = v(!1)
      , _l = v(!1)
      , El = v(!1);
    return F$3(x$2(xt, E$2( ({scrollTop: Cl}) => Cl)), Cn),
    F$3(x$2(xt, E$2( ({scrollHeight: Cl}) => Cl)), Vs),
    F$3(Cn, Cs),
    {
        deviation: as,
        fixedFooterHeight: ga,
        fixedHeaderHeight: Xs,
        footerHeight: ba,
        headerHeight: Ws,
        horizontalDirection: _l,
        scrollBy: xl,
        scrollContainerState: xt,
        scrollHeight: Vs,
        scrollingInProgress: wl,
        scrollTo: yl,
        scrollTop: Cn,
        skipAnimationFrameInResizeObserver: El,
        smoothScrollTargetReached: cs,
        statefulScrollTop: Cs,
        viewportHeight: Ls
    }
}
, [], {
    singleton: !0
})
  , oe$1 = {
    lvl: 0
};
function On(xt, Cn) {
    const as = xt.length;
    if (as === 0)
        return [];
    let {index: cs, value: Cs} = Cn(xt[0]);
    const Ls = [];
    for (let Vs = 1; Vs < as; Vs++) {
        const {index: Ws, value: Xs} = Cn(xt[Vs]);
        Ls.push({
            end: Ws - 1,
            start: cs,
            value: Cs
        }),
        cs = Ws,
        Cs = Xs
    }
    return Ls.push({
        end: 1 / 0,
        start: cs,
        value: Cs
    }),
    Ls
}
function j$4(xt) {
    return xt === oe$1
}
function re(xt, Cn) {
    if (!j$4(xt))
        return Cn === xt.k ? xt.v : Cn < xt.k ? re(xt.l, Cn) : re(xt.r, Cn)
}
function Ct$1(xt, Cn, as="k") {
    if (j$4(xt))
        return [-1 / 0, void 0];
    if (Number(xt[as]) === Cn)
        return [xt.k, xt.v];
    if (Number(xt[as]) < Cn) {
        const cs = Ct$1(xt.r, Cn, as);
        return cs[0] === -1 / 0 ? [xt.k, xt.v] : cs
    }
    return Ct$1(xt.l, Cn, as)
}
function mt$1(xt, Cn, as) {
    return j$4(xt) ? zn(Cn, as, 1) : Cn === xt.k ? ot(xt, {
        k: Cn,
        v: as
    }) : Cn < xt.k ? fn(ot(xt, {
        l: mt$1(xt.l, Cn, as)
    })) : fn(ot(xt, {
        r: mt$1(xt.r, Cn, as)
    }))
}
function Ut$1() {
    return oe$1
}
function ye$2(xt, Cn, as) {
    if (j$4(xt))
        return [];
    const cs = Ct$1(xt, Cn)[0];
    return xo(ze(xt, cs, as))
}
function Le(xt, Cn) {
    if (j$4(xt))
        return oe$1;
    const {k: as, l: cs, r: Cs} = xt;
    if (Cn === as) {
        if (j$4(cs))
            return Cs;
        if (j$4(Cs))
            return cs;
        {
            const [Ls,Vs] = Ln(cs);
            return ge$1(ot(xt, {
                k: Ls,
                l: Fn(cs),
                v: Vs
            }))
        }
    } else
        return Cn < as ? ge$1(ot(xt, {
            l: Le(cs, Cn)
        })) : ge$1(ot(xt, {
            r: Le(Cs, Cn)
        }))
}
function _t$1(xt) {
    return j$4(xt) ? [] : [..._t$1(xt.l), {
        k: xt.k,
        v: xt.v
    }, ..._t$1(xt.r)]
}
function ze(xt, Cn, as) {
    if (j$4(xt))
        return [];
    const {k: cs, l: Cs, r: Ls, v: Vs} = xt;
    let Ws = [];
    return cs > Cn && (Ws = Ws.concat(ze(Cs, Cn, as))),
    cs >= Cn && cs <= as && Ws.push({
        k: cs,
        v: Vs
    }),
    cs <= as && (Ws = Ws.concat(ze(Ls, Cn, as))),
    Ws
}
function ge$1(xt) {
    const {l: Cn, lvl: as, r: cs} = xt;
    if (cs.lvl >= as - 1 && Cn.lvl >= as - 1)
        return xt;
    if (as > cs.lvl + 1) {
        if (Ee$2(Cn))
            return Vn(ot(xt, {
                lvl: as - 1
            }));
        if (!j$4(Cn) && !j$4(Cn.r))
            return ot(Cn.r, {
                l: ot(Cn, {
                    r: Cn.r.l
                }),
                lvl: as,
                r: ot(xt, {
                    l: Cn.r.r,
                    lvl: as - 1
                })
            });
        throw new Error("Unexpected empty nodes")
    } else {
        if (Ee$2(xt))
            return Ve$1(ot(xt, {
                lvl: as - 1
            }));
        if (!j$4(cs) && !j$4(cs.l)) {
            const Cs = cs.l
              , Ls = Ee$2(Cs) ? cs.lvl - 1 : cs.lvl;
            return ot(Cs, {
                l: ot(xt, {
                    lvl: as - 1,
                    r: Cs.l
                }),
                lvl: Cs.lvl + 1,
                r: Ve$1(ot(cs, {
                    l: Cs.r,
                    lvl: Ls
                }))
            })
        } else
            throw new Error("Unexpected empty nodes")
    }
}
function ot(xt, Cn) {
    return zn(Cn.k !== void 0 ? Cn.k : xt.k, Cn.v !== void 0 ? Cn.v : xt.v, Cn.lvl !== void 0 ? Cn.lvl : xt.lvl, Cn.l !== void 0 ? Cn.l : xt.l, Cn.r !== void 0 ? Cn.r : xt.r)
}
function Fn(xt) {
    return j$4(xt.r) ? xt.l : ge$1(ot(xt, {
        r: Fn(xt.r)
    }))
}
function Ee$2(xt) {
    return j$4(xt) || xt.lvl > xt.r.lvl
}
function Ln(xt) {
    return j$4(xt.r) ? [xt.k, xt.v] : Ln(xt.r)
}
function zn(xt, Cn, as, cs=oe$1, Cs=oe$1) {
    return {
        k: xt,
        l: cs,
        lvl: as,
        r: Cs,
        v: Cn
    }
}
function fn(xt) {
    return Ve$1(Vn(xt))
}
function Vn(xt) {
    const {l: Cn} = xt;
    return !j$4(Cn) && Cn.lvl === xt.lvl ? ot(Cn, {
        r: ot(xt, {
            l: Cn.r
        })
    }) : xt
}
function Ve$1(xt) {
    const {lvl: Cn, r: as} = xt;
    return !j$4(as) && !j$4(as.r) && as.lvl === Cn && as.r.lvl === Cn ? ot(as, {
        l: ot(xt, {
            r: as.l
        }),
        lvl: Cn + 1
    }) : xt
}
function xo(xt) {
    return On(xt, ({k: Cn, v: as}) => ({
        index: Cn,
        value: as
    }))
}
function Pn(xt, Cn) {
    return !!(xt && xt.startIndex === Cn.startIndex && xt.endIndex === Cn.endIndex)
}
function se(xt, Cn) {
    return !!(xt && xt[0] === Cn[0] && xt[1] === Cn[1])
}
const Ne$1 = U$3( () => ({
    recalcInProgress: v(!1)
}), [], {
    singleton: !0
});
function An(xt, Cn, as) {
    return xt[Se$2(xt, Cn, as)]
}
function Se$2(xt, Cn, as, cs=0) {
    let Cs = xt.length - 1;
    for (; cs <= Cs; ) {
        const Ls = Math.floor((cs + Cs) / 2)
          , Vs = xt[Ls]
          , Ws = as(Vs, Cn);
        if (Ws === 0)
            return Ls;
        if (Ws === -1) {
            if (Cs - cs < 2)
                return Ls - 1;
            Cs = Ls - 1
        } else {
            if (Cs === cs)
                return Ls;
            cs = Ls + 1
        }
    }
    throw new Error(`Failed binary finding record in array - ${xt.join(",")}, searched for ${Cn}`)
}
function To(xt, Cn, as, cs) {
    const Cs = Se$2(xt, Cn, cs)
      , Ls = Se$2(xt, as, cs, Cs);
    return xt.slice(Cs, Ls + 1)
}
function wt$1(xt, Cn) {
    return Math.round(xt.getBoundingClientRect()[Cn])
}
function Re$2(xt) {
    return !j$4(xt.groupOffsetTree)
}
function De$1({index: xt}, Cn) {
    return Cn === xt ? 0 : Cn < xt ? -1 : 1
}
function Co() {
    return {
        groupIndices: [],
        groupOffsetTree: Ut$1(),
        lastIndex: 0,
        lastOffset: 0,
        lastSize: 0,
        offsetTree: [],
        sizeTree: Ut$1()
    }
}
function wo(xt, Cn) {
    let as = j$4(xt) ? 0 : 1 / 0;
    for (const cs of Cn) {
        const {endIndex: Cs, size: Ls, startIndex: Vs} = cs;
        if (as = Math.min(as, Vs),
        j$4(xt)) {
            xt = mt$1(xt, 0, Ls);
            continue
        }
        const Ws = ye$2(xt, Vs - 1, Cs + 1);
        if (Ws.some(Bo(cs)))
            continue;
        let Xs = !1
          , ga = !1;
        for (const {end: ba, start: yl, value: xl} of Ws)
            Xs ? (Cs >= yl || Ls === xl) && (xt = Le(xt, yl)) : (ga = xl !== Ls,
            Xs = !0),
            ba > Cs && Cs >= yl && xl !== Ls && (xt = mt$1(xt, Cs + 1, xl));
        ga && (xt = mt$1(xt, Vs, Ls))
    }
    return [xt, as]
}
function vo(xt) {
    return typeof xt.groupIndex < "u"
}
function yo({offset: xt}, Cn) {
    return Cn === xt ? 0 : Cn < xt ? -1 : 1
}
function ie(xt, Cn, as) {
    if (Cn.length === 0)
        return 0;
    const {index: cs, offset: Cs, size: Ls} = An(Cn, xt, De$1)
      , Vs = xt - cs
      , Ws = Ls * Vs + (Vs - 1) * as + Cs;
    return Ws > 0 ? Ws + as : Ws
}
function Mn(xt, Cn) {
    if (!Re$2(Cn))
        return xt;
    let as = 0;
    for (; Cn.groupIndices[as] <= xt + as; )
        as++;
    return xt + as
}
function Wn(xt, Cn, as) {
    if (vo(xt))
        return Cn.groupIndices[xt.groupIndex] + 1;
    {
        const cs = xt.index === "LAST" ? as : xt.index;
        let Cs = Mn(cs, Cn);
        return Cs = Math.max(0, Cs, Math.min(as, Cs)),
        Cs
    }
}
function Ro(xt, Cn, as, cs=0) {
    return cs > 0 && (Cn = Math.max(Cn, An(xt, cs, De$1).offset)),
    On(To(xt, Cn, as, yo), Eo)
}
function bo(xt, [Cn,as,cs,Cs]) {
    Cn.length > 0 && cs("received item sizes", Cn, ht$1.DEBUG);
    const Ls = xt.sizeTree;
    let Vs = Ls
      , Ws = 0;
    if (as.length > 0 && j$4(Ls) && Cn.length === 2) {
        const xl = Cn[0].size
          , wl = Cn[1].size;
        Vs = as.reduce( (_l, El) => mt$1(mt$1(_l, El, xl), El + 1, wl), Vs)
    } else
        [Vs,Ws] = wo(Vs, Cn);
    if (Vs === Ls)
        return xt;
    const {lastIndex: Xs, lastOffset: ga, lastSize: ba, offsetTree: yl} = Pe$1(xt.offsetTree, Ws, Vs, Cs);
    return {
        groupIndices: as,
        groupOffsetTree: as.reduce( (xl, wl) => mt$1(xl, wl, ie(wl, yl, Cs)), Ut$1()),
        lastIndex: Xs,
        lastOffset: ga,
        lastSize: ba,
        offsetTree: yl,
        sizeTree: Vs
    }
}
function Ho(xt) {
    return _t$1(xt).map( ({k: Cn, v: as}, cs, Cs) => {
        const Ls = Cs[cs + 1];
        return {
            endIndex: Ls ? Ls.k - 1 : 1 / 0,
            size: as,
            startIndex: Cn
        }
    }
    )
}
function mn(xt, Cn) {
    let as = 0
      , cs = 0;
    for (; as < xt; )
        as += Cn[cs + 1] - Cn[cs] - 1,
        cs++;
    return cs - (as === xt ? 0 : 1)
}
function Pe$1(xt, Cn, as, cs) {
    let Cs = xt
      , Ls = 0
      , Vs = 0
      , Ws = 0
      , Xs = 0;
    if (Cn !== 0) {
        Xs = Se$2(Cs, Cn - 1, De$1),
        Ws = Cs[Xs].offset;
        const ga = Ct$1(as, Cn - 1);
        Ls = ga[0],
        Vs = ga[1],
        Cs.length && Cs[Xs].size === Ct$1(as, Cn)[1] && (Xs -= 1),
        Cs = Cs.slice(0, Xs + 1)
    } else
        Cs = [];
    for (const {start: ga, value: ba} of ye$2(as, Cn, 1 / 0)) {
        const yl = ga - Ls
          , xl = yl * Vs + Ws + yl * cs;
        Cs.push({
            index: ga,
            offset: xl,
            size: ba
        }),
        Ls = ga,
        Ws = xl,
        Vs = ba
    }
    return {
        lastIndex: Ls,
        lastOffset: Ws,
        lastSize: Vs,
        offsetTree: Cs
    }
}
function Eo(xt) {
    return {
        index: xt.index,
        value: xt
    }
}
function Bo(xt) {
    const {endIndex: Cn, size: as, startIndex: cs} = xt;
    return Cs => Cs.start === cs && (Cs.end === Cn || Cs.end === 1 / 0) && Cs.value === as
}
const ko = {
    offsetHeight: "height",
    offsetWidth: "width"
}
  , Et$1 = U$3( ([{log: xt},{recalcInProgress: Cn}]) => {
    const as = $$1()
      , cs = $$1()
      , Cs = ct(cs, 0)
      , Ls = $$1()
      , Vs = $$1()
      , Ws = v(0)
      , Xs = v([])
      , ga = v(void 0)
      , ba = v(void 0)
      , yl = v( (Il, Ml) => wt$1(Il, ko[Ml]))
      , xl = v(void 0)
      , wl = v(0)
      , _l = Co()
      , El = ct(x$2(as, G$1(Xs, xt, wl), Rt$1(bo, _l), Y$1()), _l)
      , Cl = ct(x$2(Xs, Y$1(), Rt$1( (Il, Ml) => ({
        current: Ml,
        prev: Il.current
    }), {
        current: [],
        prev: []
    }), E$2( ({prev: Il}) => Il)), []);
    F$3(x$2(Xs, P$4(Il => Il.length > 0), G$1(El, wl), E$2( ([Il,Ml,Nl]) => {
        const Ll = Il.reduce( (Fl, Ul, Dl) => mt$1(Fl, Ul, ie(Ul, Ml.offsetTree, Nl) || Dl), Ut$1());
        return {
            ...Ml,
            groupIndices: Il,
            groupOffsetTree: Ll
        }
    }
    )), El),
    F$3(x$2(cs, G$1(El), P$4( ([Il,{lastIndex: Ml}]) => Il < Ml), E$2( ([Il,{lastIndex: Ml, lastSize: Nl}]) => [{
        endIndex: Ml,
        size: Nl,
        startIndex: Il
    }])), as),
    F$3(ga, ba);
    const $l = ct(x$2(ga, E$2(Il => Il === void 0)), !0);
    F$3(x$2(ba, P$4(Il => Il !== void 0 && j$4(lt(El).sizeTree)), E$2(Il => [{
        endIndex: 0,
        size: Il,
        startIndex: 0
    }])), as);
    const Sl = pt(x$2(as, G$1(El), Rt$1( ({sizes: Il}, [Ml,Nl]) => ({
        changed: Nl !== Il,
        sizes: Nl
    }), {
        changed: !1,
        sizes: _l
    }), E$2(Il => Il.changed)));
    K$2(x$2(Ws, Rt$1( (Il, Ml) => ({
        diff: Il.prev - Ml,
        prev: Ml
    }), {
        diff: 0,
        prev: 0
    }), E$2(Il => Il.diff)), Il => {
        const {groupIndices: Ml} = lt(El);
        if (Il > 0)
            W$1(Cn, !0),
            W$1(Ls, Il + mn(Il, Ml));
        else if (Il < 0) {
            const Nl = lt(Cl);
            Nl.length > 0 && (Il -= mn(-Il, Nl)),
            W$1(Vs, Il)
        }
    }
    ),
    K$2(x$2(Ws, G$1(xt)), ([Il,Ml]) => {
        Il < 0 && Ml("`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value", {
            firstItemIndex: Ws
        }, ht$1.ERROR)
    }
    );
    const Tl = pt(Ls);
    F$3(x$2(Ls, G$1(El), E$2( ([Il,Ml]) => {
        const Nl = Ml.groupIndices.length > 0
          , Ll = []
          , Fl = Ml.lastSize;
        if (Nl) {
            const Ul = re(Ml.sizeTree, 0);
            let Dl = 0
              , Zl = 0;
            for (; Dl < Il; ) {
                const Wl = Ml.groupIndices[Zl]
                  , Ql = Ml.groupIndices.length === Zl + 1 ? 1 / 0 : Ml.groupIndices[Zl + 1] - Wl - 1;
                Ll.push({
                    endIndex: Wl,
                    size: Ul,
                    startIndex: Wl
                }),
                Ll.push({
                    endIndex: Wl + 1 + Ql - 1,
                    size: Fl,
                    startIndex: Wl + 1
                }),
                Zl++,
                Dl += Ql + 1
            }
            const Gl = _t$1(Ml.sizeTree);
            return Dl !== Il && Gl.shift(),
            Gl.reduce( (Wl, {k: Ql, v: cu}) => {
                let pu = Wl.ranges;
                return Wl.prevSize !== 0 && (pu = [...Wl.ranges, {
                    endIndex: Ql + Il - 1,
                    size: Wl.prevSize,
                    startIndex: Wl.prevIndex
                }]),
                {
                    prevIndex: Ql + Il,
                    prevSize: cu,
                    ranges: pu
                }
            }
            , {
                prevIndex: Il,
                prevSize: 0,
                ranges: Ll
            }).ranges
        }
        return _t$1(Ml.sizeTree).reduce( (Ul, {k: Dl, v: Zl}) => ({
            prevIndex: Dl + Il,
            prevSize: Zl,
            ranges: [...Ul.ranges, {
                endIndex: Dl + Il - 1,
                size: Ul.prevSize,
                startIndex: Ul.prevIndex
            }]
        }), {
            prevIndex: 0,
            prevSize: Fl,
            ranges: []
        }).ranges
    }
    )), as);
    const Rl = pt(x$2(Vs, G$1(El, wl), E$2( ([Il,{offsetTree: Ml},Nl]) => {
        const Ll = -Il;
        return ie(Ll, Ml, Nl)
    }
    )));
    return F$3(x$2(Vs, G$1(El, wl), E$2( ([Il,Ml,Nl]) => {
        if (Ml.groupIndices.length > 0) {
            if (j$4(Ml.sizeTree))
                return Ml;
            let Ll = Ut$1();
            const Fl = lt(Cl);
            let Ul = 0
              , Dl = 0
              , Zl = 0;
            for (; Ul < -Il; ) {
                Zl = Fl[Dl];
                const Gl = Fl[Dl + 1] - Zl - 1;
                Dl++,
                Ul += Gl + 1
            }
            if (Ll = _t$1(Ml.sizeTree).reduce( (Gl, {k: Wl, v: Ql}) => mt$1(Gl, Math.max(0, Wl + Il), Ql), Ll),
            Ul !== -Il) {
                const Gl = re(Ml.sizeTree, Zl);
                Ll = mt$1(Ll, 0, Gl);
                const Wl = Ct$1(Ml.sizeTree, -Il + 1)[1];
                Ll = mt$1(Ll, 1, Wl)
            }
            return {
                ...Ml,
                sizeTree: Ll,
                ...Pe$1(Ml.offsetTree, 0, Ll, Nl)
            }
        } else {
            const Ll = _t$1(Ml.sizeTree).reduce( (Fl, {k: Ul, v: Dl}) => mt$1(Fl, Math.max(0, Ul + Il), Dl), Ut$1());
            return {
                ...Ml,
                sizeTree: Ll,
                ...Pe$1(Ml.offsetTree, 0, Ll, Nl)
            }
        }
    }
    )), El),
    {
        beforeUnshiftWith: Tl,
        data: xl,
        defaultItemSize: ba,
        firstItemIndex: Ws,
        fixedItemSize: ga,
        gap: wl,
        groupIndices: Xs,
        itemSize: yl,
        listRefresh: Sl,
        shiftWith: Vs,
        shiftWithOffset: Rl,
        sizeRanges: as,
        sizes: El,
        statefulTotalCount: Cs,
        totalCount: cs,
        trackItemSizes: $l,
        unshiftWith: Ls
    }
}
, X$3(Vt$1, Ne$1), {
    singleton: !0
});
function Oo(xt) {
    return xt.reduce( (Cn, as) => (Cn.groupIndices.push(Cn.totalCount),
    Cn.totalCount += as + 1,
    Cn), {
        groupIndices: [],
        totalCount: 0
    })
}
const _n = U$3( ([{groupIndices: xt, sizes: Cn, totalCount: as},{headerHeight: cs, scrollTop: Cs}]) => {
    const Ls = $$1()
      , Vs = $$1()
      , Ws = pt(x$2(Ls, E$2(Oo)));
    return F$3(x$2(Ws, E$2(Xs => Xs.totalCount)), as),
    F$3(x$2(Ws, E$2(Xs => Xs.groupIndices)), xt),
    F$3(x$2(rt(Cs, Cn, cs), P$4( ([Xs,ga]) => Re$2(ga)), E$2( ([Xs,ga,ba]) => Ct$1(ga.groupOffsetTree, Math.max(Xs - ba, 0), "v")[0]), Y$1(), E$2(Xs => [Xs])), Vs),
    {
        groupCounts: Ls,
        topItemsIndexes: Vs
    }
}
, X$3(Et$1, at))
  , Pt$1 = U$3( ([{log: xt}]) => {
    const Cn = v(!1)
      , as = pt(x$2(Cn, P$4(cs => cs), Y$1()));
    return K$2(Cn, cs => {
        cs && lt(xt)("props updated", {}, ht$1.DEBUG)
    }
    ),
    {
        didMount: as,
        propsReady: Cn
    }
}
, X$3(Vt$1), {
    singleton: !0
})
  , Fo = typeof document < "u" && "scrollBehavior"in document.documentElement.style;
function Gn(xt) {
    const Cn = typeof xt == "number" ? {
        index: xt
    } : xt;
    return Cn.align || (Cn.align = "start"),
    (!Cn.behavior || !Fo) && (Cn.behavior = "auto"),
    Cn.offset || (Cn.offset = 0),
    Cn
}
const ce$2 = U$3( ([{gap: xt, listRefresh: Cn, sizes: as, totalCount: cs},{fixedFooterHeight: Cs, fixedHeaderHeight: Ls, footerHeight: Vs, headerHeight: Ws, scrollingInProgress: Xs, scrollTo: ga, smoothScrollTargetReached: ba, viewportHeight: yl},{log: xl}]) => {
    const wl = $$1()
      , _l = $$1()
      , El = v(0);
    let Cl = null
      , $l = null
      , Sl = null;
    function Tl() {
        Cl && (Cl(),
        Cl = null),
        Sl && (Sl(),
        Sl = null),
        $l && (clearTimeout($l),
        $l = null),
        W$1(Xs, !1)
    }
    return F$3(x$2(wl, G$1(as, yl, cs, El, Ws, Vs, xl), G$1(xt, Ls, Cs), E$2( ([[Rl,Il,Ml,Nl,Ll,Fl,Ul,Dl],Zl,Gl,Wl]) => {
        const Ql = Gn(Rl)
          , {align: cu, behavior: pu, offset: zl} = Ql
          , Yl = Nl - 1
          , lu = Wn(Ql, Il, Yl);
        let mu = ie(lu, Il.offsetTree, Zl) + Fl;
        cu === "end" ? (mu += Gl + Ct$1(Il.sizeTree, lu)[1] - Ml + Wl,
        lu === Yl && (mu += Ul)) : cu === "center" ? mu += (Gl + Ct$1(Il.sizeTree, lu)[1] - Ml + Wl) / 2 : mu -= Ll,
        zl && (mu += zl);
        const Cu = ju => {
            Tl(),
            ju ? (Dl("retrying to scroll to", {
                location: Rl
            }, ht$1.DEBUG),
            W$1(wl, Rl)) : (W$1(_l, !0),
            Dl("list did not change, scroll successful", {}, ht$1.DEBUG))
        }
        ;
        if (Tl(),
        pu === "smooth") {
            let ju = !1;
            Sl = K$2(Cn, Lu => {
                ju = ju || Lu
            }
            ),
            Cl = bt(ba, () => {
                Cu(ju)
            }
            )
        } else
            Cl = bt(x$2(Cn, Lo(150)), Cu);
        return $l = setTimeout( () => {
            Tl()
        }
        , 1200),
        W$1(Xs, !0),
        Dl("scrolling from index to", {
            behavior: pu,
            index: lu,
            top: mu
        }, ht$1.DEBUG),
        {
            behavior: pu,
            top: mu
        }
    }
    )), ga),
    {
        scrollTargetReached: _l,
        scrollToIndex: wl,
        topListHeight: El
    }
}
, X$3(Et$1, at, Vt$1), {
    singleton: !0
});
function Lo(xt) {
    return Cn => {
        const as = setTimeout( () => {
            Cn(!1)
        }
        , xt);
        return cs => {
            cs && (Cn(!0),
            clearTimeout(as))
        }
    }
}
function $e$1(xt, Cn) {
    xt == 0 ? Cn() : requestAnimationFrame( () => {
        $e$1(xt - 1, Cn)
    }
    )
}
function Ue$1(xt, Cn) {
    const as = Cn - 1;
    return typeof xt == "number" ? xt : xt.index === "LAST" ? as : xt.index
}
const ue = U$3( ([{defaultItemSize: xt, listRefresh: Cn, sizes: as},{scrollTop: cs},{scrollTargetReached: Cs, scrollToIndex: Ls},{didMount: Vs}]) => {
    const Ws = v(!0)
      , Xs = v(0)
      , ga = v(!0);
    return F$3(x$2(Vs, G$1(Xs), P$4( ([ba,yl]) => !!yl), yt(!1)), Ws),
    F$3(x$2(Vs, G$1(Xs), P$4( ([ba,yl]) => !!yl), yt(!1)), ga),
    K$2(x$2(rt(Cn, Vs), G$1(Ws, as, xt, ga), P$4( ([[,ba],yl,{sizeTree: xl},wl,_l]) => ba && (!j$4(xl) || Me$2(wl)) && !yl && !_l), G$1(Xs)), ([,ba]) => {
        bt(Cs, () => {
            W$1(ga, !0)
        }
        ),
        $e$1(4, () => {
            bt(cs, () => {
                W$1(Ws, !0)
            }
            ),
            W$1(Ls, ba)
        }
        )
    }
    ),
    {
        initialItemFinalLocationReached: ga,
        initialTopMostItemIndex: Xs,
        scrolledToInitialItem: Ws
    }
}
, X$3(Et$1, at, ce$2, Pt$1), {
    singleton: !0
});
function Nn(xt, Cn) {
    return Math.abs(xt - Cn) < 1.01
}
const le = "up"
  , te = "down"
  , zo = "none"
  , Vo = {
    atBottom: !1,
    notAtBottomBecause: "NOT_SHOWING_LAST_ITEM",
    state: {
        offsetBottom: 0,
        scrollHeight: 0,
        scrollTop: 0,
        viewportHeight: 0
    }
}
  , Po = 0
  , ae = U$3( ([{footerHeight: xt, headerHeight: Cn, scrollBy: as, scrollContainerState: cs, scrollTop: Cs, viewportHeight: Ls}]) => {
    const Vs = v(!1)
      , Ws = v(!0)
      , Xs = $$1()
      , ga = $$1()
      , ba = v(4)
      , yl = v(Po)
      , xl = ct(x$2(an(x$2(A$2(Cs), jt(1), yt(!0)), x$2(A$2(Cs), jt(1), yt(!1), un(100))), Y$1()), !1)
      , wl = ct(x$2(an(x$2(as, yt(!0)), x$2(as, yt(!1), un(200))), Y$1()), !1);
    F$3(x$2(rt(A$2(Cs), A$2(yl)), E$2( ([Sl,Tl]) => Sl <= Tl), Y$1()), Ws),
    F$3(x$2(Ws, Lt$1(50)), ga);
    const _l = pt(x$2(rt(cs, A$2(Ls), A$2(Cn), A$2(xt), A$2(ba)), Rt$1( (Sl, [{scrollHeight: Tl, scrollTop: Rl},Il,Ml,Nl,Ll]) => {
        const Fl = Rl + Il - Tl > -Ll
          , Ul = {
            scrollHeight: Tl,
            scrollTop: Rl,
            viewportHeight: Il
        };
        if (Fl) {
            let Zl, Gl;
            return Rl > Sl.state.scrollTop ? (Zl = "SCROLLED_DOWN",
            Gl = Sl.state.scrollTop - Rl) : (Zl = "SIZE_DECREASED",
            Gl = Sl.state.scrollTop - Rl || Sl.scrollTopDelta),
            {
                atBottom: !0,
                atBottomBecause: Zl,
                scrollTopDelta: Gl,
                state: Ul
            }
        }
        let Dl;
        return Ul.scrollHeight > Sl.state.scrollHeight ? Dl = "SIZE_INCREASED" : Il < Sl.state.viewportHeight ? Dl = "VIEWPORT_HEIGHT_DECREASING" : Rl < Sl.state.scrollTop ? Dl = "SCROLLING_UPWARDS" : Dl = "NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM",
        {
            atBottom: !1,
            notAtBottomBecause: Dl,
            state: Ul
        }
    }
    , Vo), Y$1( (Sl, Tl) => Sl && Sl.atBottom === Tl.atBottom)))
      , El = ct(x$2(cs, Rt$1( (Sl, {scrollHeight: Tl, scrollTop: Rl, viewportHeight: Il}) => {
        if (Nn(Sl.scrollHeight, Tl))
            return {
                changed: !1,
                jump: 0,
                scrollHeight: Tl,
                scrollTop: Rl
            };
        {
            const Ml = Tl - (Rl + Il) < 1;
            return Sl.scrollTop !== Rl && Ml ? {
                changed: !0,
                jump: Sl.scrollTop - Rl,
                scrollHeight: Tl,
                scrollTop: Rl
            } : {
                changed: !0,
                jump: 0,
                scrollHeight: Tl,
                scrollTop: Rl
            }
        }
    }
    , {
        changed: !1,
        jump: 0,
        scrollHeight: 0,
        scrollTop: 0
    }), P$4(Sl => Sl.changed), E$2(Sl => Sl.jump)), 0);
    F$3(x$2(_l, E$2(Sl => Sl.atBottom)), Vs),
    F$3(x$2(Vs, Lt$1(50)), Xs);
    const Cl = v(te);
    F$3(x$2(cs, E$2( ({scrollTop: Sl}) => Sl), Y$1(), Rt$1( (Sl, Tl) => lt(wl) ? {
        direction: Sl.direction,
        prevScrollTop: Tl
    } : {
        direction: Tl < Sl.prevScrollTop ? le : te,
        prevScrollTop: Tl
    }, {
        direction: te,
        prevScrollTop: 0
    }), E$2(Sl => Sl.direction)), Cl),
    F$3(x$2(cs, Lt$1(50), yt(zo)), Cl);
    const $l = v(0);
    return F$3(x$2(xl, P$4(Sl => !Sl), yt(0)), $l),
    F$3(x$2(Cs, Lt$1(100), G$1(xl), P$4( ([Sl,Tl]) => !!Tl), Rt$1( ([Sl,Tl], [Rl]) => [Tl, Rl], [0, 0]), E$2( ([Sl,Tl]) => Tl - Sl)), $l),
    {
        atBottomState: _l,
        atBottomStateChange: Xs,
        atBottomThreshold: ba,
        atTopStateChange: ga,
        atTopThreshold: yl,
        isAtBottom: Vs,
        isAtTop: Ws,
        isScrolling: xl,
        lastJumpDueToItemResize: El,
        scrollDirection: Cl,
        scrollVelocity: $l
    }
}
, X$3(at))
  , xe$1 = "top"
  , Te$2 = "bottom"
  , pn = "none";
function hn(xt, Cn, as) {
    return typeof xt == "number" ? as === le && Cn === xe$1 || as === te && Cn === Te$2 ? xt : 0 : as === le ? Cn === xe$1 ? xt.main : xt.reverse : Cn === Te$2 ? xt.main : xt.reverse
}
function gn(xt, Cn) {
    var as;
    return typeof xt == "number" ? xt : (as = xt[Cn]) != null ? as : 0
}
const Ke$1 = U$3( ([{deviation: xt, fixedHeaderHeight: Cn, headerHeight: as, scrollTop: cs, viewportHeight: Cs}]) => {
    const Ls = $$1()
      , Vs = v(0)
      , Ws = v(0)
      , Xs = v(0)
      , ga = ct(x$2(rt(A$2(cs), A$2(Cs), A$2(as), A$2(Ls, se), A$2(Xs), A$2(Vs), A$2(Cn), A$2(xt), A$2(Ws)), E$2( ([ba,yl,xl,[wl,_l],El,Cl,$l,Sl,Tl]) => {
        const Rl = ba - Sl
          , Il = Cl + $l
          , Ml = Math.max(xl - Rl, 0);
        let Nl = pn;
        const Ll = gn(Tl, xe$1)
          , Fl = gn(Tl, Te$2);
        return wl -= Sl,
        wl += xl + $l,
        _l += xl + $l,
        _l -= Sl,
        wl > ba + Il - Ll && (Nl = le),
        _l < ba - Ml + yl + Fl && (Nl = te),
        Nl !== pn ? [Math.max(Rl - xl - hn(El, xe$1, Nl) - Ll, 0), Rl - Ml - $l + yl + hn(El, Te$2, Nl) + Fl] : null
    }
    ), P$4(ba => ba != null), Y$1(se)), [0, 0]);
    return {
        increaseViewportBy: Ws,
        listBoundary: Ls,
        overscan: Xs,
        topListHeight: Vs,
        visibleRange: ga
    }
}
, X$3(at), {
    singleton: !0
});
function Ao(xt, Cn, as) {
    if (Re$2(Cn)) {
        const cs = Mn(xt, Cn);
        return [{
            index: Ct$1(Cn.groupOffsetTree, cs)[0],
            offset: 0,
            size: 0
        }, {
            data: as == null ? void 0 : as[0],
            index: cs,
            offset: 0,
            size: 0
        }]
    }
    return [{
        data: as == null ? void 0 : as[0],
        index: xt,
        offset: 0,
        size: 0
    }]
}
const Be$1 = {
    bottom: 0,
    firstItemIndex: 0,
    items: [],
    offsetBottom: 0,
    offsetTop: 0,
    top: 0,
    topItems: [],
    topListHeight: 0,
    totalCount: 0
};
function Ie$1(xt, Cn, as, cs, Cs, Ls) {
    const {lastIndex: Vs, lastOffset: Ws, lastSize: Xs} = Cs;
    let ga = 0
      , ba = 0;
    if (xt.length > 0) {
        ga = xt[0].offset;
        const El = xt[xt.length - 1];
        ba = El.offset + El.size
    }
    const yl = as - Vs
      , xl = Ws + yl * Xs + (yl - 1) * cs
      , wl = ga
      , _l = xl - ba;
    return {
        bottom: ba,
        firstItemIndex: Ls,
        items: In(xt, Cs, Ls),
        offsetBottom: _l,
        offsetTop: ga,
        top: wl,
        topItems: In(Cn, Cs, Ls),
        topListHeight: Cn.reduce( (El, Cl) => Cl.size + El, 0),
        totalCount: as
    }
}
function Dn(xt, Cn, as, cs, Cs, Ls) {
    let Vs = 0;
    if (as.groupIndices.length > 0)
        for (const ba of as.groupIndices) {
            if (ba - Vs >= xt)
                break;
            Vs++
        }
    const Ws = xt + Vs
      , Xs = Ue$1(Cn, Ws)
      , ga = Array.from({
        length: Ws
    }).map( (ba, yl) => ({
        data: Ls[yl + Xs],
        index: yl + Xs,
        offset: 0,
        size: 0
    }));
    return Ie$1(ga, [], Ws, Cs, as, cs)
}
function In(xt, Cn, as) {
    if (xt.length === 0)
        return [];
    if (!Re$2(Cn))
        return xt.map(ga => ({
            ...ga,
            index: ga.index + as,
            originalIndex: ga.index
        }));
    const cs = xt[0].index
      , Cs = xt[xt.length - 1].index
      , Ls = []
      , Vs = ye$2(Cn.groupOffsetTree, cs, Cs);
    let Ws, Xs = 0;
    for (const ga of xt) {
        (!Ws || Ws.end < ga.index) && (Ws = Vs.shift(),
        Xs = Cn.groupIndices.indexOf(Ws.start));
        let ba;
        ga.index === Ws.start ? ba = {
            index: Xs,
            type: "group"
        } : ba = {
            groupIndex: Xs,
            index: ga.index - (Xs + 1) + as
        },
        Ls.push({
            ...ba,
            data: ga.data,
            offset: ga.offset,
            originalIndex: ga.index,
            size: ga.size
        })
    }
    return Ls
}
const Gt$1 = U$3( ([{data: xt, firstItemIndex: Cn, gap: as, sizes: cs, totalCount: Cs},Ls,{listBoundary: Vs, topListHeight: Ws, visibleRange: Xs},{initialTopMostItemIndex: ga, scrolledToInitialItem: ba},{topListHeight: yl},xl,{didMount: wl},{recalcInProgress: _l}]) => {
    const El = v([])
      , Cl = v(0)
      , $l = $$1();
    F$3(Ls.topItemsIndexes, El);
    const Sl = ct(x$2(rt(wl, _l, A$2(Xs, se), A$2(Cs), A$2(cs), A$2(ga), ba, A$2(El), A$2(Cn), A$2(as), xt), P$4( ([Ml,Nl,,Ll,,,,,,,Fl]) => {
        const Ul = Fl && Fl.length !== Ll;
        return Ml && !Nl && !Ul
    }
    ), E$2( ([,,[Ml,Nl],Ll,Fl,Ul,Dl,Zl,Gl,Wl,Ql]) => {
        const cu = Fl
          , {offsetTree: pu, sizeTree: zl} = cu
          , Yl = lt(Cl);
        if (Ll === 0)
            return {
                ...Be$1,
                totalCount: Ll
            };
        if (Ml === 0 && Nl === 0)
            return Yl === 0 ? {
                ...Be$1,
                totalCount: Ll
            } : Dn(Yl, Ul, Fl, Gl, Wl, Ql || []);
        if (j$4(zl))
            return Yl > 0 ? null : Ie$1(Ao(Ue$1(Ul, Ll), cu, Ql), [], Ll, Wl, cu, Gl);
        const lu = [];
        if (Zl.length > 0) {
            const Au = Zl[0]
              , Du = Zl[Zl.length - 1];
            let Qu = 0;
            for (const fu of ye$2(zl, Au, Du)) {
                const yu = fu.value
                  , vu = Math.max(fu.start, Au)
                  , _u = Math.min(fu.end, Du);
                for (let xu = vu; xu <= _u; xu++)
                    lu.push({
                        data: Ql == null ? void 0 : Ql[xu],
                        index: xu,
                        offset: Qu,
                        size: yu
                    }),
                    Qu += yu
            }
        }
        if (!Dl)
            return Ie$1([], lu, Ll, Wl, cu, Gl);
        const mu = Zl.length > 0 ? Zl[Zl.length - 1] + 1 : 0
          , Cu = Ro(pu, Ml, Nl, mu);
        if (Cu.length === 0)
            return null;
        const ju = Ll - 1
          , Lu = ve([], Au => {
            for (const Du of Cu) {
                const Qu = Du.value;
                let fu = Qu.offset
                  , yu = Du.start;
                const vu = Qu.size;
                if (Qu.offset < Ml) {
                    yu += Math.floor((Ml - Qu.offset + Wl) / (vu + Wl));
                    const xu = yu - Du.start;
                    fu += xu * vu + xu * Wl
                }
                yu < mu && (fu += (mu - yu) * vu,
                yu = mu);
                const _u = Math.min(Du.end, ju);
                for (let xu = yu; xu <= _u && !(fu >= Nl); xu++)
                    Au.push({
                        data: Ql == null ? void 0 : Ql[xu],
                        index: xu,
                        offset: fu,
                        size: vu
                    }),
                    fu += vu + Wl
            }
        }
        );
        return Ie$1(Lu, lu, Ll, Wl, cu, Gl)
    }
    ), P$4(Ml => Ml !== null), Y$1()), Be$1);
    F$3(x$2(xt, P$4(Me$2), E$2(Ml => Ml == null ? void 0 : Ml.length)), Cs),
    F$3(x$2(Sl, E$2(Ml => Ml.topListHeight)), yl),
    F$3(yl, Ws),
    F$3(x$2(Sl, E$2(Ml => [Ml.top, Ml.bottom])), Vs),
    F$3(x$2(Sl, E$2(Ml => Ml.items)), $l);
    const Tl = pt(x$2(Sl, P$4( ({items: Ml}) => Ml.length > 0), G$1(Cs, xt), P$4( ([{items: Ml},Nl]) => Ml[Ml.length - 1].originalIndex === Nl - 1), E$2( ([,Ml,Nl]) => [Ml - 1, Nl]), Y$1(se), E$2( ([Ml]) => Ml)))
      , Rl = pt(x$2(Sl, Lt$1(200), P$4( ({items: Ml, topItems: Nl}) => Ml.length > 0 && Ml[0].originalIndex === Nl.length), E$2( ({items: Ml}) => Ml[0].index), Y$1()))
      , Il = pt(x$2(Sl, P$4( ({items: Ml}) => Ml.length > 0), E$2( ({items: Ml}) => {
        let Nl = 0
          , Ll = Ml.length - 1;
        for (; Ml[Nl].type === "group" && Nl < Ll; )
            Nl++;
        for (; Ml[Ll].type === "group" && Ll > Nl; )
            Ll--;
        return {
            endIndex: Ml[Ll].index,
            startIndex: Ml[Nl].index
        }
    }
    ), Y$1(Pn)));
    return {
        endReached: Tl,
        initialItemCount: Cl,
        itemsRendered: $l,
        listState: Sl,
        rangeChanged: Il,
        startReached: Rl,
        topItemsIndexes: El,
        ...xl
    }
}
, X$3(Et$1, _n, Ke$1, ue, ce$2, ae, Pt$1, Ne$1), {
    singleton: !0
})
  , $n = U$3( ([{fixedFooterHeight: xt, fixedHeaderHeight: Cn, footerHeight: as, headerHeight: cs},{listState: Cs}]) => {
    const Ls = $$1()
      , Vs = ct(x$2(rt(as, xt, cs, Cn, Cs), E$2( ([Ws,Xs,ga,ba,yl]) => Ws + Xs + ga + ba + yl.offsetBottom + yl.bottom)), 0);
    return F$3(A$2(Vs), Ls),
    {
        totalListHeight: Vs,
        totalListHeightChanged: Ls
    }
}
, X$3(at, Gt$1), {
    singleton: !0
})
  , Mo$1 = U$3( ([{viewportHeight: xt},{totalListHeight: Cn}]) => {
    const as = v(!1)
      , cs = ct(x$2(rt(as, xt, Cn), P$4( ([Cs]) => Cs), E$2( ([,Cs,Ls]) => Math.max(0, Cs - Ls)), Lt$1(0), Y$1()), 0);
    return {
        alignToBottom: as,
        paddingTopAddition: cs
    }
}
, X$3(at, $n), {
    singleton: !0
});
function Sn(xt) {
    return xt ? xt === "smooth" ? "smooth" : "auto" : !1
}
const Wo = (xt, Cn) => typeof xt == "function" ? Sn(xt(Cn)) : Cn && Sn(xt)
  , _o = U$3( ([{listRefresh: xt, totalCount: Cn},{atBottomState: as, isAtBottom: cs},{scrollToIndex: Cs},{scrolledToInitialItem: Ls},{didMount: Vs, propsReady: Ws},{log: Xs},{scrollingInProgress: ga}]) => {
    const ba = v(!1)
      , yl = $$1();
    let xl = null;
    function wl(El) {
        W$1(Cs, {
            align: "end",
            behavior: El,
            index: "LAST"
        })
    }
    K$2(x$2(rt(x$2(A$2(Cn), jt(1)), Vs), G$1(A$2(ba), cs, Ls, ga), E$2( ([[El,Cl],$l,Sl,Tl,Rl]) => {
        let Il = Cl && Tl
          , Ml = "auto";
        return Il && (Ml = Wo($l, Sl || Rl),
        Il = Il && !!Ml),
        {
            followOutputBehavior: Ml,
            shouldFollow: Il,
            totalCount: El
        }
    }
    ), P$4( ({shouldFollow: El}) => El)), ({followOutputBehavior: El, totalCount: Cl}) => {
        xl && (xl(),
        xl = null),
        xl = bt(xt, () => {
            lt(Xs)("following output to ", {
                totalCount: Cl
            }, ht$1.DEBUG),
            wl(El),
            xl = null
        }
        )
    }
    );
    function _l(El) {
        const Cl = bt(as, $l => {
            El && !$l.atBottom && $l.notAtBottomBecause === "SIZE_INCREASED" && !xl && (lt(Xs)("scrolling to bottom due to increased size", {}, ht$1.DEBUG),
            wl("auto"))
        }
        );
        setTimeout(Cl, 100)
    }
    return K$2(x$2(rt(A$2(ba), Cn, Ws), P$4( ([El,,Cl]) => El && Cl), Rt$1( ({value: El}, [,Cl]) => ({
        refreshed: El === Cl,
        value: Cl
    }), {
        refreshed: !1,
        value: 0
    }), P$4( ({refreshed: El}) => El), G$1(ba, Cn)), ([,El]) => {
        lt(Ls) && _l(El !== !1)
    }
    ),
    K$2(yl, () => {
        _l(lt(ba) !== !1)
    }
    ),
    K$2(rt(A$2(ba), as), ([El,Cl]) => {
        El && !Cl.atBottom && Cl.notAtBottomBecause === "VIEWPORT_HEIGHT_DECREASING" && wl("auto")
    }
    ),
    {
        autoscrollToBottom: yl,
        followOutput: ba
    }
}
, X$3(Et$1, ae, ce$2, ue, Pt$1, Vt$1, at))
  , Go = U$3( ([{data: xt, firstItemIndex: Cn, gap: as, sizes: cs},{initialTopMostItemIndex: Cs},{initialItemCount: Ls, listState: Vs},{didMount: Ws}]) => (F$3(x$2(Ws, G$1(Ls), P$4( ([,Xs]) => Xs !== 0), G$1(Cs, cs, Cn, as, xt), E$2( ([[,Xs],ga,ba,yl,xl,wl=[]]) => Dn(Xs, ga, ba, yl, xl, wl))), Vs),
{}), X$3(Et$1, ue, Gt$1, Pt$1), {
    singleton: !0
})
  , No = U$3( ([{didMount: xt},{scrollTo: Cn},{listState: as}]) => {
    const cs = v(0);
    return K$2(x$2(xt, G$1(cs), P$4( ([,Cs]) => Cs !== 0), E$2( ([,Cs]) => ({
        top: Cs
    }))), Cs => {
        bt(x$2(as, jt(1), P$4(Ls => Ls.items.length > 1)), () => {
            requestAnimationFrame( () => {
                W$1(Cn, Cs)
            }
            )
        }
        )
    }
    ),
    {
        initialScrollTop: cs
    }
}
, X$3(Pt$1, at, Gt$1), {
    singleton: !0
})
  , Do = ({itemBottom: xt, itemTop: Cn, locationParams: {align: as, behavior: cs, ...Cs}, viewportBottom: Ls, viewportTop: Vs}) => Cn < Vs ? {
    ...Cs,
    align: as ?? "start",
    behavior: cs
} : xt > Ls ? {
    ...Cs,
    align: as ?? "end",
    behavior: cs
} : null
  , $o = U$3( ([{gap: xt, sizes: Cn, totalCount: as},{fixedFooterHeight: cs, fixedHeaderHeight: Cs, headerHeight: Ls, scrollingInProgress: Vs, scrollTop: Ws, viewportHeight: Xs},{scrollToIndex: ga}]) => {
    const ba = $$1();
    return F$3(x$2(ba, G$1(Cn, Xs, as, Ls, Cs, cs, Ws), G$1(xt), E$2( ([[yl,xl,wl,_l,El,Cl,$l,Sl],Tl]) => {
        const {align: Rl, behavior: Il, calculateViewLocation: Ml=Do, done: Nl, ...Ll} = yl
          , Fl = Wn(yl, xl, _l - 1)
          , Ul = ie(Fl, xl.offsetTree, Tl) + El + Cl
          , Dl = Ul + Ct$1(xl.sizeTree, Fl)[1]
          , Zl = Sl + Cl
          , Gl = Sl + wl - $l
          , Wl = Ml({
            itemBottom: Dl,
            itemTop: Ul,
            locationParams: {
                align: Rl,
                behavior: Il,
                ...Ll
            },
            viewportBottom: Gl,
            viewportTop: Zl
        });
        return Wl ? Nl && bt(x$2(Vs, P$4(Ql => !Ql), jt(lt(Vs) ? 1 : 2)), Nl) : Nl && Nl(),
        Wl
    }
    ), P$4(yl => yl !== null)), ga),
    {
        scrollIntoView: ba
    }
}
, X$3(Et$1, at, ce$2, Gt$1, Vt$1), {
    singleton: !0
})
  , Un = U$3( ([{scrollVelocity: xt}]) => {
    const Cn = v(!1)
      , as = $$1()
      , cs = v(!1);
    return F$3(x$2(xt, G$1(cs, Cn, as), P$4( ([Cs,Ls]) => !!Ls), E$2( ([Cs,Ls,Vs,Ws]) => {
        const {enter: Xs, exit: ga} = Ls;
        if (Vs) {
            if (ga(Cs, Ws))
                return !1
        } else if (Xs(Cs, Ws))
            return !0;
        return Vs
    }
    ), Y$1()), Cn),
    K$2(x$2(rt(Cn, xt, as), G$1(cs)), ([[Cs,Ls,Vs],Ws]) => {
        Cs && Ws && Ws.change && Ws.change(Ls, Vs)
    }
    ),
    {
        isSeeking: Cn,
        scrollSeekConfiguration: cs,
        scrollSeekRangeChanged: as,
        scrollVelocity: xt
    }
}
, X$3(ae), {
    singleton: !0
})
  , je$2 = U$3( ([{scrollContainerState: xt, scrollTo: Cn}]) => {
    const as = $$1()
      , cs = $$1()
      , Cs = $$1()
      , Ls = v(!1)
      , Vs = v(void 0);
    return F$3(x$2(rt(as, cs), E$2( ([{scrollHeight: Ws, scrollTop: Xs, viewportHeight: ga},{offsetTop: ba}]) => ({
        scrollHeight: Ws,
        scrollTop: Math.max(0, Xs - ba),
        viewportHeight: ga
    }))), xt),
    F$3(x$2(Cn, G$1(cs), E$2( ([Ws,{offsetTop: Xs}]) => ({
        ...Ws,
        top: Ws.top + Xs
    }))), Cs),
    {
        customScrollParent: Vs,
        useWindowScroll: Ls,
        windowScrollContainerState: as,
        windowScrollTo: Cs,
        windowViewportRect: cs
    }
}
, X$3(at))
  , Uo = U$3( ([{sizeRanges: xt, sizes: Cn},{headerHeight: as, scrollTop: cs},{initialTopMostItemIndex: Cs},{didMount: Ls},{useWindowScroll: Vs, windowScrollContainerState: Ws, windowViewportRect: Xs}]) => {
    const ga = $$1()
      , ba = v(void 0)
      , yl = v(null)
      , xl = v(null);
    return F$3(Ws, yl),
    F$3(Xs, xl),
    K$2(x$2(ga, G$1(Cn, cs, Vs, yl, xl, as)), ([wl,_l,El,Cl,$l,Sl,Tl]) => {
        const Rl = Ho(_l.sizeTree);
        Cl && $l !== null && Sl !== null && (El = $l.scrollTop - Sl.offsetTop),
        El -= Tl,
        wl({
            ranges: Rl,
            scrollTop: El
        })
    }
    ),
    F$3(x$2(ba, P$4(Me$2), E$2(Ko)), Cs),
    F$3(x$2(Ls, G$1(ba), P$4( ([,wl]) => wl !== void 0), Y$1(), E$2( ([,wl]) => wl.ranges)), xt),
    {
        getState: ga,
        restoreStateFrom: ba
    }
}
, X$3(Et$1, at, ue, Pt$1, je$2));
function Ko(xt) {
    return {
        align: "start",
        index: 0,
        offset: xt.scrollTop
    }
}
const jo = U$3( ([{topItemsIndexes: xt}]) => {
    const Cn = v(0);
    return F$3(x$2(Cn, P$4(as => as >= 0), E$2(as => Array.from({
        length: as
    }).map( (cs, Cs) => Cs))), xt),
    {
        topItemCount: Cn
    }
}
, X$3(Gt$1));
function Kn(xt) {
    let Cn = !1, as;
    return () => (Cn || (Cn = !0,
    as = xt()),
    as)
}
const qo = Kn( () => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent))
  , Yo = U$3( ([{deviation: xt, scrollBy: Cn, scrollingInProgress: as, scrollTop: cs},{isAtBottom: Cs, isScrolling: Ls, lastJumpDueToItemResize: Vs, scrollDirection: Ws},{listState: Xs},{beforeUnshiftWith: ga, gap: ba, shiftWithOffset: yl, sizes: xl},{log: wl},{recalcInProgress: _l}]) => {
    const El = pt(x$2(Xs, G$1(Vs), Rt$1( ([,$l,Sl,Tl], [{bottom: Rl, items: Il, offsetBottom: Ml, totalCount: Nl},Ll]) => {
        const Fl = Rl + Ml;
        let Ul = 0;
        return Sl === Nl && $l.length > 0 && Il.length > 0 && (Il[0].originalIndex === 0 && $l[0].originalIndex === 0 || (Ul = Fl - Tl,
        Ul !== 0 && (Ul += Ll))),
        [Ul, Il, Nl, Fl]
    }
    , [0, [], 0, 0]), P$4( ([$l]) => $l !== 0), G$1(cs, Ws, as, Cs, wl, _l), P$4( ([,$l,Sl,Tl,,,Rl]) => !Rl && !Tl && $l !== 0 && Sl === le), E$2( ([[$l],,,,,Sl]) => (Sl("Upward scrolling compensation", {
        amount: $l
    }, ht$1.DEBUG),
    $l))));
    function Cl($l) {
        $l > 0 ? (W$1(Cn, {
            behavior: "auto",
            top: -$l
        }),
        W$1(xt, 0)) : (W$1(xt, 0),
        W$1(Cn, {
            behavior: "auto",
            top: -$l
        }))
    }
    return K$2(x$2(El, G$1(xt, Ls)), ([$l,Sl,Tl]) => {
        Tl && qo() ? W$1(xt, Sl - $l) : Cl(-$l)
    }
    ),
    K$2(x$2(rt(ct(Ls, !1), xt, _l), P$4( ([$l,Sl,Tl]) => !$l && !Tl && Sl !== 0), E$2( ([$l,Sl]) => Sl), Lt$1(1)), Cl),
    F$3(x$2(yl, E$2($l => ({
        top: -$l
    }))), Cn),
    K$2(x$2(ga, G$1(xl, ba), E$2( ([$l,{groupIndices: Sl, lastSize: Tl, sizeTree: Rl},Il]) => {
        function Ml(Nl) {
            return Nl * (Tl + Il)
        }
        if (Sl.length === 0)
            return Ml($l);
        {
            let Nl = 0;
            const Ll = re(Rl, 0);
            let Fl = 0
              , Ul = 0;
            for (; Fl < $l; ) {
                Fl++,
                Nl += Ll;
                let Dl = Sl.length === Ul + 1 ? 1 / 0 : Sl[Ul + 1] - Sl[Ul] - 1;
                Fl + Dl > $l && (Nl -= Ll,
                Dl = $l - Fl + 1),
                Fl += Dl,
                Nl += Ml(Dl),
                Ul++
            }
            return Nl
        }
    }
    )), $l => {
        W$1(xt, $l),
        requestAnimationFrame( () => {
            W$1(Cn, {
                top: $l
            }),
            requestAnimationFrame( () => {
                W$1(xt, 0),
                W$1(_l, !1)
            }
            )
        }
        )
    }
    ),
    {
        deviation: xt
    }
}
, X$3(at, ae, Gt$1, Et$1, Vt$1, Ne$1))
  , Zo = U$3( ([xt,Cn,as,cs,Cs,Ls,Vs,Ws,Xs,ga]) => ({
    ...xt,
    ...Cn,
    ...as,
    ...cs,
    ...Cs,
    ...Ls,
    ...Vs,
    ...Ws,
    ...Xs,
    ...ga
}), X$3(Ke$1, Go, Pt$1, Un, $n, No, Mo$1, je$2, $o, Vt$1))
  , jn = U$3( ([{data: xt, defaultItemSize: Cn, firstItemIndex: as, fixedItemSize: cs, gap: Cs, groupIndices: Ls, itemSize: Vs, sizeRanges: Ws, sizes: Xs, statefulTotalCount: ga, totalCount: ba, trackItemSizes: yl},{initialItemFinalLocationReached: xl, initialTopMostItemIndex: wl, scrolledToInitialItem: _l},El,Cl,$l,{listState: Sl, topItemsIndexes: Tl, ...Rl},{scrollToIndex: Il},Ml,{topItemCount: Nl},{groupCounts: Ll},Fl]) => (F$3(Rl.rangeChanged, Fl.scrollSeekRangeChanged),
F$3(x$2(Fl.windowViewportRect, E$2(Ul => Ul.visibleHeight)), El.viewportHeight),
{
    data: xt,
    defaultItemHeight: Cn,
    firstItemIndex: as,
    fixedItemHeight: cs,
    gap: Cs,
    groupCounts: Ll,
    initialItemFinalLocationReached: xl,
    initialTopMostItemIndex: wl,
    scrolledToInitialItem: _l,
    sizeRanges: Ws,
    topItemCount: Nl,
    topItemsIndexes: Tl,
    totalCount: ba,
    ...$l,
    groupIndices: Ls,
    itemSize: Vs,
    listState: Sl,
    scrollToIndex: Il,
    statefulTotalCount: ga,
    trackItemSizes: yl,
    ...Rl,
    ...Fl,
    ...El,
    sizes: Xs,
    ...Cl
}), X$3(Et$1, ue, at, Uo, _o, Gt$1, ce$2, Yo, jo, _n, Zo));
function Xo(xt, Cn) {
    const as = {}
      , cs = {};
    let Cs = 0;
    const Ls = xt.length;
    for (; Cs < Ls; )
        cs[xt[Cs]] = 1,
        Cs += 1;
    for (const Vs in Cn)
        Object.hasOwn(cs, Vs) || (as[Vs] = Cn[Vs]);
    return as
}
const pe$2 = typeof document < "u" ? React__default.useLayoutEffect : React__default.useEffect;
function qe(xt, Cn, as) {
    const cs = Object.keys(Cn.required || {})
      , Cs = Object.keys(Cn.optional || {})
      , Ls = Object.keys(Cn.methods || {})
      , Vs = Object.keys(Cn.events || {})
      , Ws = React__default.createContext({});
    function Xs(Cl, $l) {
        Cl.propsReady && W$1(Cl.propsReady, !1);
        for (const Sl of cs) {
            const Tl = Cl[Cn.required[Sl]];
            W$1(Tl, $l[Sl])
        }
        for (const Sl of Cs)
            if (Sl in $l) {
                const Tl = Cl[Cn.optional[Sl]];
                W$1(Tl, $l[Sl])
            }
        Cl.propsReady && W$1(Cl.propsReady, !0)
    }
    function ga(Cl) {
        return Ls.reduce( ($l, Sl) => ($l[Sl] = Tl => {
            const Rl = Cl[Cn.methods[Sl]];
            W$1(Rl, Tl)
        }
        ,
        $l), {})
    }
    function ba(Cl) {
        return Vs.reduce( ($l, Sl) => ($l[Sl] = mo(Cl[Cn.events[Sl]]),
        $l), {})
    }
    const yl = React__default.forwardRef( (Cl, $l) => {
        const {children: Sl, ...Tl} = Cl
          , [Rl] = React__default.useState( () => ve(ho(xt), Nl => {
            Xs(Nl, Tl)
        }
        ))
          , [Il] = React__default.useState(cn(ba, Rl));
        pe$2( () => {
            for (const Nl of Vs)
                Nl in Tl && K$2(Il[Nl], Tl[Nl]);
            return () => {
                Object.values(Il).map(We$1)
            }
        }
        , [Tl, Il, Rl]),
        pe$2( () => {
            Xs(Rl, Tl)
        }
        ),
        React__default.useImperativeHandle($l, ln(ga(Rl)));
        const Ml = as;
        return jsxRuntimeExports.jsx(Ws.Provider, {
            value: Rl,
            children: as ? jsxRuntimeExports.jsx(Ml, {
                ...Xo([...cs, ...Cs, ...Vs], Tl),
                children: Sl
            }) : Sl
        })
    }
    )
      , xl = Cl => {
        const $l = React__default.useContext(Ws);
        return React__default.useCallback(Sl => {
            W$1($l[Cl], Sl)
        }
        , [$l, Cl])
    }
      , wl = Cl => {
        const $l = React__default.useContext(Ws)[Cl]
          , Sl = React__default.useCallback(Tl => K$2($l, Tl), [$l]);
        return React__default.useSyncExternalStore(Sl, () => lt($l), () => lt($l))
    }
      , _l = Cl => {
        const $l = React__default.useContext(Ws)[Cl]
          , [Sl,Tl] = React__default.useState(cn(lt, $l));
        return pe$2( () => K$2($l, Rl => {
            Rl !== Sl && Tl(ln(Rl))
        }
        ), [$l, Sl]),
        Sl
    }
      , El = React__default.version.startsWith("18") ? wl : _l;
    return {
        Component: yl,
        useEmitter: (Cl, $l) => {
            const Sl = React__default.useContext(Ws)[Cl];
            pe$2( () => K$2(Sl, $l), [$l, Sl])
        }
        ,
        useEmitterValue: El,
        usePublisher: xl
    }
}
const be$2 = React__default.createContext(void 0)
  , qn = React__default.createContext(void 0)
  , Yn = typeof document < "u" ? React__default.useLayoutEffect : React__default.useEffect;
function ke(xt) {
    return "self"in xt
}
function Jo(xt) {
    return "body"in xt
}
function Zn(xt, Cn, as, cs=Yt, Cs, Ls) {
    const Vs = React__default.useRef(null)
      , Ws = React__default.useRef(null)
      , Xs = React__default.useRef(null)
      , ga = React__default.useCallback(xl => {
        let wl, _l, El;
        const Cl = xl.target;
        if (Jo(Cl) || ke(Cl)) {
            const Sl = ke(Cl) ? Cl : Cl.defaultView;
            El = Ls ? Sl.scrollX : Sl.scrollY,
            wl = Ls ? Sl.document.documentElement.scrollWidth : Sl.document.documentElement.scrollHeight,
            _l = Ls ? Sl.innerWidth : Sl.innerHeight
        } else
            El = Ls ? Cl.scrollLeft : Cl.scrollTop,
            wl = Ls ? Cl.scrollWidth : Cl.scrollHeight,
            _l = Ls ? Cl.offsetWidth : Cl.offsetHeight;
        const $l = () => {
            xt({
                scrollHeight: wl,
                scrollTop: Math.max(El, 0),
                viewportHeight: _l
            })
        }
        ;
        xl.suppressFlushSync ? $l() : ReactDOM.flushSync($l),
        Ws.current !== null && (El === Ws.current || El <= 0 || El === wl - _l) && (Ws.current = null,
        Cn(!0),
        Xs.current && (clearTimeout(Xs.current),
        Xs.current = null))
    }
    , [xt, Cn, Ls]);
    React__default.useEffect( () => {
        const xl = Cs || Vs.current;
        return cs(Cs || Vs.current),
        ga({
            suppressFlushSync: !0,
            target: xl
        }),
        xl.addEventListener("scroll", ga, {
            passive: !0
        }),
        () => {
            cs(null),
            xl.removeEventListener("scroll", ga)
        }
    }
    , [Vs, ga, as, cs, Cs]);
    function ba(xl) {
        const wl = Vs.current;
        if (!wl || (Ls ? "offsetWidth"in wl && wl.offsetWidth === 0 : "offsetHeight"in wl && wl.offsetHeight === 0))
            return;
        const _l = xl.behavior === "smooth";
        let El, Cl, $l;
        ke(wl) ? (Cl = Math.max(wt$1(wl.document.documentElement, Ls ? "width" : "height"), Ls ? wl.document.documentElement.scrollWidth : wl.document.documentElement.scrollHeight),
        El = Ls ? wl.innerWidth : wl.innerHeight,
        $l = Ls ? window.scrollX : window.scrollY) : (Cl = wl[Ls ? "scrollWidth" : "scrollHeight"],
        El = wt$1(wl, Ls ? "width" : "height"),
        $l = wl[Ls ? "scrollLeft" : "scrollTop"]);
        const Sl = Cl - El;
        if (xl.top = Math.ceil(Math.max(Math.min(Sl, xl.top), 0)),
        Nn(El, Cl) || xl.top === $l) {
            xt({
                scrollHeight: Cl,
                scrollTop: $l,
                viewportHeight: El
            }),
            _l && Cn(!0);
            return
        }
        _l ? (Ws.current = xl.top,
        Xs.current && clearTimeout(Xs.current),
        Xs.current = setTimeout( () => {
            Xs.current = null,
            Ws.current = null,
            Cn(!0)
        }
        , 1e3)) : Ws.current = null,
        Ls && (xl = {
            behavior: xl.behavior,
            left: xl.top
        }),
        wl.scrollTo(xl)
    }
    function yl(xl) {
        Ls && (xl = {
            behavior: xl.behavior,
            left: xl.top
        }),
        Vs.current.scrollBy(xl)
    }
    return {
        scrollByCallback: yl,
        scrollerRef: Vs,
        scrollToCallback: ba
    }
}
const Oe = "-webkit-sticky"
  , xn = "sticky"
  , Xn = Kn( () => {
    if (typeof document > "u")
        return xn;
    const xt = document.createElement("div");
    return xt.style.position = Oe,
    xt.style.position === Oe ? Oe : xn
}
);
function Ye(xt) {
    return xt
}
const Qo = U$3( () => {
    const xt = v(Xs => `Item ${Xs}`)
      , Cn = v(null)
      , as = v(Xs => `Group ${Xs}`)
      , cs = v({})
      , Cs = v(Ye)
      , Ls = v("div")
      , Vs = v(Yt)
      , Ws = (Xs, ga=null) => ct(x$2(cs, E$2(ba => ba[Xs]), Y$1()), ga);
    return {
        components: cs,
        computeItemKey: Cs,
        context: Cn,
        EmptyPlaceholder: Ws("EmptyPlaceholder"),
        FooterComponent: Ws("Footer"),
        GroupComponent: Ws("Group", "div"),
        groupContent: as,
        HeaderComponent: Ws("Header"),
        HeaderFooterTag: Ls,
        ItemComponent: Ws("Item", "div"),
        itemContent: xt,
        ListComponent: Ws("List", "div"),
        ScrollerComponent: Ws("Scroller", "div"),
        scrollerRef: Vs,
        ScrollSeekPlaceholder: Ws("ScrollSeekPlaceholder"),
        TopItemListComponent: Ws("TopItemList")
    }
}
)
  , tr = U$3( ([xt,Cn]) => ({
    ...xt,
    ...Cn
}), X$3(jn, Qo))
  , er = ({height: xt}) => jsxRuntimeExports.jsx("div", {
    style: {
        height: xt
    }
})
  , nr = {
    overflowAnchor: "none",
    position: Xn(),
    zIndex: 1
}
  , Jn = {
    overflowAnchor: "none"
}
  , or = {
    ...Jn,
    display: "inline-block",
    height: "100%"
}
  , Tn = React__default.memo(function({showTopList: xt=!1}) {
    const Cn = M$3("listState")
      , as = gt$1("sizeRanges")
      , cs = M$3("useWindowScroll")
      , Cs = M$3("customScrollParent")
      , Ls = gt$1("windowScrollContainerState")
      , Vs = gt$1("scrollContainerState")
      , Ws = Cs || cs ? Ls : Vs
      , Xs = M$3("itemContent")
      , ga = M$3("context")
      , ba = M$3("groupContent")
      , yl = M$3("trackItemSizes")
      , xl = M$3("itemSize")
      , wl = M$3("log")
      , _l = gt$1("gap")
      , El = M$3("horizontalDirection")
      , {callbackRef: Cl} = kn(as, xl, yl, xt ? Yt : Ws, wl, _l, Cs, El, M$3("skipAnimationFrameInResizeObserver"))
      , [$l,Sl] = React__default.useState(0);
    Je("deviation", Wl => {
        $l !== Wl && Sl(Wl)
    }
    );
    const Tl = M$3("EmptyPlaceholder")
      , Rl = M$3("ScrollSeekPlaceholder") || er
      , Il = M$3("ListComponent")
      , Ml = M$3("ItemComponent")
      , Nl = M$3("GroupComponent")
      , Ll = M$3("computeItemKey")
      , Fl = M$3("isSeeking")
      , Ul = M$3("groupIndices").length > 0
      , Dl = M$3("alignToBottom")
      , Zl = M$3("initialItemFinalLocationReached")
      , Gl = xt ? {} : {
        boxSizing: "border-box",
        ...El ? {
            display: "inline-block",
            height: "100%",
            marginLeft: $l !== 0 ? $l : Dl ? "auto" : 0,
            paddingLeft: Cn.offsetTop,
            paddingRight: Cn.offsetBottom,
            whiteSpace: "nowrap"
        } : {
            marginTop: $l !== 0 ? $l : Dl ? "auto" : 0,
            paddingBottom: Cn.offsetBottom,
            paddingTop: Cn.offsetTop
        },
        ...Zl ? {} : {
            visibility: "hidden"
        }
    };
    return !xt && Cn.totalCount === 0 && Tl ? jsxRuntimeExports.jsx(Tl, {
        ...Z$1(Tl, ga)
    }) : jsxRuntimeExports.jsx(Il, {
        ...Z$1(Il, ga),
        "data-testid": xt ? "virtuoso-top-item-list" : "virtuoso-item-list",
        ref: Cl,
        style: Gl,
        children: (xt ? Cn.topItems : Cn.items).map(Wl => {
            const Ql = Wl.originalIndex
              , cu = Ll(Ql + Cn.firstItemIndex, Wl.data, ga);
            return Fl ? reactExports.createElement(Rl, {
                ...Z$1(Rl, ga),
                height: Wl.size,
                index: Wl.index,
                key: cu,
                type: Wl.type || "item",
                ...Wl.type === "group" ? {} : {
                    groupIndex: Wl.groupIndex
                }
            }) : Wl.type === "group" ? reactExports.createElement(Nl, {
                ...Z$1(Nl, ga),
                "data-index": Ql,
                "data-item-index": Wl.index,
                "data-known-size": Wl.size,
                key: cu,
                style: nr
            }, ba(Wl.index, ga)) : reactExports.createElement(Ml, {
                ...Z$1(Ml, ga),
                ...Qn(Ml, Wl.data),
                "data-index": Ql,
                "data-item-group-index": Wl.groupIndex,
                "data-item-index": Wl.index,
                "data-known-size": Wl.size,
                key: cu,
                style: El ? or : Jn
            }, Ul ? Xs(Wl.index, Wl.groupIndex, Wl.data, ga) : Xs(Wl.index, Wl.data, ga))
        }
        )
    })
})
  , rr = {
    height: "100%",
    outline: "none",
    overflowY: "auto",
    position: "relative",
    WebkitOverflowScrolling: "touch"
}
  , sr = {
    outline: "none",
    overflowX: "auto",
    position: "relative"
}
  , Zt = xt => ({
    height: "100%",
    position: "absolute",
    top: 0,
    width: "100%",
    ...xt ? {
        display: "flex",
        flexDirection: "column"
    } : {}
})
  , ir = {
    position: Xn(),
    top: 0,
    width: "100%",
    zIndex: 1
};
function Z$1(xt, Cn) {
    if (typeof xt != "string")
        return {
            context: Cn
        }
}
function Qn(xt, Cn) {
    return {
        item: typeof xt == "string" ? void 0 : Cn
    }
}
const lr = React__default.memo(function() {
    const xt = M$3("HeaderComponent")
      , Cn = gt$1("headerHeight")
      , as = M$3("HeaderFooterTag")
      , cs = Ht$1(React__default.useMemo( () => Ls => {
        Cn(wt$1(Ls, "height"))
    }
    , [Cn]), !0, M$3("skipAnimationFrameInResizeObserver"))
      , Cs = M$3("context");
    return xt ? jsxRuntimeExports.jsx(as, {
        ref: cs,
        children: jsxRuntimeExports.jsx(xt, {
            ...Z$1(xt, Cs)
        })
    }) : null
})
  , cr = React__default.memo(function() {
    const xt = M$3("FooterComponent")
      , Cn = gt$1("footerHeight")
      , as = M$3("HeaderFooterTag")
      , cs = Ht$1(React__default.useMemo( () => Ls => {
        Cn(wt$1(Ls, "height"))
    }
    , [Cn]), !0, M$3("skipAnimationFrameInResizeObserver"))
      , Cs = M$3("context");
    return xt ? jsxRuntimeExports.jsx(as, {
        ref: cs,
        children: jsxRuntimeExports.jsx(xt, {
            ...Z$1(xt, Cs)
        })
    }) : null
});
function Ze({useEmitter: xt, useEmitterValue: Cn, usePublisher: as}) {
    return React__default.memo(function({children: cs, style: Cs, ...Ls}) {
        const Vs = as("scrollContainerState")
          , Ws = Cn("ScrollerComponent")
          , Xs = as("smoothScrollTargetReached")
          , ga = Cn("scrollerRef")
          , ba = Cn("context")
          , yl = Cn("horizontalDirection") || !1
          , {scrollByCallback: xl, scrollerRef: wl, scrollToCallback: _l} = Zn(Vs, Xs, Ws, ga, void 0, yl);
        return xt("scrollTo", _l),
        xt("scrollBy", xl),
        jsxRuntimeExports.jsx(Ws, {
            "data-testid": "virtuoso-scroller",
            "data-virtuoso-scroller": !0,
            ref: wl,
            style: {
                ...yl ? sr : rr,
                ...Cs
            },
            tabIndex: 0,
            ...Ls,
            ...Z$1(Ws, ba),
            children: cs
        })
    })
}
function Xe({useEmitter: xt, useEmitterValue: Cn, usePublisher: as}) {
    return React__default.memo(function({children: cs, style: Cs, ...Ls}) {
        const Vs = as("windowScrollContainerState")
          , Ws = Cn("ScrollerComponent")
          , Xs = as("smoothScrollTargetReached")
          , ga = Cn("totalListHeight")
          , ba = Cn("deviation")
          , yl = Cn("customScrollParent")
          , xl = Cn("context")
          , wl = React__default.useRef(null)
          , _l = Cn("scrollerRef")
          , {scrollByCallback: El, scrollerRef: Cl, scrollToCallback: $l} = Zn(Vs, Xs, Ws, _l, yl);
        return Yn( () => {
            var Sl;
            return Cl.current = yl || ((Sl = wl.current) == null ? void 0 : Sl.ownerDocument.defaultView),
            () => {
                Cl.current = null
            }
        }
        , [Cl, yl]),
        xt("windowScrollTo", $l),
        xt("scrollBy", El),
        jsxRuntimeExports.jsx(Ws, {
            ref: wl,
            "data-virtuoso-scroller": !0,
            style: {
                position: "relative",
                ...Cs,
                ...ga !== 0 ? {
                    height: ga + ba
                } : {}
            },
            ...Ls,
            ...Z$1(Ws, xl),
            children: cs
        })
    })
}
const ur = ({children: xt}) => {
    const Cn = React__default.useContext(be$2)
      , as = gt$1("viewportHeight")
      , cs = gt$1("fixedItemHeight")
      , Cs = M$3("alignToBottom")
      , Ls = M$3("horizontalDirection")
      , Vs = React__default.useMemo( () => ne(as, Xs => wt$1(Xs, Ls ? "width" : "height")), [as, Ls])
      , Ws = Ht$1(Vs, !0, M$3("skipAnimationFrameInResizeObserver"));
    return React__default.useEffect( () => {
        Cn && (as(Cn.viewportHeight),
        cs(Cn.itemHeight))
    }
    , [Cn, as, cs]),
    jsxRuntimeExports.jsx("div", {
        "data-viewport-type": "element",
        ref: Ws,
        style: Zt(Cs),
        children: xt
    })
}
  , ar = ({children: xt}) => {
    const Cn = React__default.useContext(be$2)
      , as = gt$1("windowViewportRect")
      , cs = gt$1("fixedItemHeight")
      , Cs = M$3("customScrollParent")
      , Ls = Ge(as, Cs, M$3("skipAnimationFrameInResizeObserver"))
      , Vs = M$3("alignToBottom");
    return React__default.useEffect( () => {
        Cn && (cs(Cn.itemHeight),
        as({
            offsetTop: 0,
            visibleHeight: Cn.viewportHeight,
            visibleWidth: 100
        }))
    }
    , [Cn, as, cs]),
    jsxRuntimeExports.jsx("div", {
        "data-viewport-type": "window",
        ref: Ls,
        style: Zt(Vs),
        children: xt
    })
}
  , dr = ({children: xt}) => {
    const Cn = M$3("TopItemListComponent") || "div"
      , as = M$3("headerHeight")
      , cs = {
        ...ir,
        marginTop: `${as}px`
    }
      , Cs = M$3("context");
    return jsxRuntimeExports.jsx(Cn, {
        style: cs,
        ...Z$1(Cn, Cs),
        children: xt
    })
}
  , fr = React__default.memo(function(xt) {
    const Cn = M$3("useWindowScroll")
      , as = M$3("topItemsIndexes").length > 0
      , cs = M$3("customScrollParent")
      , Cs = M$3("context")
      , Ls = cs || Cn ? pr : mr
      , Vs = cs || Cn ? ar : ur;
    return jsxRuntimeExports.jsxs(Ls, {
        ...xt,
        ...Z$1(Ls, Cs),
        children: [as && jsxRuntimeExports.jsx(dr, {
            children: jsxRuntimeExports.jsx(Tn, {
                showTopList: !0
            })
        }), jsxRuntimeExports.jsxs(Vs, {
            children: [jsxRuntimeExports.jsx(lr, {}), jsxRuntimeExports.jsx(Tn, {}), jsxRuntimeExports.jsx(cr, {})]
        })]
    })
})
  , {Component: to, useEmitter: Je, useEmitterValue: M$3, usePublisher: gt$1} = qe(tr, {
    required: {},
    optional: {
        restoreStateFrom: "restoreStateFrom",
        context: "context",
        followOutput: "followOutput",
        itemContent: "itemContent",
        groupContent: "groupContent",
        overscan: "overscan",
        increaseViewportBy: "increaseViewportBy",
        totalCount: "totalCount",
        groupCounts: "groupCounts",
        topItemCount: "topItemCount",
        firstItemIndex: "firstItemIndex",
        initialTopMostItemIndex: "initialTopMostItemIndex",
        components: "components",
        atBottomThreshold: "atBottomThreshold",
        atTopThreshold: "atTopThreshold",
        computeItemKey: "computeItemKey",
        defaultItemHeight: "defaultItemHeight",
        fixedItemHeight: "fixedItemHeight",
        itemSize: "itemSize",
        scrollSeekConfiguration: "scrollSeekConfiguration",
        headerFooterTag: "HeaderFooterTag",
        data: "data",
        initialItemCount: "initialItemCount",
        initialScrollTop: "initialScrollTop",
        alignToBottom: "alignToBottom",
        useWindowScroll: "useWindowScroll",
        customScrollParent: "customScrollParent",
        scrollerRef: "scrollerRef",
        logLevel: "logLevel",
        horizontalDirection: "horizontalDirection",
        skipAnimationFrameInResizeObserver: "skipAnimationFrameInResizeObserver"
    },
    methods: {
        scrollToIndex: "scrollToIndex",
        scrollIntoView: "scrollIntoView",
        scrollTo: "scrollTo",
        scrollBy: "scrollBy",
        autoscrollToBottom: "autoscrollToBottom",
        getState: "getState"
    },
    events: {
        isScrolling: "isScrolling",
        endReached: "endReached",
        startReached: "startReached",
        rangeChanged: "rangeChanged",
        atBottomStateChange: "atBottomStateChange",
        atTopStateChange: "atTopStateChange",
        totalListHeightChanged: "totalListHeightChanged",
        itemsRendered: "itemsRendered",
        groupIndices: "groupIndices"
    }
}, fr)
  , mr = Ze({
    useEmitter: Je,
    useEmitterValue: M$3,
    usePublisher: gt$1
})
  , pr = Xe({
    useEmitter: Je,
    useEmitterValue: M$3,
    usePublisher: gt$1
})
  , Kr = to
  , hr = U$3( () => {
    const xt = v(Xs => jsxRuntimeExports.jsxs("td", {
        children: ["Item $", Xs]
    }))
      , Cn = v(null)
      , as = v(null)
      , cs = v(null)
      , Cs = v({})
      , Ls = v(Ye)
      , Vs = v(Yt)
      , Ws = (Xs, ga=null) => ct(x$2(Cs, E$2(ba => ba[Xs]), Y$1()), ga);
    return {
        components: Cs,
        computeItemKey: Ls,
        context: Cn,
        EmptyPlaceholder: Ws("EmptyPlaceholder"),
        FillerRow: Ws("FillerRow"),
        fixedFooterContent: cs,
        fixedHeaderContent: as,
        itemContent: xt,
        ScrollerComponent: Ws("Scroller", "div"),
        scrollerRef: Vs,
        ScrollSeekPlaceholder: Ws("ScrollSeekPlaceholder"),
        TableBodyComponent: Ws("TableBody", "tbody"),
        TableComponent: Ws("Table", "table"),
        TableFooterComponent: Ws("TableFoot", "tfoot"),
        TableHeadComponent: Ws("TableHead", "thead"),
        TableRowComponent: Ws("TableRow", "tr")
    }
}
);
X$3(jn, hr);
const wn = {
    bottom: 0,
    itemHeight: 0,
    items: [],
    itemWidth: 0,
    offsetBottom: 0,
    offsetTop: 0,
    top: 0
}
  , Hr = {
    bottom: 0,
    itemHeight: 0,
    items: [{
        index: 0
    }],
    itemWidth: 0,
    offsetBottom: 0,
    offsetTop: 0,
    top: 0
}
  , {ceil: vn, floor: Ce$1, max: ee, min: Fe$3, round: yn} = Math;
function Rn(xt, Cn, as) {
    return Array.from({
        length: Cn - xt + 1
    }).map( (cs, Cs) => ({
        data: as === null ? null : as[Cs + xt],
        index: Cs + xt
    }))
}
function Er(xt) {
    return {
        ...Hr,
        items: xt
    }
}
function he(xt, Cn) {
    return xt && xt.width === Cn.width && xt.height === Cn.height
}
function Br(xt, Cn) {
    return xt && xt.column === Cn.column && xt.row === Cn.row
}
const kr = U$3( ([{increaseViewportBy: xt, listBoundary: Cn, overscan: as, visibleRange: cs},{footerHeight: Cs, headerHeight: Ls, scrollBy: Vs, scrollContainerState: Ws, scrollTo: Xs, scrollTop: ga, smoothScrollTargetReached: ba, viewportHeight: yl},xl,wl,{didMount: _l, propsReady: El},{customScrollParent: Cl, useWindowScroll: $l, windowScrollContainerState: Sl, windowScrollTo: Tl, windowViewportRect: Rl},Il]) => {
    const Ml = v(0)
      , Nl = v(0)
      , Ll = v(wn)
      , Fl = v({
        height: 0,
        width: 0
    })
      , Ul = v({
        height: 0,
        width: 0
    })
      , Dl = $$1()
      , Zl = $$1()
      , Gl = v(0)
      , Wl = v(null)
      , Ql = v({
        column: 0,
        row: 0
    })
      , cu = $$1()
      , pu = $$1()
      , zl = v(!1)
      , Yl = v(0)
      , lu = v(!0)
      , mu = v(!1)
      , Cu = v(!1);
    K$2(x$2(_l, G$1(Yl), P$4( ([fu,yu]) => !!yu)), () => {
        W$1(lu, !1)
    }
    ),
    K$2(x$2(rt(_l, lu, Ul, Fl, Yl, mu), P$4( ([fu,yu,vu,_u,,xu]) => fu && !yu && vu.height !== 0 && _u.height !== 0 && !xu)), ([,,,,fu]) => {
        W$1(mu, !0),
        $e$1(1, () => {
            W$1(Dl, fu)
        }
        ),
        bt(x$2(ga), () => {
            W$1(Cn, [0, 0]),
            W$1(lu, !0)
        }
        )
    }
    ),
    F$3(x$2(pu, P$4(fu => fu != null && fu.scrollTop > 0), yt(0)), Nl),
    K$2(x$2(_l, G$1(pu), P$4( ([,fu]) => fu != null)), ([,fu]) => {
        fu && (W$1(Fl, fu.viewport),
        W$1(Ul, fu.item),
        W$1(Ql, fu.gap),
        fu.scrollTop > 0 && (W$1(zl, !0),
        bt(x$2(ga, jt(1)), yu => {
            W$1(zl, !1)
        }
        ),
        W$1(Xs, {
            top: fu.scrollTop
        })))
    }
    ),
    F$3(x$2(Fl, E$2( ({height: fu}) => fu)), yl),
    F$3(x$2(rt(A$2(Fl, he), A$2(Ul, he), A$2(Ql, (fu, yu) => fu && fu.column === yu.column && fu.row === yu.row), A$2(ga)), E$2( ([fu,yu,vu,_u]) => ({
        gap: vu,
        item: yu,
        scrollTop: _u,
        viewport: fu
    }))), cu),
    F$3(x$2(rt(A$2(Ml), cs, A$2(Ql, Br), A$2(Ul, he), A$2(Fl, he), A$2(Wl), A$2(Nl), A$2(zl), A$2(lu), A$2(Yl)), P$4( ([,,,,,,,fu]) => !fu), E$2( ([fu,[yu,vu],_u,xu,Ru,Iu,Ku,,dp,lp]) => {
        const {column: qu, row: hp} = _u
          , {height: fp, width: Lp} = xu
          , {width: uu} = Ru;
        if (Ku === 0 && (fu === 0 || uu === 0))
            return wn;
        if (Lp === 0) {
            const eu = Ue$1(lp, fu)
              , iu = eu + Math.max(Ku - 1, 0);
            return Er(Rn(eu, iu, Iu))
        }
        const gu = eo(uu, Lp, qu);
        let Eu, nu;
        dp ? yu === 0 && vu === 0 && Ku > 0 ? (Eu = 0,
        nu = Ku - 1) : (Eu = gu * Ce$1((yu + hp) / (fp + hp)),
        nu = gu * vn((vu + hp) / (fp + hp)) - 1,
        nu = Fe$3(fu - 1, ee(nu, gu - 1)),
        Eu = Fe$3(nu, ee(0, Eu))) : (Eu = 0,
        nu = -1);
        const Kl = Rn(Eu, nu, Iu)
          , {bottom: Bl, top: Pl} = bn(Ru, _u, xu, Kl)
          , Al = vn(fu / gu)
          , Vl = Al * fp + (Al - 1) * hp - Bl;
        return {
            bottom: Bl,
            itemHeight: fp,
            items: Kl,
            itemWidth: Lp,
            offsetBottom: Vl,
            offsetTop: Pl,
            top: Pl
        }
    }
    )), Ll),
    F$3(x$2(Wl, P$4(fu => fu !== null), E$2(fu => fu.length)), Ml),
    F$3(x$2(rt(Fl, Ul, Ll, Ql), P$4( ([fu,yu,{items: vu}]) => vu.length > 0 && yu.height !== 0 && fu.height !== 0), E$2( ([fu,yu,{items: vu},_u]) => {
        const {bottom: xu, top: Ru} = bn(fu, _u, yu, vu);
        return [Ru, xu]
    }
    ), Y$1(se)), Cn);
    const ju = v(!1);
    F$3(x$2(ga, G$1(ju), E$2( ([fu,yu]) => yu || fu !== 0)), ju);
    const Lu = pt(x$2(rt(Ll, Ml), P$4( ([{items: fu}]) => fu.length > 0), G$1(ju), P$4( ([[fu,yu],vu]) => {
        const _u = fu.items[fu.items.length - 1].index === yu - 1;
        return (vu || fu.bottom > 0 && fu.itemHeight > 0 && fu.offsetBottom === 0 && fu.items.length === yu) && _u
    }
    ), E$2( ([[,fu]]) => fu - 1), Y$1()))
      , Au = pt(x$2(A$2(Ll), P$4( ({items: fu}) => fu.length > 0 && fu[0].index === 0), yt(0), Y$1()))
      , Du = pt(x$2(A$2(Ll), G$1(zl), P$4( ([{items: fu},yu]) => fu.length > 0 && !yu), E$2( ([{items: fu}]) => ({
        endIndex: fu[fu.length - 1].index,
        startIndex: fu[0].index
    })), Y$1(Pn), Lt$1(0)));
    F$3(Du, wl.scrollSeekRangeChanged),
    F$3(x$2(Dl, G$1(Fl, Ul, Ml, Ql), E$2( ([fu,yu,vu,_u,xu]) => {
        const Ru = Gn(fu)
          , {align: Iu, behavior: Ku, offset: dp} = Ru;
        let lp = Ru.index;
        lp === "LAST" && (lp = _u - 1),
        lp = ee(0, lp, Fe$3(_u - 1, lp));
        let qu = Ae$1(yu, xu, vu, lp);
        return Iu === "end" ? qu = yn(qu - yu.height + vu.height) : Iu === "center" && (qu = yn(qu - yu.height / 2 + vu.height / 2)),
        dp && (qu += dp),
        {
            behavior: Ku,
            top: qu
        }
    }
    )), Xs);
    const Qu = ct(x$2(Ll, E$2(fu => fu.offsetBottom + fu.bottom)), 0);
    return F$3(x$2(Rl, E$2(fu => ({
        height: fu.visibleHeight,
        width: fu.visibleWidth
    }))), Fl),
    {
        customScrollParent: Cl,
        data: Wl,
        deviation: Gl,
        footerHeight: Cs,
        gap: Ql,
        headerHeight: Ls,
        increaseViewportBy: xt,
        initialItemCount: Nl,
        itemDimensions: Ul,
        overscan: as,
        restoreStateFrom: pu,
        scrollBy: Vs,
        scrollContainerState: Ws,
        scrollHeight: Zl,
        scrollTo: Xs,
        scrollToIndex: Dl,
        scrollTop: ga,
        smoothScrollTargetReached: ba,
        totalCount: Ml,
        useWindowScroll: $l,
        viewportDimensions: Fl,
        windowScrollContainerState: Sl,
        windowScrollTo: Tl,
        windowViewportRect: Rl,
        ...wl,
        gridState: Ll,
        horizontalDirection: Cu,
        initialTopMostItemIndex: Yl,
        totalListHeight: Qu,
        ...xl,
        endReached: Lu,
        propsReady: El,
        rangeChanged: Du,
        startReached: Au,
        stateChanged: cu,
        stateRestoreInProgress: zl,
        ...Il
    }
}
, X$3(Ke$1, at, ae, Un, Pt$1, je$2, Vt$1));
function eo(xt, Cn, as) {
    return ee(1, Ce$1((xt + as) / (Ce$1(Cn) + as)))
}
function bn(xt, Cn, as, cs) {
    const {height: Cs} = as;
    if (Cs === void 0 || cs.length === 0)
        return {
            bottom: 0,
            top: 0
        };
    const Ls = Ae$1(xt, Cn, as, cs[0].index);
    return {
        bottom: Ae$1(xt, Cn, as, cs[cs.length - 1].index) + Cs,
        top: Ls
    }
}
function Ae$1(xt, Cn, as, cs) {
    const Cs = eo(xt.width, as.width, Cn.column)
      , Ls = Ce$1(cs / Cs)
      , Vs = Ls * as.height + ee(0, Ls - 1) * Cn.row;
    return Vs > 0 ? Vs + Cn.row : Vs
}
const Or = U$3( () => {
    const xt = v(yl => `Item ${yl}`)
      , Cn = v({})
      , as = v(null)
      , cs = v("virtuoso-grid-item")
      , Cs = v("virtuoso-grid-list")
      , Ls = v(Ye)
      , Vs = v("div")
      , Ws = v(Yt)
      , Xs = (yl, xl=null) => ct(x$2(Cn, E$2(wl => wl[yl]), Y$1()), xl)
      , ga = v(!1)
      , ba = v(!1);
    return F$3(A$2(ba), ga),
    {
        components: Cn,
        computeItemKey: Ls,
        context: as,
        FooterComponent: Xs("Footer"),
        HeaderComponent: Xs("Header"),
        headerFooterTag: Vs,
        itemClassName: cs,
        ItemComponent: Xs("Item", "div"),
        itemContent: xt,
        listClassName: Cs,
        ListComponent: Xs("List", "div"),
        readyStateChanged: ga,
        reportReadyState: ba,
        ScrollerComponent: Xs("Scroller", "div"),
        scrollerRef: Ws,
        ScrollSeekPlaceholder: Xs("ScrollSeekPlaceholder", "div")
    }
}
)
  , Fr = U$3( ([xt,Cn]) => ({
    ...xt,
    ...Cn
}), X$3(kr, Or))
  , Lr = React__default.memo(function() {
    const xt = et("gridState")
      , Cn = et("listClassName")
      , as = et("itemClassName")
      , cs = et("itemContent")
      , Cs = et("computeItemKey")
      , Ls = et("isSeeking")
      , Vs = It$1("scrollHeight")
      , Ws = et("ItemComponent")
      , Xs = et("ListComponent")
      , ga = et("ScrollSeekPlaceholder")
      , ba = et("context")
      , yl = It$1("itemDimensions")
      , xl = It$1("gap")
      , wl = et("log")
      , _l = et("stateRestoreInProgress")
      , El = It$1("reportReadyState")
      , Cl = Ht$1(React__default.useMemo( () => $l => {
        const Sl = $l.parentElement.parentElement.scrollHeight;
        Vs(Sl);
        const Tl = $l.firstChild;
        if (Tl) {
            const {height: Rl, width: Il} = Tl.getBoundingClientRect();
            yl({
                height: Rl,
                width: Il
            })
        }
        xl({
            column: Hn("column-gap", getComputedStyle($l).columnGap, wl),
            row: Hn("row-gap", getComputedStyle($l).rowGap, wl)
        })
    }
    , [Vs, yl, xl, wl]), !0, !1);
    return Yn( () => {
        xt.itemHeight > 0 && xt.itemWidth > 0 && El(!0)
    }
    , [xt]),
    _l ? null : jsxRuntimeExports.jsx(Xs, {
        className: Cn,
        ref: Cl,
        ...Z$1(Xs, ba),
        "data-testid": "virtuoso-item-list",
        style: {
            paddingBottom: xt.offsetBottom,
            paddingTop: xt.offsetTop
        },
        children: xt.items.map($l => {
            const Sl = Cs($l.index, $l.data, ba);
            return Ls ? jsxRuntimeExports.jsx(ga, {
                ...Z$1(ga, ba),
                height: xt.itemHeight,
                index: $l.index,
                width: xt.itemWidth
            }, Sl) : reactExports.createElement(Ws, {
                ...Z$1(Ws, ba),
                className: as,
                "data-index": $l.index,
                key: Sl
            }, cs($l.index, $l.data, ba))
        }
        )
    })
})
  , zr = React__default.memo(function() {
    const xt = et("HeaderComponent")
      , Cn = It$1("headerHeight")
      , as = et("headerFooterTag")
      , cs = Ht$1(React__default.useMemo( () => Ls => {
        Cn(wt$1(Ls, "height"))
    }
    , [Cn]), !0, !1)
      , Cs = et("context");
    return xt ? jsxRuntimeExports.jsx(as, {
        ref: cs,
        children: jsxRuntimeExports.jsx(xt, {
            ...Z$1(xt, Cs)
        })
    }) : null
})
  , Vr = React__default.memo(function() {
    const xt = et("FooterComponent")
      , Cn = It$1("footerHeight")
      , as = et("headerFooterTag")
      , cs = Ht$1(React__default.useMemo( () => Ls => {
        Cn(wt$1(Ls, "height"))
    }
    , [Cn]), !0, !1)
      , Cs = et("context");
    return xt ? jsxRuntimeExports.jsx(as, {
        ref: cs,
        children: jsxRuntimeExports.jsx(xt, {
            ...Z$1(xt, Cs)
        })
    }) : null
})
  , Pr = ({children: xt}) => {
    const Cn = React__default.useContext(qn)
      , as = It$1("itemDimensions")
      , cs = It$1("viewportDimensions")
      , Cs = Ht$1(React__default.useMemo( () => Ls => {
        cs(Ls.getBoundingClientRect())
    }
    , [cs]), !0, !1);
    return React__default.useEffect( () => {
        Cn && (cs({
            height: Cn.viewportHeight,
            width: Cn.viewportWidth
        }),
        as({
            height: Cn.itemHeight,
            width: Cn.itemWidth
        }))
    }
    , [Cn, cs, as]),
    jsxRuntimeExports.jsx("div", {
        ref: Cs,
        style: Zt(!1),
        children: xt
    })
}
  , Ar = ({children: xt}) => {
    const Cn = React__default.useContext(qn)
      , as = It$1("windowViewportRect")
      , cs = It$1("itemDimensions")
      , Cs = et("customScrollParent")
      , Ls = Ge(as, Cs, !1);
    return React__default.useEffect( () => {
        Cn && (cs({
            height: Cn.itemHeight,
            width: Cn.itemWidth
        }),
        as({
            offsetTop: 0,
            visibleHeight: Cn.viewportHeight,
            visibleWidth: Cn.viewportWidth
        }))
    }
    , [Cn, as, cs]),
    jsxRuntimeExports.jsx("div", {
        ref: Ls,
        style: Zt(!1),
        children: xt
    })
}
  , Mr = React__default.memo(function({...xt}) {
    const Cn = et("useWindowScroll")
      , as = et("customScrollParent")
      , cs = as || Cn ? Gr : _r
      , Cs = as || Cn ? Ar : Pr
      , Ls = et("context");
    return jsxRuntimeExports.jsx(cs, {
        ...xt,
        ...Z$1(cs, Ls),
        children: jsxRuntimeExports.jsxs(Cs, {
            children: [jsxRuntimeExports.jsx(zr, {}), jsxRuntimeExports.jsx(Lr, {}), jsxRuntimeExports.jsx(Vr, {})]
        })
    })
})
  , {Component: Wr, useEmitter: no, useEmitterValue: et, usePublisher: It$1} = qe(Fr, {
    optional: {
        context: "context",
        totalCount: "totalCount",
        overscan: "overscan",
        itemContent: "itemContent",
        components: "components",
        computeItemKey: "computeItemKey",
        data: "data",
        initialItemCount: "initialItemCount",
        scrollSeekConfiguration: "scrollSeekConfiguration",
        headerFooterTag: "headerFooterTag",
        listClassName: "listClassName",
        itemClassName: "itemClassName",
        useWindowScroll: "useWindowScroll",
        customScrollParent: "customScrollParent",
        scrollerRef: "scrollerRef",
        logLevel: "logLevel",
        restoreStateFrom: "restoreStateFrom",
        initialTopMostItemIndex: "initialTopMostItemIndex",
        increaseViewportBy: "increaseViewportBy"
    },
    methods: {
        scrollTo: "scrollTo",
        scrollBy: "scrollBy",
        scrollToIndex: "scrollToIndex"
    },
    events: {
        isScrolling: "isScrolling",
        endReached: "endReached",
        startReached: "startReached",
        rangeChanged: "rangeChanged",
        atBottomStateChange: "atBottomStateChange",
        atTopStateChange: "atTopStateChange",
        stateChanged: "stateChanged",
        readyStateChanged: "readyStateChanged"
    }
}, Mr)
  , _r = Ze({
    useEmitter: no,
    useEmitterValue: et,
    usePublisher: It$1
})
  , Gr = Xe({
    useEmitter: no,
    useEmitterValue: et,
    usePublisher: It$1
});
function Hn(xt, Cn, as) {
    return Cn !== "normal" && !(Cn != null && Cn.endsWith("px")) && as(`${xt} was not resolved to pixel value correctly`, Cn, ht$1.WARN),
    Cn === "normal" ? 0 : parseInt(Cn ?? "0", 10)
}
const Yr = Wr
  , emptyStateTitle = "_emptyStateTitle_otij9_1"
  , emptyStateContainer = "_emptyStateContainer_otij9_4"
  , styles$1b = {
    emptyStateTitle,
    emptyStateContainer
}
  , EmptyList = ({title: xt, subtitle: Cn, footer: as}) => jsxRuntimeExports.jsxs("div", {
    className: styles$1b.emptyStateContainer,
    children: [jsxRuntimeExports.jsxs("div", {
        children: [jsxRuntimeExports.jsx("div", {
            className: styles$1b.emptyStateTitle,
            children: xt
        }), jsxRuntimeExports.jsx("div", {
            children: Cn
        })]
    }), jsxRuntimeExports.jsx("img", {
        src: "/images/common/pepe-gray.png",
        alt: "sad pepe"
    }), as]
})
  , emptyListFooterButton = "_emptyListFooterButton_o4yjl_1"
  , styles$1a = {
    emptyListFooterButton
}
  , EmptyGiveawayList = ({state: xt}) => {
    const {t: Cn} = useTranslation()
      , as = useNavigate()
      , {setCurrentTab: cs, setMultipleMode: Cs} = useStorage(ga => ({
        setCurrentTab: ga.myGifts.setCurrentTab,
        setMultipleMode: ga.myGifts.setMultipleMode
    }))
      , Ls = reactExports.useMemo( () => {
        switch (xt) {
        case "Paid":
            return "text_oops";
        case "Free":
            return "text_oops";
        case "Joined":
            return "text_you_didnt_join_giveaway";
        case "Mine":
            return "text_you_have_no_giveaways";
        default:
            return ""
        }
    }
    , [xt])
      , Vs = reactExports.useMemo( () => {
        switch (xt) {
        case "Paid":
            return "text_no_giveaways_running";
        case "Free":
            return "text_no_giveaways_running";
        default:
            return ""
        }
    }
    , [xt])
      , Ws = reactExports.useCallback( () => {
        cs("unlisted"),
        Cs("giveaway"),
        as("/my-gifts")
    }
    , [as])
      , Xs = reactExports.useMemo( () => xt === "Mine" ? jsxRuntimeExports.jsx(Button, {
        className: styles$1a.emptyListFooterButton,
        onClick: Ws,
        children: Cn("text_create_giveaway")
    }) : null, [xt]);
    return jsxRuntimeExports.jsx(EmptyList, {
        title: Cn(Ls),
        subtitle: Cn(Vs),
        footer: Xs
    })
}
  , createGiveaway = async xt => await (await fetch(getApiUrl("/api/v1/giveaways/create"), {
    method: "POST",
    body: JSON.stringify(xt),
    headers: {
        "Content-Type": "application/json"
    }
})).json()
  , fetchGiveaways = async (xt, Cn) => {
    const as = xt * DEFAULT_GA_PAGE_SIZE;
    return await (await fetch(getApiUrl(`/api/v1/giveaways?type=${Cn}&count=${DEFAULT_GA_PAGE_SIZE}&offset=${as}`))).json()
}
  , startGiveawayTaskValidation = async (xt, Cn, as) => await (await fetch(getApiUrl(`/api/v1/giveaways/start-validation/${xt}?channel=${Cn}&type=${as}`), {
    method: "POST"
})).json()
  , getGiveawayTasksValidationStatus = async xt => await (await fetch(getApiUrl(`/api/v1/giveaways/check-validations/${xt}`))).json()
  , getGiveawayInfo = async xt => await (await fetch(getApiUrl(`/api/v1/giveaways/${xt}`))).json()
  , buyGiveawayTickets = async (xt, Cn) => await (await fetch(getApiUrl(`/api/v1/giveaways/buy-tickets/${xt}?count=${Cn}`), {
    method: "POST"
})).json()
  , fetchGiveawayNotifications = async () => {
    try {
        return await (await fetch(getApiUrl("/api/v1/giveaway-notifications"), {
            method: "GET"
        })).json()
    } catch {
        return []
    }
}
  , claimGiveawayNotification = async xt => {
    await fetch(getApiUrl(`/api/v1/giveaway-notifications/${xt}/claim`), {
        method: "POST"
    })
}
  , DEFAULT_GA_PAGE_SIZE = 20
  , giveawaysInfiniteQueryOptions = xt => ({
    queryKey: [QueryKeys.giveaways, xt],
    queryFn: async ({pageParam: Cn=0}) => fetchGiveaways(Cn, xt),
    getNextPageParam: (Cn, as) => {
        if (!(Cn.length < DEFAULT_GA_PAGE_SIZE))
            return as.length
    }
    ,
    initialPageParam: 0
})
  , giveawayTasksValidationStatusQueryOptions = xt => ({
    queryKey: [QueryKeys.giveawayGetValidationStatus, xt],
    queryFn: () => getGiveawayTasksValidationStatus(xt),
    enabled: !!xt,
    staleTime: 60 * 1e3
})
  , giveawayInfoQueryOptions = xt => ({
    queryKey: [QueryKeys.giveawayInfo, xt],
    queryFn: () => getGiveawayInfo(xt),
    enabled: !!xt,
    staleTime: 60 * 1e3
})
  , giveawayNotificationsQueryOptions = () => ({
    queryKey: [QueryKeys.giveawayNotifications],
    queryFn: fetchGiveawayNotifications,
    refetchInterval: 60 * 1e3,
    refetchIntervalInBackground: !0
})
  , VirtuosoFooter = ({height: xt}) => jsxRuntimeExports.jsx("div", {
    style: {
        height: xt
    }
})
  , List$2 = reactExports.forwardRef( (xt, Cn) => jsxRuntimeExports.jsx("div", {
    ...xt,
    ref: Cn,
    className: styles$1c.virtuosoGrid
}))
  , Item$2 = reactExports.memo( ({"data-index": xt, ...Cn}) => jsxRuntimeExports.jsx("div", {
    ...Cn,
    className: styles$1c.virtuosoItem
}))
  , GiveawaysList = ({state: xt}) => {
    var _l;
    const Cn = reactExports.useRef(null)
      , as = reactExports.useRef(null)
      , cs = reactExports.useMemo( () => giveawaysInfiniteQueryOptions(xt), [xt])
      , {data: Cs, fetchNextPage: Ls, hasNextPage: Vs, isFetching: Ws} = useInfiniteQuery(cs)
      , Xs = reactExports.useCallback( () => {
        !Ws && Vs && Ls()
    }
    , [Ws, Ls, Vs])
      , ga = ((_l = Cs == null ? void 0 : Cs.pages) == null ? void 0 : _l.flatMap(El => El)) ?? []
      , ba = reactExports.useCallback( () => jsxRuntimeExports.jsx(VirtuosoFooter, {
        height: 30
    }), [])
      , yl = reactExports.useMemo( () => ({
        List: List$2,
        Item: Item$2,
        Footer: ba
    }), [])
      , xl = reactExports.useCallback(El => jsxRuntimeExports.jsx(GiveawayItem, {
        giveaway: ga[El]
    }, `giveaway-${El}`), [ga])
      , wl = reactExports.useCallback(El => `giveaway-${El.id}`, []);
    return jsxRuntimeExports.jsx("div", {
        className: styles$1c.giveawaysListContainer,
        ref: as,
        children: ga.length ? jsxRuntimeExports.jsx(Yr, {
            ref: Cn,
            className: styles$1c.virtualizer,
            totalCount: ga.length,
            overscan: 20,
            components: yl,
            endReached: Xs,
            computeItemKey: El => wl(ga[El]),
            itemContent: xl
        }) : Ws ? jsxRuntimeExports.jsx("div", {
            className: styles$1c.spinnerWrapper,
            children: jsxRuntimeExports.jsx(Spinner, {})
        }) : jsxRuntimeExports.jsx(EmptyGiveawayList, {
            state: xt
        })
    })
}
  , Giveaways = () => {
    const {activeTab: xt, setActiveTab: Cn} = useStorage(Cs => Cs.giveaways);
    reactExports.useEffect( () => () => Cn("Paid"), []);
    const as = [{
        key: "Paid",
        label: "tab_paid"
    }, {
        key: "Free",
        label: "tab_free"
    }, {
        key: "Mine",
        label: "tab_mine"
    }, {
        key: "Joined",
        label: "tab_entered"
    }]
      , cs = Cs => {
        Cn(Cs)
    }
    ;
    return jsxRuntimeExports.jsx(Page, {
        back: !1,
        children: jsxRuntimeExports.jsxs("div", {
            className: styles$1h.giveawayPageContainer,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$1h.tabsWrapper,
                children: jsxRuntimeExports.jsx(SegmentedTabs, {
                    tabs: as,
                    activeKey: xt,
                    onChange: cs
                })
            }), jsxRuntimeExports.jsx("div", {
                className: styles$1h.tabsContentWrapper,
                children: jsxRuntimeExports.jsx(GiveawaysList, {
                    state: xt
                })
            })]
        })
    })
}
  , item$1 = "_item_veclh_1"
  , selectedForListing = "_selectedForListing_veclh_12"
  , selectedForWithdraw = "_selectedForWithdraw_veclh_17"
  , itemHotRibbon = "_itemHotRibbon_veclh_23"
  , imageContainer = "_imageContainer_veclh_33"
  , frame = "_frame_veclh_54"
  , compactActions = "_compactActions_veclh_64"
  , name$1 = "_name_veclh_69"
  , number = "_number_veclh_81"
  , priceContainer = "_priceContainer_veclh_93"
  , priceLabel = "_priceLabel_veclh_104"
  , priceWrapper$1 = "_priceWrapper_veclh_116"
  , priceContent = "_priceContent_veclh_124"
  , tonIcon$1 = "_tonIcon_veclh_132"
  , priceValue = "_priceValue_veclh_140"
  , giftList = "_giftList_veclh_152"
  , virtuosoGrid$1 = "_virtuosoGrid_veclh_163"
  , virtuosoItem$1 = "_virtuosoItem_veclh_172"
  , virtualizer$1 = "_virtualizer_veclh_176"
  , giftActions = "_giftActions_veclh_188"
  , giftActionsBuy = "_giftActionsBuy_veclh_193"
  , cartIcon$1 = "_cartIcon_veclh_210"
  , trashIcon$1 = "_trashIcon_veclh_215"
  , actionButton$8 = "_actionButton_veclh_221"
  , actionWrapper = "_actionWrapper_veclh_225"
  , unlistedControls$1 = "_unlistedControls_veclh_236"
  , emptyUnlistedListContainer = "_emptyUnlistedListContainer_veclh_242"
  , mobile = "_mobile_veclh_254"
  , emptyUnlistedListTitle = "_emptyUnlistedListTitle_veclh_257"
  , emptyUnlistedListSubtitle = "_emptyUnlistedListSubtitle_veclh_257"
  , emptyUnlistedListHowto = "_emptyUnlistedListHowto_veclh_262"
  , emptyUnlistedListHowtoLink = "_emptyUnlistedListHowtoLink_veclh_272"
  , emptyUnlistedListAction = "_emptyUnlistedListAction_veclh_276"
  , spinnerWrapper$1 = "_spinnerWrapper_veclh_281"
  , styles$19 = {
    item: item$1,
    selectedForListing,
    selectedForWithdraw,
    itemHotRibbon,
    imageContainer,
    frame,
    compactActions,
    name: name$1,
    number,
    priceContainer,
    priceLabel,
    priceWrapper: priceWrapper$1,
    priceContent,
    tonIcon: tonIcon$1,
    priceValue,
    giftList,
    virtuosoGrid: virtuosoGrid$1,
    virtuosoItem: virtuosoItem$1,
    virtualizer: virtualizer$1,
    giftActions,
    giftActionsBuy,
    cartIcon: cartIcon$1,
    trashIcon: trashIcon$1,
    actionButton: actionButton$8,
    actionWrapper,
    unlistedControls: unlistedControls$1,
    emptyUnlistedListContainer,
    mobile,
    emptyUnlistedListTitle,
    emptyUnlistedListSubtitle,
    emptyUnlistedListHowto,
    emptyUnlistedListHowtoLink,
    emptyUnlistedListAction,
    spinnerWrapper: spinnerWrapper$1
}
  , getMessage = xt => {
    switch (xt) {
    case GIFTS_LIST_STATE.LISTED:
        return "text_no_gifts_listed";
    case GIFTS_LIST_STATE.UNLISTED:
        return "text_no_gifts_stored";
    case GIFTS_LIST_STATE.PUBLIC:
        return "text_no_gifts_found"
    }
}
  , EmptyGiftList = ({state: xt}) => {
    const {t: Cn} = useTranslation();
    return xt === GIFTS_LIST_STATE.UNLISTED ? jsxRuntimeExports.jsx(EmptyUnlistedGiftList, {}) : jsxRuntimeExports.jsx(EmptyList, {
        title: Cn("text_oops"),
        subtitle: Cn(getMessage(xt))
    })
}
;
function EmptyUnlistedGiftList() {
    const {t: xt} = useTranslation()
      , Cn = useNavigate()
      , {relayerBotName: as} = useStorage(cs => ({
        relayerBotName: cs.app.relayerBotName
    }));
    return jsxRuntimeExports.jsxs("div", {
        className: classNames$1(styles$19.emptyUnlistedListContainer, {
            [styles$19.mobile]: isMobile()
        }),
        children: [jsxRuntimeExports.jsx("div", {
            className: styles$19.emptyUnlistedListTitle,
            children: xt("text_oops")
        }), jsxRuntimeExports.jsx("div", {
            className: styles$19.emptyUnlistedListSubtitle,
            children: xt("text_no_gifts_stored")
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$19.emptyUnlistedListHowto,
            children: [xt("text_howto") + " ", jsxRuntimeExports.jsxs("span", {
                onClick: () => Oc(`https://t.me/${as}`),
                className: styles$19.emptyUnlistedListHowtoLink,
                children: ["@", as]
            })]
        }), jsxRuntimeExports.jsx(Button, {
            className: styles$19.emptyUnlistedListAction,
            onClick: () => Cn("/"),
            children: xt("button_go_buy_gifts")
        })]
    })
}
const promotedGiftsSlider = "_promotedGiftsSlider_xjw60_1"
  , virtualList = "_virtualList_xjw60_7"
  , giftContainer = "_giftContainer_xjw60_19"
  , sliderGiftItem = "_sliderGiftItem_xjw60_35"
  , sliderGiftItemFooter = "_sliderGiftItemFooter_xjw60_45"
  , sliderGiftItemHotRibbon = "_sliderGiftItemHotRibbon_xjw60_68"
  , styles$18 = {
    promotedGiftsSlider,
    virtualList,
    giftContainer,
    sliderGiftItem,
    sliderGiftItemFooter,
    sliderGiftItemHotRibbon
};
function clamp(xt, Cn, as) {
    return Math.max(Cn, Math.min(xt, as))
}
const V$1 = {
    toVector(xt, Cn) {
        return xt === void 0 && (xt = Cn),
        Array.isArray(xt) ? xt : [xt, xt]
    },
    add(xt, Cn) {
        return [xt[0] + Cn[0], xt[1] + Cn[1]]
    },
    sub(xt, Cn) {
        return [xt[0] - Cn[0], xt[1] - Cn[1]]
    },
    addTo(xt, Cn) {
        xt[0] += Cn[0],
        xt[1] += Cn[1]
    },
    subTo(xt, Cn) {
        xt[0] -= Cn[0],
        xt[1] -= Cn[1]
    }
};
function rubberband(xt, Cn, as) {
    return Cn === 0 || Math.abs(Cn) === 1 / 0 ? Math.pow(xt, as * 5) : xt * Cn * as / (Cn + as * xt)
}
function rubberbandIfOutOfBounds(xt, Cn, as, cs=.15) {
    return cs === 0 ? clamp(xt, Cn, as) : xt < Cn ? -rubberband(Cn - xt, as - Cn, cs) + Cn : xt > as ? +rubberband(xt - as, as - Cn, cs) + as : xt
}
function computeRubberband(xt, [Cn,as], [cs,Cs]) {
    const [[Ls,Vs],[Ws,Xs]] = xt;
    return [rubberbandIfOutOfBounds(Cn, Ls, Vs, cs), rubberbandIfOutOfBounds(as, Ws, Xs, Cs)]
}
function _toPrimitive(xt, Cn) {
    if (typeof xt != "object" || xt === null)
        return xt;
    var as = xt[Symbol.toPrimitive];
    if (as !== void 0) {
        var cs = as.call(xt, Cn);
        if (typeof cs != "object")
            return cs;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (Cn === "string" ? String : Number)(xt)
}
function _toPropertyKey(xt) {
    var Cn = _toPrimitive(xt, "string");
    return typeof Cn == "symbol" ? Cn : String(Cn)
}
function _defineProperty(xt, Cn, as) {
    return Cn = _toPropertyKey(Cn),
    Cn in xt ? Object.defineProperty(xt, Cn, {
        value: as,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : xt[Cn] = as,
    xt
}
function ownKeys(xt, Cn) {
    var as = Object.keys(xt);
    if (Object.getOwnPropertySymbols) {
        var cs = Object.getOwnPropertySymbols(xt);
        Cn && (cs = cs.filter(function(Cs) {
            return Object.getOwnPropertyDescriptor(xt, Cs).enumerable
        })),
        as.push.apply(as, cs)
    }
    return as
}
function _objectSpread2(xt) {
    for (var Cn = 1; Cn < arguments.length; Cn++) {
        var as = arguments[Cn] != null ? arguments[Cn] : {};
        Cn % 2 ? ownKeys(Object(as), !0).forEach(function(cs) {
            _defineProperty(xt, cs, as[cs])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(xt, Object.getOwnPropertyDescriptors(as)) : ownKeys(Object(as)).forEach(function(cs) {
            Object.defineProperty(xt, cs, Object.getOwnPropertyDescriptor(as, cs))
        })
    }
    return xt
}
const EVENT_TYPE_MAP = {
    pointer: {
        start: "down",
        change: "move",
        end: "up"
    },
    mouse: {
        start: "down",
        change: "move",
        end: "up"
    },
    touch: {
        start: "start",
        change: "move",
        end: "end"
    },
    gesture: {
        start: "start",
        change: "change",
        end: "end"
    }
};
function capitalize(xt) {
    return xt ? xt[0].toUpperCase() + xt.slice(1) : ""
}
const actionsWithoutCaptureSupported = ["enter", "leave"];
function hasCapture(xt=!1, Cn) {
    return xt && !actionsWithoutCaptureSupported.includes(Cn)
}
function toHandlerProp(xt, Cn="", as=!1) {
    const cs = EVENT_TYPE_MAP[xt]
      , Cs = cs && cs[Cn] || Cn;
    return "on" + capitalize(xt) + capitalize(Cs) + (hasCapture(as, Cs) ? "Capture" : "")
}
const pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
function parseProp(xt) {
    let Cn = xt.substring(2).toLowerCase();
    const as = !!~Cn.indexOf("passive");
    as && (Cn = Cn.replace("passive", ""));
    const cs = pointerCaptureEvents.includes(Cn) ? "capturecapture" : "capture"
      , Cs = !!~Cn.indexOf(cs);
    return Cs && (Cn = Cn.replace("capture", "")),
    {
        device: Cn,
        capture: Cs,
        passive: as
    }
}
function toDomEventType(xt, Cn="") {
    const as = EVENT_TYPE_MAP[xt]
      , cs = as && as[Cn] || Cn;
    return xt + cs
}
function isTouch(xt) {
    return "touches"in xt
}
function getPointerType(xt) {
    return isTouch(xt) ? "touch" : "pointerType"in xt ? xt.pointerType : "mouse"
}
function getCurrentTargetTouchList(xt) {
    return Array.from(xt.touches).filter(Cn => {
        var as, cs;
        return Cn.target === xt.currentTarget || ((as = xt.currentTarget) === null || as === void 0 || (cs = as.contains) === null || cs === void 0 ? void 0 : cs.call(as, Cn.target))
    }
    )
}
function getTouchList(xt) {
    return xt.type === "touchend" || xt.type === "touchcancel" ? xt.changedTouches : xt.targetTouches
}
function getValueEvent(xt) {
    return isTouch(xt) ? getTouchList(xt)[0] : xt
}
function distanceAngle(xt, Cn) {
    try {
        const as = Cn.clientX - xt.clientX
          , cs = Cn.clientY - xt.clientY
          , Cs = (Cn.clientX + xt.clientX) / 2
          , Ls = (Cn.clientY + xt.clientY) / 2
          , Vs = Math.hypot(as, cs);
        return {
            angle: -(Math.atan2(as, cs) * 180) / Math.PI,
            distance: Vs,
            origin: [Cs, Ls]
        }
    } catch {}
    return null
}
function touchIds(xt) {
    return getCurrentTargetTouchList(xt).map(Cn => Cn.identifier)
}
function touchDistanceAngle(xt, Cn) {
    const [as,cs] = Array.from(xt.touches).filter(Cs => Cn.includes(Cs.identifier));
    return distanceAngle(as, cs)
}
function pointerId(xt) {
    const Cn = getValueEvent(xt);
    return isTouch(xt) ? Cn.identifier : Cn.pointerId
}
function pointerValues(xt) {
    const Cn = getValueEvent(xt);
    return [Cn.clientX, Cn.clientY]
}
const LINE_HEIGHT = 40
  , PAGE_HEIGHT = 800;
function wheelValues(xt) {
    let {deltaX: Cn, deltaY: as, deltaMode: cs} = xt;
    return cs === 1 ? (Cn *= LINE_HEIGHT,
    as *= LINE_HEIGHT) : cs === 2 && (Cn *= PAGE_HEIGHT,
    as *= PAGE_HEIGHT),
    [Cn, as]
}
function scrollValues(xt) {
    var Cn, as;
    const {scrollX: cs, scrollY: Cs, scrollLeft: Ls, scrollTop: Vs} = xt.currentTarget;
    return [(Cn = cs ?? Ls) !== null && Cn !== void 0 ? Cn : 0, (as = Cs ?? Vs) !== null && as !== void 0 ? as : 0]
}
function getEventDetails(xt) {
    const Cn = {};
    if ("buttons"in xt && (Cn.buttons = xt.buttons),
    "shiftKey"in xt) {
        const {shiftKey: as, altKey: cs, metaKey: Cs, ctrlKey: Ls} = xt;
        Object.assign(Cn, {
            shiftKey: as,
            altKey: cs,
            metaKey: Cs,
            ctrlKey: Ls
        })
    }
    return Cn
}
function call(xt, ...Cn) {
    return typeof xt == "function" ? xt(...Cn) : xt
}
function noop() {}
function chain(...xt) {
    return xt.length === 0 ? noop : xt.length === 1 ? xt[0] : function() {
        let Cn;
        for (const as of xt)
            Cn = as.apply(this, arguments) || Cn;
        return Cn
    }
}
function assignDefault(xt, Cn) {
    return Object.assign({}, Cn, xt || {})
}
const BEFORE_LAST_KINEMATICS_DELAY = 32;
class Engine {
    constructor(Cn, as, cs) {
        this.ctrl = Cn,
        this.args = as,
        this.key = cs,
        this.state || (this.state = {},
        this.computeValues([0, 0]),
        this.computeInitial(),
        this.init && this.init(),
        this.reset())
    }
    get state() {
        return this.ctrl.state[this.key]
    }
    set state(Cn) {
        this.ctrl.state[this.key] = Cn
    }
    get shared() {
        return this.ctrl.state.shared
    }
    get eventStore() {
        return this.ctrl.gestureEventStores[this.key]
    }
    get timeoutStore() {
        return this.ctrl.gestureTimeoutStores[this.key]
    }
    get config() {
        return this.ctrl.config[this.key]
    }
    get sharedConfig() {
        return this.ctrl.config.shared
    }
    get handler() {
        return this.ctrl.handlers[this.key]
    }
    reset() {
        const {state: Cn, shared: as, ingKey: cs, args: Cs} = this;
        as[cs] = Cn._active = Cn.active = Cn._blocked = Cn._force = !1,
        Cn._step = [!1, !1],
        Cn.intentional = !1,
        Cn._movement = [0, 0],
        Cn._distance = [0, 0],
        Cn._direction = [0, 0],
        Cn._delta = [0, 0],
        Cn._bounds = [[-1 / 0, 1 / 0], [-1 / 0, 1 / 0]],
        Cn.args = Cs,
        Cn.axis = void 0,
        Cn.memo = void 0,
        Cn.elapsedTime = Cn.timeDelta = 0,
        Cn.direction = [0, 0],
        Cn.distance = [0, 0],
        Cn.overflow = [0, 0],
        Cn._movementBound = [!1, !1],
        Cn.velocity = [0, 0],
        Cn.movement = [0, 0],
        Cn.delta = [0, 0],
        Cn.timeStamp = 0
    }
    start(Cn) {
        const as = this.state
          , cs = this.config;
        as._active || (this.reset(),
        this.computeInitial(),
        as._active = !0,
        as.target = Cn.target,
        as.currentTarget = Cn.currentTarget,
        as.lastOffset = cs.from ? call(cs.from, as) : as.offset,
        as.offset = as.lastOffset,
        as.startTime = as.timeStamp = Cn.timeStamp)
    }
    computeValues(Cn) {
        const as = this.state;
        as._values = Cn,
        as.values = this.config.transform(Cn)
    }
    computeInitial() {
        const Cn = this.state;
        Cn._initial = Cn._values,
        Cn.initial = Cn.values
    }
    compute(Cn) {
        const {state: as, config: cs, shared: Cs} = this;
        as.args = this.args;
        let Ls = 0;
        if (Cn && (as.event = Cn,
        cs.preventDefault && Cn.cancelable && as.event.preventDefault(),
        as.type = Cn.type,
        Cs.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size,
        Cs.locked = !!document.pointerLockElement,
        Object.assign(Cs, getEventDetails(Cn)),
        Cs.down = Cs.pressed = Cs.buttons % 2 === 1 || Cs.touches > 0,
        Ls = Cn.timeStamp - as.timeStamp,
        as.timeStamp = Cn.timeStamp,
        as.elapsedTime = as.timeStamp - as.startTime),
        as._active) {
            const Ml = as._delta.map(Math.abs);
            V$1.addTo(as._distance, Ml)
        }
        this.axisIntent && this.axisIntent(Cn);
        const [Vs,Ws] = as._movement
          , [Xs,ga] = cs.threshold
          , {_step: ba, values: yl} = as;
        if (cs.hasCustomTransform ? (ba[0] === !1 && (ba[0] = Math.abs(Vs) >= Xs && yl[0]),
        ba[1] === !1 && (ba[1] = Math.abs(Ws) >= ga && yl[1])) : (ba[0] === !1 && (ba[0] = Math.abs(Vs) >= Xs && Math.sign(Vs) * Xs),
        ba[1] === !1 && (ba[1] = Math.abs(Ws) >= ga && Math.sign(Ws) * ga)),
        as.intentional = ba[0] !== !1 || ba[1] !== !1,
        !as.intentional)
            return;
        const xl = [0, 0];
        if (cs.hasCustomTransform) {
            const [Ml,Nl] = yl;
            xl[0] = ba[0] !== !1 ? Ml - ba[0] : 0,
            xl[1] = ba[1] !== !1 ? Nl - ba[1] : 0
        } else
            xl[0] = ba[0] !== !1 ? Vs - ba[0] : 0,
            xl[1] = ba[1] !== !1 ? Ws - ba[1] : 0;
        this.restrictToAxis && !as._blocked && this.restrictToAxis(xl);
        const wl = as.offset
          , _l = as._active && !as._blocked || as.active;
        _l && (as.first = as._active && !as.active,
        as.last = !as._active && as.active,
        as.active = Cs[this.ingKey] = as._active,
        Cn && (as.first && ("bounds"in cs && (as._bounds = call(cs.bounds, as)),
        this.setup && this.setup()),
        as.movement = xl,
        this.computeOffset()));
        const [El,Cl] = as.offset
          , [[$l,Sl],[Tl,Rl]] = as._bounds;
        as.overflow = [El < $l ? -1 : El > Sl ? 1 : 0, Cl < Tl ? -1 : Cl > Rl ? 1 : 0],
        as._movementBound[0] = as.overflow[0] ? as._movementBound[0] === !1 ? as._movement[0] : as._movementBound[0] : !1,
        as._movementBound[1] = as.overflow[1] ? as._movementBound[1] === !1 ? as._movement[1] : as._movementBound[1] : !1;
        const Il = as._active ? cs.rubberband || [0, 0] : [0, 0];
        if (as.offset = computeRubberband(as._bounds, as.offset, Il),
        as.delta = V$1.sub(as.offset, wl),
        this.computeMovement(),
        _l && (!as.last || Ls > BEFORE_LAST_KINEMATICS_DELAY)) {
            as.delta = V$1.sub(as.offset, wl);
            const Ml = as.delta.map(Math.abs);
            V$1.addTo(as.distance, Ml),
            as.direction = as.delta.map(Math.sign),
            as._direction = as._delta.map(Math.sign),
            !as.first && Ls > 0 && (as.velocity = [Ml[0] / Ls, Ml[1] / Ls],
            as.timeDelta = Ls)
        }
    }
    emit() {
        const Cn = this.state
          , as = this.shared
          , cs = this.config;
        if (Cn._active || this.clean(),
        (Cn._blocked || !Cn.intentional) && !Cn._force && !cs.triggerAllEvents)
            return;
        const Cs = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, as), Cn), {}, {
            [this.aliasKey]: Cn.values
        }));
        Cs !== void 0 && (Cn.memo = Cs)
    }
    clean() {
        this.eventStore.clean(),
        this.timeoutStore.clean()
    }
}
function selectAxis([xt,Cn], as) {
    const cs = Math.abs(xt)
      , Cs = Math.abs(Cn);
    if (cs > Cs && cs > as)
        return "x";
    if (Cs > cs && Cs > as)
        return "y"
}
class CoordinatesEngine extends Engine {
    constructor(...Cn) {
        super(...Cn),
        _defineProperty(this, "aliasKey", "xy")
    }
    reset() {
        super.reset(),
        this.state.axis = void 0
    }
    init() {
        this.state.offset = [0, 0],
        this.state.lastOffset = [0, 0]
    }
    computeOffset() {
        this.state.offset = V$1.add(this.state.lastOffset, this.state.movement)
    }
    computeMovement() {
        this.state.movement = V$1.sub(this.state.offset, this.state.lastOffset)
    }
    axisIntent(Cn) {
        const as = this.state
          , cs = this.config;
        if (!as.axis && Cn) {
            const Cs = typeof cs.axisThreshold == "object" ? cs.axisThreshold[getPointerType(Cn)] : cs.axisThreshold;
            as.axis = selectAxis(as._movement, Cs)
        }
        as._blocked = (cs.lockDirection || !!cs.axis) && !as.axis || !!cs.axis && cs.axis !== as.axis
    }
    restrictToAxis(Cn) {
        if (this.config.axis || this.config.lockDirection)
            switch (this.state.axis) {
            case "x":
                Cn[1] = 0;
                break;
            case "y":
                Cn[0] = 0;
                break
            }
    }
}
const identity = xt => xt
  , DEFAULT_RUBBERBAND = .15
  , commonConfigResolver = {
    enabled(xt=!0) {
        return xt
    },
    eventOptions(xt, Cn, as) {
        return _objectSpread2(_objectSpread2({}, as.shared.eventOptions), xt)
    },
    preventDefault(xt=!1) {
        return xt
    },
    triggerAllEvents(xt=!1) {
        return xt
    },
    rubberband(xt=0) {
        switch (xt) {
        case !0:
            return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
        case !1:
            return [0, 0];
        default:
            return V$1.toVector(xt)
        }
    },
    from(xt) {
        if (typeof xt == "function")
            return xt;
        if (xt != null)
            return V$1.toVector(xt)
    },
    transform(xt, Cn, as) {
        const cs = xt || as.shared.transform;
        return this.hasCustomTransform = !!cs,
        cs || identity
    },
    threshold(xt) {
        return V$1.toVector(xt, 0)
    }
}
  , DEFAULT_AXIS_THRESHOLD = 0
  , coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
    axis(xt, Cn, {axis: as}) {
        if (this.lockDirection = as === "lock",
        !this.lockDirection)
            return as
    },
    axisThreshold(xt=DEFAULT_AXIS_THRESHOLD) {
        return xt
    },
    bounds(xt={}) {
        if (typeof xt == "function")
            return Ls => coordinatesConfigResolver.bounds(xt(Ls));
        if ("current"in xt)
            return () => xt.current;
        if (typeof HTMLElement == "function" && xt instanceof HTMLElement)
            return xt;
        const {left: Cn=-1 / 0, right: as=1 / 0, top: cs=-1 / 0, bottom: Cs=1 / 0} = xt;
        return [[Cn, as], [cs, Cs]]
    }
})
  , KEYS_DELTA_MAP = {
    ArrowRight: (xt, Cn=1) => [xt * Cn, 0],
    ArrowLeft: (xt, Cn=1) => [-1 * xt * Cn, 0],
    ArrowUp: (xt, Cn=1) => [0, -1 * xt * Cn],
    ArrowDown: (xt, Cn=1) => [0, xt * Cn]
};
class DragEngine extends CoordinatesEngine {
    constructor(...Cn) {
        super(...Cn),
        _defineProperty(this, "ingKey", "dragging")
    }
    reset() {
        super.reset();
        const Cn = this.state;
        Cn._pointerId = void 0,
        Cn._pointerActive = !1,
        Cn._keyboardActive = !1,
        Cn._preventScroll = !1,
        Cn._delayed = !1,
        Cn.swipe = [0, 0],
        Cn.tap = !1,
        Cn.canceled = !1,
        Cn.cancel = this.cancel.bind(this)
    }
    setup() {
        const Cn = this.state;
        if (Cn._bounds instanceof HTMLElement) {
            const as = Cn._bounds.getBoundingClientRect()
              , cs = Cn.currentTarget.getBoundingClientRect()
              , Cs = {
                left: as.left - cs.left + Cn.offset[0],
                right: as.right - cs.right + Cn.offset[0],
                top: as.top - cs.top + Cn.offset[1],
                bottom: as.bottom - cs.bottom + Cn.offset[1]
            };
            Cn._bounds = coordinatesConfigResolver.bounds(Cs)
        }
    }
    cancel() {
        const Cn = this.state;
        Cn.canceled || (Cn.canceled = !0,
        Cn._active = !1,
        setTimeout( () => {
            this.compute(),
            this.emit()
        }
        , 0))
    }
    setActive() {
        this.state._active = this.state._pointerActive || this.state._keyboardActive
    }
    clean() {
        this.pointerClean(),
        this.state._pointerActive = !1,
        this.state._keyboardActive = !1,
        super.clean()
    }
    pointerDown(Cn) {
        const as = this.config
          , cs = this.state;
        if (Cn.buttons != null && (Array.isArray(as.pointerButtons) ? !as.pointerButtons.includes(Cn.buttons) : as.pointerButtons !== -1 && as.pointerButtons !== Cn.buttons))
            return;
        const Cs = this.ctrl.setEventIds(Cn);
        as.pointerCapture && Cn.target.setPointerCapture(Cn.pointerId),
        !(Cs && Cs.size > 1 && cs._pointerActive) && (this.start(Cn),
        this.setupPointer(Cn),
        cs._pointerId = pointerId(Cn),
        cs._pointerActive = !0,
        this.computeValues(pointerValues(Cn)),
        this.computeInitial(),
        as.preventScrollAxis && getPointerType(Cn) !== "mouse" ? (cs._active = !1,
        this.setupScrollPrevention(Cn)) : as.delay > 0 ? (this.setupDelayTrigger(Cn),
        as.triggerAllEvents && (this.compute(Cn),
        this.emit())) : this.startPointerDrag(Cn))
    }
    startPointerDrag(Cn) {
        const as = this.state;
        as._active = !0,
        as._preventScroll = !0,
        as._delayed = !1,
        this.compute(Cn),
        this.emit()
    }
    pointerMove(Cn) {
        const as = this.state
          , cs = this.config;
        if (!as._pointerActive)
            return;
        const Cs = pointerId(Cn);
        if (as._pointerId !== void 0 && Cs !== as._pointerId)
            return;
        const Ls = pointerValues(Cn);
        if (document.pointerLockElement === Cn.target ? as._delta = [Cn.movementX, Cn.movementY] : (as._delta = V$1.sub(Ls, as._values),
        this.computeValues(Ls)),
        V$1.addTo(as._movement, as._delta),
        this.compute(Cn),
        as._delayed && as.intentional) {
            this.timeoutStore.remove("dragDelay"),
            as.active = !1,
            this.startPointerDrag(Cn);
            return
        }
        if (cs.preventScrollAxis && !as._preventScroll)
            if (as.axis)
                if (as.axis === cs.preventScrollAxis || cs.preventScrollAxis === "xy") {
                    as._active = !1,
                    this.clean();
                    return
                } else {
                    this.timeoutStore.remove("startPointerDrag"),
                    this.startPointerDrag(Cn);
                    return
                }
            else
                return;
        this.emit()
    }
    pointerUp(Cn) {
        this.ctrl.setEventIds(Cn);
        try {
            this.config.pointerCapture && Cn.target.hasPointerCapture(Cn.pointerId) && Cn.target.releasePointerCapture(Cn.pointerId)
        } catch {}
        const as = this.state
          , cs = this.config;
        if (!as._active || !as._pointerActive)
            return;
        const Cs = pointerId(Cn);
        if (as._pointerId !== void 0 && Cs !== as._pointerId)
            return;
        this.state._pointerActive = !1,
        this.setActive(),
        this.compute(Cn);
        const [Ls,Vs] = as._distance;
        if (as.tap = Ls <= cs.tapsThreshold && Vs <= cs.tapsThreshold,
        as.tap && cs.filterTaps)
            as._force = !0;
        else {
            const [Ws,Xs] = as._delta
              , [ga,ba] = as._movement
              , [yl,xl] = cs.swipe.velocity
              , [wl,_l] = cs.swipe.distance
              , El = cs.swipe.duration;
            if (as.elapsedTime < El) {
                const Cl = Math.abs(Ws / as.timeDelta)
                  , $l = Math.abs(Xs / as.timeDelta);
                Cl > yl && Math.abs(ga) > wl && (as.swipe[0] = Math.sign(Ws)),
                $l > xl && Math.abs(ba) > _l && (as.swipe[1] = Math.sign(Xs))
            }
        }
        this.emit()
    }
    pointerClick(Cn) {
        !this.state.tap && Cn.detail > 0 && (Cn.preventDefault(),
        Cn.stopPropagation())
    }
    setupPointer(Cn) {
        const as = this.config
          , cs = as.device;
        as.pointerLock && Cn.currentTarget.requestPointerLock(),
        as.pointerCapture || (this.eventStore.add(this.sharedConfig.window, cs, "change", this.pointerMove.bind(this)),
        this.eventStore.add(this.sharedConfig.window, cs, "end", this.pointerUp.bind(this)),
        this.eventStore.add(this.sharedConfig.window, cs, "cancel", this.pointerUp.bind(this)))
    }
    pointerClean() {
        this.config.pointerLock && document.pointerLockElement === this.state.currentTarget && document.exitPointerLock()
    }
    preventScroll(Cn) {
        this.state._preventScroll && Cn.cancelable && Cn.preventDefault()
    }
    setupScrollPrevention(Cn) {
        this.state._preventScroll = !1,
        persistEvent(Cn);
        const as = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
            passive: !1
        });
        this.eventStore.add(this.sharedConfig.window, "touch", "end", as),
        this.eventStore.add(this.sharedConfig.window, "touch", "cancel", as),
        this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, Cn)
    }
    setupDelayTrigger(Cn) {
        this.state._delayed = !0,
        this.timeoutStore.add("dragDelay", () => {
            this.state._step = [0, 0],
            this.startPointerDrag(Cn)
        }
        , this.config.delay)
    }
    keyDown(Cn) {
        const as = KEYS_DELTA_MAP[Cn.key];
        if (as) {
            const cs = this.state
              , Cs = Cn.shiftKey ? 10 : Cn.altKey ? .1 : 1;
            this.start(Cn),
            cs._delta = as(this.config.keyboardDisplacement, Cs),
            cs._keyboardActive = !0,
            V$1.addTo(cs._movement, cs._delta),
            this.compute(Cn),
            this.emit()
        }
    }
    keyUp(Cn) {
        Cn.key in KEYS_DELTA_MAP && (this.state._keyboardActive = !1,
        this.setActive(),
        this.compute(Cn),
        this.emit())
    }
    bind(Cn) {
        const as = this.config.device;
        Cn(as, "start", this.pointerDown.bind(this)),
        this.config.pointerCapture && (Cn(as, "change", this.pointerMove.bind(this)),
        Cn(as, "end", this.pointerUp.bind(this)),
        Cn(as, "cancel", this.pointerUp.bind(this)),
        Cn("lostPointerCapture", "", this.pointerUp.bind(this))),
        this.config.keys && (Cn("key", "down", this.keyDown.bind(this)),
        Cn("key", "up", this.keyUp.bind(this))),
        this.config.filterTaps && Cn("click", "", this.pointerClick.bind(this), {
            capture: !0,
            passive: !1
        })
    }
}
function persistEvent(xt) {
    "persist"in xt && typeof xt.persist == "function" && xt.persist()
}
const isBrowser = typeof window < "u" && window.document && window.document.createElement;
function supportsTouchEvents() {
    return isBrowser && "ontouchstart"in window
}
function isTouchScreen() {
    return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1
}
function supportsPointerEvents() {
    return isBrowser && "onpointerdown"in window
}
function supportsPointerLock() {
    return isBrowser && "exitPointerLock"in window.document
}
function supportsGestureEvents() {
    try {
        return "constructor"in GestureEvent
    } catch {
        return !1
    }
}
const SUPPORT = {
    isBrowser,
    gesture: supportsGestureEvents(),
    touch: supportsTouchEvents(),
    touchscreen: isTouchScreen(),
    pointer: supportsPointerEvents(),
    pointerLock: supportsPointerLock()
}
  , DEFAULT_PREVENT_SCROLL_DELAY = 250
  , DEFAULT_DRAG_DELAY = 180
  , DEFAULT_SWIPE_VELOCITY = .5
  , DEFAULT_SWIPE_DISTANCE = 50
  , DEFAULT_SWIPE_DURATION = 250
  , DEFAULT_KEYBOARD_DISPLACEMENT = 10
  , DEFAULT_DRAG_AXIS_THRESHOLD = {
    mouse: 0,
    touch: 0,
    pen: 8
}
  , dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
    device(xt, Cn, {pointer: {touch: as=!1, lock: cs=!1, mouse: Cs=!1}={}}) {
        return this.pointerLock = cs && SUPPORT.pointerLock,
        SUPPORT.touch && as ? "touch" : this.pointerLock ? "mouse" : SUPPORT.pointer && !Cs ? "pointer" : SUPPORT.touch ? "touch" : "mouse"
    },
    preventScrollAxis(xt, Cn, {preventScroll: as}) {
        if (this.preventScrollDelay = typeof as == "number" ? as : as || as === void 0 && xt ? DEFAULT_PREVENT_SCROLL_DELAY : void 0,
        !(!SUPPORT.touchscreen || as === !1))
            return xt || (as !== void 0 ? "y" : void 0)
    },
    pointerCapture(xt, Cn, {pointer: {capture: as=!0, buttons: cs=1, keys: Cs=!0}={}}) {
        return this.pointerButtons = cs,
        this.keys = Cs,
        !this.pointerLock && this.device === "pointer" && as
    },
    threshold(xt, Cn, {filterTaps: as=!1, tapsThreshold: cs=3, axis: Cs=void 0}) {
        const Ls = V$1.toVector(xt, as ? cs : Cs ? 1 : 0);
        return this.filterTaps = as,
        this.tapsThreshold = cs,
        Ls
    },
    swipe({velocity: xt=DEFAULT_SWIPE_VELOCITY, distance: Cn=DEFAULT_SWIPE_DISTANCE, duration: as=DEFAULT_SWIPE_DURATION}={}) {
        return {
            velocity: this.transform(V$1.toVector(xt)),
            distance: this.transform(V$1.toVector(Cn)),
            duration: as
        }
    },
    delay(xt=0) {
        switch (xt) {
        case !0:
            return DEFAULT_DRAG_DELAY;
        case !1:
            return 0;
        default:
            return xt
        }
    },
    axisThreshold(xt) {
        return xt ? _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), xt) : DEFAULT_DRAG_AXIS_THRESHOLD
    },
    keyboardDisplacement(xt=DEFAULT_KEYBOARD_DISPLACEMENT) {
        return xt
    }
});
function clampStateInternalMovementToBounds(xt) {
    const [Cn,as] = xt.overflow
      , [cs,Cs] = xt._delta
      , [Ls,Vs] = xt._direction;
    (Cn < 0 && cs > 0 && Ls < 0 || Cn > 0 && cs < 0 && Ls > 0) && (xt._movement[0] = xt._movementBound[0]),
    (as < 0 && Cs > 0 && Vs < 0 || as > 0 && Cs < 0 && Vs > 0) && (xt._movement[1] = xt._movementBound[1])
}
const SCALE_ANGLE_RATIO_INTENT_DEG = 30
  , PINCH_WHEEL_RATIO = 100;
class PinchEngine extends Engine {
    constructor(...Cn) {
        super(...Cn),
        _defineProperty(this, "ingKey", "pinching"),
        _defineProperty(this, "aliasKey", "da")
    }
    init() {
        this.state.offset = [1, 0],
        this.state.lastOffset = [1, 0],
        this.state._pointerEvents = new Map
    }
    reset() {
        super.reset();
        const Cn = this.state;
        Cn._touchIds = [],
        Cn.canceled = !1,
        Cn.cancel = this.cancel.bind(this),
        Cn.turns = 0
    }
    computeOffset() {
        const {type: Cn, movement: as, lastOffset: cs} = this.state;
        Cn === "wheel" ? this.state.offset = V$1.add(as, cs) : this.state.offset = [(1 + as[0]) * cs[0], as[1] + cs[1]]
    }
    computeMovement() {
        const {offset: Cn, lastOffset: as} = this.state;
        this.state.movement = [Cn[0] / as[0], Cn[1] - as[1]]
    }
    axisIntent() {
        const Cn = this.state
          , [as,cs] = Cn._movement;
        if (!Cn.axis) {
            const Cs = Math.abs(as) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(cs);
            Cs < 0 ? Cn.axis = "angle" : Cs > 0 && (Cn.axis = "scale")
        }
    }
    restrictToAxis(Cn) {
        this.config.lockDirection && (this.state.axis === "scale" ? Cn[1] = 0 : this.state.axis === "angle" && (Cn[0] = 0))
    }
    cancel() {
        const Cn = this.state;
        Cn.canceled || setTimeout( () => {
            Cn.canceled = !0,
            Cn._active = !1,
            this.compute(),
            this.emit()
        }
        , 0)
    }
    touchStart(Cn) {
        this.ctrl.setEventIds(Cn);
        const as = this.state
          , cs = this.ctrl.touchIds;
        if (as._active && as._touchIds.every(Ls => cs.has(Ls)) || cs.size < 2)
            return;
        this.start(Cn),
        as._touchIds = Array.from(cs).slice(0, 2);
        const Cs = touchDistanceAngle(Cn, as._touchIds);
        Cs && this.pinchStart(Cn, Cs)
    }
    pointerStart(Cn) {
        if (Cn.buttons != null && Cn.buttons % 2 !== 1)
            return;
        this.ctrl.setEventIds(Cn),
        Cn.target.setPointerCapture(Cn.pointerId);
        const as = this.state
          , cs = as._pointerEvents
          , Cs = this.ctrl.pointerIds;
        if (as._active && Array.from(cs.keys()).every(Vs => Cs.has(Vs)) || (cs.size < 2 && cs.set(Cn.pointerId, Cn),
        as._pointerEvents.size < 2))
            return;
        this.start(Cn);
        const Ls = distanceAngle(...Array.from(cs.values()));
        Ls && this.pinchStart(Cn, Ls)
    }
    pinchStart(Cn, as) {
        const cs = this.state;
        cs.origin = as.origin,
        this.computeValues([as.distance, as.angle]),
        this.computeInitial(),
        this.compute(Cn),
        this.emit()
    }
    touchMove(Cn) {
        if (!this.state._active)
            return;
        const as = touchDistanceAngle(Cn, this.state._touchIds);
        as && this.pinchMove(Cn, as)
    }
    pointerMove(Cn) {
        const as = this.state._pointerEvents;
        if (as.has(Cn.pointerId) && as.set(Cn.pointerId, Cn),
        !this.state._active)
            return;
        const cs = distanceAngle(...Array.from(as.values()));
        cs && this.pinchMove(Cn, cs)
    }
    pinchMove(Cn, as) {
        const cs = this.state
          , Cs = cs._values[1]
          , Ls = as.angle - Cs;
        let Vs = 0;
        Math.abs(Ls) > 270 && (Vs += Math.sign(Ls)),
        this.computeValues([as.distance, as.angle - 360 * Vs]),
        cs.origin = as.origin,
        cs.turns = Vs,
        cs._movement = [cs._values[0] / cs._initial[0] - 1, cs._values[1] - cs._initial[1]],
        this.compute(Cn),
        this.emit()
    }
    touchEnd(Cn) {
        this.ctrl.setEventIds(Cn),
        this.state._active && this.state._touchIds.some(as => !this.ctrl.touchIds.has(as)) && (this.state._active = !1,
        this.compute(Cn),
        this.emit())
    }
    pointerEnd(Cn) {
        const as = this.state;
        this.ctrl.setEventIds(Cn);
        try {
            Cn.target.releasePointerCapture(Cn.pointerId)
        } catch {}
        as._pointerEvents.has(Cn.pointerId) && as._pointerEvents.delete(Cn.pointerId),
        as._active && as._pointerEvents.size < 2 && (as._active = !1,
        this.compute(Cn),
        this.emit())
    }
    gestureStart(Cn) {
        Cn.cancelable && Cn.preventDefault();
        const as = this.state;
        as._active || (this.start(Cn),
        this.computeValues([Cn.scale, Cn.rotation]),
        as.origin = [Cn.clientX, Cn.clientY],
        this.compute(Cn),
        this.emit())
    }
    gestureMove(Cn) {
        if (Cn.cancelable && Cn.preventDefault(),
        !this.state._active)
            return;
        const as = this.state;
        this.computeValues([Cn.scale, Cn.rotation]),
        as.origin = [Cn.clientX, Cn.clientY];
        const cs = as._movement;
        as._movement = [Cn.scale - 1, Cn.rotation],
        as._delta = V$1.sub(as._movement, cs),
        this.compute(Cn),
        this.emit()
    }
    gestureEnd(Cn) {
        this.state._active && (this.state._active = !1,
        this.compute(Cn),
        this.emit())
    }
    wheel(Cn) {
        const as = this.config.modifierKey;
        as && (Array.isArray(as) ? !as.find(cs => Cn[cs]) : !Cn[as]) || (this.state._active ? this.wheelChange(Cn) : this.wheelStart(Cn),
        this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this)))
    }
    wheelStart(Cn) {
        this.start(Cn),
        this.wheelChange(Cn)
    }
    wheelChange(Cn) {
        "uv"in Cn || Cn.cancelable && Cn.preventDefault();
        const cs = this.state;
        cs._delta = [-wheelValues(Cn)[1] / PINCH_WHEEL_RATIO * cs.offset[0], 0],
        V$1.addTo(cs._movement, cs._delta),
        clampStateInternalMovementToBounds(cs),
        this.state.origin = [Cn.clientX, Cn.clientY],
        this.compute(Cn),
        this.emit()
    }
    wheelEnd() {
        this.state._active && (this.state._active = !1,
        this.compute(),
        this.emit())
    }
    bind(Cn) {
        const as = this.config.device;
        as && (Cn(as, "start", this[as + "Start"].bind(this)),
        Cn(as, "change", this[as + "Move"].bind(this)),
        Cn(as, "end", this[as + "End"].bind(this)),
        Cn(as, "cancel", this[as + "End"].bind(this)),
        Cn("lostPointerCapture", "", this[as + "End"].bind(this))),
        this.config.pinchOnWheel && Cn("wheel", "", this.wheel.bind(this), {
            passive: !1
        })
    }
}
const pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
    device(xt, Cn, {shared: as, pointer: {touch: cs=!1}={}}) {
        if (as.target && !SUPPORT.touch && SUPPORT.gesture)
            return "gesture";
        if (SUPPORT.touch && cs)
            return "touch";
        if (SUPPORT.touchscreen) {
            if (SUPPORT.pointer)
                return "pointer";
            if (SUPPORT.touch)
                return "touch"
        }
    },
    bounds(xt, Cn, {scaleBounds: as={}, angleBounds: cs={}}) {
        const Cs = Vs => {
            const Ws = assignDefault(call(as, Vs), {
                min: -1 / 0,
                max: 1 / 0
            });
            return [Ws.min, Ws.max]
        }
          , Ls = Vs => {
            const Ws = assignDefault(call(cs, Vs), {
                min: -1 / 0,
                max: 1 / 0
            });
            return [Ws.min, Ws.max]
        }
        ;
        return typeof as != "function" && typeof cs != "function" ? [Cs(), Ls()] : Vs => [Cs(Vs), Ls(Vs)]
    },
    threshold(xt, Cn, as) {
        return this.lockDirection = as.axis === "lock",
        V$1.toVector(xt, this.lockDirection ? [.1, 3] : 0)
    },
    modifierKey(xt) {
        return xt === void 0 ? "ctrlKey" : xt
    },
    pinchOnWheel(xt=!0) {
        return xt
    }
});
class MoveEngine extends CoordinatesEngine {
    constructor(...Cn) {
        super(...Cn),
        _defineProperty(this, "ingKey", "moving")
    }
    move(Cn) {
        this.config.mouseOnly && Cn.pointerType !== "mouse" || (this.state._active ? this.moveChange(Cn) : this.moveStart(Cn),
        this.timeoutStore.add("moveEnd", this.moveEnd.bind(this)))
    }
    moveStart(Cn) {
        this.start(Cn),
        this.computeValues(pointerValues(Cn)),
        this.compute(Cn),
        this.computeInitial(),
        this.emit()
    }
    moveChange(Cn) {
        if (!this.state._active)
            return;
        const as = pointerValues(Cn)
          , cs = this.state;
        cs._delta = V$1.sub(as, cs._values),
        V$1.addTo(cs._movement, cs._delta),
        this.computeValues(as),
        this.compute(Cn),
        this.emit()
    }
    moveEnd(Cn) {
        this.state._active && (this.state._active = !1,
        this.compute(Cn),
        this.emit())
    }
    bind(Cn) {
        Cn("pointer", "change", this.move.bind(this)),
        Cn("pointer", "leave", this.moveEnd.bind(this))
    }
}
const moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
    mouseOnly: (xt=!0) => xt
});
class ScrollEngine extends CoordinatesEngine {
    constructor(...Cn) {
        super(...Cn),
        _defineProperty(this, "ingKey", "scrolling")
    }
    scroll(Cn) {
        this.state._active || this.start(Cn),
        this.scrollChange(Cn),
        this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this))
    }
    scrollChange(Cn) {
        Cn.cancelable && Cn.preventDefault();
        const as = this.state
          , cs = scrollValues(Cn);
        as._delta = V$1.sub(cs, as._values),
        V$1.addTo(as._movement, as._delta),
        this.computeValues(cs),
        this.compute(Cn),
        this.emit()
    }
    scrollEnd() {
        this.state._active && (this.state._active = !1,
        this.compute(),
        this.emit())
    }
    bind(Cn) {
        Cn("scroll", "", this.scroll.bind(this))
    }
}
const scrollConfigResolver = coordinatesConfigResolver;
class WheelEngine extends CoordinatesEngine {
    constructor(...Cn) {
        super(...Cn),
        _defineProperty(this, "ingKey", "wheeling")
    }
    wheel(Cn) {
        this.state._active || this.start(Cn),
        this.wheelChange(Cn),
        this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this))
    }
    wheelChange(Cn) {
        const as = this.state;
        as._delta = wheelValues(Cn),
        V$1.addTo(as._movement, as._delta),
        clampStateInternalMovementToBounds(as),
        this.compute(Cn),
        this.emit()
    }
    wheelEnd() {
        this.state._active && (this.state._active = !1,
        this.compute(),
        this.emit())
    }
    bind(Cn) {
        Cn("wheel", "", this.wheel.bind(this))
    }
}
const wheelConfigResolver = coordinatesConfigResolver;
class HoverEngine extends CoordinatesEngine {
    constructor(...Cn) {
        super(...Cn),
        _defineProperty(this, "ingKey", "hovering")
    }
    enter(Cn) {
        this.config.mouseOnly && Cn.pointerType !== "mouse" || (this.start(Cn),
        this.computeValues(pointerValues(Cn)),
        this.compute(Cn),
        this.emit())
    }
    leave(Cn) {
        if (this.config.mouseOnly && Cn.pointerType !== "mouse")
            return;
        const as = this.state;
        if (!as._active)
            return;
        as._active = !1;
        const cs = pointerValues(Cn);
        as._movement = as._delta = V$1.sub(cs, as._values),
        this.computeValues(cs),
        this.compute(Cn),
        as.delta = as.movement,
        this.emit()
    }
    bind(Cn) {
        Cn("pointer", "enter", this.enter.bind(this)),
        Cn("pointer", "leave", this.leave.bind(this))
    }
}
const hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
    mouseOnly: (xt=!0) => xt
})
  , EngineMap = new Map
  , ConfigResolverMap = new Map;
function registerAction(xt) {
    EngineMap.set(xt.key, xt.engine),
    ConfigResolverMap.set(xt.key, xt.resolver)
}
const dragAction = {
    key: "drag",
    engine: DragEngine,
    resolver: dragConfigResolver
}
  , hoverAction = {
    key: "hover",
    engine: HoverEngine,
    resolver: hoverConfigResolver
}
  , moveAction = {
    key: "move",
    engine: MoveEngine,
    resolver: moveConfigResolver
}
  , pinchAction = {
    key: "pinch",
    engine: PinchEngine,
    resolver: pinchConfigResolver
}
  , scrollAction = {
    key: "scroll",
    engine: ScrollEngine,
    resolver: scrollConfigResolver
}
  , wheelAction = {
    key: "wheel",
    engine: WheelEngine,
    resolver: wheelConfigResolver
};
function _objectWithoutPropertiesLoose(xt, Cn) {
    if (xt == null)
        return {};
    var as = {}, cs = Object.keys(xt), Cs, Ls;
    for (Ls = 0; Ls < cs.length; Ls++)
        Cs = cs[Ls],
        !(Cn.indexOf(Cs) >= 0) && (as[Cs] = xt[Cs]);
    return as
}
function _objectWithoutProperties(xt, Cn) {
    if (xt == null)
        return {};
    var as = _objectWithoutPropertiesLoose(xt, Cn), cs, Cs;
    if (Object.getOwnPropertySymbols) {
        var Ls = Object.getOwnPropertySymbols(xt);
        for (Cs = 0; Cs < Ls.length; Cs++)
            cs = Ls[Cs],
            !(Cn.indexOf(cs) >= 0) && Object.prototype.propertyIsEnumerable.call(xt, cs) && (as[cs] = xt[cs])
    }
    return as
}
const sharedConfigResolver = {
    target(xt) {
        if (xt)
            return () => "current"in xt ? xt.current : xt
    },
    enabled(xt=!0) {
        return xt
    },
    window(xt=SUPPORT.isBrowser ? window : void 0) {
        return xt
    },
    eventOptions({passive: xt=!0, capture: Cn=!1}={}) {
        return {
            passive: xt,
            capture: Cn
        }
    },
    transform(xt) {
        return xt
    }
}
  , _excluded = ["target", "eventOptions", "window", "enabled", "transform"];
function resolveWith(xt={}, Cn) {
    const as = {};
    for (const [cs,Cs] of Object.entries(Cn))
        switch (typeof Cs) {
        case "function":
            as[cs] = Cs.call(as, xt[cs], cs, xt);
            break;
        case "object":
            as[cs] = resolveWith(xt[cs], Cs);
            break;
        case "boolean":
            Cs && (as[cs] = xt[cs]);
            break
        }
    return as
}
function parse(xt, Cn, as={}) {
    const cs = xt
      , {target: Cs, eventOptions: Ls, window: Vs, enabled: Ws, transform: Xs} = cs
      , ga = _objectWithoutProperties(cs, _excluded);
    if (as.shared = resolveWith({
        target: Cs,
        eventOptions: Ls,
        window: Vs,
        enabled: Ws,
        transform: Xs
    }, sharedConfigResolver),
    Cn) {
        const ba = ConfigResolverMap.get(Cn);
        as[Cn] = resolveWith(_objectSpread2({
            shared: as.shared
        }, ga), ba)
    } else
        for (const ba in ga) {
            const yl = ConfigResolverMap.get(ba);
            yl && (as[ba] = resolveWith(_objectSpread2({
                shared: as.shared
            }, ga[ba]), yl))
        }
    return as
}
class EventStore {
    constructor(Cn, as) {
        _defineProperty(this, "_listeners", new Set),
        this._ctrl = Cn,
        this._gestureKey = as
    }
    add(Cn, as, cs, Cs, Ls) {
        const Vs = this._listeners
          , Ws = toDomEventType(as, cs)
          , Xs = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}
          , ga = _objectSpread2(_objectSpread2({}, Xs), Ls);
        Cn.addEventListener(Ws, Cs, ga);
        const ba = () => {
            Cn.removeEventListener(Ws, Cs, ga),
            Vs.delete(ba)
        }
        ;
        return Vs.add(ba),
        ba
    }
    clean() {
        this._listeners.forEach(Cn => Cn()),
        this._listeners.clear()
    }
}
class TimeoutStore {
    constructor() {
        _defineProperty(this, "_timeouts", new Map)
    }
    add(Cn, as, cs=140, ...Cs) {
        this.remove(Cn),
        this._timeouts.set(Cn, window.setTimeout(as, cs, ...Cs))
    }
    remove(Cn) {
        const as = this._timeouts.get(Cn);
        as && window.clearTimeout(as)
    }
    clean() {
        this._timeouts.forEach(Cn => void window.clearTimeout(Cn)),
        this._timeouts.clear()
    }
}
let Controller$1 = class {
    constructor(Cn) {
        _defineProperty(this, "gestures", new Set),
        _defineProperty(this, "_targetEventStore", new EventStore(this)),
        _defineProperty(this, "gestureEventStores", {}),
        _defineProperty(this, "gestureTimeoutStores", {}),
        _defineProperty(this, "handlers", {}),
        _defineProperty(this, "config", {}),
        _defineProperty(this, "pointerIds", new Set),
        _defineProperty(this, "touchIds", new Set),
        _defineProperty(this, "state", {
            shared: {
                shiftKey: !1,
                metaKey: !1,
                ctrlKey: !1,
                altKey: !1
            }
        }),
        resolveGestures(this, Cn)
    }
    setEventIds(Cn) {
        if (isTouch(Cn))
            return this.touchIds = new Set(touchIds(Cn)),
            this.touchIds;
        if ("pointerId"in Cn)
            return Cn.type === "pointerup" || Cn.type === "pointercancel" ? this.pointerIds.delete(Cn.pointerId) : Cn.type === "pointerdown" && this.pointerIds.add(Cn.pointerId),
            this.pointerIds
    }
    applyHandlers(Cn, as) {
        this.handlers = Cn,
        this.nativeHandlers = as
    }
    applyConfig(Cn, as) {
        this.config = parse(Cn, as, this.config)
    }
    clean() {
        this._targetEventStore.clean();
        for (const Cn of this.gestures)
            this.gestureEventStores[Cn].clean(),
            this.gestureTimeoutStores[Cn].clean()
    }
    effect() {
        return this.config.shared.target && this.bind(),
        () => this._targetEventStore.clean()
    }
    bind(...Cn) {
        const as = this.config.shared
          , cs = {};
        let Cs;
        if (!(as.target && (Cs = as.target(),
        !Cs))) {
            if (as.enabled) {
                for (const Vs of this.gestures) {
                    const Ws = this.config[Vs]
                      , Xs = bindToProps(cs, Ws.eventOptions, !!Cs);
                    if (Ws.enabled) {
                        const ga = EngineMap.get(Vs);
                        new ga(this,Cn,Vs).bind(Xs)
                    }
                }
                const Ls = bindToProps(cs, as.eventOptions, !!Cs);
                for (const Vs in this.nativeHandlers)
                    Ls(Vs, "", Ws => this.nativeHandlers[Vs](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {
                        event: Ws,
                        args: Cn
                    })), void 0, !0)
            }
            for (const Ls in cs)
                cs[Ls] = chain(...cs[Ls]);
            if (!Cs)
                return cs;
            for (const Ls in cs) {
                const {device: Vs, capture: Ws, passive: Xs} = parseProp(Ls);
                this._targetEventStore.add(Cs, Vs, "", cs[Ls], {
                    capture: Ws,
                    passive: Xs
                })
            }
        }
    }
}
;
function setupGesture(xt, Cn) {
    xt.gestures.add(Cn),
    xt.gestureEventStores[Cn] = new EventStore(xt,Cn),
    xt.gestureTimeoutStores[Cn] = new TimeoutStore
}
function resolveGestures(xt, Cn) {
    Cn.drag && setupGesture(xt, "drag"),
    Cn.wheel && setupGesture(xt, "wheel"),
    Cn.scroll && setupGesture(xt, "scroll"),
    Cn.move && setupGesture(xt, "move"),
    Cn.pinch && setupGesture(xt, "pinch"),
    Cn.hover && setupGesture(xt, "hover")
}
const bindToProps = (xt, Cn, as) => (cs, Cs, Ls, Vs={}, Ws=!1) => {
    var Xs, ga;
    const ba = (Xs = Vs.capture) !== null && Xs !== void 0 ? Xs : Cn.capture
      , yl = (ga = Vs.passive) !== null && ga !== void 0 ? ga : Cn.passive;
    let xl = Ws ? cs : toHandlerProp(cs, Cs, ba);
    as && yl && (xl += "Passive"),
    xt[xl] = xt[xl] || [],
    xt[xl].push(Ls)
}
  , RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function sortHandlers(xt) {
    const Cn = {}
      , as = {}
      , cs = new Set;
    for (let Cs in xt)
        RE_NOT_NATIVE.test(Cs) ? (cs.add(RegExp.lastMatch),
        as[Cs] = xt[Cs]) : Cn[Cs] = xt[Cs];
    return [as, Cn, cs]
}
function registerGesture(xt, Cn, as, cs, Cs, Ls) {
    if (!xt.has(as) || !EngineMap.has(cs))
        return;
    const Vs = as + "Start"
      , Ws = as + "End"
      , Xs = ga => {
        let ba;
        return ga.first && Vs in Cn && Cn[Vs](ga),
        as in Cn && (ba = Cn[as](ga)),
        ga.last && Ws in Cn && Cn[Ws](ga),
        ba
    }
    ;
    Cs[cs] = Xs,
    Ls[cs] = Ls[cs] || {}
}
function parseMergedHandlers(xt, Cn) {
    const [as,cs,Cs] = sortHandlers(xt)
      , Ls = {};
    return registerGesture(Cs, as, "onDrag", "drag", Ls, Cn),
    registerGesture(Cs, as, "onWheel", "wheel", Ls, Cn),
    registerGesture(Cs, as, "onScroll", "scroll", Ls, Cn),
    registerGesture(Cs, as, "onPinch", "pinch", Ls, Cn),
    registerGesture(Cs, as, "onMove", "move", Ls, Cn),
    registerGesture(Cs, as, "onHover", "hover", Ls, Cn),
    {
        handlers: Ls,
        config: Cn,
        nativeHandlers: cs
    }
}
function useRecognizers(xt, Cn={}, as, cs) {
    const Cs = React__default.useMemo( () => new Controller$1(xt), []);
    if (Cs.applyHandlers(xt, cs),
    Cs.applyConfig(Cn, as),
    React__default.useEffect(Cs.effect.bind(Cs)),
    React__default.useEffect( () => Cs.clean.bind(Cs), []),
    Cn.target === void 0)
        return Cs.bind.bind(Cs)
}
function createUseGesture(xt) {
    return xt.forEach(registerAction),
    function(as, cs) {
        const {handlers: Cs, nativeHandlers: Ls, config: Vs} = parseMergedHandlers(as, cs || {});
        return useRecognizers(Cs, Vs, void 0, Ls)
    }
}
function useGesture(xt, Cn) {
    return createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction])(xt, Cn || {})
}
const SliderGiftItem = ({gift: xt}) => {
    const {setSelectedGiftForOverview: Cn, addModal: as} = useStorage(Cs => ({
        setSelectedGiftForOverview: Cs.gifts.setSelectedGiftForOverview,
        addModal: Cs.modal.addModal
    }))
      , cs = () => {
        Cn(xt),
        as(ModalNames.GIFT_OVERVIEW)
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$18.sliderGiftItem,
        children: [jsxRuntimeExports.jsx(GiftIcon, {
            gift: xt,
            width: 74,
            height: 74
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$18.sliderGiftItemFooter,
            onClick: cs,
            children: [jsxRuntimeExports.jsx(SvgTonIcon, {}), jsxRuntimeExports.jsx("span", {
                children: formatNanotons(xt.salePrice ?? 0)
            })]
        }), jsxRuntimeExports.jsx("img", {
            className: styles$18.sliderGiftItemHotRibbon,
            src: "/images/common/ribbon.png",
            alt: ""
        })]
    })
}
  , INTERACTION_TIMEOUT = 3e3
  , PromotedGiftsSlider = ({promotedItems: xt}) => {
    const Cn = reactExports.useRef(null)
      , [as,cs] = reactExports.useState(null)
      , [Cs,Ls] = reactExports.useState(0)
      , [Vs,{open: Ws, close: Xs}] = useDisclosure(!0)
      , {start: ga, clear: ba} = useTimeout(Ws, INTERACTION_TIMEOUT)
      , {setupResizeListener: yl, isResizeListenerSetup: xl} = useStorage(Cl => ({
        setupResizeListener: Cl.promotions.setupResizeListener,
        isResizeListenerSetup: Cl.promotions.isResizeListenerSetup
    }));
    reactExports.useEffect( () => {
        xl || yl()
    }
    , [yl, xl]),
    reactExports.useEffect( () => {
        if (!as)
            return;
        const Cl = $l => {
            $l.preventDefault(),
            as.scrollLeft += $l.deltaY / 2
        }
        ;
        return as.addEventListener("wheel", Cl),
        () => {
            as && as.removeEventListener("wheel", Cl)
        }
    }
    , [as]);
    const wl = () => {
        ba(),
        Xs()
    }
      , _l = useGesture({
        onMouseEnter: wl,
        onTouchStart: wl,
        onTouchMove: wl,
        onScroll: wl,
        onDrag: ({movement: [Cl], down: $l}) => {
            wl(),
            as && $l && (as.scrollLeft -= Cl / 20)
        }
        ,
        onMouseLeave: ga,
        onTouchEnd: ga,
        onDragEnd: ga
    }, {
        drag: {
            filterTaps: !0,
            rubberband: !0
        }
    });
    useAnimationFrame( (Cl, $l) => {
        as && Vs && Ls(Sl => Sl >= 1 ? (as.scrollLeft += Sl,
        $l / 20) : Sl + $l / 20)
    }
    );
    const El = reactExports.useCallback( (Cl, $l) => jsxRuntimeExports.jsx("div", {
        className: styles$18.giftContainer,
        children: jsxRuntimeExports.jsx(SliderGiftItem, {
            gift: $l
        })
    }), []);
    return jsxRuntimeExports.jsx("div", {
        ..._l(),
        className: styles$18.promotedGiftsSlider,
        "data-mounted": !0,
        children: jsxRuntimeExports.jsx(Kr, {
            scrollerRef: Cl => {
                cs(Cl)
            }
            ,
            ref: Cn,
            data: xt,
            className: styles$18.virtualList,
            horizontalDirection: !0,
            increaseViewportBy: {
                top: 200,
                bottom: 200
            },
            itemContent: El
        })
    })
}
;
var fastDeepEqual = function xt(Cn, as) {
    if (Cn === as)
        return !0;
    if (Cn && as && typeof Cn == "object" && typeof as == "object") {
        if (Cn.constructor !== as.constructor)
            return !1;
        var cs, Cs, Ls;
        if (Array.isArray(Cn)) {
            if (cs = Cn.length,
            cs != as.length)
                return !1;
            for (Cs = cs; Cs-- !== 0; )
                if (!xt(Cn[Cs], as[Cs]))
                    return !1;
            return !0
        }
        if (Cn.constructor === RegExp)
            return Cn.source === as.source && Cn.flags === as.flags;
        if (Cn.valueOf !== Object.prototype.valueOf)
            return Cn.valueOf() === as.valueOf();
        if (Cn.toString !== Object.prototype.toString)
            return Cn.toString() === as.toString();
        if (Ls = Object.keys(Cn),
        cs = Ls.length,
        cs !== Object.keys(as).length)
            return !1;
        for (Cs = cs; Cs-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(as, Ls[Cs]))
                return !1;
        for (Cs = cs; Cs-- !== 0; ) {
            var Vs = Ls[Cs];
            if (!xt(Cn[Vs], as[Vs]))
                return !1
        }
        return !0
    }
    return Cn !== Cn && as !== as
};
const deepEqual$1 = getDefaultExportFromCjs(fastDeepEqual)
  , getDefaultFiltersRequest = () => ({
    ...baseFilterValue,
    ordering: GiftOrdering.None,
    lowToHigh: !1,
    query: null,
    promotedFirst: !1
})
  , isDefaultFilters = xt => {
    const Cn = getDefaultFiltersRequest()
      , as = {};
    for (const Vs of Object.keys(xt))
        Vs in Cn && (as[Vs] = Cn[Vs]);
    for (const [Vs,Ws] of Object.entries(xt))
        if (Array.isArray(Ws) && Ws.length > 0)
            return !1;
    const cs = {
        ...xt
    }
      , Cs = {
        ...as
    };
    for (const Vs of Object.keys(cs))
        Array.isArray(cs[Vs]) && (delete cs[Vs],
        delete Cs[Vs]);
    return delete cs.promotedFirst,
    delete Cs.promotedFirst,
    deepEqual$1(cs, Cs)
}
  , promotionsInfiniteQueryOptions = (xt, Cn) => ({
    queryKey: [QueryKeys.promotions, xt],
    queryFn: async ({pageParam: as=0}) => {
        if (as === 0 && isDefaultFilters(xt)) {
            const cs = await prefetchInitialPromotions();
            return store.setState(Cs => ({
                promotions: {
                    ...Cs.promotions,
                    prefetchedPromotions: cs
                }
            })),
            cs
        }
        return fetchPromotions(as, xt)
    }
    ,
    getNextPageParam: (as, cs) => {
        if (!(as.length < DEFAULT_PROMOTIONS_PAGE_SIZE))
            return cs.length
    }
    ,
    initialPageParam: 0,
    enabled: Cn,
    placeholderData: keepPreviousData,
    initialData: () => {
        const as = store.getState().promotions.prefetchedPromotions;
        if (as.length > 0 && isDefaultFilters(xt))
            return {
                pages: [as],
                pageParams: [0]
            }
    }
});
var util;
(function(xt) {
    xt.assertEqual = Cs => Cs;
    function Cn(Cs) {}
    xt.assertIs = Cn;
    function as(Cs) {
        throw new Error
    }
    xt.assertNever = as,
    xt.arrayToEnum = Cs => {
        const Ls = {};
        for (const Vs of Cs)
            Ls[Vs] = Vs;
        return Ls
    }
    ,
    xt.getValidEnumValues = Cs => {
        const Ls = xt.objectKeys(Cs).filter(Ws => typeof Cs[Cs[Ws]] != "number")
          , Vs = {};
        for (const Ws of Ls)
            Vs[Ws] = Cs[Ws];
        return xt.objectValues(Vs)
    }
    ,
    xt.objectValues = Cs => xt.objectKeys(Cs).map(function(Ls) {
        return Cs[Ls]
    }),
    xt.objectKeys = typeof Object.keys == "function" ? Cs => Object.keys(Cs) : Cs => {
        const Ls = [];
        for (const Vs in Cs)
            Object.prototype.hasOwnProperty.call(Cs, Vs) && Ls.push(Vs);
        return Ls
    }
    ,
    xt.find = (Cs, Ls) => {
        for (const Vs of Cs)
            if (Ls(Vs))
                return Vs
    }
    ,
    xt.isInteger = typeof Number.isInteger == "function" ? Cs => Number.isInteger(Cs) : Cs => typeof Cs == "number" && isFinite(Cs) && Math.floor(Cs) === Cs;
    function cs(Cs, Ls=" | ") {
        return Cs.map(Vs => typeof Vs == "string" ? `'${Vs}'` : Vs).join(Ls)
    }
    xt.joinValues = cs,
    xt.jsonStringifyReplacer = (Cs, Ls) => typeof Ls == "bigint" ? Ls.toString() : Ls
}
)(util || (util = {}));
var objectUtil;
(function(xt) {
    xt.mergeShapes = (Cn, as) => ({
        ...Cn,
        ...as
    })
}
)(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"])
  , getParsedType = xt => {
    switch (typeof xt) {
    case "undefined":
        return ZodParsedType.undefined;
    case "string":
        return ZodParsedType.string;
    case "number":
        return isNaN(xt) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
        return ZodParsedType.boolean;
    case "function":
        return ZodParsedType.function;
    case "bigint":
        return ZodParsedType.bigint;
    case "symbol":
        return ZodParsedType.symbol;
    case "object":
        return Array.isArray(xt) ? ZodParsedType.array : xt === null ? ZodParsedType.null : xt.then && typeof xt.then == "function" && xt.catch && typeof xt.catch == "function" ? ZodParsedType.promise : typeof Map < "u" && xt instanceof Map ? ZodParsedType.map : typeof Set < "u" && xt instanceof Set ? ZodParsedType.set : typeof Date < "u" && xt instanceof Date ? ZodParsedType.date : ZodParsedType.object;
    default:
        return ZodParsedType.unknown
    }
}
  , ZodIssueCode = util.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"])
  , quotelessJson = xt => JSON.stringify(xt, null, 2).replace(/"([^"]+)":/g, "$1:");
class ZodError extends Error {
    get errors() {
        return this.issues
    }
    constructor(Cn) {
        super(),
        this.issues = [],
        this.addIssue = cs => {
            this.issues = [...this.issues, cs]
        }
        ,
        this.addIssues = (cs=[]) => {
            this.issues = [...this.issues, ...cs]
        }
        ;
        const as = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, as) : this.__proto__ = as,
        this.name = "ZodError",
        this.issues = Cn
    }
    format(Cn) {
        const as = Cn || function(Ls) {
            return Ls.message
        }
          , cs = {
            _errors: []
        }
          , Cs = Ls => {
            for (const Vs of Ls.issues)
                if (Vs.code === "invalid_union")
                    Vs.unionErrors.map(Cs);
                else if (Vs.code === "invalid_return_type")
                    Cs(Vs.returnTypeError);
                else if (Vs.code === "invalid_arguments")
                    Cs(Vs.argumentsError);
                else if (Vs.path.length === 0)
                    cs._errors.push(as(Vs));
                else {
                    let Ws = cs
                      , Xs = 0;
                    for (; Xs < Vs.path.length; ) {
                        const ga = Vs.path[Xs];
                        Xs === Vs.path.length - 1 ? (Ws[ga] = Ws[ga] || {
                            _errors: []
                        },
                        Ws[ga]._errors.push(as(Vs))) : Ws[ga] = Ws[ga] || {
                            _errors: []
                        },
                        Ws = Ws[ga],
                        Xs++
                    }
                }
        }
        ;
        return Cs(this),
        cs
    }
    static assert(Cn) {
        if (!(Cn instanceof ZodError))
            throw new Error(`Not a ZodError: ${Cn}`)
    }
    toString() {
        return this.message
    }
    get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2)
    }
    get isEmpty() {
        return this.issues.length === 0
    }
    flatten(Cn=as => as.message) {
        const as = {}
          , cs = [];
        for (const Cs of this.issues)
            Cs.path.length > 0 ? (as[Cs.path[0]] = as[Cs.path[0]] || [],
            as[Cs.path[0]].push(Cn(Cs))) : cs.push(Cn(Cs));
        return {
            formErrors: cs,
            fieldErrors: as
        }
    }
    get formErrors() {
        return this.flatten()
    }
}
ZodError.create = xt => new ZodError(xt);
const errorMap = (xt, Cn) => {
    let as;
    switch (xt.code) {
    case ZodIssueCode.invalid_type:
        xt.received === ZodParsedType.undefined ? as = "Required" : as = `Expected ${xt.expected}, received ${xt.received}`;
        break;
    case ZodIssueCode.invalid_literal:
        as = `Invalid literal value, expected ${JSON.stringify(xt.expected, util.jsonStringifyReplacer)}`;
        break;
    case ZodIssueCode.unrecognized_keys:
        as = `Unrecognized key(s) in object: ${util.joinValues(xt.keys, ", ")}`;
        break;
    case ZodIssueCode.invalid_union:
        as = "Invalid input";
        break;
    case ZodIssueCode.invalid_union_discriminator:
        as = `Invalid discriminator value. Expected ${util.joinValues(xt.options)}`;
        break;
    case ZodIssueCode.invalid_enum_value:
        as = `Invalid enum value. Expected ${util.joinValues(xt.options)}, received '${xt.received}'`;
        break;
    case ZodIssueCode.invalid_arguments:
        as = "Invalid function arguments";
        break;
    case ZodIssueCode.invalid_return_type:
        as = "Invalid function return type";
        break;
    case ZodIssueCode.invalid_date:
        as = "Invalid date";
        break;
    case ZodIssueCode.invalid_string:
        typeof xt.validation == "object" ? "includes"in xt.validation ? (as = `Invalid input: must include "${xt.validation.includes}"`,
        typeof xt.validation.position == "number" && (as = `${as} at one or more positions greater than or equal to ${xt.validation.position}`)) : "startsWith"in xt.validation ? as = `Invalid input: must start with "${xt.validation.startsWith}"` : "endsWith"in xt.validation ? as = `Invalid input: must end with "${xt.validation.endsWith}"` : util.assertNever(xt.validation) : xt.validation !== "regex" ? as = `Invalid ${xt.validation}` : as = "Invalid";
        break;
    case ZodIssueCode.too_small:
        xt.type === "array" ? as = `Array must contain ${xt.exact ? "exactly" : xt.inclusive ? "at least" : "more than"} ${xt.minimum} element(s)` : xt.type === "string" ? as = `String must contain ${xt.exact ? "exactly" : xt.inclusive ? "at least" : "over"} ${xt.minimum} character(s)` : xt.type === "number" ? as = `Number must be ${xt.exact ? "exactly equal to " : xt.inclusive ? "greater than or equal to " : "greater than "}${xt.minimum}` : xt.type === "date" ? as = `Date must be ${xt.exact ? "exactly equal to " : xt.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(xt.minimum))}` : as = "Invalid input";
        break;
    case ZodIssueCode.too_big:
        xt.type === "array" ? as = `Array must contain ${xt.exact ? "exactly" : xt.inclusive ? "at most" : "less than"} ${xt.maximum} element(s)` : xt.type === "string" ? as = `String must contain ${xt.exact ? "exactly" : xt.inclusive ? "at most" : "under"} ${xt.maximum} character(s)` : xt.type === "number" ? as = `Number must be ${xt.exact ? "exactly" : xt.inclusive ? "less than or equal to" : "less than"} ${xt.maximum}` : xt.type === "bigint" ? as = `BigInt must be ${xt.exact ? "exactly" : xt.inclusive ? "less than or equal to" : "less than"} ${xt.maximum}` : xt.type === "date" ? as = `Date must be ${xt.exact ? "exactly" : xt.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(xt.maximum))}` : as = "Invalid input";
        break;
    case ZodIssueCode.custom:
        as = "Invalid input";
        break;
    case ZodIssueCode.invalid_intersection_types:
        as = "Intersection results could not be merged";
        break;
    case ZodIssueCode.not_multiple_of:
        as = `Number must be a multiple of ${xt.multipleOf}`;
        break;
    case ZodIssueCode.not_finite:
        as = "Number must be finite";
        break;
    default:
        as = Cn.defaultError,
        util.assertNever(xt)
    }
    return {
        message: as
    }
}
;
let overrideErrorMap = errorMap;
function setErrorMap(xt) {
    overrideErrorMap = xt
}
function getErrorMap() {
    return overrideErrorMap
}
const makeIssue = xt => {
    const {data: Cn, path: as, errorMaps: cs, issueData: Cs} = xt
      , Ls = [...as, ...Cs.path || []]
      , Vs = {
        ...Cs,
        path: Ls
    };
    if (Cs.message !== void 0)
        return {
            ...Cs,
            path: Ls,
            message: Cs.message
        };
    let Ws = "";
    const Xs = cs.filter(ga => !!ga).slice().reverse();
    for (const ga of Xs)
        Ws = ga(Vs, {
            data: Cn,
            defaultError: Ws
        }).message;
    return {
        ...Cs,
        path: Ls,
        message: Ws
    }
}
  , EMPTY_PATH = [];
function addIssueToContext(xt, Cn) {
    const as = getErrorMap()
      , cs = makeIssue({
        issueData: Cn,
        data: xt.data,
        path: xt.path,
        errorMaps: [xt.common.contextualErrorMap, xt.schemaErrorMap, as, as === errorMap ? void 0 : errorMap].filter(Cs => !!Cs)
    });
    xt.common.issues.push(cs)
}
class ParseStatus {
    constructor() {
        this.value = "valid"
    }
    dirty() {
        this.value === "valid" && (this.value = "dirty")
    }
    abort() {
        this.value !== "aborted" && (this.value = "aborted")
    }
    static mergeArray(Cn, as) {
        const cs = [];
        for (const Cs of as) {
            if (Cs.status === "aborted")
                return INVALID;
            Cs.status === "dirty" && Cn.dirty(),
            cs.push(Cs.value)
        }
        return {
            status: Cn.value,
            value: cs
        }
    }
    static async mergeObjectAsync(Cn, as) {
        const cs = [];
        for (const Cs of as) {
            const Ls = await Cs.key
              , Vs = await Cs.value;
            cs.push({
                key: Ls,
                value: Vs
            })
        }
        return ParseStatus.mergeObjectSync(Cn, cs)
    }
    static mergeObjectSync(Cn, as) {
        const cs = {};
        for (const Cs of as) {
            const {key: Ls, value: Vs} = Cs;
            if (Ls.status === "aborted" || Vs.status === "aborted")
                return INVALID;
            Ls.status === "dirty" && Cn.dirty(),
            Vs.status === "dirty" && Cn.dirty(),
            Ls.value !== "__proto__" && (typeof Vs.value < "u" || Cs.alwaysSet) && (cs[Ls.value] = Vs.value)
        }
        return {
            status: Cn.value,
            value: cs
        }
    }
}
const INVALID = Object.freeze({
    status: "aborted"
})
  , DIRTY = xt => ({
    status: "dirty",
    value: xt
})
  , OK = xt => ({
    status: "valid",
    value: xt
})
  , isAborted = xt => xt.status === "aborted"
  , isDirty = xt => xt.status === "dirty"
  , isValid = xt => xt.status === "valid"
  , isAsync = xt => typeof Promise < "u" && xt instanceof Promise;
function __classPrivateFieldGet(xt, Cn, as, cs) {
    if (typeof Cn == "function" ? xt !== Cn || !0 : !Cn.has(xt))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return Cn.get(xt)
}
function __classPrivateFieldSet(xt, Cn, as, cs, Cs) {
    if (typeof Cn == "function" ? xt !== Cn || !0 : !Cn.has(xt))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return Cn.set(xt, as),
    as
}
typeof SuppressedError == "function" && SuppressedError;
var errorUtil;
(function(xt) {
    xt.errToObj = Cn => typeof Cn == "string" ? {
        message: Cn
    } : Cn || {},
    xt.toString = Cn => typeof Cn == "string" ? Cn : Cn == null ? void 0 : Cn.message
}
)(errorUtil || (errorUtil = {}));
var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
    constructor(Cn, as, cs, Cs) {
        this._cachedPath = [],
        this.parent = Cn,
        this.data = as,
        this._path = cs,
        this._key = Cs
    }
    get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)),
        this._cachedPath
    }
}
const handleResult = (xt, Cn) => {
    if (isValid(Cn))
        return {
            success: !0,
            data: Cn.value
        };
    if (!xt.common.issues.length)
        throw new Error("Validation failed but no issues detected.");
    return {
        success: !1,
        get error() {
            if (this._error)
                return this._error;
            const as = new ZodError(xt.common.issues);
            return this._error = as,
            this._error
        }
    }
}
;
function processCreateParams(xt) {
    if (!xt)
        return {};
    const {errorMap: Cn, invalid_type_error: as, required_error: cs, description: Cs} = xt;
    if (Cn && (as || cs))
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return Cn ? {
        errorMap: Cn,
        description: Cs
    } : {
        errorMap: (Vs, Ws) => {
            var Xs, ga;
            const {message: ba} = xt;
            return Vs.code === "invalid_enum_value" ? {
                message: ba ?? Ws.defaultError
            } : typeof Ws.data > "u" ? {
                message: (Xs = ba ?? cs) !== null && Xs !== void 0 ? Xs : Ws.defaultError
            } : Vs.code !== "invalid_type" ? {
                message: Ws.defaultError
            } : {
                message: (ga = ba ?? as) !== null && ga !== void 0 ? ga : Ws.defaultError
            }
        }
        ,
        description: Cs
    }
}
class ZodType {
    get description() {
        return this._def.description
    }
    _getType(Cn) {
        return getParsedType(Cn.data)
    }
    _getOrReturnCtx(Cn, as) {
        return as || {
            common: Cn.parent.common,
            data: Cn.data,
            parsedType: getParsedType(Cn.data),
            schemaErrorMap: this._def.errorMap,
            path: Cn.path,
            parent: Cn.parent
        }
    }
    _processInputParams(Cn) {
        return {
            status: new ParseStatus,
            ctx: {
                common: Cn.parent.common,
                data: Cn.data,
                parsedType: getParsedType(Cn.data),
                schemaErrorMap: this._def.errorMap,
                path: Cn.path,
                parent: Cn.parent
            }
        }
    }
    _parseSync(Cn) {
        const as = this._parse(Cn);
        if (isAsync(as))
            throw new Error("Synchronous parse encountered promise.");
        return as
    }
    _parseAsync(Cn) {
        const as = this._parse(Cn);
        return Promise.resolve(as)
    }
    parse(Cn, as) {
        const cs = this.safeParse(Cn, as);
        if (cs.success)
            return cs.data;
        throw cs.error
    }
    safeParse(Cn, as) {
        var cs;
        const Cs = {
            common: {
                issues: [],
                async: (cs = as == null ? void 0 : as.async) !== null && cs !== void 0 ? cs : !1,
                contextualErrorMap: as == null ? void 0 : as.errorMap
            },
            path: (as == null ? void 0 : as.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: Cn,
            parsedType: getParsedType(Cn)
        }
          , Ls = this._parseSync({
            data: Cn,
            path: Cs.path,
            parent: Cs
        });
        return handleResult(Cs, Ls)
    }
    "~validate"(Cn) {
        var as, cs;
        const Cs = {
            common: {
                issues: [],
                async: !!this["~standard"].async
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: Cn,
            parsedType: getParsedType(Cn)
        };
        if (!this["~standard"].async)
            try {
                const Ls = this._parseSync({
                    data: Cn,
                    path: [],
                    parent: Cs
                });
                return isValid(Ls) ? {
                    value: Ls.value
                } : {
                    issues: Cs.common.issues
                }
            } catch (Ls) {
                !((cs = (as = Ls == null ? void 0 : Ls.message) === null || as === void 0 ? void 0 : as.toLowerCase()) === null || cs === void 0) && cs.includes("encountered") && (this["~standard"].async = !0),
                Cs.common = {
                    issues: [],
                    async: !0
                }
            }
        return this._parseAsync({
            data: Cn,
            path: [],
            parent: Cs
        }).then(Ls => isValid(Ls) ? {
            value: Ls.value
        } : {
            issues: Cs.common.issues
        })
    }
    async parseAsync(Cn, as) {
        const cs = await this.safeParseAsync(Cn, as);
        if (cs.success)
            return cs.data;
        throw cs.error
    }
    async safeParseAsync(Cn, as) {
        const cs = {
            common: {
                issues: [],
                contextualErrorMap: as == null ? void 0 : as.errorMap,
                async: !0
            },
            path: (as == null ? void 0 : as.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: Cn,
            parsedType: getParsedType(Cn)
        }
          , Cs = this._parse({
            data: Cn,
            path: cs.path,
            parent: cs
        })
          , Ls = await (isAsync(Cs) ? Cs : Promise.resolve(Cs));
        return handleResult(cs, Ls)
    }
    refine(Cn, as) {
        const cs = Cs => typeof as == "string" || typeof as > "u" ? {
            message: as
        } : typeof as == "function" ? as(Cs) : as;
        return this._refinement( (Cs, Ls) => {
            const Vs = Cn(Cs)
              , Ws = () => Ls.addIssue({
                code: ZodIssueCode.custom,
                ...cs(Cs)
            });
            return typeof Promise < "u" && Vs instanceof Promise ? Vs.then(Xs => Xs ? !0 : (Ws(),
            !1)) : Vs ? !0 : (Ws(),
            !1)
        }
        )
    }
    refinement(Cn, as) {
        return this._refinement( (cs, Cs) => Cn(cs) ? !0 : (Cs.addIssue(typeof as == "function" ? as(cs, Cs) : as),
        !1))
    }
    _refinement(Cn) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: {
                type: "refinement",
                refinement: Cn
            }
        })
    }
    superRefine(Cn) {
        return this._refinement(Cn)
    }
    constructor(Cn) {
        this.spa = this.safeParseAsync,
        this._def = Cn,
        this.parse = this.parse.bind(this),
        this.safeParse = this.safeParse.bind(this),
        this.parseAsync = this.parseAsync.bind(this),
        this.safeParseAsync = this.safeParseAsync.bind(this),
        this.spa = this.spa.bind(this),
        this.refine = this.refine.bind(this),
        this.refinement = this.refinement.bind(this),
        this.superRefine = this.superRefine.bind(this),
        this.optional = this.optional.bind(this),
        this.nullable = this.nullable.bind(this),
        this.nullish = this.nullish.bind(this),
        this.array = this.array.bind(this),
        this.promise = this.promise.bind(this),
        this.or = this.or.bind(this),
        this.and = this.and.bind(this),
        this.transform = this.transform.bind(this),
        this.brand = this.brand.bind(this),
        this.default = this.default.bind(this),
        this.catch = this.catch.bind(this),
        this.describe = this.describe.bind(this),
        this.pipe = this.pipe.bind(this),
        this.readonly = this.readonly.bind(this),
        this.isNullable = this.isNullable.bind(this),
        this.isOptional = this.isOptional.bind(this),
        this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: as => this["~validate"](as)
        }
    }
    optional() {
        return ZodOptional.create(this, this._def)
    }
    nullable() {
        return ZodNullable.create(this, this._def)
    }
    nullish() {
        return this.nullable().optional()
    }
    array() {
        return ZodArray.create(this)
    }
    promise() {
        return ZodPromise.create(this, this._def)
    }
    or(Cn) {
        return ZodUnion.create([this, Cn], this._def)
    }
    and(Cn) {
        return ZodIntersection.create(this, Cn, this._def)
    }
    transform(Cn) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: {
                type: "transform",
                transform: Cn
            }
        })
    }
    default(Cn) {
        const as = typeof Cn == "function" ? Cn : () => Cn;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: as,
            typeName: ZodFirstPartyTypeKind.ZodDefault
        })
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def)
        })
    }
    catch(Cn) {
        const as = typeof Cn == "function" ? Cn : () => Cn;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: as,
            typeName: ZodFirstPartyTypeKind.ZodCatch
        })
    }
    describe(Cn) {
        const as = this.constructor;
        return new as({
            ...this._def,
            description: Cn
        })
    }
    pipe(Cn) {
        return ZodPipeline.create(this, Cn)
    }
    readonly() {
        return ZodReadonly.create(this)
    }
    isOptional() {
        return this.safeParse(void 0).success
    }
    isNullable() {
        return this.safeParse(null).success
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i
  , cuid2Regex = /^[0-9a-z]+$/
  , ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i
  , uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i
  , nanoidRegex = /^[a-z0-9_-]{21}$/i
  , jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
  , durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/
  , emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i
  , _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/
  , ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/
  , ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/
  , ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/
  , base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/
  , base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/
  , dateRegexSource = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))"
  , dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(xt) {
    let Cn = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return xt.precision ? Cn = `${Cn}\\.\\d{${xt.precision}}` : xt.precision == null && (Cn = `${Cn}(\\.\\d+)?`),
    Cn
}
function timeRegex(xt) {
    return new RegExp(`^${timeRegexSource(xt)}$`)
}
function datetimeRegex(xt) {
    let Cn = `${dateRegexSource}T${timeRegexSource(xt)}`;
    const as = [];
    return as.push(xt.local ? "Z?" : "Z"),
    xt.offset && as.push("([+-]\\d{2}:?\\d{2})"),
    Cn = `${Cn}(${as.join("|")})`,
    new RegExp(`^${Cn}$`)
}
function isValidIP(xt, Cn) {
    return !!((Cn === "v4" || !Cn) && ipv4Regex.test(xt) || (Cn === "v6" || !Cn) && ipv6Regex.test(xt))
}
function isValidJWT(xt, Cn) {
    if (!jwtRegex.test(xt))
        return !1;
    try {
        const [as] = xt.split(".")
          , cs = as.replace(/-/g, "+").replace(/_/g, "/").padEnd(as.length + (4 - as.length % 4) % 4, "=")
          , Cs = JSON.parse(atob(cs));
        return !(typeof Cs != "object" || Cs === null || !Cs.typ || !Cs.alg || Cn && Cs.alg !== Cn)
    } catch {
        return !1
    }
}
function isValidCidr(xt, Cn) {
    return !!((Cn === "v4" || !Cn) && ipv4CidrRegex.test(xt) || (Cn === "v6" || !Cn) && ipv6CidrRegex.test(xt))
}
class ZodString extends ZodType {
    _parse(Cn) {
        if (this._def.coerce && (Cn.data = String(Cn.data)),
        this._getType(Cn) !== ZodParsedType.string) {
            const Ls = this._getOrReturnCtx(Cn);
            return addIssueToContext(Ls, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: Ls.parsedType
            }),
            INVALID
        }
        const cs = new ParseStatus;
        let Cs;
        for (const Ls of this._def.checks)
            if (Ls.kind === "min")
                Cn.data.length < Ls.value && (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    code: ZodIssueCode.too_small,
                    minimum: Ls.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: Ls.message
                }),
                cs.dirty());
            else if (Ls.kind === "max")
                Cn.data.length > Ls.value && (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    code: ZodIssueCode.too_big,
                    maximum: Ls.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: Ls.message
                }),
                cs.dirty());
            else if (Ls.kind === "length") {
                const Vs = Cn.data.length > Ls.value
                  , Ws = Cn.data.length < Ls.value;
                (Vs || Ws) && (Cs = this._getOrReturnCtx(Cn, Cs),
                Vs ? addIssueToContext(Cs, {
                    code: ZodIssueCode.too_big,
                    maximum: Ls.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: Ls.message
                }) : Ws && addIssueToContext(Cs, {
                    code: ZodIssueCode.too_small,
                    minimum: Ls.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: Ls.message
                }),
                cs.dirty())
            } else if (Ls.kind === "email")
                emailRegex.test(Cn.data) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    validation: "email",
                    code: ZodIssueCode.invalid_string,
                    message: Ls.message
                }),
                cs.dirty());
            else if (Ls.kind === "emoji")
                emojiRegex || (emojiRegex = new RegExp(_emojiRegex,"u")),
                emojiRegex.test(Cn.data) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    validation: "emoji",
                    code: ZodIssueCode.invalid_string,
                    message: Ls.message
                }),
                cs.dirty());
            else if (Ls.kind === "uuid")
                uuidRegex.test(Cn.data) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    validation: "uuid",
                    code: ZodIssueCode.invalid_string,
                    message: Ls.message
                }),
                cs.dirty());
            else if (Ls.kind === "nanoid")
                nanoidRegex.test(Cn.data) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    validation: "nanoid",
                    code: ZodIssueCode.invalid_string,
                    message: Ls.message
                }),
                cs.dirty());
            else if (Ls.kind === "cuid")
                cuidRegex.test(Cn.data) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    validation: "cuid",
                    code: ZodIssueCode.invalid_string,
                    message: Ls.message
                }),
                cs.dirty());
            else if (Ls.kind === "cuid2")
                cuid2Regex.test(Cn.data) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    validation: "cuid2",
                    code: ZodIssueCode.invalid_string,
                    message: Ls.message
                }),
                cs.dirty());
            else if (Ls.kind === "ulid")
                ulidRegex.test(Cn.data) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    validation: "ulid",
                    code: ZodIssueCode.invalid_string,
                    message: Ls.message
                }),
                cs.dirty());
            else if (Ls.kind === "url")
                try {
                    new URL(Cn.data)
                } catch {
                    Cs = this._getOrReturnCtx(Cn, Cs),
                    addIssueToContext(Cs, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: Ls.message
                    }),
                    cs.dirty()
                }
            else
                Ls.kind === "regex" ? (Ls.regex.lastIndex = 0,
                Ls.regex.test(Cn.data) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    validation: "regex",
                    code: ZodIssueCode.invalid_string,
                    message: Ls.message
                }),
                cs.dirty())) : Ls.kind === "trim" ? Cn.data = Cn.data.trim() : Ls.kind === "includes" ? Cn.data.includes(Ls.value, Ls.position) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    code: ZodIssueCode.invalid_string,
                    validation: {
                        includes: Ls.value,
                        position: Ls.position
                    },
                    message: Ls.message
                }),
                cs.dirty()) : Ls.kind === "toLowerCase" ? Cn.data = Cn.data.toLowerCase() : Ls.kind === "toUpperCase" ? Cn.data = Cn.data.toUpperCase() : Ls.kind === "startsWith" ? Cn.data.startsWith(Ls.value) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    code: ZodIssueCode.invalid_string,
                    validation: {
                        startsWith: Ls.value
                    },
                    message: Ls.message
                }),
                cs.dirty()) : Ls.kind === "endsWith" ? Cn.data.endsWith(Ls.value) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    code: ZodIssueCode.invalid_string,
                    validation: {
                        endsWith: Ls.value
                    },
                    message: Ls.message
                }),
                cs.dirty()) : Ls.kind === "datetime" ? datetimeRegex(Ls).test(Cn.data) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    code: ZodIssueCode.invalid_string,
                    validation: "datetime",
                    message: Ls.message
                }),
                cs.dirty()) : Ls.kind === "date" ? dateRegex.test(Cn.data) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    code: ZodIssueCode.invalid_string,
                    validation: "date",
                    message: Ls.message
                }),
                cs.dirty()) : Ls.kind === "time" ? timeRegex(Ls).test(Cn.data) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    code: ZodIssueCode.invalid_string,
                    validation: "time",
                    message: Ls.message
                }),
                cs.dirty()) : Ls.kind === "duration" ? durationRegex.test(Cn.data) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    validation: "duration",
                    code: ZodIssueCode.invalid_string,
                    message: Ls.message
                }),
                cs.dirty()) : Ls.kind === "ip" ? isValidIP(Cn.data, Ls.version) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    validation: "ip",
                    code: ZodIssueCode.invalid_string,
                    message: Ls.message
                }),
                cs.dirty()) : Ls.kind === "jwt" ? isValidJWT(Cn.data, Ls.alg) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    validation: "jwt",
                    code: ZodIssueCode.invalid_string,
                    message: Ls.message
                }),
                cs.dirty()) : Ls.kind === "cidr" ? isValidCidr(Cn.data, Ls.version) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    validation: "cidr",
                    code: ZodIssueCode.invalid_string,
                    message: Ls.message
                }),
                cs.dirty()) : Ls.kind === "base64" ? base64Regex.test(Cn.data) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    validation: "base64",
                    code: ZodIssueCode.invalid_string,
                    message: Ls.message
                }),
                cs.dirty()) : Ls.kind === "base64url" ? base64urlRegex.test(Cn.data) || (Cs = this._getOrReturnCtx(Cn, Cs),
                addIssueToContext(Cs, {
                    validation: "base64url",
                    code: ZodIssueCode.invalid_string,
                    message: Ls.message
                }),
                cs.dirty()) : util.assertNever(Ls);
        return {
            status: cs.value,
            value: Cn.data
        }
    }
    _regex(Cn, as, cs) {
        return this.refinement(Cs => Cn.test(Cs), {
            validation: as,
            code: ZodIssueCode.invalid_string,
            ...errorUtil.errToObj(cs)
        })
    }
    _addCheck(Cn) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, Cn]
        })
    }
    email(Cn) {
        return this._addCheck({
            kind: "email",
            ...errorUtil.errToObj(Cn)
        })
    }
    url(Cn) {
        return this._addCheck({
            kind: "url",
            ...errorUtil.errToObj(Cn)
        })
    }
    emoji(Cn) {
        return this._addCheck({
            kind: "emoji",
            ...errorUtil.errToObj(Cn)
        })
    }
    uuid(Cn) {
        return this._addCheck({
            kind: "uuid",
            ...errorUtil.errToObj(Cn)
        })
    }
    nanoid(Cn) {
        return this._addCheck({
            kind: "nanoid",
            ...errorUtil.errToObj(Cn)
        })
    }
    cuid(Cn) {
        return this._addCheck({
            kind: "cuid",
            ...errorUtil.errToObj(Cn)
        })
    }
    cuid2(Cn) {
        return this._addCheck({
            kind: "cuid2",
            ...errorUtil.errToObj(Cn)
        })
    }
    ulid(Cn) {
        return this._addCheck({
            kind: "ulid",
            ...errorUtil.errToObj(Cn)
        })
    }
    base64(Cn) {
        return this._addCheck({
            kind: "base64",
            ...errorUtil.errToObj(Cn)
        })
    }
    base64url(Cn) {
        return this._addCheck({
            kind: "base64url",
            ...errorUtil.errToObj(Cn)
        })
    }
    jwt(Cn) {
        return this._addCheck({
            kind: "jwt",
            ...errorUtil.errToObj(Cn)
        })
    }
    ip(Cn) {
        return this._addCheck({
            kind: "ip",
            ...errorUtil.errToObj(Cn)
        })
    }
    cidr(Cn) {
        return this._addCheck({
            kind: "cidr",
            ...errorUtil.errToObj(Cn)
        })
    }
    datetime(Cn) {
        var as, cs;
        return typeof Cn == "string" ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            local: !1,
            message: Cn
        }) : this._addCheck({
            kind: "datetime",
            precision: typeof (Cn == null ? void 0 : Cn.precision) > "u" ? null : Cn == null ? void 0 : Cn.precision,
            offset: (as = Cn == null ? void 0 : Cn.offset) !== null && as !== void 0 ? as : !1,
            local: (cs = Cn == null ? void 0 : Cn.local) !== null && cs !== void 0 ? cs : !1,
            ...errorUtil.errToObj(Cn == null ? void 0 : Cn.message)
        })
    }
    date(Cn) {
        return this._addCheck({
            kind: "date",
            message: Cn
        })
    }
    time(Cn) {
        return typeof Cn == "string" ? this._addCheck({
            kind: "time",
            precision: null,
            message: Cn
        }) : this._addCheck({
            kind: "time",
            precision: typeof (Cn == null ? void 0 : Cn.precision) > "u" ? null : Cn == null ? void 0 : Cn.precision,
            ...errorUtil.errToObj(Cn == null ? void 0 : Cn.message)
        })
    }
    duration(Cn) {
        return this._addCheck({
            kind: "duration",
            ...errorUtil.errToObj(Cn)
        })
    }
    regex(Cn, as) {
        return this._addCheck({
            kind: "regex",
            regex: Cn,
            ...errorUtil.errToObj(as)
        })
    }
    includes(Cn, as) {
        return this._addCheck({
            kind: "includes",
            value: Cn,
            position: as == null ? void 0 : as.position,
            ...errorUtil.errToObj(as == null ? void 0 : as.message)
        })
    }
    startsWith(Cn, as) {
        return this._addCheck({
            kind: "startsWith",
            value: Cn,
            ...errorUtil.errToObj(as)
        })
    }
    endsWith(Cn, as) {
        return this._addCheck({
            kind: "endsWith",
            value: Cn,
            ...errorUtil.errToObj(as)
        })
    }
    min(Cn, as) {
        return this._addCheck({
            kind: "min",
            value: Cn,
            ...errorUtil.errToObj(as)
        })
    }
    max(Cn, as) {
        return this._addCheck({
            kind: "max",
            value: Cn,
            ...errorUtil.errToObj(as)
        })
    }
    length(Cn, as) {
        return this._addCheck({
            kind: "length",
            value: Cn,
            ...errorUtil.errToObj(as)
        })
    }
    nonempty(Cn) {
        return this.min(1, errorUtil.errToObj(Cn))
    }
    trim() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "trim"
            }]
        })
    }
    toLowerCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toLowerCase"
            }]
        })
    }
    toUpperCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toUpperCase"
            }]
        })
    }
    get isDatetime() {
        return !!this._def.checks.find(Cn => Cn.kind === "datetime")
    }
    get isDate() {
        return !!this._def.checks.find(Cn => Cn.kind === "date")
    }
    get isTime() {
        return !!this._def.checks.find(Cn => Cn.kind === "time")
    }
    get isDuration() {
        return !!this._def.checks.find(Cn => Cn.kind === "duration")
    }
    get isEmail() {
        return !!this._def.checks.find(Cn => Cn.kind === "email")
    }
    get isURL() {
        return !!this._def.checks.find(Cn => Cn.kind === "url")
    }
    get isEmoji() {
        return !!this._def.checks.find(Cn => Cn.kind === "emoji")
    }
    get isUUID() {
        return !!this._def.checks.find(Cn => Cn.kind === "uuid")
    }
    get isNANOID() {
        return !!this._def.checks.find(Cn => Cn.kind === "nanoid")
    }
    get isCUID() {
        return !!this._def.checks.find(Cn => Cn.kind === "cuid")
    }
    get isCUID2() {
        return !!this._def.checks.find(Cn => Cn.kind === "cuid2")
    }
    get isULID() {
        return !!this._def.checks.find(Cn => Cn.kind === "ulid")
    }
    get isIP() {
        return !!this._def.checks.find(Cn => Cn.kind === "ip")
    }
    get isCIDR() {
        return !!this._def.checks.find(Cn => Cn.kind === "cidr")
    }
    get isBase64() {
        return !!this._def.checks.find(Cn => Cn.kind === "base64")
    }
    get isBase64url() {
        return !!this._def.checks.find(Cn => Cn.kind === "base64url")
    }
    get minLength() {
        let Cn = null;
        for (const as of this._def.checks)
            as.kind === "min" && (Cn === null || as.value > Cn) && (Cn = as.value);
        return Cn
    }
    get maxLength() {
        let Cn = null;
        for (const as of this._def.checks)
            as.kind === "max" && (Cn === null || as.value < Cn) && (Cn = as.value);
        return Cn
    }
}
ZodString.create = xt => {
    var Cn;
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (Cn = xt == null ? void 0 : xt.coerce) !== null && Cn !== void 0 ? Cn : !1,
        ...processCreateParams(xt)
    })
}
;
function floatSafeRemainder(xt, Cn) {
    const as = (xt.toString().split(".")[1] || "").length
      , cs = (Cn.toString().split(".")[1] || "").length
      , Cs = as > cs ? as : cs
      , Ls = parseInt(xt.toFixed(Cs).replace(".", ""))
      , Vs = parseInt(Cn.toFixed(Cs).replace(".", ""));
    return Ls % Vs / Math.pow(10, Cs)
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments),
        this.min = this.gte,
        this.max = this.lte,
        this.step = this.multipleOf
    }
    _parse(Cn) {
        if (this._def.coerce && (Cn.data = Number(Cn.data)),
        this._getType(Cn) !== ZodParsedType.number) {
            const Ls = this._getOrReturnCtx(Cn);
            return addIssueToContext(Ls, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.number,
                received: Ls.parsedType
            }),
            INVALID
        }
        let cs;
        const Cs = new ParseStatus;
        for (const Ls of this._def.checks)
            Ls.kind === "int" ? util.isInteger(Cn.data) || (cs = this._getOrReturnCtx(Cn, cs),
            addIssueToContext(cs, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: Ls.message
            }),
            Cs.dirty()) : Ls.kind === "min" ? (Ls.inclusive ? Cn.data < Ls.value : Cn.data <= Ls.value) && (cs = this._getOrReturnCtx(Cn, cs),
            addIssueToContext(cs, {
                code: ZodIssueCode.too_small,
                minimum: Ls.value,
                type: "number",
                inclusive: Ls.inclusive,
                exact: !1,
                message: Ls.message
            }),
            Cs.dirty()) : Ls.kind === "max" ? (Ls.inclusive ? Cn.data > Ls.value : Cn.data >= Ls.value) && (cs = this._getOrReturnCtx(Cn, cs),
            addIssueToContext(cs, {
                code: ZodIssueCode.too_big,
                maximum: Ls.value,
                type: "number",
                inclusive: Ls.inclusive,
                exact: !1,
                message: Ls.message
            }),
            Cs.dirty()) : Ls.kind === "multipleOf" ? floatSafeRemainder(Cn.data, Ls.value) !== 0 && (cs = this._getOrReturnCtx(Cn, cs),
            addIssueToContext(cs, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: Ls.value,
                message: Ls.message
            }),
            Cs.dirty()) : Ls.kind === "finite" ? Number.isFinite(Cn.data) || (cs = this._getOrReturnCtx(Cn, cs),
            addIssueToContext(cs, {
                code: ZodIssueCode.not_finite,
                message: Ls.message
            }),
            Cs.dirty()) : util.assertNever(Ls);
        return {
            status: Cs.value,
            value: Cn.data
        }
    }
    gte(Cn, as) {
        return this.setLimit("min", Cn, !0, errorUtil.toString(as))
    }
    gt(Cn, as) {
        return this.setLimit("min", Cn, !1, errorUtil.toString(as))
    }
    lte(Cn, as) {
        return this.setLimit("max", Cn, !0, errorUtil.toString(as))
    }
    lt(Cn, as) {
        return this.setLimit("max", Cn, !1, errorUtil.toString(as))
    }
    setLimit(Cn, as, cs, Cs) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, {
                kind: Cn,
                value: as,
                inclusive: cs,
                message: errorUtil.toString(Cs)
            }]
        })
    }
    _addCheck(Cn) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, Cn]
        })
    }
    int(Cn) {
        return this._addCheck({
            kind: "int",
            message: errorUtil.toString(Cn)
        })
    }
    positive(Cn) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: errorUtil.toString(Cn)
        })
    }
    negative(Cn) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: errorUtil.toString(Cn)
        })
    }
    nonpositive(Cn) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: errorUtil.toString(Cn)
        })
    }
    nonnegative(Cn) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: errorUtil.toString(Cn)
        })
    }
    multipleOf(Cn, as) {
        return this._addCheck({
            kind: "multipleOf",
            value: Cn,
            message: errorUtil.toString(as)
        })
    }
    finite(Cn) {
        return this._addCheck({
            kind: "finite",
            message: errorUtil.toString(Cn)
        })
    }
    safe(Cn) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil.toString(Cn)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil.toString(Cn)
        })
    }
    get minValue() {
        let Cn = null;
        for (const as of this._def.checks)
            as.kind === "min" && (Cn === null || as.value > Cn) && (Cn = as.value);
        return Cn
    }
    get maxValue() {
        let Cn = null;
        for (const as of this._def.checks)
            as.kind === "max" && (Cn === null || as.value < Cn) && (Cn = as.value);
        return Cn
    }
    get isInt() {
        return !!this._def.checks.find(Cn => Cn.kind === "int" || Cn.kind === "multipleOf" && util.isInteger(Cn.value))
    }
    get isFinite() {
        let Cn = null
          , as = null;
        for (const cs of this._def.checks) {
            if (cs.kind === "finite" || cs.kind === "int" || cs.kind === "multipleOf")
                return !0;
            cs.kind === "min" ? (as === null || cs.value > as) && (as = cs.value) : cs.kind === "max" && (Cn === null || cs.value < Cn) && (Cn = cs.value)
        }
        return Number.isFinite(as) && Number.isFinite(Cn)
    }
}
ZodNumber.create = xt => new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (xt == null ? void 0 : xt.coerce) || !1,
    ...processCreateParams(xt)
});
class ZodBigInt extends ZodType {
    constructor() {
        super(...arguments),
        this.min = this.gte,
        this.max = this.lte
    }
    _parse(Cn) {
        if (this._def.coerce)
            try {
                Cn.data = BigInt(Cn.data)
            } catch {
                return this._getInvalidInput(Cn)
            }
        if (this._getType(Cn) !== ZodParsedType.bigint)
            return this._getInvalidInput(Cn);
        let cs;
        const Cs = new ParseStatus;
        for (const Ls of this._def.checks)
            Ls.kind === "min" ? (Ls.inclusive ? Cn.data < Ls.value : Cn.data <= Ls.value) && (cs = this._getOrReturnCtx(Cn, cs),
            addIssueToContext(cs, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: Ls.value,
                inclusive: Ls.inclusive,
                message: Ls.message
            }),
            Cs.dirty()) : Ls.kind === "max" ? (Ls.inclusive ? Cn.data > Ls.value : Cn.data >= Ls.value) && (cs = this._getOrReturnCtx(Cn, cs),
            addIssueToContext(cs, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: Ls.value,
                inclusive: Ls.inclusive,
                message: Ls.message
            }),
            Cs.dirty()) : Ls.kind === "multipleOf" ? Cn.data % Ls.value !== BigInt(0) && (cs = this._getOrReturnCtx(Cn, cs),
            addIssueToContext(cs, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: Ls.value,
                message: Ls.message
            }),
            Cs.dirty()) : util.assertNever(Ls);
        return {
            status: Cs.value,
            value: Cn.data
        }
    }
    _getInvalidInput(Cn) {
        const as = this._getOrReturnCtx(Cn);
        return addIssueToContext(as, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.bigint,
            received: as.parsedType
        }),
        INVALID
    }
    gte(Cn, as) {
        return this.setLimit("min", Cn, !0, errorUtil.toString(as))
    }
    gt(Cn, as) {
        return this.setLimit("min", Cn, !1, errorUtil.toString(as))
    }
    lte(Cn, as) {
        return this.setLimit("max", Cn, !0, errorUtil.toString(as))
    }
    lt(Cn, as) {
        return this.setLimit("max", Cn, !1, errorUtil.toString(as))
    }
    setLimit(Cn, as, cs, Cs) {
        return new ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, {
                kind: Cn,
                value: as,
                inclusive: cs,
                message: errorUtil.toString(Cs)
            }]
        })
    }
    _addCheck(Cn) {
        return new ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, Cn]
        })
    }
    positive(Cn) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: errorUtil.toString(Cn)
        })
    }
    negative(Cn) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: errorUtil.toString(Cn)
        })
    }
    nonpositive(Cn) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: errorUtil.toString(Cn)
        })
    }
    nonnegative(Cn) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: errorUtil.toString(Cn)
        })
    }
    multipleOf(Cn, as) {
        return this._addCheck({
            kind: "multipleOf",
            value: Cn,
            message: errorUtil.toString(as)
        })
    }
    get minValue() {
        let Cn = null;
        for (const as of this._def.checks)
            as.kind === "min" && (Cn === null || as.value > Cn) && (Cn = as.value);
        return Cn
    }
    get maxValue() {
        let Cn = null;
        for (const as of this._def.checks)
            as.kind === "max" && (Cn === null || as.value < Cn) && (Cn = as.value);
        return Cn
    }
}
ZodBigInt.create = xt => {
    var Cn;
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (Cn = xt == null ? void 0 : xt.coerce) !== null && Cn !== void 0 ? Cn : !1,
        ...processCreateParams(xt)
    })
}
;
class ZodBoolean extends ZodType {
    _parse(Cn) {
        if (this._def.coerce && (Cn.data = !!Cn.data),
        this._getType(Cn) !== ZodParsedType.boolean) {
            const cs = this._getOrReturnCtx(Cn);
            return addIssueToContext(cs, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.boolean,
                received: cs.parsedType
            }),
            INVALID
        }
        return OK(Cn.data)
    }
}
ZodBoolean.create = xt => new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (xt == null ? void 0 : xt.coerce) || !1,
    ...processCreateParams(xt)
});
class ZodDate extends ZodType {
    _parse(Cn) {
        if (this._def.coerce && (Cn.data = new Date(Cn.data)),
        this._getType(Cn) !== ZodParsedType.date) {
            const Ls = this._getOrReturnCtx(Cn);
            return addIssueToContext(Ls, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.date,
                received: Ls.parsedType
            }),
            INVALID
        }
        if (isNaN(Cn.data.getTime())) {
            const Ls = this._getOrReturnCtx(Cn);
            return addIssueToContext(Ls, {
                code: ZodIssueCode.invalid_date
            }),
            INVALID
        }
        const cs = new ParseStatus;
        let Cs;
        for (const Ls of this._def.checks)
            Ls.kind === "min" ? Cn.data.getTime() < Ls.value && (Cs = this._getOrReturnCtx(Cn, Cs),
            addIssueToContext(Cs, {
                code: ZodIssueCode.too_small,
                message: Ls.message,
                inclusive: !0,
                exact: !1,
                minimum: Ls.value,
                type: "date"
            }),
            cs.dirty()) : Ls.kind === "max" ? Cn.data.getTime() > Ls.value && (Cs = this._getOrReturnCtx(Cn, Cs),
            addIssueToContext(Cs, {
                code: ZodIssueCode.too_big,
                message: Ls.message,
                inclusive: !0,
                exact: !1,
                maximum: Ls.value,
                type: "date"
            }),
            cs.dirty()) : util.assertNever(Ls);
        return {
            status: cs.value,
            value: new Date(Cn.data.getTime())
        }
    }
    _addCheck(Cn) {
        return new ZodDate({
            ...this._def,
            checks: [...this._def.checks, Cn]
        })
    }
    min(Cn, as) {
        return this._addCheck({
            kind: "min",
            value: Cn.getTime(),
            message: errorUtil.toString(as)
        })
    }
    max(Cn, as) {
        return this._addCheck({
            kind: "max",
            value: Cn.getTime(),
            message: errorUtil.toString(as)
        })
    }
    get minDate() {
        let Cn = null;
        for (const as of this._def.checks)
            as.kind === "min" && (Cn === null || as.value > Cn) && (Cn = as.value);
        return Cn != null ? new Date(Cn) : null
    }
    get maxDate() {
        let Cn = null;
        for (const as of this._def.checks)
            as.kind === "max" && (Cn === null || as.value < Cn) && (Cn = as.value);
        return Cn != null ? new Date(Cn) : null
    }
}
ZodDate.create = xt => new ZodDate({
    checks: [],
    coerce: (xt == null ? void 0 : xt.coerce) || !1,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(xt)
});
class ZodSymbol extends ZodType {
    _parse(Cn) {
        if (this._getType(Cn) !== ZodParsedType.symbol) {
            const cs = this._getOrReturnCtx(Cn);
            return addIssueToContext(cs, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.symbol,
                received: cs.parsedType
            }),
            INVALID
        }
        return OK(Cn.data)
    }
}
ZodSymbol.create = xt => new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(xt)
});
class ZodUndefined extends ZodType {
    _parse(Cn) {
        if (this._getType(Cn) !== ZodParsedType.undefined) {
            const cs = this._getOrReturnCtx(Cn);
            return addIssueToContext(cs, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.undefined,
                received: cs.parsedType
            }),
            INVALID
        }
        return OK(Cn.data)
    }
}
ZodUndefined.create = xt => new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(xt)
});
class ZodNull extends ZodType {
    _parse(Cn) {
        if (this._getType(Cn) !== ZodParsedType.null) {
            const cs = this._getOrReturnCtx(Cn);
            return addIssueToContext(cs, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.null,
                received: cs.parsedType
            }),
            INVALID
        }
        return OK(Cn.data)
    }
}
ZodNull.create = xt => new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(xt)
});
class ZodAny extends ZodType {
    constructor() {
        super(...arguments),
        this._any = !0
    }
    _parse(Cn) {
        return OK(Cn.data)
    }
}
ZodAny.create = xt => new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(xt)
});
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments),
        this._unknown = !0
    }
    _parse(Cn) {
        return OK(Cn.data)
    }
}
ZodUnknown.create = xt => new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(xt)
});
class ZodNever extends ZodType {
    _parse(Cn) {
        const as = this._getOrReturnCtx(Cn);
        return addIssueToContext(as, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: as.parsedType
        }),
        INVALID
    }
}
ZodNever.create = xt => new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(xt)
});
class ZodVoid extends ZodType {
    _parse(Cn) {
        if (this._getType(Cn) !== ZodParsedType.undefined) {
            const cs = this._getOrReturnCtx(Cn);
            return addIssueToContext(cs, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.void,
                received: cs.parsedType
            }),
            INVALID
        }
        return OK(Cn.data)
    }
}
ZodVoid.create = xt => new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(xt)
});
class ZodArray extends ZodType {
    _parse(Cn) {
        const {ctx: as, status: cs} = this._processInputParams(Cn)
          , Cs = this._def;
        if (as.parsedType !== ZodParsedType.array)
            return addIssueToContext(as, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: as.parsedType
            }),
            INVALID;
        if (Cs.exactLength !== null) {
            const Vs = as.data.length > Cs.exactLength.value
              , Ws = as.data.length < Cs.exactLength.value;
            (Vs || Ws) && (addIssueToContext(as, {
                code: Vs ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                minimum: Ws ? Cs.exactLength.value : void 0,
                maximum: Vs ? Cs.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: Cs.exactLength.message
            }),
            cs.dirty())
        }
        if (Cs.minLength !== null && as.data.length < Cs.minLength.value && (addIssueToContext(as, {
            code: ZodIssueCode.too_small,
            minimum: Cs.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: Cs.minLength.message
        }),
        cs.dirty()),
        Cs.maxLength !== null && as.data.length > Cs.maxLength.value && (addIssueToContext(as, {
            code: ZodIssueCode.too_big,
            maximum: Cs.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: Cs.maxLength.message
        }),
        cs.dirty()),
        as.common.async)
            return Promise.all([...as.data].map( (Vs, Ws) => Cs.type._parseAsync(new ParseInputLazyPath(as,Vs,as.path,Ws)))).then(Vs => ParseStatus.mergeArray(cs, Vs));
        const Ls = [...as.data].map( (Vs, Ws) => Cs.type._parseSync(new ParseInputLazyPath(as,Vs,as.path,Ws)));
        return ParseStatus.mergeArray(cs, Ls)
    }
    get element() {
        return this._def.type
    }
    min(Cn, as) {
        return new ZodArray({
            ...this._def,
            minLength: {
                value: Cn,
                message: errorUtil.toString(as)
            }
        })
    }
    max(Cn, as) {
        return new ZodArray({
            ...this._def,
            maxLength: {
                value: Cn,
                message: errorUtil.toString(as)
            }
        })
    }
    length(Cn, as) {
        return new ZodArray({
            ...this._def,
            exactLength: {
                value: Cn,
                message: errorUtil.toString(as)
            }
        })
    }
    nonempty(Cn) {
        return this.min(1, Cn)
    }
}
ZodArray.create = (xt, Cn) => new ZodArray({
    type: xt,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(Cn)
});
function deepPartialify(xt) {
    if (xt instanceof ZodObject) {
        const Cn = {};
        for (const as in xt.shape) {
            const cs = xt.shape[as];
            Cn[as] = ZodOptional.create(deepPartialify(cs))
        }
        return new ZodObject({
            ...xt._def,
            shape: () => Cn
        })
    } else
        return xt instanceof ZodArray ? new ZodArray({
            ...xt._def,
            type: deepPartialify(xt.element)
        }) : xt instanceof ZodOptional ? ZodOptional.create(deepPartialify(xt.unwrap())) : xt instanceof ZodNullable ? ZodNullable.create(deepPartialify(xt.unwrap())) : xt instanceof ZodTuple ? ZodTuple.create(xt.items.map(Cn => deepPartialify(Cn))) : xt
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments),
        this._cached = null,
        this.nonstrict = this.passthrough,
        this.augment = this.extend
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const Cn = this._def.shape()
          , as = util.objectKeys(Cn);
        return this._cached = {
            shape: Cn,
            keys: as
        }
    }
    _parse(Cn) {
        if (this._getType(Cn) !== ZodParsedType.object) {
            const ga = this._getOrReturnCtx(Cn);
            return addIssueToContext(ga, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ga.parsedType
            }),
            INVALID
        }
        const {status: cs, ctx: Cs} = this._processInputParams(Cn)
          , {shape: Ls, keys: Vs} = this._getCached()
          , Ws = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip"))
            for (const ga in Cs.data)
                Vs.includes(ga) || Ws.push(ga);
        const Xs = [];
        for (const ga of Vs) {
            const ba = Ls[ga]
              , yl = Cs.data[ga];
            Xs.push({
                key: {
                    status: "valid",
                    value: ga
                },
                value: ba._parse(new ParseInputLazyPath(Cs,yl,Cs.path,ga)),
                alwaysSet: ga in Cs.data
            })
        }
        if (this._def.catchall instanceof ZodNever) {
            const ga = this._def.unknownKeys;
            if (ga === "passthrough")
                for (const ba of Ws)
                    Xs.push({
                        key: {
                            status: "valid",
                            value: ba
                        },
                        value: {
                            status: "valid",
                            value: Cs.data[ba]
                        }
                    });
            else if (ga === "strict")
                Ws.length > 0 && (addIssueToContext(Cs, {
                    code: ZodIssueCode.unrecognized_keys,
                    keys: Ws
                }),
                cs.dirty());
            else if (ga !== "strip")
                throw new Error("Internal ZodObject error: invalid unknownKeys value.")
        } else {
            const ga = this._def.catchall;
            for (const ba of Ws) {
                const yl = Cs.data[ba];
                Xs.push({
                    key: {
                        status: "valid",
                        value: ba
                    },
                    value: ga._parse(new ParseInputLazyPath(Cs,yl,Cs.path,ba)),
                    alwaysSet: ba in Cs.data
                })
            }
        }
        return Cs.common.async ? Promise.resolve().then(async () => {
            const ga = [];
            for (const ba of Xs) {
                const yl = await ba.key
                  , xl = await ba.value;
                ga.push({
                    key: yl,
                    value: xl,
                    alwaysSet: ba.alwaysSet
                })
            }
            return ga
        }
        ).then(ga => ParseStatus.mergeObjectSync(cs, ga)) : ParseStatus.mergeObjectSync(cs, Xs)
    }
    get shape() {
        return this._def.shape()
    }
    strict(Cn) {
        return errorUtil.errToObj,
        new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...Cn !== void 0 ? {
                errorMap: (as, cs) => {
                    var Cs, Ls, Vs, Ws;
                    const Xs = (Vs = (Ls = (Cs = this._def).errorMap) === null || Ls === void 0 ? void 0 : Ls.call(Cs, as, cs).message) !== null && Vs !== void 0 ? Vs : cs.defaultError;
                    return as.code === "unrecognized_keys" ? {
                        message: (Ws = errorUtil.errToObj(Cn).message) !== null && Ws !== void 0 ? Ws : Xs
                    } : {
                        message: Xs
                    }
                }
            } : {}
        })
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip"
        })
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough"
        })
    }
    extend(Cn) {
        return new ZodObject({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...Cn
            })
        })
    }
    merge(Cn) {
        return new ZodObject({
            unknownKeys: Cn._def.unknownKeys,
            catchall: Cn._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...Cn._def.shape()
            }),
            typeName: ZodFirstPartyTypeKind.ZodObject
        })
    }
    setKey(Cn, as) {
        return this.augment({
            [Cn]: as
        })
    }
    catchall(Cn) {
        return new ZodObject({
            ...this._def,
            catchall: Cn
        })
    }
    pick(Cn) {
        const as = {};
        return util.objectKeys(Cn).forEach(cs => {
            Cn[cs] && this.shape[cs] && (as[cs] = this.shape[cs])
        }
        ),
        new ZodObject({
            ...this._def,
            shape: () => as
        })
    }
    omit(Cn) {
        const as = {};
        return util.objectKeys(this.shape).forEach(cs => {
            Cn[cs] || (as[cs] = this.shape[cs])
        }
        ),
        new ZodObject({
            ...this._def,
            shape: () => as
        })
    }
    deepPartial() {
        return deepPartialify(this)
    }
    partial(Cn) {
        const as = {};
        return util.objectKeys(this.shape).forEach(cs => {
            const Cs = this.shape[cs];
            Cn && !Cn[cs] ? as[cs] = Cs : as[cs] = Cs.optional()
        }
        ),
        new ZodObject({
            ...this._def,
            shape: () => as
        })
    }
    required(Cn) {
        const as = {};
        return util.objectKeys(this.shape).forEach(cs => {
            if (Cn && !Cn[cs])
                as[cs] = this.shape[cs];
            else {
                let Ls = this.shape[cs];
                for (; Ls instanceof ZodOptional; )
                    Ls = Ls._def.innerType;
                as[cs] = Ls
            }
        }
        ),
        new ZodObject({
            ...this._def,
            shape: () => as
        })
    }
    keyof() {
        return createZodEnum(util.objectKeys(this.shape))
    }
}
ZodObject.create = (xt, Cn) => new ZodObject({
    shape: () => xt,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(Cn)
});
ZodObject.strictCreate = (xt, Cn) => new ZodObject({
    shape: () => xt,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(Cn)
});
ZodObject.lazycreate = (xt, Cn) => new ZodObject({
    shape: xt,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(Cn)
});
class ZodUnion extends ZodType {
    _parse(Cn) {
        const {ctx: as} = this._processInputParams(Cn)
          , cs = this._def.options;
        function Cs(Ls) {
            for (const Ws of Ls)
                if (Ws.result.status === "valid")
                    return Ws.result;
            for (const Ws of Ls)
                if (Ws.result.status === "dirty")
                    return as.common.issues.push(...Ws.ctx.common.issues),
                    Ws.result;
            const Vs = Ls.map(Ws => new ZodError(Ws.ctx.common.issues));
            return addIssueToContext(as, {
                code: ZodIssueCode.invalid_union,
                unionErrors: Vs
            }),
            INVALID
        }
        if (as.common.async)
            return Promise.all(cs.map(async Ls => {
                const Vs = {
                    ...as,
                    common: {
                        ...as.common,
                        issues: []
                    },
                    parent: null
                };
                return {
                    result: await Ls._parseAsync({
                        data: as.data,
                        path: as.path,
                        parent: Vs
                    }),
                    ctx: Vs
                }
            }
            )).then(Cs);
        {
            let Ls;
            const Vs = [];
            for (const Xs of cs) {
                const ga = {
                    ...as,
                    common: {
                        ...as.common,
                        issues: []
                    },
                    parent: null
                }
                  , ba = Xs._parseSync({
                    data: as.data,
                    path: as.path,
                    parent: ga
                });
                if (ba.status === "valid")
                    return ba;
                ba.status === "dirty" && !Ls && (Ls = {
                    result: ba,
                    ctx: ga
                }),
                ga.common.issues.length && Vs.push(ga.common.issues)
            }
            if (Ls)
                return as.common.issues.push(...Ls.ctx.common.issues),
                Ls.result;
            const Ws = Vs.map(Xs => new ZodError(Xs));
            return addIssueToContext(as, {
                code: ZodIssueCode.invalid_union,
                unionErrors: Ws
            }),
            INVALID
        }
    }
    get options() {
        return this._def.options
    }
}
ZodUnion.create = (xt, Cn) => new ZodUnion({
    options: xt,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(Cn)
});
const getDiscriminator = xt => xt instanceof ZodLazy ? getDiscriminator(xt.schema) : xt instanceof ZodEffects ? getDiscriminator(xt.innerType()) : xt instanceof ZodLiteral ? [xt.value] : xt instanceof ZodEnum ? xt.options : xt instanceof ZodNativeEnum ? util.objectValues(xt.enum) : xt instanceof ZodDefault ? getDiscriminator(xt._def.innerType) : xt instanceof ZodUndefined ? [void 0] : xt instanceof ZodNull ? [null] : xt instanceof ZodOptional ? [void 0, ...getDiscriminator(xt.unwrap())] : xt instanceof ZodNullable ? [null, ...getDiscriminator(xt.unwrap())] : xt instanceof ZodBranded || xt instanceof ZodReadonly ? getDiscriminator(xt.unwrap()) : xt instanceof ZodCatch ? getDiscriminator(xt._def.innerType) : [];
class ZodDiscriminatedUnion extends ZodType {
    _parse(Cn) {
        const {ctx: as} = this._processInputParams(Cn);
        if (as.parsedType !== ZodParsedType.object)
            return addIssueToContext(as, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: as.parsedType
            }),
            INVALID;
        const cs = this.discriminator
          , Cs = as.data[cs]
          , Ls = this.optionsMap.get(Cs);
        return Ls ? as.common.async ? Ls._parseAsync({
            data: as.data,
            path: as.path,
            parent: as
        }) : Ls._parseSync({
            data: as.data,
            path: as.path,
            parent: as
        }) : (addIssueToContext(as, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [cs]
        }),
        INVALID)
    }
    get discriminator() {
        return this._def.discriminator
    }
    get options() {
        return this._def.options
    }
    get optionsMap() {
        return this._def.optionsMap
    }
    static create(Cn, as, cs) {
        const Cs = new Map;
        for (const Ls of as) {
            const Vs = getDiscriminator(Ls.shape[Cn]);
            if (!Vs.length)
                throw new Error(`A discriminator value for key \`${Cn}\` could not be extracted from all schema options`);
            for (const Ws of Vs) {
                if (Cs.has(Ws))
                    throw new Error(`Discriminator property ${String(Cn)} has duplicate value ${String(Ws)}`);
                Cs.set(Ws, Ls)
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator: Cn,
            options: as,
            optionsMap: Cs,
            ...processCreateParams(cs)
        })
    }
}
function mergeValues(xt, Cn) {
    const as = getParsedType(xt)
      , cs = getParsedType(Cn);
    if (xt === Cn)
        return {
            valid: !0,
            data: xt
        };
    if (as === ZodParsedType.object && cs === ZodParsedType.object) {
        const Cs = util.objectKeys(Cn)
          , Ls = util.objectKeys(xt).filter(Ws => Cs.indexOf(Ws) !== -1)
          , Vs = {
            ...xt,
            ...Cn
        };
        for (const Ws of Ls) {
            const Xs = mergeValues(xt[Ws], Cn[Ws]);
            if (!Xs.valid)
                return {
                    valid: !1
                };
            Vs[Ws] = Xs.data
        }
        return {
            valid: !0,
            data: Vs
        }
    } else if (as === ZodParsedType.array && cs === ZodParsedType.array) {
        if (xt.length !== Cn.length)
            return {
                valid: !1
            };
        const Cs = [];
        for (let Ls = 0; Ls < xt.length; Ls++) {
            const Vs = xt[Ls]
              , Ws = Cn[Ls]
              , Xs = mergeValues(Vs, Ws);
            if (!Xs.valid)
                return {
                    valid: !1
                };
            Cs.push(Xs.data)
        }
        return {
            valid: !0,
            data: Cs
        }
    } else
        return as === ZodParsedType.date && cs === ZodParsedType.date && +xt == +Cn ? {
            valid: !0,
            data: xt
        } : {
            valid: !1
        }
}
class ZodIntersection extends ZodType {
    _parse(Cn) {
        const {status: as, ctx: cs} = this._processInputParams(Cn)
          , Cs = (Ls, Vs) => {
            if (isAborted(Ls) || isAborted(Vs))
                return INVALID;
            const Ws = mergeValues(Ls.value, Vs.value);
            return Ws.valid ? ((isDirty(Ls) || isDirty(Vs)) && as.dirty(),
            {
                status: as.value,
                value: Ws.data
            }) : (addIssueToContext(cs, {
                code: ZodIssueCode.invalid_intersection_types
            }),
            INVALID)
        }
        ;
        return cs.common.async ? Promise.all([this._def.left._parseAsync({
            data: cs.data,
            path: cs.path,
            parent: cs
        }), this._def.right._parseAsync({
            data: cs.data,
            path: cs.path,
            parent: cs
        })]).then( ([Ls,Vs]) => Cs(Ls, Vs)) : Cs(this._def.left._parseSync({
            data: cs.data,
            path: cs.path,
            parent: cs
        }), this._def.right._parseSync({
            data: cs.data,
            path: cs.path,
            parent: cs
        }))
    }
}
ZodIntersection.create = (xt, Cn, as) => new ZodIntersection({
    left: xt,
    right: Cn,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(as)
});
class ZodTuple extends ZodType {
    _parse(Cn) {
        const {status: as, ctx: cs} = this._processInputParams(Cn);
        if (cs.parsedType !== ZodParsedType.array)
            return addIssueToContext(cs, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: cs.parsedType
            }),
            INVALID;
        if (cs.data.length < this._def.items.length)
            return addIssueToContext(cs, {
                code: ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array"
            }),
            INVALID;
        !this._def.rest && cs.data.length > this._def.items.length && (addIssueToContext(cs, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }),
        as.dirty());
        const Ls = [...cs.data].map( (Vs, Ws) => {
            const Xs = this._def.items[Ws] || this._def.rest;
            return Xs ? Xs._parse(new ParseInputLazyPath(cs,Vs,cs.path,Ws)) : null
        }
        ).filter(Vs => !!Vs);
        return cs.common.async ? Promise.all(Ls).then(Vs => ParseStatus.mergeArray(as, Vs)) : ParseStatus.mergeArray(as, Ls)
    }
    get items() {
        return this._def.items
    }
    rest(Cn) {
        return new ZodTuple({
            ...this._def,
            rest: Cn
        })
    }
}
ZodTuple.create = (xt, Cn) => {
    if (!Array.isArray(xt))
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new ZodTuple({
        items: xt,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(Cn)
    })
}
;
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(Cn) {
        const {status: as, ctx: cs} = this._processInputParams(Cn);
        if (cs.parsedType !== ZodParsedType.object)
            return addIssueToContext(cs, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: cs.parsedType
            }),
            INVALID;
        const Cs = []
          , Ls = this._def.keyType
          , Vs = this._def.valueType;
        for (const Ws in cs.data)
            Cs.push({
                key: Ls._parse(new ParseInputLazyPath(cs,Ws,cs.path,Ws)),
                value: Vs._parse(new ParseInputLazyPath(cs,cs.data[Ws],cs.path,Ws)),
                alwaysSet: Ws in cs.data
            });
        return cs.common.async ? ParseStatus.mergeObjectAsync(as, Cs) : ParseStatus.mergeObjectSync(as, Cs)
    }
    get element() {
        return this._def.valueType
    }
    static create(Cn, as, cs) {
        return as instanceof ZodType ? new ZodRecord({
            keyType: Cn,
            valueType: as,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(cs)
        }) : new ZodRecord({
            keyType: ZodString.create(),
            valueType: Cn,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(as)
        })
    }
}
class ZodMap extends ZodType {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(Cn) {
        const {status: as, ctx: cs} = this._processInputParams(Cn);
        if (cs.parsedType !== ZodParsedType.map)
            return addIssueToContext(cs, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.map,
                received: cs.parsedType
            }),
            INVALID;
        const Cs = this._def.keyType
          , Ls = this._def.valueType
          , Vs = [...cs.data.entries()].map( ([Ws,Xs], ga) => ({
            key: Cs._parse(new ParseInputLazyPath(cs,Ws,cs.path,[ga, "key"])),
            value: Ls._parse(new ParseInputLazyPath(cs,Xs,cs.path,[ga, "value"]))
        }));
        if (cs.common.async) {
            const Ws = new Map;
            return Promise.resolve().then(async () => {
                for (const Xs of Vs) {
                    const ga = await Xs.key
                      , ba = await Xs.value;
                    if (ga.status === "aborted" || ba.status === "aborted")
                        return INVALID;
                    (ga.status === "dirty" || ba.status === "dirty") && as.dirty(),
                    Ws.set(ga.value, ba.value)
                }
                return {
                    status: as.value,
                    value: Ws
                }
            }
            )
        } else {
            const Ws = new Map;
            for (const Xs of Vs) {
                const ga = Xs.key
                  , ba = Xs.value;
                if (ga.status === "aborted" || ba.status === "aborted")
                    return INVALID;
                (ga.status === "dirty" || ba.status === "dirty") && as.dirty(),
                Ws.set(ga.value, ba.value)
            }
            return {
                status: as.value,
                value: Ws
            }
        }
    }
}
ZodMap.create = (xt, Cn, as) => new ZodMap({
    valueType: Cn,
    keyType: xt,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(as)
});
class ZodSet extends ZodType {
    _parse(Cn) {
        const {status: as, ctx: cs} = this._processInputParams(Cn);
        if (cs.parsedType !== ZodParsedType.set)
            return addIssueToContext(cs, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.set,
                received: cs.parsedType
            }),
            INVALID;
        const Cs = this._def;
        Cs.minSize !== null && cs.data.size < Cs.minSize.value && (addIssueToContext(cs, {
            code: ZodIssueCode.too_small,
            minimum: Cs.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: Cs.minSize.message
        }),
        as.dirty()),
        Cs.maxSize !== null && cs.data.size > Cs.maxSize.value && (addIssueToContext(cs, {
            code: ZodIssueCode.too_big,
            maximum: Cs.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: Cs.maxSize.message
        }),
        as.dirty());
        const Ls = this._def.valueType;
        function Vs(Xs) {
            const ga = new Set;
            for (const ba of Xs) {
                if (ba.status === "aborted")
                    return INVALID;
                ba.status === "dirty" && as.dirty(),
                ga.add(ba.value)
            }
            return {
                status: as.value,
                value: ga
            }
        }
        const Ws = [...cs.data.values()].map( (Xs, ga) => Ls._parse(new ParseInputLazyPath(cs,Xs,cs.path,ga)));
        return cs.common.async ? Promise.all(Ws).then(Xs => Vs(Xs)) : Vs(Ws)
    }
    min(Cn, as) {
        return new ZodSet({
            ...this._def,
            minSize: {
                value: Cn,
                message: errorUtil.toString(as)
            }
        })
    }
    max(Cn, as) {
        return new ZodSet({
            ...this._def,
            maxSize: {
                value: Cn,
                message: errorUtil.toString(as)
            }
        })
    }
    size(Cn, as) {
        return this.min(Cn, as).max(Cn, as)
    }
    nonempty(Cn) {
        return this.min(1, Cn)
    }
}
ZodSet.create = (xt, Cn) => new ZodSet({
    valueType: xt,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(Cn)
});
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments),
        this.validate = this.implement
    }
    _parse(Cn) {
        const {ctx: as} = this._processInputParams(Cn);
        if (as.parsedType !== ZodParsedType.function)
            return addIssueToContext(as, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.function,
                received: as.parsedType
            }),
            INVALID;
        function cs(Ws, Xs) {
            return makeIssue({
                data: Ws,
                path: as.path,
                errorMaps: [as.common.contextualErrorMap, as.schemaErrorMap, getErrorMap(), errorMap].filter(ga => !!ga),
                issueData: {
                    code: ZodIssueCode.invalid_arguments,
                    argumentsError: Xs
                }
            })
        }
        function Cs(Ws, Xs) {
            return makeIssue({
                data: Ws,
                path: as.path,
                errorMaps: [as.common.contextualErrorMap, as.schemaErrorMap, getErrorMap(), errorMap].filter(ga => !!ga),
                issueData: {
                    code: ZodIssueCode.invalid_return_type,
                    returnTypeError: Xs
                }
            })
        }
        const Ls = {
            errorMap: as.common.contextualErrorMap
        }
          , Vs = as.data;
        if (this._def.returns instanceof ZodPromise) {
            const Ws = this;
            return OK(async function(...Xs) {
                const ga = new ZodError([])
                  , ba = await Ws._def.args.parseAsync(Xs, Ls).catch(wl => {
                    throw ga.addIssue(cs(Xs, wl)),
                    ga
                }
                )
                  , yl = await Reflect.apply(Vs, this, ba);
                return await Ws._def.returns._def.type.parseAsync(yl, Ls).catch(wl => {
                    throw ga.addIssue(Cs(yl, wl)),
                    ga
                }
                )
            })
        } else {
            const Ws = this;
            return OK(function(...Xs) {
                const ga = Ws._def.args.safeParse(Xs, Ls);
                if (!ga.success)
                    throw new ZodError([cs(Xs, ga.error)]);
                const ba = Reflect.apply(Vs, this, ga.data)
                  , yl = Ws._def.returns.safeParse(ba, Ls);
                if (!yl.success)
                    throw new ZodError([Cs(ba, yl.error)]);
                return yl.data
            })
        }
    }
    parameters() {
        return this._def.args
    }
    returnType() {
        return this._def.returns
    }
    args(...Cn) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(Cn).rest(ZodUnknown.create())
        })
    }
    returns(Cn) {
        return new ZodFunction({
            ...this._def,
            returns: Cn
        })
    }
    implement(Cn) {
        return this.parse(Cn)
    }
    strictImplement(Cn) {
        return this.parse(Cn)
    }
    static create(Cn, as, cs) {
        return new ZodFunction({
            args: Cn || ZodTuple.create([]).rest(ZodUnknown.create()),
            returns: as || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(cs)
        })
    }
}
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter()
    }
    _parse(Cn) {
        const {ctx: as} = this._processInputParams(Cn);
        return this._def.getter()._parse({
            data: as.data,
            path: as.path,
            parent: as
        })
    }
}
ZodLazy.create = (xt, Cn) => new ZodLazy({
    getter: xt,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(Cn)
});
class ZodLiteral extends ZodType {
    _parse(Cn) {
        if (Cn.data !== this._def.value) {
            const as = this._getOrReturnCtx(Cn);
            return addIssueToContext(as, {
                received: as.data,
                code: ZodIssueCode.invalid_literal,
                expected: this._def.value
            }),
            INVALID
        }
        return {
            status: "valid",
            value: Cn.data
        }
    }
    get value() {
        return this._def.value
    }
}
ZodLiteral.create = (xt, Cn) => new ZodLiteral({
    value: xt,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(Cn)
});
function createZodEnum(xt, Cn) {
    return new ZodEnum({
        values: xt,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(Cn)
    })
}
class ZodEnum extends ZodType {
    constructor() {
        super(...arguments),
        _ZodEnum_cache.set(this, void 0)
    }
    _parse(Cn) {
        if (typeof Cn.data != "string") {
            const as = this._getOrReturnCtx(Cn)
              , cs = this._def.values;
            return addIssueToContext(as, {
                expected: util.joinValues(cs),
                received: as.parsedType,
                code: ZodIssueCode.invalid_type
            }),
            INVALID
        }
        if (__classPrivateFieldGet(this, _ZodEnum_cache) || __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values)),
        !__classPrivateFieldGet(this, _ZodEnum_cache).has(Cn.data)) {
            const as = this._getOrReturnCtx(Cn)
              , cs = this._def.values;
            return addIssueToContext(as, {
                received: as.data,
                code: ZodIssueCode.invalid_enum_value,
                options: cs
            }),
            INVALID
        }
        return OK(Cn.data)
    }
    get options() {
        return this._def.values
    }
    get enum() {
        const Cn = {};
        for (const as of this._def.values)
            Cn[as] = as;
        return Cn
    }
    get Values() {
        const Cn = {};
        for (const as of this._def.values)
            Cn[as] = as;
        return Cn
    }
    get Enum() {
        const Cn = {};
        for (const as of this._def.values)
            Cn[as] = as;
        return Cn
    }
    extract(Cn, as=this._def) {
        return ZodEnum.create(Cn, {
            ...this._def,
            ...as
        })
    }
    exclude(Cn, as=this._def) {
        return ZodEnum.create(this.options.filter(cs => !Cn.includes(cs)), {
            ...this._def,
            ...as
        })
    }
}
_ZodEnum_cache = new WeakMap;
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    constructor() {
        super(...arguments),
        _ZodNativeEnum_cache.set(this, void 0)
    }
    _parse(Cn) {
        const as = util.getValidEnumValues(this._def.values)
          , cs = this._getOrReturnCtx(Cn);
        if (cs.parsedType !== ZodParsedType.string && cs.parsedType !== ZodParsedType.number) {
            const Cs = util.objectValues(as);
            return addIssueToContext(cs, {
                expected: util.joinValues(Cs),
                received: cs.parsedType,
                code: ZodIssueCode.invalid_type
            }),
            INVALID
        }
        if (__classPrivateFieldGet(this, _ZodNativeEnum_cache) || __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values))),
        !__classPrivateFieldGet(this, _ZodNativeEnum_cache).has(Cn.data)) {
            const Cs = util.objectValues(as);
            return addIssueToContext(cs, {
                received: cs.data,
                code: ZodIssueCode.invalid_enum_value,
                options: Cs
            }),
            INVALID
        }
        return OK(Cn.data)
    }
    get enum() {
        return this._def.values
    }
}
_ZodNativeEnum_cache = new WeakMap;
ZodNativeEnum.create = (xt, Cn) => new ZodNativeEnum({
    values: xt,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(Cn)
});
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type
    }
    _parse(Cn) {
        const {ctx: as} = this._processInputParams(Cn);
        if (as.parsedType !== ZodParsedType.promise && as.common.async === !1)
            return addIssueToContext(as, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.promise,
                received: as.parsedType
            }),
            INVALID;
        const cs = as.parsedType === ZodParsedType.promise ? as.data : Promise.resolve(as.data);
        return OK(cs.then(Cs => this._def.type.parseAsync(Cs, {
            path: as.path,
            errorMap: as.common.contextualErrorMap
        })))
    }
}
ZodPromise.create = (xt, Cn) => new ZodPromise({
    type: xt,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(Cn)
});
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema
    }
    _parse(Cn) {
        const {status: as, ctx: cs} = this._processInputParams(Cn)
          , Cs = this._def.effect || null
          , Ls = {
            addIssue: Vs => {
                addIssueToContext(cs, Vs),
                Vs.fatal ? as.abort() : as.dirty()
            }
            ,
            get path() {
                return cs.path
            }
        };
        if (Ls.addIssue = Ls.addIssue.bind(Ls),
        Cs.type === "preprocess") {
            const Vs = Cs.transform(cs.data, Ls);
            if (cs.common.async)
                return Promise.resolve(Vs).then(async Ws => {
                    if (as.value === "aborted")
                        return INVALID;
                    const Xs = await this._def.schema._parseAsync({
                        data: Ws,
                        path: cs.path,
                        parent: cs
                    });
                    return Xs.status === "aborted" ? INVALID : Xs.status === "dirty" || as.value === "dirty" ? DIRTY(Xs.value) : Xs
                }
                );
            {
                if (as.value === "aborted")
                    return INVALID;
                const Ws = this._def.schema._parseSync({
                    data: Vs,
                    path: cs.path,
                    parent: cs
                });
                return Ws.status === "aborted" ? INVALID : Ws.status === "dirty" || as.value === "dirty" ? DIRTY(Ws.value) : Ws
            }
        }
        if (Cs.type === "refinement") {
            const Vs = Ws => {
                const Xs = Cs.refinement(Ws, Ls);
                if (cs.common.async)
                    return Promise.resolve(Xs);
                if (Xs instanceof Promise)
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return Ws
            }
            ;
            if (cs.common.async === !1) {
                const Ws = this._def.schema._parseSync({
                    data: cs.data,
                    path: cs.path,
                    parent: cs
                });
                return Ws.status === "aborted" ? INVALID : (Ws.status === "dirty" && as.dirty(),
                Vs(Ws.value),
                {
                    status: as.value,
                    value: Ws.value
                })
            } else
                return this._def.schema._parseAsync({
                    data: cs.data,
                    path: cs.path,
                    parent: cs
                }).then(Ws => Ws.status === "aborted" ? INVALID : (Ws.status === "dirty" && as.dirty(),
                Vs(Ws.value).then( () => ({
                    status: as.value,
                    value: Ws.value
                }))))
        }
        if (Cs.type === "transform")
            if (cs.common.async === !1) {
                const Vs = this._def.schema._parseSync({
                    data: cs.data,
                    path: cs.path,
                    parent: cs
                });
                if (!isValid(Vs))
                    return Vs;
                const Ws = Cs.transform(Vs.value, Ls);
                if (Ws instanceof Promise)
                    throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                return {
                    status: as.value,
                    value: Ws
                }
            } else
                return this._def.schema._parseAsync({
                    data: cs.data,
                    path: cs.path,
                    parent: cs
                }).then(Vs => isValid(Vs) ? Promise.resolve(Cs.transform(Vs.value, Ls)).then(Ws => ({
                    status: as.value,
                    value: Ws
                })) : Vs);
        util.assertNever(Cs)
    }
}
ZodEffects.create = (xt, Cn, as) => new ZodEffects({
    schema: xt,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect: Cn,
    ...processCreateParams(as)
});
ZodEffects.createWithPreprocess = (xt, Cn, as) => new ZodEffects({
    schema: Cn,
    effect: {
        type: "preprocess",
        transform: xt
    },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(as)
});
class ZodOptional extends ZodType {
    _parse(Cn) {
        return this._getType(Cn) === ZodParsedType.undefined ? OK(void 0) : this._def.innerType._parse(Cn)
    }
    unwrap() {
        return this._def.innerType
    }
}
ZodOptional.create = (xt, Cn) => new ZodOptional({
    innerType: xt,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(Cn)
});
class ZodNullable extends ZodType {
    _parse(Cn) {
        return this._getType(Cn) === ZodParsedType.null ? OK(null) : this._def.innerType._parse(Cn)
    }
    unwrap() {
        return this._def.innerType
    }
}
ZodNullable.create = (xt, Cn) => new ZodNullable({
    innerType: xt,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(Cn)
});
class ZodDefault extends ZodType {
    _parse(Cn) {
        const {ctx: as} = this._processInputParams(Cn);
        let cs = as.data;
        return as.parsedType === ZodParsedType.undefined && (cs = this._def.defaultValue()),
        this._def.innerType._parse({
            data: cs,
            path: as.path,
            parent: as
        })
    }
    removeDefault() {
        return this._def.innerType
    }
}
ZodDefault.create = (xt, Cn) => new ZodDefault({
    innerType: xt,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof Cn.default == "function" ? Cn.default : () => Cn.default,
    ...processCreateParams(Cn)
});
class ZodCatch extends ZodType {
    _parse(Cn) {
        const {ctx: as} = this._processInputParams(Cn)
          , cs = {
            ...as,
            common: {
                ...as.common,
                issues: []
            }
        }
          , Cs = this._def.innerType._parse({
            data: cs.data,
            path: cs.path,
            parent: {
                ...cs
            }
        });
        return isAsync(Cs) ? Cs.then(Ls => ({
            status: "valid",
            value: Ls.status === "valid" ? Ls.value : this._def.catchValue({
                get error() {
                    return new ZodError(cs.common.issues)
                },
                input: cs.data
            })
        })) : {
            status: "valid",
            value: Cs.status === "valid" ? Cs.value : this._def.catchValue({
                get error() {
                    return new ZodError(cs.common.issues)
                },
                input: cs.data
            })
        }
    }
    removeCatch() {
        return this._def.innerType
    }
}
ZodCatch.create = (xt, Cn) => new ZodCatch({
    innerType: xt,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof Cn.catch == "function" ? Cn.catch : () => Cn.catch,
    ...processCreateParams(Cn)
});
class ZodNaN extends ZodType {
    _parse(Cn) {
        if (this._getType(Cn) !== ZodParsedType.nan) {
            const cs = this._getOrReturnCtx(Cn);
            return addIssueToContext(cs, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.nan,
                received: cs.parsedType
            }),
            INVALID
        }
        return {
            status: "valid",
            value: Cn.data
        }
    }
}
ZodNaN.create = xt => new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(xt)
});
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(Cn) {
        const {ctx: as} = this._processInputParams(Cn)
          , cs = as.data;
        return this._def.type._parse({
            data: cs,
            path: as.path,
            parent: as
        })
    }
    unwrap() {
        return this._def.type
    }
}
class ZodPipeline extends ZodType {
    _parse(Cn) {
        const {status: as, ctx: cs} = this._processInputParams(Cn);
        if (cs.common.async)
            return (async () => {
                const Ls = await this._def.in._parseAsync({
                    data: cs.data,
                    path: cs.path,
                    parent: cs
                });
                return Ls.status === "aborted" ? INVALID : Ls.status === "dirty" ? (as.dirty(),
                DIRTY(Ls.value)) : this._def.out._parseAsync({
                    data: Ls.value,
                    path: cs.path,
                    parent: cs
                })
            }
            )();
        {
            const Cs = this._def.in._parseSync({
                data: cs.data,
                path: cs.path,
                parent: cs
            });
            return Cs.status === "aborted" ? INVALID : Cs.status === "dirty" ? (as.dirty(),
            {
                status: "dirty",
                value: Cs.value
            }) : this._def.out._parseSync({
                data: Cs.value,
                path: cs.path,
                parent: cs
            })
        }
    }
    static create(Cn, as) {
        return new ZodPipeline({
            in: Cn,
            out: as,
            typeName: ZodFirstPartyTypeKind.ZodPipeline
        })
    }
}
class ZodReadonly extends ZodType {
    _parse(Cn) {
        const as = this._def.innerType._parse(Cn)
          , cs = Cs => (isValid(Cs) && (Cs.value = Object.freeze(Cs.value)),
        Cs);
        return isAsync(as) ? as.then(Cs => cs(Cs)) : cs(as)
    }
    unwrap() {
        return this._def.innerType
    }
}
ZodReadonly.create = (xt, Cn) => new ZodReadonly({
    innerType: xt,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(Cn)
});
function cleanParams(xt, Cn) {
    const as = typeof xt == "function" ? xt(Cn) : typeof xt == "string" ? {
        message: xt
    } : xt;
    return typeof as == "string" ? {
        message: as
    } : as
}
function custom(xt, Cn={}, as) {
    return xt ? ZodAny.create().superRefine( (cs, Cs) => {
        var Ls, Vs;
        const Ws = xt(cs);
        if (Ws instanceof Promise)
            return Ws.then(Xs => {
                var ga, ba;
                if (!Xs) {
                    const yl = cleanParams(Cn, cs)
                      , xl = (ba = (ga = yl.fatal) !== null && ga !== void 0 ? ga : as) !== null && ba !== void 0 ? ba : !0;
                    Cs.addIssue({
                        code: "custom",
                        ...yl,
                        fatal: xl
                    })
                }
            }
            );
        if (!Ws) {
            const Xs = cleanParams(Cn, cs)
              , ga = (Vs = (Ls = Xs.fatal) !== null && Ls !== void 0 ? Ls : as) !== null && Vs !== void 0 ? Vs : !0;
            Cs.addIssue({
                code: "custom",
                ...Xs,
                fatal: ga
            })
        }
    }
    ) : ZodAny.create()
}
const late = {
    object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(xt) {
    xt.ZodString = "ZodString",
    xt.ZodNumber = "ZodNumber",
    xt.ZodNaN = "ZodNaN",
    xt.ZodBigInt = "ZodBigInt",
    xt.ZodBoolean = "ZodBoolean",
    xt.ZodDate = "ZodDate",
    xt.ZodSymbol = "ZodSymbol",
    xt.ZodUndefined = "ZodUndefined",
    xt.ZodNull = "ZodNull",
    xt.ZodAny = "ZodAny",
    xt.ZodUnknown = "ZodUnknown",
    xt.ZodNever = "ZodNever",
    xt.ZodVoid = "ZodVoid",
    xt.ZodArray = "ZodArray",
    xt.ZodObject = "ZodObject",
    xt.ZodUnion = "ZodUnion",
    xt.ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
    xt.ZodIntersection = "ZodIntersection",
    xt.ZodTuple = "ZodTuple",
    xt.ZodRecord = "ZodRecord",
    xt.ZodMap = "ZodMap",
    xt.ZodSet = "ZodSet",
    xt.ZodFunction = "ZodFunction",
    xt.ZodLazy = "ZodLazy",
    xt.ZodLiteral = "ZodLiteral",
    xt.ZodEnum = "ZodEnum",
    xt.ZodEffects = "ZodEffects",
    xt.ZodNativeEnum = "ZodNativeEnum",
    xt.ZodOptional = "ZodOptional",
    xt.ZodNullable = "ZodNullable",
    xt.ZodDefault = "ZodDefault",
    xt.ZodCatch = "ZodCatch",
    xt.ZodPromise = "ZodPromise",
    xt.ZodBranded = "ZodBranded",
    xt.ZodPipeline = "ZodPipeline",
    xt.ZodReadonly = "ZodReadonly"
}
)(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (xt, Cn={
    message: `Input not instance of ${xt.name}`
}) => custom(as => as instanceof xt, Cn)
  , stringType = ZodString.create
  , numberType = ZodNumber.create
  , nanType = ZodNaN.create
  , bigIntType = ZodBigInt.create
  , booleanType = ZodBoolean.create
  , dateType = ZodDate.create
  , symbolType = ZodSymbol.create
  , undefinedType = ZodUndefined.create
  , nullType = ZodNull.create
  , anyType = ZodAny.create
  , unknownType = ZodUnknown.create
  , neverType = ZodNever.create
  , voidType = ZodVoid.create
  , arrayType = ZodArray.create
  , objectType = ZodObject.create
  , strictObjectType = ZodObject.strictCreate
  , unionType = ZodUnion.create
  , discriminatedUnionType = ZodDiscriminatedUnion.create
  , intersectionType = ZodIntersection.create
  , tupleType = ZodTuple.create
  , recordType = ZodRecord.create
  , mapType = ZodMap.create
  , setType = ZodSet.create
  , functionType = ZodFunction.create
  , lazyType = ZodLazy.create
  , literalType = ZodLiteral.create
  , enumType = ZodEnum.create
  , nativeEnumType = ZodNativeEnum.create
  , promiseType = ZodPromise.create
  , effectsType = ZodEffects.create
  , optionalType = ZodOptional.create
  , nullableType = ZodNullable.create
  , preprocessType = ZodEffects.createWithPreprocess
  , pipelineType = ZodPipeline.create
  , ostring = () => stringType().optional()
  , onumber = () => numberType().optional()
  , oboolean = () => booleanType().optional()
  , coerce = {
    string: xt => ZodString.create({
        ...xt,
        coerce: !0
    }),
    number: xt => ZodNumber.create({
        ...xt,
        coerce: !0
    }),
    boolean: xt => ZodBoolean.create({
        ...xt,
        coerce: !0
    }),
    bigint: xt => ZodBigInt.create({
        ...xt,
        coerce: !0
    }),
    date: xt => ZodDate.create({
        ...xt,
        coerce: !0
    })
}
  , NEVER = INVALID;
var z$1 = Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap,
    getErrorMap,
    makeIssue,
    EMPTY_PATH,
    addIssueToContext,
    ParseStatus,
    INVALID,
    DIRTY,
    OK,
    isAborted,
    isDirty,
    isValid,
    isAsync,
    get util() {
        return util
    },
    get objectUtil() {
        return objectUtil
    },
    ZodParsedType,
    getParsedType,
    ZodType,
    datetimeRegex,
    ZodString,
    ZodNumber,
    ZodBigInt,
    ZodBoolean,
    ZodDate,
    ZodSymbol,
    ZodUndefined,
    ZodNull,
    ZodAny,
    ZodUnknown,
    ZodNever,
    ZodVoid,
    ZodArray,
    ZodObject,
    ZodUnion,
    ZodDiscriminatedUnion,
    ZodIntersection,
    ZodTuple,
    ZodRecord,
    ZodMap,
    ZodSet,
    ZodFunction,
    ZodLazy,
    ZodLiteral,
    ZodEnum,
    ZodNativeEnum,
    ZodPromise,
    ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional,
    ZodNullable,
    ZodDefault,
    ZodCatch,
    ZodNaN,
    BRAND,
    ZodBranded,
    ZodPipeline,
    ZodReadonly,
    custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late,
    get ZodFirstPartyTypeKind() {
        return ZodFirstPartyTypeKind
    },
    coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    enum: enumType,
    function: functionType,
    instanceof: instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    null: nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean,
    onumber,
    optional: optionalType,
    ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    undefined: undefinedType,
    union: unionType,
    unknown: unknownType,
    void: voidType,
    NEVER,
    ZodIssueCode,
    quotelessJson,
    ZodError
});
const filtersSchema = z$1.object({
    collectionNames: z$1.array(z$1.string()),
    modelNames: z$1.array(z$1.string()),
    backdropNames: z$1.array(z$1.string()),
    symbolNames: z$1.array(z$1.string()),
    minPrice: z$1.coerce.number().nonnegative().nullable().transform(xt => xt ? Number(dist$1.toNano(xt.toString())) : null),
    maxPrice: z$1.coerce.number().nonnegative().nullable().transform(xt => xt ? Number(dist$1.toNano(xt.toString())) : null),
    mintable: z$1.boolean().nullable(),
    number: z$1.coerce.number().nonnegative().nullable()
})
  , feedFiltersSchema = z$1.object({
    collectionNames: z$1.array(z$1.string()),
    modelNames: z$1.array(z$1.string()),
    backdropNames: z$1.array(z$1.string()),
    number: z$1.coerce.number().nonnegative().nullable(),
    type: z$1.array(z$1.nativeEnum(FeedType))
})
  , useFilters = (xt=!1) => {
    const {filters: Cn, ordering: as, lowToHigh: cs, promotedFirst: Cs, query: Ls, feedOrdering: Vs, feedLowToHigh: Ws} = useStorage(xl => ({
        filters: xl.filters.filters,
        ordering: xl.filters.ordering,
        lowToHigh: xl.filters.lowToHigh,
        promotedFirst: xl.filters.promotedFirst,
        query: xl.filters.query,
        feedOrdering: xl.filters.feedOrdering,
        feedLowToHigh: xl.filters.feedLowToHigh
    }))
      , Xs = reactExports.useMemo( () => filtersSchema.parse(Cn), [Cn])
      , ga = reactExports.useMemo( () => feedFiltersSchema.parse(Cn), [Cn])
      , ba = reactExports.useMemo( () => ({
        ...xt ? ga : Xs,
        ...xt ? {
            ordering: Vs,
            lowToHigh: Ws
        } : {
            ordering: as,
            lowToHigh: cs,
            promotedFirst: Cs,
            query: Ls
        }
    }), [Xs, ga, as, cs, Cs, Ls, Vs, Ws, xt])
      , [yl] = useDebouncedValue(ba, 1e3);
    return yl
}
  , myGiftsInfiniteQueryOptions = (xt, Cn) => {
    const as = xt === "listed";
    return {
        queryKey: [QueryKeys.myGifts, xt, Cn],
        queryFn: async ({pageParam: cs=0}) => {
            if (cs === 0 && isDefaultFilters(Cn)) {
                const Cs = await prefetchInitialMyGifts(as);
                return store.setState(Ls => ({
                    myGifts: {
                        ...Ls.myGifts,
                        prefetchedListedGifts: as ? Cs : Ls.myGifts.prefetchedListedGifts,
                        prefetchedUnlistedGifts: as ? Ls.myGifts.prefetchedUnlistedGifts : Cs
                    }
                })),
                Cs
            }
            return fetchMyGifts(cs, as, Cn)
        }
        ,
        getNextPageParam: (cs, Cs) => {
            if (!(cs.length < DEFAULT_PAGE_SIZE))
                return Cs.length
        }
        ,
        initialPageParam: 0,
        placeholderData: keepPreviousData,
        initialData: () => {
            const {prefetchedListedGifts: cs, prefetchedUnlistedGifts: Cs} = store.getState().myGifts
              , Ls = as ? cs : Cs;
            if (Ls.length > 0 && isDefaultFilters(Cn))
                return {
                    pages: [Ls],
                    pageParams: [0]
                }
        }
    }
}
  , giftsInfiniteQueryOptions = xt => ({
    queryKey: [QueryKeys.gifts, xt],
    queryFn: async ({pageParam: Cn=0}) => {
        if (Cn === 0 && isDefaultFilters(xt)) {
            const as = "promotedFirst"in xt ? xt.promotedFirst : !1
              , cs = await prefetchInitialGifts(!!as);
            return store.setState(Cs => ({
                gifts: {
                    ...Cs.gifts,
                    prefetchedGifts: cs
                }
            })),
            cs
        }
        return fetchGifts(Cn, xt)
    }
    ,
    getNextPageParam: (Cn, as) => {
        if (!(Cn.length < DEFAULT_PAGE_SIZE))
            return as.length
    }
    ,
    initialPageParam: 0,
    placeholderData: keepPreviousData,
    initialData: () => {
        const Cn = store.getState().gifts.prefetchedGifts;
        if (Cn.length > 0 && isDefaultFilters(xt))
            return {
                pages: [Cn],
                pageParams: [0]
            }
    }
})
  , bannerWrapper = "_bannerWrapper_jcajf_1"
  , bannerContent = "_bannerContent_jcajf_14"
  , bannerContentTextWrapper = "_bannerContentTextWrapper_jcajf_30"
  , bannerContentHeader = "_bannerContentHeader_jcajf_38"
  , bannerContentText = "_bannerContentText_jcajf_30"
  , botLabel = "_botLabel_jcajf_58"
  , bannerButton = "_bannerButton_jcajf_67"
  , styles$17 = {
    bannerWrapper,
    bannerContent,
    bannerContentTextWrapper,
    bannerContentHeader,
    bannerContentText,
    botLabel,
    bannerButton
}
  , SvgBannerIcon = xt => reactExports.createElement("svg", {
    width: 56,
    height: 56,
    viewBox: "0 0 56 56",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M50.9167 34.875C50.9167 43.7437 43.7437 50.9167 34.875 50.9167L37.2813 46.9062",
    stroke: "#F7F7F8",
    strokeWidth: 2.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M5.08325 21.125C5.08325 12.2563 12.2562 5.08337 21.1249 5.08337L18.7187 9.09379",
    stroke: "#F7F7F8",
    strokeWidth: 2.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M31.8958 10.698L41.0166 15.9688L50.0457 10.7209",
    stroke: "#F7F7F8",
    strokeWidth: 2.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M41.0166 25.296V15.9459",
    stroke: "#F7F7F8",
    strokeWidth: 2.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M38.8625 5.56462L33.3625 8.61244C32.125 9.29994 31.0938 11.0416 31.0938 12.4624V18.2833C31.0938 19.7042 32.1021 21.4458 33.3625 22.1333L38.8625 25.1813C40.0312 25.8459 41.9562 25.8459 43.1479 25.1813L48.6479 22.1333C49.8854 21.4458 50.9167 19.7042 50.9167 18.2833V12.4624C50.9167 11.0416 49.9083 9.29994 48.6479 8.61244L43.1479 5.56462C41.9792 4.92296 40.0542 4.92296 38.8625 5.56462Z",
    stroke: "#F7F7F8",
    strokeWidth: 2.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M5.88525 35.9062L14.9832 41.1771L24.0353 35.9292",
    stroke: "#F7F7F8",
    strokeWidth: 2.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M14.9832 50.5042V41.1542",
    stroke: "#F7F7F8",
    strokeWidth: 2.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M12.852 30.7729L7.35201 33.8207C6.11451 34.5082 5.08325 36.2498 5.08325 37.6707V43.4916C5.08325 44.9124 6.0916 46.6541 7.35201 47.3416L12.852 50.3895C14.0208 51.0541 15.9457 51.0541 17.1374 50.3895L22.6374 47.3416C23.8749 46.6541 24.9062 44.9124 24.9062 43.4916V37.6707C24.9062 36.2498 23.8978 34.5082 22.6374 33.8207L17.1374 30.7729C15.9457 30.1312 14.0208 30.1312 12.852 30.7729Z",
    stroke: "#F7F7F8",
    strokeWidth: 2.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))
  , WelcomeBanner = () => {
    const {t: xt} = useTranslation()
      , {relayerBotName: Cn, setWelcomeBannerDismissed: as} = useStorage(cs => ({
        relayerBotName: cs.app.relayerBotName,
        setWelcomeBannerDismissed: cs.app.setWelcomeBannerDismissed
    }));
    return jsxRuntimeExports.jsxs("div", {
        className: styles$17.bannerWrapper,
        children: [jsxRuntimeExports.jsxs("div", {
            className: styles$17.bannerContent,
            children: [jsxRuntimeExports.jsx(SvgBannerIcon, {}), jsxRuntimeExports.jsxs("div", {
                className: styles$17.bannerContentTextWrapper,
                children: [jsxRuntimeExports.jsx("span", {
                    className: styles$17.bannerContentHeader,
                    children: xt("welcome_banner_header")
                }), jsxRuntimeExports.jsxs("div", {
                    className: styles$17.bannerContentText,
                    children: [xt("welcome_banner_text"), " ", jsxRuntimeExports.jsxs("span", {
                        className: styles$17.botLabel,
                        children: ["@", Cn]
                    })]
                })]
            })]
        }), jsxRuntimeExports.jsx(Button, {
            size: "small",
            className: styles$17.bannerButton,
            onClick: () => {
                Oc(`https://t.me/${Cn}`),
                as(!0)
            }
            ,
            children: xt("welcome_banner_button")
        })]
    })
}
;
var GIFTS_LIST_STATE = (xt => (xt.LISTED = "LISTED",
xt.UNLISTED = "UNLISTED",
xt.PUBLIC = "PUBLIC",
xt))(GIFTS_LIST_STATE || {});
const List$1 = reactExports.forwardRef( (xt, Cn) => jsxRuntimeExports.jsx("div", {
    ...xt,
    ref: Cn,
    className: styles$19.virtuosoGrid
}))
  , Item$1 = reactExports.memo( ({"data-index": xt, ...Cn}) => jsxRuntimeExports.jsx("div", {
    ...Cn,
    className: styles$19.virtuosoItem
}))
  , GiftListComponent = ({state: xt, showPromoted: Cn=!1}) => {
    var cu;
    const as = reactExports.useRef(null)
      , cs = reactExports.useRef(null)
      , {itemWidth: Cs, setItemWidth: Ls, promotedFirst: Vs, currentTab: Ws, isFirstTime: Xs, welcomeBannerDismissed: ga} = useStorage(pu => ({
        itemWidth: pu.giftDisplay.itemWidth,
        setItemWidth: pu.giftDisplay.setItemWidth,
        promotedFirst: pu.filters.promotedFirst,
        currentTab: pu.myGifts.currentTab,
        isFirstTime: pu.auth.isFirstTime,
        welcomeBannerDismissed: pu.app.welcomeBannerDismissed
    }))
      , ba = useFilters()
      , yl = reactExports.useMemo( () => xt === "LISTED", [xt])
      , xl = reactExports.useMemo( () => xt === "PUBLIC", [xt])
      , wl = reactExports.useMemo( () => Xs && xl && !ga, [Xs, xl, ga])
      , _l = reactExports.useMemo( () => xl ? giftsInfiniteQueryOptions(ba) : myGiftsInfiniteQueryOptions(Ws, ba), [yl, xl, ba, ba, Ws])
      , {data: El, isFetchingNextPage: Cl, fetchNextPage: $l, hasNextPage: Sl, isFetching: Tl} = useInfiniteQuery(_l)
      , Rl = ((cu = El == null ? void 0 : El.pages) == null ? void 0 : cu.flatMap(pu => pu)) ?? []
      , Il = reactExports.useCallback( () => {
        !Tl && Sl && $l()
    }
    , [Tl, $l, Sl])
      , Ml = reactExports.useMemo( () => promotionsInfiniteQueryOptions(ba, Cn), [ba, Cn])
      , {data: Nl} = useInfiniteQuery(Ml)
      , Ll = reactExports.useMemo( () => Nl ? Nl.pages.flatMap(pu => pu) : [], [Nl])
      , Fl = reactExports.useCallback( () => {
        if (!as.current)
            return;
        const pu = as.current.clientWidth
          , zl = 15
          , Yl = 8 * 4;
        let mu = Math.floor((pu + zl) / (148 + zl));
        mu = Math.max(2, mu);
        const Cu = Math.floor((pu - (mu - 1) * zl) / mu - Yl);
        Ls(Cu)
    }
    , [Ls]);
    reactExports.useEffect( () => {
        Fl()
    }
    , [Fl]),
    reactExports.useEffect( () => {
        const pu = () => Fl();
        return window.addEventListener("resize", pu),
        () => window.removeEventListener("resize", pu)
    }
    , [Fl]);
    const Ul = reactExports.useMemo( () => Cn && !Vs && Ll.length > MIN_ITEMS_FOR_LAYOUT ? () => jsxRuntimeExports.jsx(PromotedGiftsSlider, {
        promotedItems: Ll
    }) : () => null, [Cn, Vs, Ll])
      , Dl = reactExports.useMemo( () => !yl && !xl ? 216 : yl && isMobile() ? 46 : 16, [yl, xl])
      , Zl = reactExports.useCallback( () => jsxRuntimeExports.jsx(VirtuosoFooter, {
        height: Dl
    }), [Dl])
      , Gl = reactExports.useCallback(pu => {
        if (wl && pu === 0)
            return jsxRuntimeExports.jsx(WelcomeBanner, {});
        const zl = wl ? Rl[pu - 1] : Rl[pu];
        return jsxRuntimeExports.jsx(GiftItem, {
            state: xt,
            promoteEndAt: zl == null ? void 0 : zl.promoteEndAt,
            gift: zl,
            iconWidth: Cs
        }, zl == null ? void 0 : zl.id)
    }
    , [Rl, xt, Cs, xl])
      , Wl = reactExports.useCallback(pu => {
        const zl = Rl[pu];
        return (zl == null ? void 0 : zl.id) || `item-${pu}`
    }
    , [Rl])
      , Ql = reactExports.useMemo( () => ({
        List: List$1,
        Item: Item$1,
        Header: Ul,
        Footer: Zl
    }), [Ul, Zl]);
    return jsxRuntimeExports.jsxs("div", {
        className: styles$19.giftList,
        ref: as,
        children: [Rl.length === 0 ? Tl ? jsxRuntimeExports.jsx("div", {
            className: styles$19.spinnerWrapper,
            children: jsxRuntimeExports.jsx(Spinner, {})
        }) : jsxRuntimeExports.jsx(EmptyGiftList, {
            state: xt
        }) : jsxRuntimeExports.jsx(Yr, {
            ref: cs,
            className: styles$19.virtualizer,
            totalCount: wl ? Rl.length + 1 : Rl.length,
            overscan: 20,
            components: Ql,
            endReached: Il,
            computeItemKey: Wl,
            itemContent: Gl
        }), Cl && jsxRuntimeExports.jsx("div", {
            className: styles$19.loadingMoreText,
            children: "Loading more..."
        })]
    })
}
  , GiftList = reactExports.memo(GiftListComponent)
  , SvgTrash = xt => reactExports.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M17.25 8.48844C15.3075 8.29594 13.3533 8.19678 11.405 8.19678C10.25 8.19678 9.095 8.25511 7.94 8.37178L6.75 8.48844",
    stroke: "#D44326",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M9.95825 7.89925L10.0866 7.13508C10.1799 6.58091 10.2499 6.16675 11.2358 6.16675H12.7641C13.7499 6.16675 13.8258 6.60425 13.9133 7.14091L14.0416 7.89925",
    stroke: "#D44326",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M15.9958 10.3318L15.6167 16.206C15.5525 17.1218 15.5 17.8335 13.8725 17.8335H10.1275C8.49998 17.8335 8.44748 17.1218 8.38332 16.206L8.00415 10.3318",
    stroke: "#D44326",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))
  , PublicItemControls = ({gift: xt, isInCart: Cn}) => {
    const {setSelectedGiftForQuickBuy: as, setSelectedGiftForOverview: cs, addModal: Cs, removeFromCart: Ls, addToCart: Vs} = useStorage(ba => ({
        setSelectedGiftForQuickBuy: ba.gifts.setSelectedGiftForQuickBuy,
        addModal: ba.modal.addModal,
        removeFromCart: ba.cart.removeFromCart,
        addToCart: ba.cart.addToCart,
        setSelectedGiftForOverview: ba.gifts.setSelectedGiftForOverview
    }))
      , Ws = reactExports.useCallback( () => {
        xt.isMine ? (cs(xt),
        Cs(ModalNames.GIFT_OVERVIEW)) : (as(xt),
        Cs(ModalNames.QUICK_BUY))
    }
    , [xt, as, Cs])
      , Xs = reactExports.useCallback( () => Vs(xt), [xt, Vs])
      , ga = reactExports.useCallback( () => Ls(xt.id), [xt.id, Ls]);
    return jsxRuntimeExports.jsxs("div", {
        className: styles$19.giftActions,
        children: [jsxRuntimeExports.jsxs(Button, {
            size: "small",
            variant: "secondary",
            onClick: Ws,
            className: styles$19.giftActionsBuy,
            children: [jsxRuntimeExports.jsx(SvgTonIcon, {}), formatNanotons(xt.salePrice ?? 0)]
        }), xt.isMine ? null : jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: Cn ? jsxRuntimeExports.jsx(Button, {
                onClick: ga,
                size: "small",
                variant: "secondary",
                iconButton: !0,
                children: jsxRuntimeExports.jsx(SvgTrash, {
                    className: styles$19.trashIcon
                })
            }) : jsxRuntimeExports.jsx(Button, {
                onClick: Xs,
                size: "small",
                variant: "secondary",
                iconButton: !0,
                children: jsxRuntimeExports.jsx(SvgCart, {
                    className: styles$19.cartIcon
                })
            })
        })]
    })
}
  , ListedItemControls = ({gift: xt}) => {
    const {cancelSale: Cn, addModal: as} = useStorage(Ls => ({
        cancelSale: Ls.myGifts.cancelSale,
        addModal: Ls.modal.addModal
    }))
      , {t: cs} = useTranslation()
      , Cs = reactExports.useCallback( () => {
        Cn(xt),
        as(ModalNames.CANCEL_SALE_CONFIRM)
    }
    , [xt, Cn, as]);
    return jsxRuntimeExports.jsx(Button, {
        className: styles$19.actionButton,
        onClick: Cs,
        "aria-label": cs("button_cancel_sale"),
        variant: "warning",
        size: "small",
        children: cs("button_cancel_sale")
    })
}
  , UnlistedItemControls = ({gift: xt}) => {
    const {listGift: Cn, toggleSelectedItem: as, addModal: cs, isHiSaid: Cs, startIsHaiPolling: Ls, relayerBotName: Vs} = useStorage(ba => ({
        listGift: ba.myGifts.listGift,
        toggleSelectedItem: ba.myGifts.toggleSelectedItem,
        addModal: ba.modal.addModal,
        isHiSaid: ba.myGifts.isHiSaid,
        startIsHaiPolling: ba.myGifts.startIsHaiPolling,
        relayerBotName: ba.app.relayerBotName
    }))
      , {t: Ws} = useTranslation()
      , Xs = reactExports.useCallback( () => Cn(xt), [xt, Cn])
      , ga = reactExports.useCallback( () => {
        Cs ? (as(xt),
        cs(ModalNames.WITHDRAW_GIFT_CONFIRM)) : (cs(ModalNames.ERROR, 0, {
            title: "text_error",
            message: "text_say_hi",
            onButtonClickHandler: () => Oc(`https://t.me/${Vs}`),
            buttonText: "button_say_hi"
        }),
        Ls())
    }
    , [Cs, xt, as, cs, Vs, Ls]);
    return jsxRuntimeExports.jsxs("div", {
        className: styles$19.unlistedControls,
        children: [jsxRuntimeExports.jsx(Button, {
            onClick: ga,
            "aria-label": Ws("Output Gift"),
            size: "small",
            iconButton: !0,
            children: jsxRuntimeExports.jsx("img", {
                src: "/icons/common/withdraw.svg",
                alt: "withdraw"
            })
        }), jsxRuntimeExports.jsx(Button, {
            className: styles$19.actionButton,
            onClick: Xs,
            "aria-label": Ws("button_list_sale"),
            size: "small",
            children: Ws("button_list_sale")
        })]
    })
}
  , GiftItemComponent = ({gift: xt, state: Cn, promoteEndAt: as, iconWidth: cs=148, compact: Cs=!1}) => {
    const {t: Ls} = useTranslation()
      , {multipleMode: Vs, selectedItems: Ws, toggleSelectedItem: Xs, cartGifts: ga, getMaxSelectableItems: ba} = useStorage(Sl => ({
        multipleMode: Sl.myGifts.multipleMode,
        selectedItems: Sl.myGifts.selectedItems,
        toggleSelectedItem: Sl.myGifts.toggleSelectedItem,
        cartGifts: Sl.cart.gifts,
        getMaxSelectableItems: Sl.myGifts.getMaxSelectableItems
    }))
      , [yl,xl] = reactExports.useState(!1)
      , wl = reactExports.useMemo( () => ba(), [Vs]);
    reactExports.useEffect( () => {
        const Sl = () => {
            if (as) {
                const Rl = new Date
                  , Il = new Date(as);
                xl(Rl < Il)
            } else
                xl(!1)
        }
        ;
        Sl();
        const Tl = setInterval(Sl, 1e3);
        return () => clearInterval(Tl)
    }
    , [xt, as]);
    const _l = Ws.some(Sl => Sl.id === xt.id)
      , El = reactExports.useMemo( () => ga.some(Sl => Sl.id === xt.id), [ga, xt.id])
      , Cl = () => {
        if (window.Telegram.WebApp.HapticFeedback.impactOccurred("soft"),
        Vs && Cn === GIFTS_LIST_STATE.UNLISTED) {
            if (!_l && Ws.length >= wl)
                return;
            Xs(xt)
        }
    }
      , $l = reactExports.useMemo( () => {
        switch (Cn) {
        case GIFTS_LIST_STATE.LISTED:
            return jsxRuntimeExports.jsx(ListedItemControls, {
                gift: xt
            });
        case GIFTS_LIST_STATE.UNLISTED:
            return jsxRuntimeExports.jsx(UnlistedItemControls, {
                gift: xt
            });
        default:
            return jsxRuntimeExports.jsx(PublicItemControls, {
                gift: xt,
                isInCart: El
            })
        }
    }
    , [Cn, xt, El]);
    return jsxRuntimeExports.jsxs("div", {
        className: `${styles$19.item} ${_l && Vs ? Vs === "listing" ? styles$19.selectedForListing : styles$19.selectedForWithdraw : ""}`,
        onClick: Cl,
        style: {
            cursor: "pointer"
        },
        children: [yl && jsxRuntimeExports.jsx("img", {
            className: styles$19.itemHotRibbon,
            src: "/images/common/ribbon.png",
            alt: ""
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$19.imageContainer,
            style: {
                width: cs,
                height: cs
            },
            children: [jsxRuntimeExports.jsx(GiftIcon, {
                gift: xt,
                width: cs,
                showMine: Cn === GIFTS_LIST_STATE.PUBLIC
            }), !Vs && Cs && jsxRuntimeExports.jsx("div", {
                className: styles$19.compactActions,
                children: jsxRuntimeExports.jsx("div", {
                    className: styles$19.actionWrapper,
                    children: $l
                })
            })]
        }), !Cs && jsxRuntimeExports.jsxs("div", {
            className: styles$19.frame,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$19.name,
                children: xt.title
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$19.number,
                children: ["#", xt.number]
            })]
        }), Cn === GIFTS_LIST_STATE.LISTED && jsxRuntimeExports.jsxs("div", {
            className: styles$19.priceContainer,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$19.priceLabel,
                children: Ls("text_price")
            }), jsxRuntimeExports.jsx("div", {
                className: styles$19.priceWrapper,
                children: jsxRuntimeExports.jsxs("div", {
                    className: styles$19.priceContent,
                    children: [jsxRuntimeExports.jsx(SvgTonIcon, {
                        className: styles$19.tonIcon
                    }), jsxRuntimeExports.jsx("div", {
                        className: styles$19.priceValue,
                        children: formatNanotons(xt.salePrice ?? 0)
                    })]
                })
            })]
        }), !Vs && !Cs && jsxRuntimeExports.jsx("div", {
            className: styles$19.actionWrapper,
            children: $l
        })]
    })
}
  , GiftItem = reactExports.memo(GiftItemComponent, (xt, Cn) => xt.gift.id === Cn.gift.id && xt.state === Cn.state && xt.iconWidth === Cn.iconWidth && xt.compact === Cn.compact && xt.promoteEndAt === Cn.promoteEndAt)
  , container$l = "_container_1mblb_1"
  , containerMobile$1 = "_containerMobile_1mblb_7"
  , styles$16 = {
    container: container$l,
    containerMobile: containerMobile$1
}
  , container$k = "_container_19ria_1"
  , logoContainer$2 = "_logoContainer_19ria_10"
  , tooltipWrapper$5 = "_tooltipWrapper_19ria_22"
  , content$7 = "_content_19ria_31"
  , mainContainer$1 = "_mainContainer_19ria_44"
  , infoContainer$1 = "_infoContainer_19ria_51"
  , infoSmallText = "_infoSmallText_19ria_78"
  , buttonWrapper$1 = "_buttonWrapper_19ria_89"
  , buttonRow = "_buttonRow_19ria_99"
  , button$3 = "_button_19ria_89"
  , smallButton = "_smallButton_19ria_111"
  , friendsIcon = "_friendsIcon_19ria_116"
  , buttonContent$1 = "_buttonContent_19ria_121"
  , roundLabel = "_roundLabel_19ria_138"
  , giftsLabelText = "_giftsLabelText_19ria_157"
  , walletDisconnectIcon = "_walletDisconnectIcon_19ria_167"
  , imgContainer$1 = "_imgContainer_19ria_176"
  , loadingTitle$1 = "_loadingTitle_19ria_184"
  , brickImg = "_brickImg_19ria_194"
  , infoItem = "_infoItem_19ria_199"
  , divider$5 = "_divider_19ria_208"
  , mrktCopyButton = "_mrktCopyButton_19ria_213"
  , styles$15 = {
    container: container$k,
    logoContainer: logoContainer$2,
    tooltipWrapper: tooltipWrapper$5,
    content: content$7,
    mainContainer: mainContainer$1,
    infoContainer: infoContainer$1,
    infoSmallText,
    buttonWrapper: buttonWrapper$1,
    buttonRow,
    button: button$3,
    smallButton,
    friendsIcon,
    buttonContent: buttonContent$1,
    roundLabel,
    giftsLabelText,
    walletDisconnectIcon,
    imgContainer: imgContainer$1,
    loadingTitle: loadingTitle$1,
    brickImg,
    infoItem,
    divider: divider$5,
    mrktCopyButton
}
  , supportButtonWrapper = "_supportButtonWrapper_cxyju_1"
  , supportButtonContent = "_supportButtonContent_cxyju_7"
  , supportButton = "_supportButton_cxyju_1"
  , tooltipWrapper$4 = "_tooltipWrapper_cxyju_16"
  , styles$14 = {
    supportButtonWrapper,
    supportButtonContent,
    supportButton,
    tooltipWrapper: tooltipWrapper$4
}
  , SupportButton = ({className: xt, style: Cn}) => {
    const as = reactExports.useRef(null)
      , [cs,Cs] = reactExports.useState(0)
      , [Ls,Vs] = reactExports.useState(!1)
      , Ws = () => {
        as.current && clearTimeout(as.current),
        Ls ? (Vs(!1),
        Cs(Xs => Xs + 1),
        Vs(!0)) : (Cs(Xs => Xs + 1),
        Vs(!0)),
        as.current = setTimeout( () => {
            Vs(!1)
        }
        , 3e3)
    }
    ;
    return jsxRuntimeExports.jsx("div", {
        className: `${styles$14.supportButtonWrapper} ${xt || ""}`,
        style: Cn,
        children: jsxRuntimeExports.jsxs("div", {
            className: styles$14.supportButtonContent,
            children: [jsxRuntimeExports.jsx(Button, {
                size: "small",
                className: styles$14.supportButton,
                onClick: Ws,
                children: jsxRuntimeExports.jsx("img", {
                    src: "/icons/common/support.svg"
                })
            }), Ls && jsxRuntimeExports.jsx("div", {
                className: styles$14.tooltipWrapper,
                children: jsxRuntimeExports.jsx(Tooltip, {
                    translationKey: "pr_support_closed",
                    position: "bottom"
                }, cs)
            })]
        })
    })
}
  , truncateAddress = (xt, Cn=8) => {
    if (!xt)
        return "";
    const as = xt.slice(0, Cn)
      , cs = xt.slice(-Cn);
    return `${as}...${cs}`
}
  , SvgBrick = xt => reactExports.createElement("svg", {
    width: 45,
    height: 45,
    viewBox: "0 0 45 45",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("g", {
    id: "brick"
}, reactExports.createElement("g", {
    id: "brick_2"
}, reactExports.createElement("path", {
    id: "Vector",
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M42.9496 23.7904L16.0867 39.9998L2 31.1886V21.2135L16.0843 30.0539L43 13.8535L42.9496 23.7904Z",
    stroke: "#7E7E82",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector 295",
    d: "M16.0872 30.0205V39.9955",
    stroke: "#7E7E82",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_2",
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M16.0846 30.0357L43.0003 13.8353L28.9821 5L2.06641 21.2004L16.0846 30.0357Z",
    stroke: "#7E7E82",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_3",
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M35.7015 15.4184L29.6819 11.5946L32.3027 10.0153L38.3223 13.839L35.7015 15.4184ZM26.324 9.43338L28.9448 7.854L30.9513 9.14244L28.3306 10.7218L26.324 9.43338ZM27.5525 15.834L21.5329 12.0103L24.1537 10.4309L30.1733 14.2546L27.5525 15.834ZM16.7418 15.0028L19.3626 13.4234L21.3691 14.7118L18.7484 16.2912L16.7418 15.0028ZM17.4789 21.819L11.4593 17.9953L14.0801 16.4159L20.0997 20.2397L17.4789 21.819ZM6.66821 21.0294L9.28899 19.45L11.2955 20.7384L8.67474 22.3178L6.66821 21.0294ZM18.7893 25.5597L16.1685 27.1391L10.1489 23.3153L12.7697 21.7359L18.7893 25.5597ZM23.6623 22.6087L21.0415 24.1881L19.035 22.8997L21.6558 21.3203L23.6623 22.6087ZM22.8024 15.7509L28.822 19.5747L26.2012 21.154L20.1816 17.3303L22.8024 15.7509ZM33.7359 16.5822L31.1151 18.1615L29.1086 16.8731L31.7294 15.2937L33.7359 16.5822Z",
    stroke: "#7E7E82",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))))
  , boxedTimer = "_boxedTimer_1kaan_1"
  , timeBox = "_timeBox_1kaan_14"
  , value = "_value_1kaan_20"
  , label$3 = "_label_1kaan_30"
  , styles$13 = {
    boxedTimer,
    timeBox,
    value,
    label: label$3
}
  , Timer = () => {
    const {t: xt} = useTranslation()
      , Cn = Ws => Ws.toString().padStart(2, "0")
      , {serverTime: as, initialOffset: cs, startDate: Cs} = useStorage(Ws => ({
        serverTime: Ws.app.serverTime,
        initialOffset: Ws.app.initialOffset,
        startDate: Ws.app.startDate
    }))
      , [Ls,Vs] = reactExports.useState({
        days: 0,
        hours: 0,
        minutes: 0,
        seconds: 0
    });
    return reactExports.useEffect( () => {
        if (!as || cs === null || !Cs)
            return;
        const Ws = () => {
            const ga = new Date().getTime() + cs
              , ba = new Date(Cs).getTime() - ga;
            if (ba > 0) {
                const yl = Math.floor(ba / 36e5 / 24)
                  , xl = Math.floor(ba / (1e3 * 60 * 60) % 24)
                  , wl = Math.floor(ba / 1e3 / 60 % 60)
                  , _l = Math.floor(ba / 1e3 % 60);
                Vs({
                    days: yl,
                    hours: xl,
                    minutes: wl,
                    seconds: _l
                })
            } else
                Vs({
                    days: 0,
                    hours: 0,
                    minutes: 0,
                    seconds: 0
                })
        }
          , Xs = setInterval(Ws, 1e3);
        return Ws(),
        () => clearInterval(Xs)
    }
    , [Cs, as, cs]),
    jsxRuntimeExports.jsxs("div", {
        className: styles$13.boxedTimer,
        children: [jsxRuntimeExports.jsxs("div", {
            className: styles$13.timeBox,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$13.value,
                children: Cn(Ls.days)
            }), jsxRuntimeExports.jsx("div", {
                className: styles$13.label,
                children: xt("timer_days")
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$13.timeBox,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$13.value,
                children: Cn(Ls.hours)
            }), jsxRuntimeExports.jsx("div", {
                className: styles$13.label,
                children: xt("timer_hours")
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$13.timeBox,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$13.value,
                children: Cn(Ls.minutes)
            }), jsxRuntimeExports.jsx("div", {
                className: styles$13.label,
                children: xt("timer_minutes")
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$13.timeBox,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$13.value,
                children: Cn(Ls.seconds)
            }), jsxRuntimeExports.jsx("div", {
                className: styles$13.label,
                children: xt("timer_seconds")
            })]
        })]
    })
}
  , Wait = () => {
    const {refLink: xt, referralsWithWalletsCount: Cn, updateWallet: as, state: cs, getReferralShareMessageId: Cs, fetchGiftsCount: Ls, giftsCount: Vs, relayerBotName: Ws} = useStorage(Nl => ({
        refLink: Nl.profile.refUrl,
        referralsWithWalletsCount: Nl.referrals.referralsWithWalletsCount,
        updateWallet: Nl.wallet.updateWallet,
        state: Nl.app.state,
        getReferralShareMessageId: Nl.referrals.getReferralShareMessageId,
        fetchGiftsCount: Nl.profile.fetchGiftsCount,
        giftsCount: Nl.profile.giftsCount,
        relayerBotName: Nl.app.relayerBotName
    }));
    reactExports.useEffect( () => {
        Hc.hide()
    }
    , []);
    const {t: Xs} = useTranslation();
    useNavigate();
    const ga = useTonAddress(!0)
      , [ba] = useTonConnectUI()
      , yl = reactExports.useRef(null)
      , xl = reactExports.useRef(null)
      , [wl,_l] = reactExports.useState(0)
      , [El,Cl] = reactExports.useState(!1)
      , [$l,Sl] = reactExports.useState(!1)
      , Tl = () => {
        navigator.clipboard.writeText(xt || ""),
        yl.current && clearTimeout(yl.current),
        El ? (Cl(!1),
        _l(Nl => Nl + 1),
        Cl(!0)) : (_l(Nl => Nl + 1),
        Cl(!0)),
        yl.current = setTimeout( () => {
            Cl(!1)
        }
        , 1e3)
    }
      , Rl = () => {
        navigator.clipboard.writeText(`@${Ws}`),
        xl.current && clearTimeout(xl.current),
        $l ? (Sl(!1),
        _l(Nl => Nl + 1),
        Sl(!0)) : (_l(Nl => Nl + 1),
        Sl(!0)),
        xl.current = setTimeout( () => {
            Sl(!1)
        }
        , 1e3)
    }
      , Il = debounce(async () => {
        var Ll;
        const Nl = await Cs();
        ((Ll = window == null ? void 0 : window.Telegram) == null ? void 0 : Ll.WebApp).shareMessage(Nl, Fl => {
            logInfo(`Share message sent ${Fl}`)
        }
        )
    }
    , 3e3)
      , Ml = () => {
        ga ? ba.disconnect() : ba.openModal()
    }
    ;
    return reactExports.useEffect( () => {
        ga && cs === APP_STATE.READY && as(ga)
    }
    , [ga, cs]),
    reactExports.useEffect( () => {
        const Nl = setInterval(Ls, 6e4);
        return () => clearInterval(Nl)
    }
    , []),
    jsxRuntimeExports.jsxs("div", {
        className: styles$15.container,
        children: [jsxRuntimeExports.jsx(SupportButton, {
            style: {
                top: isMobile() ? "100px" : "16px"
            }
        }), jsxRuntimeExports.jsx("div", {
            className: styles$15.logoContainer,
            style: {
                paddingBottom: isMobile() ? "50px" : "16px"
            },
            children: jsxRuntimeExports.jsxs("div", {
                className: styles$15.content,
                children: [jsxRuntimeExports.jsxs("div", {
                    className: styles$15.mainContainer,
                    children: [jsxRuntimeExports.jsx("div", {
                        className: styles$15.imgContainer,
                        children: jsxRuntimeExports.jsx("img", {
                            style: {
                                width: isMobile() ? 176 : 100
                            },
                            src: "/icons/common/mrkt_logo.svg"
                        })
                    }), jsxRuntimeExports.jsx("div", {
                        className: styles$15.loadingTitle,
                        children: Xs("text_title_1")
                    })]
                }), jsxRuntimeExports.jsx(Timer, {}), jsxRuntimeExports.jsx("div", {
                    className: styles$15.infoContainer,
                    children: jsxRuntimeExports.jsxs("div", {
                        className: styles$15.buttonWrapper,
                        children: [jsxRuntimeExports.jsx("div", {
                            className: styles$15.infoItem,
                            children: jsxRuntimeExports.jsx(SvgBrick, {
                                className: styles$15.brickImg
                            })
                        }), jsxRuntimeExports.jsx("div", {
                            className: styles$15.infoItem,
                            children: jsxRuntimeExports.jsxs("div", {
                                className: styles$15.buttonRow,
                                children: [$l && jsxRuntimeExports.jsx("div", {
                                    className: styles$15.tooltipWrapper,
                                    children: jsxRuntimeExports.jsx(Tooltip, {
                                        translationKey: "tooltip_text_relayer_copied",
                                        postfixIcon: jsxRuntimeExports.jsx("img", {
                                            src: "/icons/common/like.svg"
                                        }),
                                        position: "top"
                                    }, wl)
                                }), jsxRuntimeExports.jsx("div", {
                                    className: styles$15.roundLabel,
                                    onClick: () => Oc(`https://t.me/${Ws}`),
                                    children: jsxRuntimeExports.jsx("span", {
                                        className: styles$15.giftsLabelText,
                                        children: Xs("preloader_gifts_stored", {
                                            counter: Vs
                                        })
                                    })
                                }), jsxRuntimeExports.jsx(Button, {
                                    className: styles$15.mrktCopyButton,
                                    onClick: Rl,
                                    children: jsxRuntimeExports.jsx("img", {
                                        src: "/icons/common/copy-white.svg"
                                    })
                                })]
                            })
                        }), jsxRuntimeExports.jsx("div", {
                            className: styles$15.divider
                        }), jsxRuntimeExports.jsxs("div", {
                            className: styles$15.infoItem,
                            children: [El && jsxRuntimeExports.jsx("div", {
                                className: styles$15.tooltipWrapper,
                                children: jsxRuntimeExports.jsx(Tooltip, {
                                    translationKey: "tooltip_text_link_copied",
                                    postfixIcon: jsxRuntimeExports.jsx("img", {
                                        src: "/icons/common/like.svg"
                                    }),
                                    position: "top"
                                }, wl)
                            }), jsxRuntimeExports.jsxs("div", {
                                className: styles$15.buttonRow,
                                children: [jsxRuntimeExports.jsx(Button, {
                                    className: styles$15.button,
                                    onClick: Il,
                                    children: jsxRuntimeExports.jsxs("div", {
                                        className: styles$15.buttonContent,
                                        children: [jsxRuntimeExports.jsx("img", {
                                            className: styles$15.friendsIcon,
                                            src: "/icons/common/profile-add-blue.svg"
                                        }), jsxRuntimeExports.jsxs("span", {
                                            children: [Xs("button_invite"), " (", Cn, ")"]
                                        })]
                                    })
                                }), jsxRuntimeExports.jsx(Button, {
                                    className: styles$15.smallButton,
                                    onClick: Tl,
                                    children: jsxRuntimeExports.jsx("img", {
                                        src: "/icons/common/copy-blue.svg"
                                    })
                                })]
                            }), jsxRuntimeExports.jsx("span", {
                                className: styles$15.infoSmallText,
                                children: Xs("text_info_2")
                            })]
                        }), jsxRuntimeExports.jsxs("div", {
                            className: styles$15.infoItem,
                            children: [ga ? jsxRuntimeExports.jsx("div", {
                                className: styles$15.buttonRow,
                                children: jsxRuntimeExports.jsxs("div", {
                                    className: styles$15.roundLabel,
                                    children: [truncateAddress(ga), jsxRuntimeExports.jsx("img", {
                                        onClick: Ml,
                                        src: "/icons/common/wallet-disconnect-grey.svg",
                                        className: styles$15.walletDisconnectIcon
                                    })]
                                })
                            }) : jsxRuntimeExports.jsx("div", {
                                className: styles$15.buttonRow,
                                children: jsxRuntimeExports.jsx(Button, {
                                    className: styles$15.button,
                                    onClick: Ml,
                                    children: jsxRuntimeExports.jsxs("div", {
                                        className: styles$15.buttonContent,
                                        children: [jsxRuntimeExports.jsx("img", {
                                            src: "/icons/common/wallet-blue.svg"
                                        }), jsxRuntimeExports.jsx("span", {
                                            children: Xs("button_connect_wallet")
                                        })]
                                    })
                                })
                            }), jsxRuntimeExports.jsx("span", {
                                className: styles$15.infoSmallText,
                                children: Xs("text_info_3")
                            })]
                        })]
                    })
                })]
            })
        })]
    })
}
  , Market = () => {
    const {addModal: xt, removeModal: Cn, shouldShowWaitScreen: as, isOnPrelaunch: cs, isAdmin: Cs} = useStorage(Vs => ({
        addModal: Vs.modal.addModal,
        removeModal: Vs.modal.removeModal,
        shouldShowWaitScreen: Vs.app.shouldShowWaitScreen,
        isOnPrelaunch: Vs.app.isOnPrelaunch,
        isAdmin: Vs.app.isAdmin
    }))
      , Ls = reactExports.useMemo( () => as && !(cs && Cs), [as, cs, Cs]);
    return reactExports.useEffect( () => {
        if (!Ls)
            return xt(ModalNames.SWEEP, 1e3),
            () => Cn(ModalNames.SWEEP)
    }
    , [xt, Cn, Ls]),
    Ls ? jsxRuntimeExports.jsx(Wait, {}) : jsxRuntimeExports.jsx(Page, {
        back: !1,
        children: jsxRuntimeExports.jsx("div", {
            className: classNames$1(styles$16.container, {
                [styles$16.containerMobile]: isMobile()
            }),
            children: jsxRuntimeExports.jsx(GiftList, {
                showPromoted: !0,
                state: GIFTS_LIST_STATE.PUBLIC
            })
        })
    })
}
  , myGiftsContainer = "_myGiftsContainer_13fpe_1"
  , giftListContainer = "_giftListContainer_13fpe_7"
  , styles$12 = {
    myGiftsContainer,
    giftListContainer
}
  , tabs = "_tabs_zyyvk_1"
  , tabsWrapper = "_tabsWrapper_zyyvk_6"
  , tab = "_tab_zyyvk_1"
  , active = "_active_zyyvk_29"
  , disabled$1 = "_disabled_zyyvk_33"
  , indicator = "_indicator_zyyvk_38"
  , styles$11 = {
    tabs,
    tabsWrapper,
    tab,
    active,
    disabled: disabled$1,
    indicator
}
  , Tabs = ({items: xt, activeKey: Cn, onChange: as, className: cs}) => {
    const Cs = reactExports.useRef({})
      , Ls = reactExports.useRef({})
      , Vs = reactExports.useRef(null)
      , Ws = reactExports.useRef(!1)
      , Xs = reactExports.useRef(Cn)
      , [ga,ba] = reactExports.useState({})
      , [yl,xl] = reactExports.useState(null)
      , [wl,_l] = reactExports.useState(null)
      , El = reactExports.useRef({})
      , Cl = reactExports.useCallback( () => {
        const Rl = Vs.current;
        if (!Rl)
            return;
        const Il = Rl.getBoundingClientRect()
          , Ml = {};
        Object.entries(Ls.current).forEach( ([Nl,Ll]) => {
            if (Ll) {
                const Fl = Ll.getBoundingClientRect();
                if (Cs.current[Nl]) {
                    const Dl = Fl.width + 20
                      , Zl = Fl.left - Il.left;
                    Ml[Nl] = {
                        left: Zl + Fl.width / 2 - Dl / 2,
                        width: Dl
                    }
                }
            }
        }
        ),
        El.current = Ml,
        ba(Ml)
    }
    , [])
      , $l = reactExports.useCallback(Rl => {
        const Il = El.current[Rl];
        Il && xl(Il)
    }
    , []);
    reactExports.useEffect( () => {
        Cl();
        const Rl = () => {
            Cl(),
            Cn && $l(Cn)
        }
        ;
        return window.addEventListener("resize", Rl),
        () => window.removeEventListener("resize", Rl)
    }
    , [Cl, Cn, $l]),
    reactExports.useEffect( () => {
        const Rl = setTimeout( () => {
            Cl(),
            Cn && $l(Cn)
        }
        , 50);
        return () => clearTimeout(Rl)
    }
    , [Cl, Cn, $l]),
    reactExports.useEffect( () => {
        const Rl = El.current[Cn];
        if (Rl && !yl && xl(Rl),
        !Ws.current && Cn !== Xs.current) {
            const Il = El.current[Cn]
              , Ml = El.current[Xs.current];
            Il && Ml && (_l(Ml),
            xl(Il)),
            Xs.current = Cn
        }
    }
    , [Cn, yl]);
    const Sl = reactExports.useCallback( (Rl, Il) => {
        if (!Il && Cn !== Rl) {
            const Ml = El.current[Rl]
              , Nl = El.current[Cn];
            Ml && Nl && (Ws.current = !0,
            _l(Nl),
            xl(Ml),
            as(Rl))
        }
    }
    , [Cn, as])
      , Tl = () => {
        Ws.current = !1,
        Cl(),
        Cn && $l(Cn)
    }
    ;
    return jsxRuntimeExports.jsx("div", {
        className: `${styles$11.tabs} ${cs || ""}`,
        children: jsxRuntimeExports.jsxs("div", {
            className: styles$11.tabsWrapper,
            ref: Vs,
            children: [xt.map(Rl => jsxRuntimeExports.jsx("div", {
                ref: Il => Cs.current[Rl.key] = Il,
                className: `${styles$11.tab} ${Cn === Rl.key ? styles$11.active : ""} ${Rl.disabled ? styles$11.disabled : ""}`,
                onClick: () => Sl(Rl.key, Rl.disabled),
                children: jsxRuntimeExports.jsx("span", {
                    ref: Il => Ls.current[Rl.key] = Il,
                    children: Rl.label
                })
            }, Rl.key)), jsxRuntimeExports.jsx(AnimatePresence, {
                children: yl && jsxRuntimeExports.jsx(motion.div, {
                    className: styles$11.indicator,
                    initial: wl ? {
                        x: wl.left,
                        width: wl.width,
                        opacity: 1
                    } : {
                        x: yl.left,
                        width: yl.width,
                        opacity: 1
                    },
                    animate: {
                        x: yl.left,
                        width: yl.width,
                        opacity: 1
                    },
                    transition: {
                        type: "spring",
                        stiffness: 1e3,
                        damping: 100
                    },
                    onAnimationComplete: Tl
                })
            })]
        })
    })
}
  , MyGifts = () => {
    const {t: xt} = useTranslation()
      , {currentTab: Cn, setCurrentTab: as, setMultipleMode: cs, clearSelectedItems: Cs} = useStorage(_l => _l.myGifts)
      , {addModal: Ls, removeModal: Vs, queue: Ws} = useStorage(_l => _l.modal)
      , Xs = useFilters()
      , ga = reactExports.useMemo( () => myGiftsInfiniteQueryOptions(Cn, Xs), [Cn, Xs])
      , {data: ba} = useInfiniteQuery(ga)
      , yl = reactExports.useMemo( () => {
        var _l;
        return ((_l = ba == null ? void 0 : ba.pages) == null ? void 0 : _l.flatMap(El => El)) ?? []
    }
    , [ba == null ? void 0 : ba.pages]);
    reactExports.useEffect( () => () => {
        as("listed"),
        Cs(),
        Vs(ModalNames.MY_GIFTS_ACTIONS),
        cs(null)
    }
    , []),
    reactExports.useEffect( () => {
        Cn === "listed" && (Cs(),
        Vs(ModalNames.MY_GIFTS_ACTIONS),
        cs(null))
    }
    , [Cn]),
    reactExports.useEffect( () => {
        Cn === "unlisted" && yl.length > 0 ? Ws.findIndex(El => El.name === ModalNames.MY_GIFTS_ACTIONS) !== -1 || Ls(ModalNames.MY_GIFTS_ACTIONS, 1e3) : Vs(ModalNames.MY_GIFTS_ACTIONS)
    }
    , [Cn, yl.length, Ws, Ls, Vs]);
    const xl = reactExports.useCallback(_l => as(_l), [as])
      , wl = reactExports.useMemo( () => Cn === "listed" ? GIFTS_LIST_STATE.LISTED : GIFTS_LIST_STATE.UNLISTED, [Cn]);
    return jsxRuntimeExports.jsx(Page, {
        back: !1,
        children: jsxRuntimeExports.jsxs("div", {
            className: styles$12.myGiftsContainer,
            children: [jsxRuntimeExports.jsx(Tabs, {
                items: [{
                    key: "listed",
                    label: xt("tab_listed")
                }, {
                    key: "unlisted",
                    label: xt("tab_unlisted")
                }],
                activeKey: Cn || "listed",
                onChange: xl
            }), jsxRuntimeExports.jsx("div", {
                className: styles$12.giftListContainer,
                children: jsxRuntimeExports.jsx(GiftList, {
                    state: wl
                })
            })]
        })
    })
}
  , profileContainer = "_profileContainer_3xkbc_1"
  , styles$10 = {
    profileContainer
}
  , SvgWallet = xt => reactExports.createElement("svg", {
    width: 12,
    height: 12,
    viewBox: "0 0 12 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M1 3.5C1 2.11929 2.11929 1 3.5 1H8.5C9.88071 1 11 2.11929 11 3.5V8.5C11 9.88071 9.88071 11 8.5 11H3.5C2.11929 11 1 9.88071 1 8.5V3.5ZM3.5 2C2.67157 2 2 2.67157 2 3.5V8.5C2 9.32843 2.67157 10 3.5 10H8.5C9.32843 10 10 9.32843 10 8.5V3.5C10 2.67157 9.32843 2 8.5 2H3.5Z",
    fill: "#7E7E82"
}), reactExports.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M5.5 6C5.5 4.89543 6.39543 4 7.5 4H10C10.5523 4 11 4.44772 11 5V7C11 7.55228 10.5523 8 10 8H7.5C6.39543 8 5.5 7.10457 5.5 6ZM7.5 5C6.94772 5 6.5 5.44772 6.5 6C6.5 6.55228 6.94772 7 7.5 7H10V5H7.5Z",
    fill: "#7E7E82"
}), reactExports.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M7 6C7 5.72386 7.22386 5.5 7.5 5.5L7.55 5.5C7.82614 5.5 8.05 5.72386 8.05 6C8.05 6.27614 7.82614 6.5 7.55 6.5L7.5 6.5C7.22386 6.5 7 6.27614 7 6Z",
    fill: "#7E7E82"
}))
  , balance$3 = "_balance_1prxr_1"
  , balanceMain = "_balanceMain_1prxr_8"
  , balanceTitle = "_balanceTitle_1prxr_14"
  , balanceAmount$1 = "_balanceAmount_1prxr_21"
  , balanceIcon$2 = "_balanceIcon_1prxr_27"
  , balanceValue$1 = "_balanceValue_1prxr_31"
  , balanceWallet = "_balanceWallet_1prxr_40"
  , expanded = "_expanded_1prxr_55"
  , walletAddress$1 = "_walletAddress_1prxr_59"
  , walletIcon$4 = "_walletIcon_1prxr_70"
  , styles$$ = {
    balance: balance$3,
    balanceMain,
    balanceTitle,
    balanceAmount: balanceAmount$1,
    balanceIcon: balanceIcon$2,
    balanceValue: balanceValue$1,
    balanceWallet,
    expanded,
    walletAddress: walletAddress$1,
    walletIcon: walletIcon$4
}
  , Balance = ({walletAddress: xt}) => {
    const {t: Cn} = useTranslation()
      , {hard: as} = useStorage(Cs => ({
        hard: Cs.wallet.balance.hard
    }))
      , cs = formatNanotons(as, !0);
    return jsxRuntimeExports.jsxs("div", {
        className: styles$$.balance,
        children: [jsxRuntimeExports.jsxs("div", {
            className: styles$$.balanceMain,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$$.balanceTitle,
                children: Cn("text_wallet_balance")
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$$.balanceAmount,
                children: [jsxRuntimeExports.jsx(SvgTonIcon, {
                    className: styles$$.balanceIcon
                }), jsxRuntimeExports.jsx("div", {
                    className: styles$$.balanceValue,
                    children: cs
                })]
            })]
        }), xt && jsxRuntimeExports.jsxs("div", {
            className: classNames$1(styles$$.balanceWallet, {
                [styles$$.expanded]: !!xt
            }),
            children: [jsxRuntimeExports.jsx(SvgWallet, {
                className: styles$$.walletIcon
            }), jsxRuntimeExports.jsx("div", {
                className: styles$$.walletAddress,
                children: truncateAddress(xt, 4)
            })]
        })]
    })
}
  , actions$4 = "_actions_jg7hz_1"
  , actionsItem = "_actionsItem_jg7hz_7"
  , actionsItemIcon = "_actionsItemIcon_jg7hz_14"
  , walletIcon$3 = "_walletIcon_jg7hz_19"
  , disabled = "_disabled_jg7hz_27"
  , tooltipWrapper$3 = "_tooltipWrapper_jg7hz_31"
  , styles$_ = {
    actions: actions$4,
    actionsItem,
    actionsItemIcon,
    walletIcon: walletIcon$3,
    disabled,
    tooltipWrapper: tooltipWrapper$3
}
  , SvgArrowUp = xt => reactExports.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M24 12C24 5.37258 18.6274 0 12 0C5.37258 0 0 5.37258 0 12C0 18.6274 5.37258 24 12 24C18.6274 24 24 18.6274 24 12ZM13.2428 17.5555C13.2428 18.1692 12.6864 18.6666 12 18.6666C11.3136 18.6666 10.7571 18.1692 10.7571 17.5555V9.12687L7.455 12.0789C6.96964 12.5128 6.1827 12.5128 5.69733 12.0789C5.21196 11.645 5.21196 10.9415 5.69733 10.5076L11.1211 5.65874C11.6065 5.22482 12.3934 5.22482 12.8788 5.65874L18.3026 10.5076C18.788 10.9415 18.788 11.645 18.3026 12.0789C17.8172 12.5128 17.0303 12.5128 16.5449 12.0789L13.2428 9.12687V17.5555Z",
    fill: "#F7F7F8"
}))
  , SvgArrowDown = xt => reactExports.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0C18.6274 0 24 5.37258 24 12ZM13.243 6.44442C13.243 5.83077 12.6865 5.3333 12.0001 5.3333C11.3137 5.3333 10.7572 5.83077 10.7572 6.44442V14.8731L7.45513 11.921C6.96976 11.4871 6.18283 11.4871 5.69746 11.921C5.21209 12.3549 5.21209 13.0584 5.69746 13.4924L11.1213 18.3412C11.6066 18.7751 12.3936 18.7751 12.8789 18.3412L18.3027 13.4924C18.7881 13.0584 18.7881 12.3549 18.3027 11.921C17.8174 11.4871 17.0304 11.4871 16.5451 11.921L13.243 14.8731V6.44442Z",
    fill: "#F7F7F8"
}))
  , SvgProfileAdd = xt => reactExports.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M18.5 19.5H14.5",
    stroke: "#F7F7F8",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M16.5 21.5V17.5",
    stroke: "#F7F7F8",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M12.16 10.87C12.06 10.86 11.94 10.86 11.83 10.87C9.44997 10.79 7.55997 8.84 7.55997 6.44C7.54997 3.99 9.53997 2 11.99 2C14.44 2 16.43 3.99 16.43 6.44C16.43 8.84 14.53 10.79 12.16 10.87Z",
    stroke: "#F7F7F8",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M11.99 21.81C10.17 21.81 8.36004 21.35 6.98004 20.43C4.56004 18.81 4.56004 16.17 6.98004 14.56C9.73004 12.72 14.24 12.72 16.99 14.56",
    stroke: "#F7F7F8",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))
  , SvgCopy = xt => reactExports.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M16 12.9V17.1C16 20.6 14.6 22 11.1 22H6.9C3.4 22 2 20.6 2 17.1V12.9C2 9.4 3.4 8 6.9 8H11.1C14.6 8 16 9.4 16 12.9Z",
    stroke: "#F7F7F8",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M22 6.9V11.1C22 14.6 20.6 16 17.1 16H16V12.9C16 9.4 14.6 8 11.1 8H8V6.9C8 3.4 9.4 2 12.9 2H17.1C20.6 2 22 3.4 22 6.9Z",
    stroke: "#F7F7F8",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))
  , SvgThumbsUp = xt => reactExports.createElement("svg", {
    width: 14,
    height: 14,
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("g", {
    clipPath: "url(#clip0_1275_1362)"
}, reactExports.createElement("path", {
    d: "M3.37 5.85001L5.91 1.79001C6.00843 1.62954 6.14675 1.4973 6.31149 1.40617C6.47622 1.31504 6.66175 1.26813 6.85 1.27001V1.27001C6.99826 1.26466 7.14608 1.28908 7.28474 1.34184C7.4234 1.39459 7.55008 1.47461 7.65729 1.57715C7.7645 1.6797 7.85006 1.8027 7.90893 1.93888C7.96779 2.07506 7.99876 2.22166 8 2.37001V5.28001H12.39C12.5522 5.28527 12.7115 5.32481 12.8573 5.39602C13.0032 5.46723 13.1323 5.56851 13.2362 5.69319C13.3401 5.81788 13.4164 5.96314 13.4602 6.11943C13.5039 6.27572 13.5141 6.43951 13.49 6.60001L12.69 11.76C12.6559 12.0358 12.5222 12.2896 12.3141 12.4737C12.106 12.6579 11.8379 12.7597 11.56 12.76H5C4.68771 12.7612 4.37949 12.6893 4.1 12.55L3.38 12.19",
    stroke: "#F7F7F8",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M3.37 5.85001V12.16",
    stroke: "#F7F7F8",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M1 5.85001H3.37V12.16H1C0.867392 12.16 0.740215 12.1073 0.646447 12.0136C0.552678 11.9198 0.5 11.7926 0.5 11.66V6.35001C0.5 6.2174 0.552678 6.09022 0.646447 5.99645C0.740215 5.90268 0.867392 5.85001 1 5.85001V5.85001Z",
    stroke: "#F7F7F8",
    strokeLinecap: "round",
    strokeLinejoin: "round"
})), reactExports.createElement("defs", null, reactExports.createElement("clipPath", {
    id: "clip0_1275_1362"
}, reactExports.createElement("rect", {
    width: 14,
    height: 14,
    fill: "white"
}))))
  , Actions = ({walletAddress: xt, onWalletClick: Cn}) => {
    const {addModal: as, getReferralShareMessageId: cs, hard: Cs, refUrl: Ls} = useStorage($l => ({
        addModal: $l.modal.addModal,
        getReferralShareMessageId: $l.referrals.getReferralShareMessageId,
        hard: $l.wallet.balance.hard,
        refUrl: $l.profile.refUrl
    }))
      , [Vs,Ws] = reactExports.useState(!1)
      , [Xs,ga] = reactExports.useState(!1)
      , {start: ba, clear: yl} = useTimeout( () => ga(!1), 3e3)
      , [xl] = useTonConnectUI()
      , wl = debounce(async () => {
        var $l;
        try {
            const Sl = await cs();
            await (($l = window == null ? void 0 : window.Telegram) == null ? void 0 : $l.WebApp).shareMessage(Sl, Tl => {
                logInfo(`Share message sent ${Tl}`)
            }
            )
        } finally {
            Ws(!1)
        }
    }
    , 3e3)
      , _l = () => {
        xt ? as(ModalNames.DEPOSIT) : xl.openModal()
    }
      , El = () => {
        ga(!0),
        yl(),
        ba(),
        window.navigator.clipboard.writeText(Ls)
    }
      , Cl = () => {
        xt ? as(ModalNames.WITHDRAW) : xl.openModal()
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$_.actions,
        children: [jsxRuntimeExports.jsx(Button, {
            className: styles$_.actionsItem,
            onClick: _l,
            children: jsxRuntimeExports.jsx(SvgArrowDown, {
                className: styles$_.actionsItemIcon
            })
        }), jsxRuntimeExports.jsx(Button, {
            className: styles$_.actionsItem,
            onClick: Cn,
            children: jsxRuntimeExports.jsx(SvgWallet, {
                className: classNames$1(styles$_.actionsItemIcon, styles$_.walletIcon)
            })
        }), jsxRuntimeExports.jsx(Button, {
            className: styles$_.actionsItem,
            onClick: () => {
                Ws(!0),
                wl()
            }
            ,
            loading: Vs,
            children: jsxRuntimeExports.jsx(SvgProfileAdd, {
                className: styles$_.actionsItemIcon
            })
        }), jsxRuntimeExports.jsxs(Button, {
            className: classNames$1(styles$_.actionsItem),
            onClick: El,
            children: [jsxRuntimeExports.jsx(SvgCopy, {
                className: styles$_.actionsItemIcon
            }), Xs && jsxRuntimeExports.jsx("div", {
                className: styles$_.tooltipWrapper,
                children: jsxRuntimeExports.jsx(Tooltip, {
                    postfixIcon: jsxRuntimeExports.jsx(SvgThumbsUp, {}),
                    translationKey: "text_invite_link_tooltip",
                    position: "top"
                })
            })]
        }), jsxRuntimeExports.jsx(Button, {
            disabled: !Cs,
            className: classNames$1(styles$_.actionsItem, !Cs && styles$_.disabled),
            onClick: Cl,
            children: jsxRuntimeExports.jsx(SvgArrowUp, {
                className: styles$_.actionsItemIcon
            })
        })]
    })
}
  , profileInfoContainer = "_profileInfoContainer_1wnjr_1"
  , profileInfoRow = "_profileInfoRow_1wnjr_7"
  , profileInfoItem = "_profileInfoItem_1wnjr_13"
  , profileInfoContent = "_profileInfoContent_1wnjr_22"
  , profileInfoLabelRow = "_profileInfoLabelRow_1wnjr_28"
  , profileInfoLabel = "_profileInfoLabel_1wnjr_28"
  , profileInfoValue = "_profileInfoValue_1wnjr_43"
  , profileInfoValueIcon = "_profileInfoValueIcon_1wnjr_52"
  , profileInfoIcon = "_profileInfoIcon_1wnjr_56"
  , tooltipWrapper$2 = "_tooltipWrapper_1wnjr_65"
  , achivementsContent = "_achivementsContent_1wnjr_70"
  , smallLabel = "_smallLabel_1wnjr_78"
  , achivement = "_achivement_1wnjr_70"
  , feeLabel = "_feeLabel_1wnjr_99"
  , styles$Z = {
    profileInfoContainer,
    profileInfoRow,
    profileInfoItem,
    profileInfoContent,
    profileInfoLabelRow,
    profileInfoLabel,
    profileInfoValue,
    profileInfoValueIcon,
    profileInfoIcon,
    tooltipWrapper: tooltipWrapper$2,
    achivementsContent,
    smallLabel,
    achivement,
    feeLabel
}
  , SvgInfoCircle = xt => reactExports.createElement("svg", {
    width: 17,
    height: 16,
    viewBox: "0 0 17 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M8.50004 14.6666C12.1667 14.6666 15.1667 11.6666 15.1667 7.99998C15.1667 4.33331 12.1667 1.33331 8.50004 1.33331C4.83337 1.33331 1.83337 4.33331 1.83337 7.99998C1.83337 11.6666 4.83337 14.6666 8.50004 14.6666Z",
    stroke: "#F7F7F8",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M8.5 5.33331V8.66665",
    stroke: "#F7F7F8",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M8.49634 10.6667H8.50233",
    stroke: "#F7F7F8",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))
  , SvgArrowRight = xt => reactExports.createElement("svg", {
    width: 9,
    height: 9,
    viewBox: "0 0 9 9",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M4.63636 8.31534L3.75852 7.44602L6.38778 4.81676H0V3.54688H6.38778L3.75852 0.921875L4.63636 0.0482953L8.76989 4.18182L4.63636 8.31534Z",
    fill: "#7E7E82"
}))
  , fetchReferralsCount = async () => await (await fetch(getApiUrl("/api/v1/referrals/with-wallet-count"))).json()
  , fetchReferralsRevenue = async () => await (await fetch(getApiUrl("/api/v1/referrals/total-revenue"))).json()
  , referralsCountQueryOptions = () => ({
    queryKey: [QueryKeys.referralsCount],
    queryFn: () => fetchReferralsCount(),
    placeholderData: 0
})
  , referralsTotalRevenueQueryOptions = () => ({
    queryKey: [QueryKeys.referralsRevenue],
    queryFn: () => fetchReferralsRevenue(),
    placeholderData: 0
})
  , fetchGiftsStats = async () => await (await fetch(getApiUrl("/api/v1/gift-statistics"))).json()
  , giftsStatsQueryOptions = () => ({
    queryKey: [QueryKeys.giftsStats],
    queryFn: async () => fetchGiftsStats(),
    refetchInterval: 60 * 1e3,
    refetchIntervalInBackground: !0
})
  , ProfileInfo = () => {
    const {t: xt} = useTranslation()
      , [Cn,as] = reactExports.useState(!1)
      , [cs,Cs] = reactExports.useState(!1)
      , Ls = reactExports.useRef(null)
      , Vs = reactExports.useRef(null)
      , {data: Ws} = useQuery(referralsCountQueryOptions())
      , {data: Xs} = useQuery(referralsTotalRevenueQueryOptions())
      , {data: ga} = useQuery(giftsStatsQueryOptions())
      , {referralRevenueCoef: ba, fee: yl, currentFee: xl} = useStorage(El => ({
        referralRevenueCoef: El.profile.referralRevenueCoef,
        fee: El.app.salesFee,
        currentFee: El.profile.salesFee
    }))
      , wl = () => {
        Ls.current && clearTimeout(Ls.current),
        Cn && as(!1),
        as(!0),
        Ls.current = setTimeout( () => {
            as(!1)
        }
        , 3e3)
    }
      , _l = () => {
        Vs.current && clearTimeout(Vs.current),
        cs && Cs(!1),
        Cs(!0),
        Vs.current = setTimeout( () => {
            Cs(!1)
        }
        , 3e3)
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$Z.profileInfoContainer,
        children: [jsxRuntimeExports.jsxs("div", {
            className: styles$Z.profileInfoRow,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$Z.profileInfoItem,
                children: jsxRuntimeExports.jsxs("div", {
                    className: styles$Z.profileInfoContent,
                    children: [jsxRuntimeExports.jsx("div", {
                        className: styles$Z.profileInfoLabel,
                        children: xt("tab_commission")
                    }), jsxRuntimeExports.jsxs("div", {
                        className: styles$Z.profileInfoValue,
                        children: [yl * 100, "%", " ", !!(ga != null && ga.userLevel) && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                            children: [jsxRuntimeExports.jsx(SvgArrowRight, {}), " ", jsxRuntimeExports.jsxs("span", {
                                className: styles$Z.feeLabel,
                                children: [xl, "%"]
                            })]
                        })]
                    })]
                })
            }), jsxRuntimeExports.jsx("div", {
                className: styles$Z.profileInfoItem,
                children: jsxRuntimeExports.jsxs("div", {
                    className: styles$Z.profileInfoContent,
                    children: [jsxRuntimeExports.jsx("div", {
                        className: styles$Z.profileInfoLabel,
                        children: xt("text_gifts_sold")
                    }), jsxRuntimeExports.jsx("div", {
                        className: styles$Z.profileInfoValue,
                        children: numberFormatter.format((ga == null ? void 0 : ga.amount) || 0)
                    })]
                })
            }), jsxRuntimeExports.jsx("div", {
                className: styles$Z.profileInfoItem,
                children: jsxRuntimeExports.jsxs("div", {
                    className: styles$Z.profileInfoContent,
                    children: [jsxRuntimeExports.jsx("div", {
                        className: styles$Z.profileInfoLabel,
                        children: xt("text_total_volume")
                    }), jsxRuntimeExports.jsxs("div", {
                        className: styles$Z.profileInfoValue,
                        children: [jsxRuntimeExports.jsx(SvgTonIcon, {
                            className: styles$Z.profileInfoValueIcon
                        }), formatNanotons((ga == null ? void 0 : ga.volume) || 0)]
                    })]
                })
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$Z.profileInfoRow,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$Z.profileInfoItem,
                children: jsxRuntimeExports.jsxs("div", {
                    className: styles$Z.profileInfoContent,
                    children: [jsxRuntimeExports.jsx("div", {
                        className: styles$Z.profileInfoLabel,
                        children: xt("text_referrals")
                    }), jsxRuntimeExports.jsx("div", {
                        className: styles$Z.profileInfoValue,
                        children: Ws
                    })]
                })
            }), jsxRuntimeExports.jsx("div", {
                className: styles$Z.profileInfoItem,
                children: jsxRuntimeExports.jsxs("div", {
                    className: styles$Z.profileInfoContent,
                    children: [jsxRuntimeExports.jsxs("div", {
                        className: styles$Z.profileInfoLabelRow,
                        children: [jsxRuntimeExports.jsx("div", {
                            className: styles$Z.profileInfoLabel,
                            onClick: wl,
                            children: xt("text_fee")
                        }), jsxRuntimeExports.jsx(SvgInfoCircle, {
                            className: styles$Z.profileInfoIcon,
                            onClick: wl
                        }), jsxRuntimeExports.jsx("div", {
                            className: styles$Z.tooltipWrapper,
                            children: Cn && jsxRuntimeExports.jsx(Tooltip, {
                                prefixIcon: jsxRuntimeExports.jsx(SvgInfoCircle, {
                                    className: styles$Z.profileInfoIcon
                                }),
                                translationKey: "text_fee_tooltip",
                                position: "top"
                            })
                        })]
                    }), jsxRuntimeExports.jsxs("div", {
                        className: styles$Z.profileInfoValue,
                        children: [ba * 100, "%"]
                    })]
                })
            }), jsxRuntimeExports.jsx("div", {
                className: styles$Z.profileInfoItem,
                children: jsxRuntimeExports.jsxs("div", {
                    className: styles$Z.profileInfoContent,
                    children: [jsxRuntimeExports.jsx("div", {
                        className: styles$Z.profileInfoLabel,
                        children: xt("text_revenue")
                    }), jsxRuntimeExports.jsxs("div", {
                        className: styles$Z.profileInfoValue,
                        children: [jsxRuntimeExports.jsx(SvgTonIcon, {
                            className: styles$Z.profileInfoValueIcon
                        }), formatNanotons(Xs ?? 0)]
                    })]
                })
            })]
        }), jsxRuntimeExports.jsx("div", {
            className: styles$Z.profileInfoRow,
            children: jsxRuntimeExports.jsx("div", {
                className: styles$Z.profileInfoItem,
                children: jsxRuntimeExports.jsxs("div", {
                    className: styles$Z.achivementsContent,
                    children: [jsxRuntimeExports.jsxs("div", {
                        className: styles$Z.profileInfoLabel,
                        children: [xt("tab_achievements"), " ", jsxRuntimeExports.jsx("span", {
                            className: styles$Z.smallLabel,
                            children: xt("tab_achievements_soon")
                        })]
                    }), jsxRuntimeExports.jsxs("div", {
                        className: styles$Z.profileInfoValue,
                        children: [jsxRuntimeExports.jsx("img", {
                            className: styles$Z.achivement,
                            src: "/images/achivements/early-bird.webp",
                            onClick: _l
                        }), jsxRuntimeExports.jsx("div", {
                            className: styles$Z.tooltipWrapper,
                            children: cs && jsxRuntimeExports.jsx(Tooltip, {
                                translationKey: "achievements_bird",
                                position: "top"
                            })
                        })]
                    })]
                })
            })
        })]
    })
}
  , profileEventsContainer = "_profileEventsContainer_1gnmd_1"
  , profileEventsWrapper = "_profileEventsWrapper_1gnmd_8"
  , eventItem = "_eventItem_1gnmd_14"
  , eventItemContainer = "_eventItemContainer_1gnmd_26"
  , eventItemContent = "_eventItemContent_1gnmd_41"
  , eventItemHeader = "_eventItemHeader_1gnmd_51"
  , eventItemTitle = "_eventItemTitle_1gnmd_60"
  , eventItemId = "_eventItemId_1gnmd_71"
  , eventItemFooter = "_eventItemFooter_1gnmd_82"
  , eventItemFooterLeft = "_eventItemFooterLeft_1gnmd_91"
  , eventItemPrice = "_eventItemPrice_1gnmd_96"
  , eventItemPriceIcon = "_eventItemPriceIcon_1gnmd_103"
  , eventItemPriceValue = "_eventItemPriceValue_1gnmd_111"
  , eventItemDate = "_eventItemDate_1gnmd_122"
  , eventItemDateIcon = "_eventItemDateIcon_1gnmd_129"
  , eventItemDateValue = "_eventItemDateValue_1gnmd_134"
  , eventItemAction = "_eventItemAction_1gnmd_145"
  , actionBuy = "_actionBuy_1gnmd_155"
  , actionSell = "_actionSell_1gnmd_158"
  , actionDeposit = "_actionDeposit_1gnmd_161"
  , actionWithdraw = "_actionWithdraw_1gnmd_164"
  , eventItemTransfer = "_eventItemTransfer_1gnmd_167"
  , eventItemTransferIcon = "_eventItemTransferIcon_1gnmd_174"
  , eventItemTransferContent = "_eventItemTransferContent_1gnmd_183"
  , eventItemTransferRight = "_eventItemTransferRight_1gnmd_189"
  , eventItemTransferAmount = "_eventItemTransferAmount_1gnmd_195"
  , eventItemTransferType = "_eventItemTransferType_1gnmd_200"
  , eventItemTransferStatus = "_eventItemTransferStatus_1gnmd_206"
  , eventItemTransferWarning = "_eventItemTransferWarning_1gnmd_212"
  , transferAmountDeposit = "_transferAmountDeposit_1gnmd_222"
  , transferAmountWithdraw = "_transferAmountWithdraw_1gnmd_226"
  , loadingTrigger = "_loadingTrigger_1gnmd_230"
  , emptyState = "_emptyState_1gnmd_239"
  , divider$4 = "_divider_1gnmd_253"
  , styles$Y = {
    profileEventsContainer,
    profileEventsWrapper,
    eventItem,
    eventItemContainer,
    eventItemContent,
    eventItemHeader,
    eventItemTitle,
    eventItemId,
    eventItemFooter,
    eventItemFooterLeft,
    eventItemPrice,
    eventItemPriceIcon,
    eventItemPriceValue,
    eventItemDate,
    eventItemDateIcon,
    eventItemDateValue,
    eventItemAction,
    actionBuy,
    actionSell,
    actionDeposit,
    actionWithdraw,
    eventItemTransfer,
    eventItemTransferIcon,
    eventItemTransferContent,
    eventItemTransferRight,
    eventItemTransferAmount,
    eventItemTransferType,
    eventItemTransferStatus,
    eventItemTransferWarning,
    transferAmountDeposit,
    transferAmountWithdraw,
    loadingTrigger,
    emptyState,
    divider: divider$4
}
  , SvgCalendar = xt => reactExports.createElement("svg", {
    width: 13,
    height: 14,
    viewBox: "0 0 13 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("g", {
    id: "calendar"
}, reactExports.createElement("g", {
    id: "vuesax/linear/calendar"
}, reactExports.createElement("g", {
    id: "calendar_2"
}, reactExports.createElement("path", {
    id: "Vector",
    d: "M4.33325 1.5835V3.20848",
    stroke: "#7E7E82",
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_2",
    d: "M8.66675 1.5835V3.20848",
    stroke: "#7E7E82",
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_3",
    d: "M1.89563 5.42389H11.1039",
    stroke: "#7E7E82",
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_4",
    d: "M11.3749 5.10425V9.70838C11.3749 11.3334 10.5624 12.4167 8.66662 12.4167H4.33331C2.43749 12.4167 1.625 11.3334 1.625 9.70838V5.10425C1.625 3.47926 2.43749 2.39594 4.33331 2.39594H8.66662C10.5624 2.39594 11.3749 3.47926 11.3749 5.10425Z",
    stroke: "#7E7E82",
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_5",
    d: "M8.50125 7.92073H8.50612",
    stroke: "#7E7E82",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_6",
    d: "M8.50125 9.54561H8.50612",
    stroke: "#7E7E82",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_7",
    d: "M6.49759 7.92073H6.50246",
    stroke: "#7E7E82",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_8",
    d: "M6.49759 9.54561H6.50246",
    stroke: "#7E7E82",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_9",
    d: "M4.49271 7.92073H4.49757",
    stroke: "#7E7E82",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_10",
    d: "M4.49271 9.54561H4.49757",
    stroke: "#7E7E82",
    strokeLinecap: "round",
    strokeLinejoin: "round"
})))))
  , SvgProfileRevenue = xt => reactExports.createElement("svg", {
    width: 37,
    height: 37,
    viewBox: "0 0 37 37",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M17.747 15.9676C17.609 15.9538 17.4435 15.9538 17.2918 15.9676C14.0088 15.8573 11.4018 13.1675 11.4018 9.85693C11.388 6.47743 14.133 3.73246 17.5125 3.73246C20.892 3.73246 23.6369 6.47743 23.6369 9.85693C23.6369 13.1675 21.0161 15.8573 17.747 15.9676Z",
    stroke: "#F7F7F8",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M17.5125 31.0581C15.002 31.0581 12.5053 30.4236 10.6017 29.1545C7.26362 26.9199 7.26362 23.2784 10.6017 21.0575C14.395 18.5195 20.6161 18.5195 24.4094 21.0575",
    stroke: "#F7F7F8",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M25.3381 31.3684C25.3381 32.1011 25.9004 32.6918 26.5991 32.6918H28.0247C28.6324 32.6918 29.1266 32.175 29.1266 31.5388C29.1266 30.8459 28.8255 30.6016 28.3768 30.4426L26.0879 29.6474C25.6392 29.4884 25.3381 29.2442 25.3381 28.5512C25.3381 27.9151 25.8323 27.3982 26.44 27.3982H27.8657C28.5643 27.3982 29.1266 27.9889 29.1266 28.7216",
    stroke: "#F7F7F8",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M27.2284 26.6372V33.453",
    stroke: "#F7F7F8",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M27.2283 35.7249C30.3652 35.7249 32.9081 33.182 32.9081 30.0451C32.9081 26.9082 30.3652 24.3653 27.2283 24.3653C24.0914 24.3653 21.5485 26.9082 21.5485 30.0451C21.5485 33.182 24.0914 35.7249 27.2283 35.7249Z",
    stroke: "#F7F7F8",
    strokeWidth: 1.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))
  , SvgGear = xt => reactExports.createElement("svg", {
    width: 25,
    height: 25,
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M12.5 15.625C14.2259 15.625 15.625 14.2259 15.625 12.5C15.625 10.7741 14.2259 9.375 12.5 9.375C10.7741 9.375 9.375 10.7741 9.375 12.5C9.375 14.2259 10.7741 15.625 12.5 15.625Z",
    stroke: "#F7F7F8",
    strokeWidth: 1.5,
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M2.08331 13.4166V11.5833C2.08331 10.5 2.96873 9.60414 4.06248 9.60414C5.9479 9.60414 6.71873 8.27081 5.77081 6.63539C5.22915 5.69789 5.55206 4.47914 6.49998 3.93747L8.30206 2.90622C9.12498 2.41664 10.1875 2.70831 10.6771 3.53122L10.7916 3.72914C11.7291 5.36456 13.2708 5.36456 14.2187 3.72914L14.3333 3.53122C14.8229 2.70831 15.8854 2.41664 16.7083 2.90622L18.5104 3.93747C19.4583 4.47914 19.7812 5.69789 19.2396 6.63539C18.2916 8.27081 19.0625 9.60414 20.9479 9.60414C22.0312 9.60414 22.9271 10.4896 22.9271 11.5833V13.4166C22.9271 14.5 22.0416 15.3958 20.9479 15.3958C19.0625 15.3958 18.2916 16.7291 19.2396 18.3646C19.7812 19.3125 19.4583 20.5208 18.5104 21.0625L16.7083 22.0937C15.8854 22.5833 14.8229 22.2916 14.3333 21.4687L14.2187 21.2708C13.2812 19.6354 11.7396 19.6354 10.7916 21.2708L10.6771 21.4687C10.1875 22.2916 9.12498 22.5833 8.30206 22.0937L6.49998 21.0625C5.55206 20.5208 5.22915 19.3021 5.77081 18.3646C6.71873 16.7291 5.9479 15.3958 4.06248 15.3958C2.96873 15.3958 2.08331 14.5 2.08331 13.4166Z",
    stroke: "#F7F7F8",
    strokeWidth: 1.5,
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))
  , SvgLightning = xt => reactExports.createElement("svg", {
    width: 25,
    height: 25,
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M6.41038 13.6267H9.59511V21.0475C9.59511 22.779 10.533 23.1294 11.677 21.8308L19.4791 12.9671C20.4376 11.8849 20.0357 10.9882 18.5824 10.9882H15.3977V3.5675C15.3977 1.836 14.4598 1.48557 13.3158 2.7842L5.5137 11.6479C4.5655 12.7404 4.96745 13.6267 6.41038 13.6267Z",
    stroke: "#F7F7F8",
    strokeWidth: 1.5,
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))
  , SvgGift = xt => reactExports.createElement("svg", {
    width: 47,
    height: 47,
    viewBox: "0 0 47 47",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("g", {
    id: "Saved Messages"
}, reactExports.createElement("path", {
    id: "Oval",
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M23.5 47C36.4787 47 47 36.4787 47 23.5C47 10.5213 36.4787 0 23.5 0C10.5213 0 0 10.5213 0 23.5C0 36.4787 10.5213 47 23.5 47Z",
    fill: "#1D2733"
}), reactExports.createElement("g", {
    id: "vuesax/linear/gift"
}, reactExports.createElement("g", {
    id: "gift"
}, reactExports.createElement("path", {
    id: "Vector",
    d: "M32.913 22.1116H14.6517V30.0372C14.6517 33.0093 15.7931 34 19.217 34H28.3477C31.7716 34 32.913 33.0093 32.913 30.0372V22.1116Z",
    stroke: "#F7F7F8",
    strokeWidth: 1.5,
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_2",
    d: "M34.6765 18.6583V19.7905C34.6765 21.036 34.0735 22.055 32.4009 22.055H15.3344C13.5936 22.055 13.0588 21.036 13.0588 19.7905V18.6583C13.0588 17.4129 13.5936 16.3939 15.3344 16.3939H32.4009C34.0735 16.3939 34.6765 17.4129 34.6765 18.6583Z",
    stroke: "#F7F7F8",
    strokeWidth: 1.5,
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_3",
    d: "M23.4581 16.3939H17.1776C16.7908 15.9749 16.8021 15.3296 17.2117 14.922L18.8274 13.3142C19.2483 12.8953 19.9424 12.8953 20.3634 13.3142L23.4581 16.3939Z",
    stroke: "#F7F7F8",
    strokeWidth: 1.5,
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    id: "Vector_4",
    d: "M30.5464 16.3939H24.2659L27.3607 13.3142C27.7816 12.8953 28.4757 12.8953 28.8967 13.3142L30.5123 14.922C30.9219 15.3296 30.9333 15.9749 30.5464 16.3939Z",
    stroke: "#F7F7F8",
    strokeWidth: 1.5,
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
})))))
  , formatDate = xt => {
    const Cn = new Date(xt)
      , as = Cn.getDate()
      , cs = Cn.toLocaleString("en-US", {
        month: "short"
    })
      , Cs = Cn.getHours().toString().padStart(2, "0")
      , Ls = Cn.getMinutes().toString().padStart(2, "0");
    return `${as} ${cs} ${Cs}:${Ls}`
}
  , EventItem = ({data: {type: xt, amount: Cn, price: as, gift: cs, date: Cs, status: Ls}}) => {
    const {t: Vs} = useTranslation()
      , Ws = xt === "income" || xt === "withdraw" || xt === "referral_revenue" || xt === "giveaway_sell_ticket" || xt === "giveaway_buy_ticket" || xt === "giveaway_create" || xt === "gift_promotion"
      , Xs = () => {
        switch (xt) {
        case "buy":
        case "put-on-giveaway":
            return styles$Y.actionBuy;
        case "sell":
        case "get-on-giveaway":
            return styles$Y.actionSell;
        case "income":
            return styles$Y.actionDeposit;
        case "withdraw":
            return styles$Y.actionWithdraw
        }
    }
      , ga = () => xt === "income" || xt === "referral_revenue" || xt === "giveaway_sell_ticket" || xt === "giveaway_buy_ticket" && !Cn ? styles$Y.transferAmountDeposit : xt === "withdraw" || xt === "giveaway_buy_ticket" && Cn || xt === "giveaway_create" || xt === "gift_promotion" ? styles$Y.transferAmountWithdraw : ""
      , ba = reactExports.useMemo( () => {
        switch (xt) {
        case "sell":
            return "status_sell";
        case "buy":
            return "status_buy";
        case "withdraw":
            return "operation_withdraw";
        case "income":
            return "operation_deposit";
        case "referral_revenue":
            return "status_referral_revenue";
        case "giveaway_sell_ticket":
            return "operation_giveaway_payout";
        case "giveaway_buy_ticket":
            return "operation_giveaway_ticket";
        case "giveaway_create":
            return "operation_giveaway_start";
        case "put-on-giveaway":
            return "status_sent";
        case "get-on-giveaway":
            return "status_recieve";
        case "gift_promotion":
            return "operation_gift_promote";
        default:
            return ""
        }
    }
    , [xt])
      , yl = reactExports.useMemo( () => {
        switch (xt) {
        case "income":
            return jsxRuntimeExports.jsx(SvgArrowDown, {});
        case "withdraw":
            return jsxRuntimeExports.jsx(SvgArrowUp, {});
        case "referral_revenue":
            return jsxRuntimeExports.jsx(SvgProfileRevenue, {});
        case "gift_promotion":
            return jsxRuntimeExports.jsx(SvgLightning, {});
        case "giveaway_buy_ticket":
        case "giveaway_create":
        case "giveaway_sell_ticket":
            return jsxRuntimeExports.jsx(SvgGift, {});
        default:
            return jsxRuntimeExports.jsx(SvgGear, {})
        }
    }
    , [xt])
      , xl = jsxRuntimeExports.jsxs("div", {
        className: styles$Y.eventItemTransfer,
        children: [jsxRuntimeExports.jsx("div", {
            className: styles$Y.eventItemTransferIcon,
            children: yl
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$Y.eventItemTransferContent,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$Y.eventItemTitle,
                children: Vs(ba)
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$Y.eventItemDate,
                children: [jsxRuntimeExports.jsx(SvgCalendar, {
                    className: styles$Y.eventItemDateIcon
                }), jsxRuntimeExports.jsx("div", {
                    className: styles$Y.eventItemDateValue,
                    children: formatDate(Cs)
                })]
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$Y.eventItemTransferRight,
            children: [jsxRuntimeExports.jsx("div", {
                className: `${styles$Y.eventItemTransferAmount} ${ga()}`,
                children: Cn ? `${`${(Cn ?? 0) < 0 ? "" : "+"}${formatNanotons(Cn || 0)}`} TON` : xt === "giveaway_buy_ticket" ? Vs("text_free") : ""
            }), Ws && Ls !== "None" && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [Ls === "Pending" && jsxRuntimeExports.jsx("div", {
                    className: styles$Y.eventItemTransferWarning,
                    children: Vs("status_pending")
                }), Ls === "Completed" && jsxRuntimeExports.jsx("div", {
                    className: styles$Y.eventItemTransferStatus,
                    children: Vs("status_success")
                }), Ls === "Canceled" && jsxRuntimeExports.jsx("div", {
                    className: styles$Y.eventItemTransferWarning,
                    children: Vs("status_canceled")
                })]
            })]
        })]
    })
      , wl = jsxRuntimeExports.jsxs("div", {
        className: styles$Y.eventItemContainer,
        children: [cs && jsxRuntimeExports.jsx(GiftIcon, {
            gift: cs,
            width: 47
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$Y.eventItemContent,
            children: [jsxRuntimeExports.jsxs("div", {
                className: styles$Y.eventItemHeader,
                children: [jsxRuntimeExports.jsx("div", {
                    className: styles$Y.eventItemTitle,
                    children: cs == null ? void 0 : cs.title
                }), jsxRuntimeExports.jsxs("div", {
                    className: styles$Y.eventItemId,
                    children: ["#", cs == null ? void 0 : cs.number]
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$Y.eventItemFooter,
                children: [jsxRuntimeExports.jsxs("div", {
                    className: styles$Y.eventItemFooterLeft,
                    children: [!!as && jsxRuntimeExports.jsxs("div", {
                        className: styles$Y.eventItemPrice,
                        children: [jsxRuntimeExports.jsx(SvgTonIcon, {
                            className: styles$Y.eventItemPriceIcon
                        }), jsxRuntimeExports.jsx("div", {
                            className: styles$Y.eventItemPriceValue,
                            children: formatNanotons(as || 0)
                        })]
                    }), jsxRuntimeExports.jsxs("div", {
                        className: styles$Y.eventItemDate,
                        children: [jsxRuntimeExports.jsx(SvgCalendar, {
                            className: styles$Y.eventItemDateIcon
                        }), jsxRuntimeExports.jsx("div", {
                            className: styles$Y.eventItemDateValue,
                            children: formatDate(Cs)
                        })]
                    })]
                }), jsxRuntimeExports.jsx("div", {
                    className: `${styles$Y.eventItemAction} ${Xs()}`,
                    children: Vs(ba)
                })]
            })]
        })]
    });
    return jsxRuntimeExports.jsx("div", {
        className: `${styles$Y.eventItem} ${Ws ? styles$Y.eventItemTransferType : ""}`,
        children: Ws ? xl : wl
    })
}
  , ProfileEvents = () => {
    const [xt,Cn] = reactExports.useState("history")
      , {t: as} = useTranslation()
      , {items: cs, fetchHistory: Cs, isLoading: Ls, hasReachedEnd: Vs, pendingWithdrawals: Ws, processedItems: Xs, startPendingWithdrawPolling: ga, stopPendingWithdrawPolling: ba} = useStorage(wl => ({
        items: wl.history.items,
        fetchHistory: wl.history.fetchHistory,
        isLoading: wl.history.isLoading,
        hasReachedEnd: wl.history.hasReachedEnd,
        pendingWithdrawals: wl.history.pendingWithdrawals,
        processedItems: wl.history.processedItems,
        startPendingWithdrawPolling: wl.withdraw.startPendingWithdrawPolling,
        stopPendingWithdrawPolling: wl.withdraw.stopPendingWithdrawPolling
    }));
    reactExports.useEffect( () => {
        Cs(!0)
    }
    , []),
    reactExports.useEffect( () => (Ws.length > 0 && ga(),
    () => {
        ba()
    }
    ), [Ws.length]);
    const yl = reactExports.useRef(null)
      , xl = wl => {
        wl[0].isIntersecting && !Vs && Cs()
    }
    ;
    return reactExports.useEffect( () => {
        const wl = {
            root: null,
            rootMargin: "0px",
            threshold: .1
        }
          , _l = new IntersectionObserver(xl,wl);
        return yl.current && _l.observe(yl.current),
        () => {
            yl.current && _l.unobserve(yl.current)
        }
    }
    , [xl]),
    jsxRuntimeExports.jsxs("div", {
        className: styles$Y.profileEventsContainer,
        children: [jsxRuntimeExports.jsx(Tabs, {
            items: [{
                key: "history",
                label: as("tab_history")
            }, {
                key: "activities",
                label: as("tab_activities"),
                disabled: !0
            }],
            activeKey: xt,
            onChange: wl => Cn(wl)
        }), xt === "history" ? jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: cs.length ? jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                children: jsxRuntimeExports.jsxs("div", {
                    className: styles$Y.profileEventsWrapper,
                    children: [Ws.map(wl => jsxRuntimeExports.jsx(EventItem, {
                        data: wl
                    }, wl.date)), !!Ws.length && jsxRuntimeExports.jsx("div", {
                        className: styles$Y.divider
                    }), Xs.map(wl => jsxRuntimeExports.jsx(EventItem, {
                        data: wl
                    }, wl.date)), jsxRuntimeExports.jsxs("div", {
                        ref: yl,
                        className: styles$Y.loadingTrigger,
                        children: [Xs.length > 0 && !Vs && jsxRuntimeExports.jsx("div", {
                            className: styles$Y.loader
                        }), !Vs && jsxRuntimeExports.jsx(Spinner, {
                            size: 12
                        })]
                    })]
                })
            }) : jsxRuntimeExports.jsx("div", {
                className: styles$Y.emptyState,
                children: Ls ? jsxRuntimeExports.jsx(Spinner, {}) : jsxRuntimeExports.jsx("div", {
                    children: as("tab_blank_history")
                })
            })
        }) : jsxRuntimeExports.jsx("div", {})]
    })
}
  , container$j = "_container_1yhpx_1"
  , button$2 = "_button_1yhpx_7"
  , buttonContent = "_buttonContent_1yhpx_10"
  , buttonIconSmall = "_buttonIconSmall_1yhpx_17"
  , styles$X = {
    container: container$j,
    button: button$2,
    buttonContent,
    buttonIconSmall
}
  , SvgTelegramLogo = xt => reactExports.createElement("svg", {
    width: 20,
    height: 18,
    viewBox: "0 0 20 18",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M2.23741 7.8879L2.53166 8.57776L2.54338 8.57276L2.55493 8.56737L2.23741 7.8879ZM11.9033 3.42212L11.5978 2.73719L11.9033 3.42212ZM18.0861 1.00013L18.072 0.250259L18.0861 1.00013ZM18.7284 1.20682L19.2208 0.641078V0.641078L18.7284 1.20682ZM18.9643 1.68826L18.2237 1.80643V1.80643L18.9643 1.68826ZM18.992 2.38811L19.7391 2.4544L18.992 2.38811ZM17.1142 15.1694L17.853 15.2983L17.1142 15.1694ZM15.9815 16.9921L15.9078 16.2457L15.9815 16.9921ZM13.3558 15.6543L12.9244 16.2679V16.2679L13.3558 15.6543ZM9.65691 12.9893L9.22401 13.6018L9.65691 12.9893ZM10.0139 10.158L10.572 10.659L10.0139 10.158ZM13.0638 6.58285L13.6361 7.06758C13.8708 6.79049 13.8733 6.38509 13.642 6.10515C13.4107 5.82522 13.0121 5.75117 12.6957 5.92937L13.0638 6.58285ZM7.16938 9.97978L6.72952 9.37227L6.7246 9.37589L7.16938 9.97978ZM5.37193 10.6919L5.35455 11.4417L5.37193 10.6919ZM2.79548 10.038L3.04239 9.32976L2.79548 10.038ZM1.00436 8.87009L1.74929 8.95716L1.00436 8.87009ZM2.55493 8.56737C7.38778 6.30892 10.6038 4.82314 12.2089 4.10705L11.5978 2.73719C9.97863 3.45953 6.75069 4.95094 1.91988 7.20843L2.55493 8.56737ZM12.2089 4.10705C14.5132 3.07902 15.8865 2.48404 16.7591 2.1444C17.6461 1.79915 17.9328 1.75316 18.1003 1.74999L18.072 0.250259C17.616 0.258875 17.1128 0.397129 16.215 0.746551C15.3028 1.10159 13.8964 1.71172 11.5978 2.73719L12.2089 4.10705ZM18.1003 1.74999C18.0989 1.75002 18.1109 1.74989 18.1325 1.75232C18.1533 1.75466 18.1762 1.75861 18.198 1.76421C18.2202 1.7699 18.2356 1.7758 18.2441 1.77983C18.2528 1.78392 18.248 1.783 18.236 1.77255L19.2208 0.641078C19.0027 0.451247 18.7548 0.358423 18.5704 0.31116C18.3826 0.263035 18.204 0.247764 18.072 0.250259L18.1003 1.74999ZM18.236 1.77255C18.2271 1.76477 18.2197 1.75617 18.2145 1.74852C18.2095 1.7413 18.2079 1.73709 18.2084 1.73822C18.2089 1.73959 18.2111 1.74525 18.2141 1.757C18.217 1.76892 18.2201 1.78425 18.2237 1.80643L19.7049 1.57009C19.6769 1.39431 19.5972 0.968738 19.2208 0.641078L18.236 1.77255ZM18.2237 1.80643C18.2298 1.84474 18.2399 1.93162 18.2457 2.03844C18.2516 2.14601 18.2515 2.24752 18.2449 2.32182L19.7391 2.4544C19.768 2.12859 19.7334 1.74855 19.7049 1.57009L18.2237 1.80643ZM18.2449 2.32182C17.9987 5.09721 16.9248 11.8897 16.3753 15.0406L17.853 15.2983C18.4017 12.1522 19.4865 5.30119 19.7391 2.4544L18.2449 2.32182ZM16.3753 15.0406C16.2688 15.6513 16.1232 15.9756 16.0126 16.1335C15.9162 16.271 15.8746 16.249 15.9078 16.2457L16.0551 17.7384C16.5312 17.6915 16.9398 17.4242 17.241 16.9943C17.5279 16.585 17.7272 16.0198 17.853 15.2983L16.3753 15.0406ZM15.9078 16.2457C15.6644 16.2697 15.4123 16.1939 15.0571 15.9701C14.8782 15.8574 14.6926 15.7198 14.4785 15.5567C14.2719 15.3993 14.0354 15.2153 13.7872 15.0408L12.9244 16.2679C13.1423 16.4211 13.3467 16.5801 13.5694 16.7498C13.7847 16.9138 14.0168 17.0875 14.2574 17.2392C14.7414 17.5441 15.336 17.8094 16.0551 17.7384L15.9078 16.2457ZM13.7872 15.0408C13.0636 14.5321 12.4975 14.1194 11.9327 13.7069C11.3678 13.2943 10.8033 12.8812 10.0898 12.3769L9.22401 13.6018C9.92656 14.0984 10.4821 14.5049 11.048 14.9182C11.6139 15.3315 12.1892 15.7509 12.9244 16.2679L13.7872 15.0408ZM10.0898 12.3769C9.72294 12.1176 9.60097 11.9496 9.56552 11.8768C9.55238 11.8498 9.54978 11.8536 9.56622 11.8134C9.60091 11.7286 9.68988 11.5984 9.88755 11.3827C9.98159 11.2801 10.0844 11.1744 10.203 11.0517C10.3185 10.9322 10.4454 10.8 10.572 10.659L9.45578 9.657C9.34923 9.7757 9.23905 9.89064 9.12436 10.0093C9.01285 10.1247 8.89256 10.2482 8.78158 10.3694C8.56918 10.6012 8.32036 10.8971 8.17782 11.2456C8.01704 11.6388 7.99777 12.0833 8.21683 12.5333C8.41358 12.9375 8.77266 13.2828 9.22401 13.6018L10.0898 12.3769ZM6.7246 9.37589C6.12974 9.81402 5.6927 9.94914 5.3893 9.94211L5.35455 11.4417C6.1248 11.4596 6.88605 11.1199 7.61415 10.5837L6.7246 9.37589ZM5.3893 9.94211C5.19095 9.93752 4.83395 9.8699 4.37393 9.74618C3.93265 9.62749 3.45477 9.47354 3.04239 9.32976L2.54856 10.7461C2.98246 10.8974 3.4969 11.0636 3.98433 11.1947C4.45302 11.3208 4.96111 11.4326 5.35455 11.4417L5.3893 9.94211ZM3.04239 9.32976C2.46267 9.12764 2.09276 9.02003 1.82952 8.88326C1.7094 8.82085 1.69227 8.79028 1.70549 8.80771C1.73867 8.85145 1.7539 8.91773 1.74929 8.95716L0.259432 8.78302C0.218906 9.12976 0.310317 9.45045 0.510409 9.71423C0.690545 9.95171 0.931062 10.1068 1.13796 10.2143C1.52874 10.4174 2.0903 10.5864 2.54856 10.7461L3.04239 9.32976ZM1.74929 8.95716C1.73415 9.08669 1.66424 9.08557 1.80797 8.97108C1.93832 8.86725 2.16798 8.73288 2.53166 8.57776L1.94315 7.19803C1.52222 7.37757 1.15407 7.57424 0.873395 7.79781C0.606115 8.01071 0.311988 8.33336 0.259432 8.78302L1.74929 8.95716ZM10.572 10.659C10.7743 10.4336 11.5462 9.52863 12.2554 8.69451C12.6127 8.27426 12.9579 7.86754 13.2137 7.56592C13.3416 7.4151 13.4472 7.29054 13.5208 7.20367C13.5576 7.16024 13.5864 7.12622 13.606 7.10307C13.6159 7.09149 13.6234 7.08262 13.6284 7.07665C13.631 7.07366 13.6329 7.07139 13.6342 7.06988C13.6348 7.06912 13.6353 7.06854 13.6356 7.06816C13.6358 7.06797 13.6359 7.06782 13.636 7.06773C13.636 7.06768 13.6361 7.06764 13.6361 7.06762C13.6361 7.06759 13.6361 7.06758 13.0638 6.58285C12.4915 6.09812 12.4915 6.09813 12.4915 6.09815C12.4914 6.09818 12.4914 6.09821 12.4914 6.09826C12.4913 6.09835 12.4912 6.09849 12.491 6.09868C12.4907 6.09906 12.4902 6.09963 12.4896 6.10038C12.4883 6.10189 12.4864 6.10414 12.4839 6.10711C12.4788 6.11306 12.4713 6.1219 12.4616 6.13345C12.442 6.15656 12.4132 6.19051 12.3765 6.23388C12.3029 6.32063 12.1975 6.44505 12.0697 6.59571C11.8141 6.89704 11.4694 7.30326 11.1126 7.72289C10.3937 8.56852 9.6406 9.4511 9.45578 9.657L10.572 10.659ZM13.0638 6.58285C12.6957 5.92937 12.6957 5.92939 12.6957 5.92941C12.6956 5.92943 12.6956 5.92947 12.6955 5.92952C12.6953 5.92961 12.6951 5.92976 12.6947 5.92994C12.6941 5.93032 12.6931 5.93088 12.6918 5.93162C12.6891 5.93309 12.6852 5.93529 12.6801 5.9382C12.6698 5.944 12.6545 5.95261 12.6346 5.96385C12.5947 5.98632 12.5362 6.01931 12.4616 6.0614C12.3124 6.14559 12.0987 6.26623 11.8409 6.41206C11.3252 6.70369 10.6325 7.09627 9.92466 7.49978C9.21714 7.9031 8.49299 8.3182 7.91503 8.65461C7.36025 8.97752 6.88791 9.25762 6.72954 9.37229L7.60922 10.5873C7.60921 10.5873 7.60939 10.5871 7.60978 10.5869C7.61017 10.5866 7.61073 10.5862 7.61147 10.5857C7.61298 10.5846 7.61506 10.5832 7.61778 10.5813C7.62328 10.5776 7.63056 10.5727 7.63986 10.5666C7.65861 10.5543 7.68286 10.5388 7.71302 10.5198C7.77341 10.482 7.85168 10.4341 7.94653 10.3771C8.13599 10.2632 8.38332 10.1176 8.6696 9.951C9.24171 9.61799 9.96126 9.20552 10.6675 8.80292C11.3734 8.40053 12.0646 8.00885 12.5793 7.71771C12.8367 7.57215 13.0499 7.45177 13.1987 7.36779C13.2731 7.3258 13.3315 7.29291 13.3712 7.27053C13.391 7.25934 13.4062 7.25078 13.4164 7.24502C13.4215 7.24214 13.4254 7.23996 13.428 7.2385C13.4293 7.23777 13.4303 7.23723 13.4309 7.23686C13.4312 7.23668 13.4315 7.23654 13.4316 7.23645C13.4317 7.23641 13.4318 7.23638 13.4318 7.23635C13.4318 7.23633 13.4319 7.23632 13.0638 6.58285Z",
    fill: "#0A84FF"
}))
  , SvgBoost = xt => reactExports.createElement("svg", {
    width: 21,
    height: 20,
    viewBox: "0 0 21 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M5.94025 10.8959H8.0634V15.9355C8.0634 17.1114 8.68867 17.3494 9.45136 16.4674L14.6527 10.448C15.2918 9.71303 15.0238 9.10408 14.055 9.10408H11.9318V4.06452C11.9318 2.88862 11.3065 2.65064 10.5439 3.53257L5.34247 9.55204C4.71033 10.294 4.9783 10.8959 5.94025 10.8959Z",
    stroke: "#0A84FF",
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))
  , ProfileLinks = () => {
    const {t: xt} = useTranslation()
      , Cn = () => {
        Oc(xt("button_mrkt_channel_link"))
    }
      , as = () => {
        Oc(xt("button_mrkt_boost_link"))
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$X.container,
        children: [jsxRuntimeExports.jsx(Button, {
            onClick: Cn,
            className: styles$X.button,
            children: jsxRuntimeExports.jsxs("div", {
                className: styles$X.buttonContent,
                children: [xt("button_mrkt_channel"), jsxRuntimeExports.jsx(SvgTelegramLogo, {
                    className: styles$X.buttonIconSmall
                })]
            })
        }), jsxRuntimeExports.jsx(Button, {
            onClick: as,
            className: styles$X.button,
            children: jsxRuntimeExports.jsxs("div", {
                className: styles$X.buttonContent,
                children: [xt("button_mrkt_boost"), jsxRuntimeExports.jsx(SvgBoost, {})]
            })
        })]
    })
}
  , progressBarContainer = "_progressBarContainer_19vi9_1"
  , progressBarHeaderContainer = "_progressBarHeaderContainer_19vi9_8"
  , progressBarHeaderItemWrapper = "_progressBarHeaderItemWrapper_19vi9_15"
  , headerText = "_headerText_19vi9_21"
  , highlighted$1 = "_highlighted_19vi9_30"
  , betaTag = "_betaTag_19vi9_38"
  , progressBarWrapper = "_progressBarWrapper_19vi9_54"
  , progressBarLabel = "_progressBarLabel_19vi9_63"
  , tooltipWrapper$1 = "_tooltipWrapper_19vi9_73"
  , styles$W = {
    progressBarContainer,
    progressBarHeaderContainer,
    progressBarHeaderItemWrapper,
    headerText,
    highlighted: highlighted$1,
    betaTag,
    progressBarWrapper,
    progressBarLabel,
    tooltipWrapper: tooltipWrapper$1
}
  , ProgressBar = () => {
    const {t: xt} = useTranslation()
      , {tradingVolumeLevels: Cn} = useStorage(Xs => ({
        tradingVolumeLevels: Xs.app.tradingVolumeLevels
    }))
      , {data: as} = useQuery(giftsStatsQueryOptions())
      , cs = (as == null ? void 0 : as.volume) || 0
      , Cs = (as == null ? void 0 : as.userLevel) || 0
      , Vs = ( () => {
        const Xs = Number(Cn[Cs - 1])
          , ga = Number(Cn[Cs])
          , ba = cs - Xs
          , yl = ga - Xs;
        return Math.max(Math.min(ba / yl * 100, 100), 0)
    }
    )()
      , Ws = Cs >= Cn.length;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$W.progressBarContainer,
        children: [jsxRuntimeExports.jsxs("div", {
            className: styles$W.progressBarHeaderContainer,
            children: [jsxRuntimeExports.jsx(LevelDisplay, {
                currentLevel: Cs
            }), jsxRuntimeExports.jsx(VolumeDisplay, {
                volume: cs,
                currentLevel: Cs,
                isMaxLevel: Ws,
                tradingVolumeLevels: Cn
            })]
        }), jsxRuntimeExports.jsx(ProgressBarVisual, {
            progressPercentage: Vs
        })]
    })
}
  , LevelDisplay = ({currentLevel: xt}) => {
    const {t: Cn} = useTranslation();
    return jsxRuntimeExports.jsxs("div", {
        className: styles$W.progressBarHeaderItemWrapper,
        children: [jsxRuntimeExports.jsx("span", {
            className: classNames$1(styles$W.headerText, styles$W.highlighted),
            children: xt
        }), jsxRuntimeExports.jsx("span", {
            className: styles$W.headerText,
            children: Cn("trading_level")
        })]
    })
}
  , VolumeDisplay = ({volume: xt, currentLevel: Cn, isMaxLevel: as, tradingVolumeLevels: cs}) => {
    const {t: Cs} = useTranslation()
      , Ls = reactExports.useRef(null)
      , [Vs,Ws] = reactExports.useState(!1)
      , Xs = () => {
        Ls.current && clearTimeout(Ls.current),
        Vs && Ws(!1),
        Ws(!0),
        Ls.current = setTimeout( () => {
            Ws(!1)
        }
        , 3e3)
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$W.progressBarHeaderItemWrapper,
        children: [jsxRuntimeExports.jsx("span", {
            className: classNames$1(styles$W.headerText, styles$W.highlighted),
            children: formatNanotons(xt)
        }), !as && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [jsxRuntimeExports.jsx("span", {
                className: styles$W.headerText,
                children: Cs("/")
            }), jsxRuntimeExports.jsx("span", {
                className: styles$W.headerText,
                children: formatNanotons(Number(cs[Cn]))
            })]
        }), jsxRuntimeExports.jsx("span", {
            className: styles$W.betaTag,
            onClick: Xs,
            children: Cs("trading_level_beta")
        }), jsxRuntimeExports.jsx("div", {
            className: styles$W.tooltipWrapper,
            children: Vs && jsxRuntimeExports.jsx(Tooltip, {
                prefixIcon: jsxRuntimeExports.jsx(SvgInfoCircle, {}),
                translationKey: "trading_level_tooltip",
                position: "top"
            })
        })]
    })
}
  , ProgressBarVisual = ({progressPercentage: xt}) => jsxRuntimeExports.jsx("div", {
    className: styles$W.progressBarWrapper,
    children: jsxRuntimeExports.jsx("div", {
        className: styles$W.progressBarLabel,
        style: {
            width: `${xt}%`
        }
    })
})
  , Profile = () => {
    const {addModal: xt} = useStorage(Cs => ({
        addModal: Cs.modal.addModal
    }))
      , Cn = useTonAddress(!0)
      , [as] = useTonConnectUI()
      , cs = () => {
        Cn ? xt(ModalNames.WALLET_DISCONNECT_COFIRM) : as.openModal()
    }
    ;
    return jsxRuntimeExports.jsx(Page, {
        back: !0,
        children: jsxRuntimeExports.jsxs("div", {
            className: styles$10.profileContainer,
            children: [jsxRuntimeExports.jsx(Balance, {
                walletAddress: Cn
            }), jsxRuntimeExports.jsx(Actions, {
                walletAddress: Cn,
                onWalletClick: cs
            }), jsxRuntimeExports.jsx(ProgressBar, {}), jsxRuntimeExports.jsx(ProfileInfo, {}), jsxRuntimeExports.jsx(ProfileLinks, {}), jsxRuntimeExports.jsx(ProfileEvents, {})]
        })
    })
}
  , container$i = "_container_1o0kc_1"
  , containerMobile = "_containerMobile_1o0kc_8"
  , spinnerWrapper = "_spinnerWrapper_1o0kc_12"
  , virtuosoGrid = "_virtuosoGrid_1o0kc_16"
  , virtuosoItem = "_virtuosoItem_1o0kc_22"
  , virtualizer = "_virtualizer_1o0kc_28"
  , styles$V = {
    container: container$i,
    containerMobile,
    spinnerWrapper,
    virtuosoGrid,
    virtuosoItem,
    virtualizer
}
  , eventContainer = "_eventContainer_15n3t_1"
  , eventInfo = "_eventInfo_15n3t_8"
  , eventHeader = "_eventHeader_15n3t_14"
  , eventFooter = "_eventFooter_15n3t_18"
  , eventFooterRight = "_eventFooterRight_15n3t_22"
  , eventPrice = "_eventPrice_15n3t_27"
  , eventPriceIcon = "_eventPriceIcon_15n3t_35"
  , eventName = "_eventName_15n3t_42"
  , eventDate$1 = "_eventDate_15n3t_47"
  , eventDateIcon$1 = "_eventDateIcon_15n3t_54"
  , eventNumber = "_eventNumber_15n3t_58"
  , eventType = "_eventType_15n3t_62"
  , sale = "_sale_15n3t_67"
  , floor$1 = "_floor_15n3t_67"
  , auction = "_auction_15n3t_70"
  , bid = "_bid_15n3t_70"
  , listing = "_listing_15n3t_73"
  , eventShareButton = "_eventShareButton_15n3t_76"
  , styles$U = {
    eventContainer,
    eventInfo,
    eventHeader,
    eventFooter,
    eventFooterRight,
    eventPrice,
    eventPriceIcon,
    eventName,
    eventDate: eventDate$1,
    eventDateIcon: eventDateIcon$1,
    eventNumber,
    eventType,
    sale,
    floor: floor$1,
    auction,
    bid,
    listing,
    eventShareButton
}
  , FeedEvent = ({event: xt}) => {
    var Ws;
    const {t: Cn} = useTranslation()
      , {openFeedEvent: as, shareEvent: cs} = useStorage(Xs => ({
        inGameLink: Xs.app.inGameLink,
        addModal: Xs.modal.addModal,
        setSelectedGiftForOverview: Xs.gifts.setSelectedGiftForOverview,
        openFeedEvent: Xs.feed.openFeedEvent,
        shareEvent: Xs.feed.shareEvent
    }))
      , Cs = () => {
        as(xt)
    }
      , Ls = xt.gift ?? ((Ws = xt.gifts) == null ? void 0 : Ws[0])
      , Vs = () => {
        switch (xt.type) {
        case FeedType.Listing.toLowerCase():
            return "type_listing";
        case FeedType.Sale.toLowerCase():
            return "type_sale";
        default:
            return xt.type
        }
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$U.eventContainer,
        onClick: Cs,
        children: [Ls && jsxRuntimeExports.jsx(GiftIcon, {
            gift: Ls,
            width: 47,
            clicksAvailable: !1
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$U.eventInfo,
            children: [jsxRuntimeExports.jsxs("div", {
                className: styles$U.eventHeader,
                children: [jsxRuntimeExports.jsx("div", {
                    className: styles$U.eventName,
                    children: (Ls == null ? void 0 : Ls.title) ?? ""
                }), !!xt.gift && jsxRuntimeExports.jsxs("div", {
                    className: styles$U.eventNumber,
                    children: ["#", xt.gift.number]
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$U.eventFooter,
                children: [jsxRuntimeExports.jsxs("div", {
                    className: styles$U.eventFooterRight,
                    children: [jsxRuntimeExports.jsxs("div", {
                        className: styles$U.eventPrice,
                        children: [jsxRuntimeExports.jsx(SvgTonIcon, {
                            className: styles$U.eventPriceIcon
                        }), formatNanotons(xt.amount ?? 0)]
                    }), jsxRuntimeExports.jsxs("div", {
                        className: styles$U.eventDate,
                        children: [jsxRuntimeExports.jsx(SvgCalendar, {
                            className: styles$U.eventDateIcon
                        }), format(xt.date, "dd MMM HH:mm:ss")]
                    })]
                }), jsxRuntimeExports.jsx("div", {
                    className: classNames$1(styles$U.eventType, styles$U[xt.type]),
                    children: Cn(Vs())
                })]
            })]
        })]
    })
}
  , fetchFeed = async (xt, Cn) => {
    try {
        const as = xt * DEFAULT_PAGE_SIZE;
        return await (await fetch(getApiUrl("/api/v1/feed"), {
            method: "POST",
            body: JSON.stringify({
                count: DEFAULT_PAGE_SIZE,
                offset: as,
                ...Cn
            }),
            headers: {
                "Content-Type": "application/json"
            }
        })).json()
    } catch (as) {
        return console.error("Error while fetching feed", as),
        []
    }
}
  , feedInfiniteQueryOptions = xt => ({
    queryKey: [QueryKeys.feed, xt],
    queryFn: async ({pageParam: Cn=0}) => fetchFeed(Cn, xt),
    getNextPageParam: (Cn, as) => {
        if (!(Cn.length < DEFAULT_PAGE_SIZE))
            return as.length
    }
    ,
    initialPageParam: 0,
    placeholderData: keepPreviousData
})
  , EmptyFeed = () => {
    const {t: xt} = useTranslation();
    return jsxRuntimeExports.jsx(EmptyList, {
        title: xt("text_ooops"),
        subtitle: xt("text_no_transactions")
    })
}
  , List = reactExports.forwardRef( (xt, Cn) => jsxRuntimeExports.jsx("div", {
    ...xt,
    ref: Cn,
    className: styles$V.virtuosoGrid
}))
  , Item = reactExports.memo( ({"data-index": xt, ...Cn}) => jsxRuntimeExports.jsx("div", {
    ...Cn,
    className: styles$V.virtuosoItem
}))
  , Feed = () => {
    var Cl;
    const xt = reactExports.useRef(null)
      , {addModal: Cn, removeModal: as} = useStorage($l => $l.modal);
    reactExports.useEffect( () => (Cn(ModalNames.REFRESH_FEED, 1e3),
    () => as(ModalNames.REFRESH_FEED)), []);
    const cs = useFilters(!0)
      , Cs = reactExports.useMemo( () => feedInfiniteQueryOptions(cs), [cs])
      , {data: Ls, isFetchingNextPage: Vs, fetchNextPage: Ws, hasNextPage: Xs, isFetching: ga} = useInfiniteQuery(Cs)
      , ba = ((Cl = Ls == null ? void 0 : Ls.pages) == null ? void 0 : Cl.flatMap($l => $l)) ?? []
      , yl = reactExports.useCallback( () => {
        !ga && Xs && Ws()
    }
    , [ga, Ws, Xs])
      , xl = reactExports.useCallback( ($l, Sl) => jsxRuntimeExports.jsx(FeedEvent, {
        event: Sl
    }, Sl.id), [])
      , wl = reactExports.useCallback( ($l, Sl) => Sl.id, [])
      , _l = reactExports.useCallback( () => jsxRuntimeExports.jsx(VirtuosoFooter, {
        height: 16
    }), [])
      , El = reactExports.useMemo( () => ({
        List,
        Item,
        Footer: _l
    }), []);
    return jsxRuntimeExports.jsx(Page, {
        back: !1,
        children: jsxRuntimeExports.jsx("div", {
            className: classNames$1(styles$V.container, {
                [styles$V.containerMobile]: isMobile()
            }),
            children: ba.length === 0 ? ga ? jsxRuntimeExports.jsx("div", {
                className: styles$V.spinnerWrapper,
                children: jsxRuntimeExports.jsx(Spinner, {})
            }) : jsxRuntimeExports.jsx(EmptyFeed, {}) : jsxRuntimeExports.jsx(Yr, {
                className: styles$V.virtualizer,
                ref: xt,
                data: ba,
                totalCount: ba.length,
                overscan: 20,
                increaseViewportBy: {
                    top: 400,
                    bottom: 400
                },
                endReached: yl,
                computeItemKey: wl,
                itemContent: xl,
                components: El
            })
        })
    })
}
  , leaderboardWrapper = "_leaderboardWrapper_2c6yi_1"
  , cupImg = "_cupImg_2c6yi_17"
  , header$2 = "_header_2c6yi_22"
  , leaderboardContainer = "_leaderboardContainer_2c6yi_36"
  , text = "_text_2c6yi_58"
  , spinnerContainer$1 = "_spinnerContainer_2c6yi_68"
  , spinner = "_spinner_2c6yi_68"
  , botName = "_botName_2c6yi_97"
  , styles$T = {
    leaderboardWrapper,
    cupImg,
    header: header$2,
    leaderboardContainer,
    text,
    spinnerContainer: spinnerContainer$1,
    spinner,
    botName
}
  , leaderboardItem = "_leaderboardItem_s1aow_1"
  , highlighted = "_highlighted_s1aow_12"
  , avatar = "_avatar_s1aow_18"
  , info$3 = "_info_s1aow_34"
  , name = "_name_s1aow_41"
  , points = "_points_s1aow_48"
  , star = "_star_s1aow_60"
  , rank = "_rank_s1aow_65"
  , initials = "_initials_s1aow_71"
  , giftIcon$5 = "_giftIcon_s1aow_77"
  , styles$S = {
    leaderboardItem,
    highlighted,
    avatar,
    info: info$3,
    name,
    points,
    star,
    rank,
    initials,
    giftIcon: giftIcon$5
}
  , LeaderboardItem = ({rank: xt, name: Cn, score: as, photo: cs, isHighlighted: Cs=!1}) => {
    const Ls = Ws => {
        const Xs = String(Ws);
        if (Xs === "")
            return "U";
        const ga = Xs.split(/[\s_-]+/);
        return ga.length > 2 ? ga.slice(0, 2).map(ba => ba[0]).join("") : ga.map(ba => ba[0]).join("")
    }
      , Vs = Ws => {
        if (typeof Ws == "string")
            return Ws;
        if (Ws >= 1 && Ws <= 3)
            return jsxRuntimeExports.jsx("img", {
                src: "/images/pepe.png",
                className: styles$S.giftIcon
            });
        if (Ws >= 4 && Ws <= 13)
            return jsxRuntimeExports.jsx("img", {
                src: "/images/cap.png",
                className: styles$S.giftIcon
            });
        if (Ws >= 14 && Ws <= 33)
            return jsxRuntimeExports.jsx("img", {
                src: "/images/peach.png",
                className: styles$S.giftIcon
            });
        if (Ws >= 34 && Ws <= 100)
            return jsxRuntimeExports.jsx("img", {
                src: "/images/ions.png",
                className: styles$S.giftIcon
            })
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: `${styles$S.leaderboardItem} ${Cs ? styles$S.highlighted : ""}`,
        children: [jsxRuntimeExports.jsx("div", {
            className: styles$S.avatar,
            children: cs ? jsxRuntimeExports.jsx("img", {
                src: cs,
                alt: "User avatar"
            }) : jsxRuntimeExports.jsx("span", {
                className: styles$S.initials,
                children: Ls(Cn)
            })
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$S.info,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$S.name,
                children: Cn
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$S.points,
                children: [jsxRuntimeExports.jsx("img", {
                    src: "/images/giftbox.png",
                    alt: "Star",
                    className: styles$S.star
                }), jsxRuntimeExports.jsx("span", {
                    children: Math.max(as, 0)
                })]
            })]
        }), jsxRuntimeExports.jsx("div", {
            className: styles$S.rank,
            children: Vs(xt)
        })]
    })
}
  , Leaderboard = () => {
    const xt = useNavigate()
      , {t: Cn} = useTranslation()
      , {leaderboard: as, fetchLeaderboard: cs, relayerBotName: Cs} = useStorage(El => ({
        leaderboard: El.leaderboards.leaderboard,
        fetchLeaderboard: El.leaderboards.fetchLeaderboard,
        relayerBotName: El.app.relayerBotName
    }))
      , [Ls,Vs] = reactExports.useState(!1)
      , Ws = reactExports.useRef(null)
      , Xs = reactExports.useRef(null)
      , [ga,ba] = reactExports.useState("calc(100vh - 240px)");
    reactExports.useEffect( () => {
        Hc.show(),
        Hc.onClick( () => xt("/")),
        (async () => {
            Vs(!0),
            await cs(!0),
            Vs(!1)
        }
        )()
    }
    , []),
    reactExports.useEffect( () => {
        const El = () => {
            if (Ws.current) {
                const $l = Ws.current.getBoundingClientRect().top;
                ba(`calc(100vh - ${$l}px)`)
            }
        }
        ;
        return El(),
        window.addEventListener("resize", El),
        () => {
            window.removeEventListener("resize", El)
        }
    }
    , [as]),
    reactExports.useEffect( () => {
        if (as && as.users && Xs.current) {
            const El = as.users.findIndex(Cl => Cl.isMe);
            El !== -1 && setTimeout( () => {
                var Cl;
                (Cl = Xs.current) == null || Cl.scrollToIndex({
                    index: El,
                    behavior: "smooth",
                    align: "center"
                })
            }
            , 500)
        }
    }
    , [as]);
    const yl = async () => {
        Ls || as != null && as.users.length || (Vs(!0),
        await cs(!1),
        Vs(!1))
    }
      , xl = as && as.me
      , wl = !(as != null && as.users.find(El => El.isMe))
      , _l = xl && (xl.points === -1 || xl.place > 100 || wl);
    return jsxRuntimeExports.jsxs("div", {
        className: styles$T.leaderboardWrapper,
        style: {
            paddingTop: isMobile() ? "100px" : "16px"
        },
        children: [jsxRuntimeExports.jsx(SupportButton, {
            style: {
                top: isMobile() ? "100px" : "16px"
            }
        }), jsxRuntimeExports.jsx("img", {
            className: styles$T.cupImg,
            src: "/images/cup.png"
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$T.header,
            children: [jsxRuntimeExports.jsxs("div", {
                children: [Cn("pr_leaderboard_header_1"), jsxRuntimeExports.jsxs("span", {
                    className: styles$T.botName,
                    onClick: () => Oc(`https://t.me/${Cs}`),
                    children: ["@", Cs]
                })]
            }), jsxRuntimeExports.jsx("div", {
                children: Cn("pr_leaderboard_header_2")
            })]
        }), jsxRuntimeExports.jsx("div", {
            className: styles$T.text,
            children: Cn("pr_leaderboard_text_1")
        }), jsxRuntimeExports.jsx("div", {
            className: styles$T.text,
            children: Cn("pr_leaderboard_text_2")
        }), jsxRuntimeExports.jsx("div", {
            ref: Ws,
            className: styles$T.leaderboardContainer,
            children: as && as.users && as.users.length > 0 ? jsxRuntimeExports.jsx(Kr, {
                ref: Xs,
                style: {
                    height: ga
                },
                totalCount: as.users.length,
                endReached: yl,
                overscan: 20,
                className: styles$T.virtuosoList,
                itemContent: El => {
                    const Cl = as.users[El];
                    return jsxRuntimeExports.jsx(LeaderboardItem, {
                        rank: Cl.place,
                        name: Cl.publicName,
                        score: Cl.points,
                        photo: Cl.photo,
                        isHighlighted: Cl.isMe
                    }, El)
                }
                ,
                components: {
                    Header: () => _l ? jsxRuntimeExports.jsx(LeaderboardItem, {
                        rank: xl.points === -1 || wl ? "#100+" : xl.place,
                        name: xl.publicName,
                        score: xl.points,
                        photo: xl.photo,
                        isHighlighted: !0
                    }, -1) : null,
                    Footer: () => jsxRuntimeExports.jsx("div", {
                        style: {
                            paddingBottom: "50px"
                        }
                    })
                }
            }) : jsxRuntimeExports.jsx("div", {
                className: styles$T.spinnerContainer,
                children: jsxRuntimeExports.jsx("div", {
                    className: styles$T.spinner
                })
            })
        })]
    })
}
  , routes = [{
    path: "/",
    element: jsxRuntimeExports.jsx(Market, {}),
    title: "Market"
}, {
    path: "/auction",
    element: jsxRuntimeExports.jsx(Auction, {}),
    title: "Auction"
}, {
    path: "/profile",
    element: jsxRuntimeExports.jsx(Profile, {}),
    title: "Profile"
}, {
    path: "/my-gifts",
    element: jsxRuntimeExports.jsx(MyGifts, {}),
    title: "My Gifts"
}, {
    path: "/giveaways",
    element: jsxRuntimeExports.jsx(Giveaways, {}),
    title: "Giveaways"
}, {
    path: "/feed",
    element: jsxRuntimeExports.jsx(Feed, {}),
    title: "Feed"
}, {
    path: "/leaderboard",
    element: jsxRuntimeExports.jsx(Leaderboard, {}),
    title: "Leaderboard"
}]
  , appContainer = "_appContainer_1sicn_1"
  , styles$R = {
    appContainer
}
  , container$h = "_container_1bg9h_1"
  , logoContainer$1 = "_logoContainer_1bg9h_10"
  , title$6 = "_title_1bg9h_19"
  , infoText$1 = "_infoText_1bg9h_28"
  , dots$1 = "_dots_1bg9h_42"
  , loaderContainer = "_loaderContainer_1bg9h_48"
  , maintenanceIcon = "_maintenanceIcon_1bg9h_65"
  , styles$Q = {
    container: container$h,
    logoContainer: logoContainer$1,
    title: title$6,
    infoText: infoText$1,
    dots: dots$1,
    loaderContainer,
    maintenanceIcon
}
  , Maintenance = () => {
    const [xt,Cn] = reactExports.useState("");
    return reactExports.useEffect( () => {
        const as = setInterval( () => {
            Cn(cs => cs.length >= 3 ? "" : cs + ".")
        }
        , 1e3);
        return () => clearInterval(as)
    }
    , []),
    jsxRuntimeExports.jsxs("div", {
        className: styles$Q.container,
        children: [jsxRuntimeExports.jsxs("div", {
            className: styles$Q.logoContainer,
            children: [jsxRuntimeExports.jsx("img", {
                className: styles$Q.maintenanceIcon,
                src: "/icons/common/maintenance.svg"
            }), jsxRuntimeExports.jsxs("div", {
                children: [jsxRuntimeExports.jsx("div", {
                    className: styles$Q.title,
                    children: "Maintenance"
                }), jsxRuntimeExports.jsx("div", {
                    className: styles$Q.title,
                    children: "work in progress"
                })]
            })]
        }), jsxRuntimeExports.jsx("div", {
            className: styles$Q.loaderContainer,
            children: jsxRuntimeExports.jsxs("span", {
                className: styles$Q.infoText,
                children: [jsxRuntimeExports.jsx("span", {
                    className: styles$Q.loadingText,
                    children: "Please come back later"
                }), jsxRuntimeExports.jsx("span", {
                    className: styles$Q.dots,
                    children: xt
                })]
            })
        })]
    })
}
  , container$g = "_container_1lkl9_1"
  , logoContainer = "_logoContainer_1lkl9_10"
  , content$6 = "_content_1lkl9_22"
  , mainContainer = "_mainContainer_1lkl9_30"
  , imgContainer = "_imgContainer_1lkl9_37"
  , loadingTitle = "_loadingTitle_1lkl9_45"
  , infoContainer = "_infoContainer_1lkl9_55"
  , infoText = "_infoText_1lkl9_66"
  , dots = "_dots_1lkl9_80"
  , styles$P = {
    container: container$g,
    logoContainer,
    content: content$6,
    mainContainer,
    imgContainer,
    loadingTitle,
    infoContainer,
    infoText,
    dots
}
  , Loading = () => {
    const [xt,Cn] = reactExports.useState("");
    return reactExports.useEffect( () => {
        const as = setInterval( () => {
            Cn(cs => cs.length >= 3 ? "" : cs + ".")
        }
        , 1e3);
        return () => clearInterval(as)
    }
    , []),
    jsxRuntimeExports.jsx("div", {
        className: styles$P.container,
        children: jsxRuntimeExports.jsx("div", {
            className: styles$P.logoContainer,
            style: {
                paddingBottom: isMobile() ? "50px" : "16px"
            },
            children: jsxRuntimeExports.jsxs("div", {
                className: styles$P.content,
                children: [jsxRuntimeExports.jsxs("div", {
                    className: styles$P.mainContainer,
                    children: [jsxRuntimeExports.jsxs("div", {
                        className: styles$P.imgContainer,
                        children: [jsxRuntimeExports.jsx("img", {
                            alt: "",
                            className: styles$P.logoImg,
                            src: "/icons/common/logo.svg"
                        }), jsxRuntimeExports.jsx("img", {
                            alt: "",
                            className: styles$P.logoLabel,
                            src: "/icons/common/logo-label.svg"
                        })]
                    }), jsxRuntimeExports.jsx("div", {
                        className: styles$P.loadingTitle,
                        children: "Digital Assets Home"
                    })]
                }), jsxRuntimeExports.jsx("div", {
                    className: styles$P.infoContainer,
                    style: {
                        bottom: isMobile() ? "44px" : "10px"
                    },
                    children: jsxRuntimeExports.jsxs("span", {
                        className: styles$P.infoText,
                        children: [jsxRuntimeExports.jsx("span", {
                            children: "Loading"
                        }), jsxRuntimeExports.jsx("span", {
                            className: styles$P.dots,
                            children: xt
                        })]
                    })
                })]
            })
        })
    })
}
  , overlay = "_overlay_l8r63_1"
  , popup = "_popup_l8r63_13"
  , fullHeight = "_fullHeight_l8r63_30"
  , popupMobile = "_popupMobile_l8r63_33"
  , closing = "_closing_l8r63_41"
  , header$1 = "_header_l8r63_45"
  , heading = "_heading_l8r63_52"
  , closeButton$1 = "_closeButton_l8r63_61"
  , content$5 = "_content_l8r63_68"
  , styles$O = {
    overlay,
    popup,
    fullHeight,
    popupMobile,
    closing,
    header: header$1,
    heading,
    closeButton: closeButton$1,
    content: content$5
}
  , Popup = ({isOpen: xt, onClose: Cn, children: as, className: cs, heading: Cs, closeButton: Ls=!0, hasOverlay: Vs=!0, fullHeight: Ws=!1}) => {
    const {t: Xs} = useTranslation()
      , [ga,ba] = reactExports.useState(!1);
    reactExports.useEffect( () => (xt ? document.body.style.overflow = "hidden" : document.body.style.overflow = "",
    () => {
        document.body.style.overflow = ""
    }
    ), [xt]);
    const yl = () => {
        ba(!0),
        setTimeout( () => {
            ba(!1),
            Cn()
        }
        , 300)
    }
    ;
    if (!xt && !ga)
        return null;
    const xl = jsxRuntimeExports.jsxs("div", {
        className: classNames$1(styles$O.popup, {
            [styles$O.closing]: ga,
            [styles$O.popupMobile]: isMobile(),
            [styles$O.fullHeight]: Ws
        }),
        onClick: wl => wl.stopPropagation(),
        children: [(Ls || Cs) && jsxRuntimeExports.jsxs("div", {
            className: styles$O.header,
            children: [Cs && jsxRuntimeExports.jsx("div", {
                className: styles$O.heading,
                children: typeof Cs == "string" ? Xs(Cs) : Cs
            }), Ls && jsxRuntimeExports.jsx("img", {
                className: styles$O.closeButton,
                onClick: yl,
                src: "/icons/common/close-icon.svg",
                alt: ""
            })]
        }), jsxRuntimeExports.jsx("div", {
            className: classNames$1(styles$O.content, cs),
            children: as
        })]
    });
    return ReactDOM.createPortal(Vs ? jsxRuntimeExports.jsx("div", {
        className: styles$O.overlay,
        onClick: yl,
        children: xl
    }) : xl, document.body)
}
  , modalOverlay = "_modalOverlay_ockwz_1"
  , modalContent = "_modalContent_ockwz_14"
  , standard = "_standard_ockwz_22"
  , purple = "_purple_ockwz_25"
  , dark = "_dark_ockwz_28"
  , buttonWrapper = "_buttonWrapper_ockwz_32"
  , closeButton = "_closeButton_ockwz_38"
  , styles$N = {
    modalOverlay,
    modalContent,
    standard,
    purple,
    dark,
    buttonWrapper,
    closeButton
}
  , Alert = ({isOpen: xt, onClose: Cn, children: as, closeButton: cs=!0, style: Cs, variant: Ls="standard"}) => {
    const {addBackButtonHandler: Vs, removeBackButtonHandler: Ws} = useStorage(ga => ({
        addBackButtonHandler: ga.backButton.addBackButtonHandler,
        removeBackButtonHandler: ga.backButton.removeBackButtonHandler
    }))
      , Xs = reactExports.useCallback( () => {
        Cn()
    }
    , [Cn]);
    return reactExports.useEffect( () => {
        if (xt && cs)
            return Vs(HANDLER_NAMES.MODAL_CLOSE_HANDLER, Xs),
            () => {
                Ws(HANDLER_NAMES.MODAL_CLOSE_HANDLER)
            }
    }
    , [xt, Cn, Xs, Vs, Ws]),
    xt ? ReactDOM.createPortal(jsxRuntimeExports.jsx("div", {
        className: classNames$1(styles$N.modalOverlay),
        children: jsxRuntimeExports.jsxs("div", {
            className: classNames$1(styles$N.modalContent, styles$N[Ls]),
            onClick: ga => ga.stopPropagation(),
            style: Cs,
            children: [cs && jsxRuntimeExports.jsx("div", {
                className: styles$N.buttonWrapper,
                children: jsxRuntimeExports.jsx(SvgCloseIcon, {
                    className: classNames$1(styles$N.closeButton, styles$N[Ls]),
                    onClick: Cn
                })
            }), as]
        })
    }), document.body) : null
}
  , cancelSaleAlert = "_cancelSaleAlert_1c32p_1"
  , cancelSaleAlertText = "_cancelSaleAlertText_1c32p_54"
  , cancelSaleAlertActions = "_cancelSaleAlertActions_1c32p_66"
  , cancelSaleAlertButton = "_cancelSaleAlertButton_1c32p_75"
  , styles$M = {
    cancelSaleAlert,
    cancelSaleAlertText,
    cancelSaleAlertActions,
    cancelSaleAlertButton
}
  , giftCard = "_giftCard_1prgn_1"
  , error = "_error_1prgn_11"
  , giftCardInfo = "_giftCardInfo_1prgn_14"
  , giftCardInfoName = "_giftCardInfoName_1prgn_20"
  , small$1 = "_small_1prgn_26"
  , large = "_large_1prgn_29"
  , giftCardInfoNumber = "_giftCardInfoNumber_1prgn_32"
  , styles$L = {
    giftCard,
    error,
    giftCardInfo,
    giftCardInfoName,
    small: small$1,
    large,
    giftCardInfoNumber
}
  , GiftCard = ({gift: xt, width: Cn=148, size: as="small", error: cs=!1}) => jsxRuntimeExports.jsxs("div", {
    className: classNames$1(styles$L.giftCard, {
        [styles$L.error]: cs
    }, styles$L[as]),
    children: [jsxRuntimeExports.jsx(GiftIcon, {
        gift: xt,
        width: Cn,
        clicksAvailable: !1
    }), jsxRuntimeExports.jsxs("div", {
        className: styles$L.giftCardInfo,
        children: [jsxRuntimeExports.jsx("div", {
            className: classNames$1(styles$L.giftCardInfoName, styles$L[as]),
            children: xt.title
        }), jsxRuntimeExports.jsxs("div", {
            className: classNames$1(styles$L.giftCardInfoNumber, styles$L[as]),
            children: ["#", xt.number]
        })]
    })]
})
  , useCancelSale = (xt, Cn) => {
    const {addModal: as, removeModal: cs} = useStorage(Vs => Vs.modal)
      , Cs = useQueryClient()
      , {t: Ls} = useTranslation();
    return useMutation({
        mutationFn: () => cancelSale(xt.map(Vs => Vs.id)),
        onSuccess: () => {
            Cs.invalidateQueries({
                queryKey: [QueryKeys.myGifts]
            }),
            Cs.invalidateQueries({
                queryKey: [QueryKeys.gifts]
            }),
            as(ModalNames.CONGRATS, 0, {
                image: "/images/common/green-check-mark.png",
                title: "text_success_sale_cancel",
                message: Ls("text_gift_sale_cancel_detail", {
                    GiftTitle: xt[0].title,
                    GiftNumber: `#${xt[0].number}`
                }),
                buttonText: "button_nice"
            })
        }
        ,
        onError: () => {
            as(ModalNames.ERROR, 0, {
                message: Ls("text_fail_two_minutes_sale_cooldown", {
                    value: 2
                })
            })
        }
        ,
        onSettled: () => {
            Cn && cs(Cn)
        }
    })
}
  , useListGifts = (xt, Cn) => {
    const {addModal: as, removeModal: cs} = useStorage(Vs => Vs.modal)
      , Cs = useStorage(Vs => Vs.wallet.updateBalance)
      , Ls = useQueryClient();
    return useMutation({
        mutationFn: Vs => listGifts((xt == null ? void 0 : xt.map(Ws => Ws.id)) ?? [], Vs),
        onSuccess: async Vs => {
            Ls.invalidateQueries({
                queryKey: [QueryKeys.myGifts]
            }),
            Ls.invalidateQueries({
                queryKey: [QueryKeys.gifts]
            }),
            Cs(),
            Vs.ids.length ? (xt == null ? void 0 : xt.length) === 1 ? as(ModalNames.CONGRATS, 0, {
                image: "/images/common/confetti.png",
                title: "text_success_gift_listed",
                message: `${xt[0].title} #${xt[0].number} was successfully listed for sale!`,
                buttonText: "button_nice"
            }) : as(ModalNames.CONGRATS, 0, {
                image: "/images/common/confetti.png",
                title: "text_success_gifts_listed",
                buttonText: "button_nice"
            }) : as(ModalNames.ERROR, 0, {
                title: "text_error",
                message: "There was an error that occurred during the listing"
            })
        }
        ,
        onSettled: () => {
            Cn && cs(Cn)
        }
    })
}
  , useWithdrawGifts = () => {
    const xt = useQueryClient()
      , {addModal: Cn, updateBalance: as} = useStorage(cs => ({
        addModal: cs.modal.addModal,
        updateBalance: cs.wallet.updateBalance
    }));
    return useMutation({
        mutationFn: cs => withdrawGift(cs.map(Cs => Cs.id)),
        onSuccess: cs => {
            xt.invalidateQueries({
                queryKey: [QueryKeys.myGifts, "unlisted"]
            }),
            xt.invalidateQueries({
                queryKey: [QueryKeys.gifts]
            }),
            cs.length === 1 ? Cn(ModalNames.CONGRATS, 0, {
                image: "/images/common/withdraw.png",
                title: "text_success_gift_returned",
                buttonText: "button_nice"
            }) : Cn(ModalNames.CONGRATS, 0, {
                image: "/images/common/withdraw.png",
                title: "text_gifts_returned",
                message: "text_return_note",
                buttonText: "button_nice"
            }),
            as()
        }
        ,
        onError: cs => {
            console.error("Failed to withdraw gift:", cs),
            Cn(ModalNames.ERROR, 0, {
                title: cs.title || "text_error",
                message: cs.message || "text_fail_return_gifts"
            })
        }
    })
}
  , CancelSaleConfirm = () => {
    const {t: xt} = useTranslation()
      , {selectedGiftForCancellation: Cn, clearSelectedGift: as} = useStorage(Xs => Xs.myGifts)
      , {removeModal: cs} = useStorage(Xs => Xs.modal)
      , {mutateAsync: Cs, isPending: Ls} = useCancelSale(Cn ? [Cn] : [], ModalNames.CANCEL_SALE_CONFIRM)
      , Vs = async () => {
        await Cs(),
        as()
    }
      , Ws = () => {
        cs(ModalNames.CANCEL_SALE_CONFIRM),
        as()
    }
    ;
    return Cn ? jsxRuntimeExports.jsxs("div", {
        className: styles$M.cancelSaleAlert,
        children: [jsxRuntimeExports.jsx(GiftCard, {
            gift: Cn
        }), jsxRuntimeExports.jsx("p", {
            className: styles$M.cancelSaleAlertText,
            children: xt("text_cancel_confirmation")
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$M.cancelSaleAlertActions,
            children: [jsxRuntimeExports.jsx(Button, {
                loading: Ls,
                className: styles$M.cancelSaleAlertButton,
                onClick: Vs,
                variant: "success",
                children: xt("button_yes")
            }), jsxRuntimeExports.jsx(Button, {
                disabled: Ls,
                className: styles$M.cancelSaleAlertButton,
                onClick: Ws,
                variant: "error",
                children: xt("button_no")
            })]
        })]
    }) : null
}
  , content$4 = "_content_1lp3k_1"
  , saleCanceledText = "_saleCanceledText_1lp3k_12"
  , details$4 = "_details_1lp3k_24"
  , giftInfo$3 = "_giftInfo_1lp3k_35"
  , giftText$1 = "_giftText_1lp3k_42"
  , confirmButton$3 = "_confirmButton_1lp3k_65"
  , confirmIcon$1 = "_confirmIcon_1lp3k_69"
  , styles$K = {
    content: content$4,
    saleCanceledText,
    details: details$4,
    giftInfo: giftInfo$3,
    giftText: giftText$1,
    confirmButton: confirmButton$3,
    confirmIcon: confirmIcon$1
}
  , Error$1 = () => {
    const {t: xt} = useTranslation()
      , {removeModal: Cn, queue: as} = useStorage(ga => ({
        removeModal: ga.modal.removeModal,
        queue: ga.modal.queue
    }))
      , cs = as.find(ga => ga.name === ModalNames.ERROR)
      , {title: Cs="text_error", message: Ls="An error occurred", onButtonClickHandler: Vs, buttonText: Ws="button_ok"} = (cs == null ? void 0 : cs.params) || {}
      , Xs = () => {
        Vs && Vs(),
        Cn(ModalNames.ERROR)
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$K.content,
        children: [jsxRuntimeExports.jsx("img", {
            src: "/images/common/exclamation-mark.png",
            className: styles$K.confirmIcon
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$K.details,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$K.saleCanceledText,
                children: xt(Cs)
            }), jsxRuntimeExports.jsx("div", {
                className: styles$K.giftInfo,
                children: jsxRuntimeExports.jsx("div", {
                    className: styles$K.giftText,
                    children: xt(Ls)
                })
            })]
        }), jsxRuntimeExports.jsx(Button, {
            className: styles$K.confirmButton,
            onClick: Xs,
            children: xt(Ws)
        })]
    })
}
  , inputWrapper$1 = "_inputWrapper_11gmw_1"
  , priceInput$1 = "_priceInput_11gmw_8"
  , inputError$2 = "_inputError_11gmw_12"
  , listGiftPrice = "_listGiftPrice_11gmw_17"
  , listGiftPriceFee = "_listGiftPriceFee_11gmw_25"
  , listGiftPriceFormTitle = "_listGiftPriceFormTitle_11gmw_74"
  , listGiftPriceFormFloor = "_listGiftPriceFormFloor_11gmw_104"
  , listGiftPriceFormFloorIcon = "_listGiftPriceFormFloorIcon_11gmw_114"
  , listGiftPriceButton = "_listGiftPriceButton_11gmw_118"
  , styles$J = {
    inputWrapper: inputWrapper$1,
    priceInput: priceInput$1,
    inputError: inputError$2,
    listGiftPrice,
    listGiftPriceFee,
    listGiftPriceFormTitle,
    listGiftPriceFormFloor,
    listGiftPriceFormFloorIcon,
    listGiftPriceButton
}
  , TonIcon = "data:image/svg+xml,%3csvg%20width='22'%20height='22'%20viewBox='0%200%2022%2022'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M19.4687%206.33953L11.7971%2018.52C11.7037%2018.6671%2011.5745%2018.7882%2011.4216%2018.8721C11.2686%2018.956%2011.0969%2019%2010.9223%2019C10.7464%2019.0003%2010.5732%2018.956%2010.4193%2018.8711C10.2653%2018.7862%2010.1356%2018.6636%2010.0423%2018.5148L2.5209%206.33437C2.31019%205.99296%202.19906%205.59977%202.19996%205.1989C2.2095%204.60707%202.45412%204.04319%202.88016%203.63099C3.30619%203.21879%203.87883%202.99194%204.47243%203.00022H17.5378C18.7854%203.00022%2019.8%203.98085%2019.8%205.19374C19.8%205.59631%2019.6861%205.99373%2019.4687%206.33953ZM4.3689%205.93179L9.96466%2014.5355V5.06471H4.95384C4.37407%205.06471%204.11525%205.44664%204.3689%205.93179ZM12.0352%2014.5355L17.631%205.93179C17.8898%205.44664%2017.6258%205.06471%2017.0461%205.06471H12.0352V14.5355Z'%20fill='%237E7E82'/%3e%3c/svg%3e"
  , ListGiftPrice = () => {
    const {t: xt} = useTranslation()
      , {removeModal: Cn, addModal: as} = useStorage($l => $l.modal)
      , {selectedGiftForListing: cs, minSalePrice: Cs, setListingPrice: Ls, maxSalePrice: Vs, salesFee: Ws} = useStorage($l => ({
        selectedGiftForListing: $l.myGifts.selectedGiftForListing,
        setListingPrice: $l.myGifts.setListingPrice,
        minSalePrice: $l.app.minSalePrice,
        maxSalePrice: $l.app.maxSalePrice,
        salesFee: $l.profile.salesFee
    }))
      , {data: Xs} = useQuery(collectionsQueryOptions())
      , [ga,ba] = reactExports.useState("")
      , yl = !!ga && Number(ga) < Number(dist$1.fromNano(Cs))
      , xl = !!ga && Number(ga) > Number(dist$1.fromNano(Vs))
      , wl = yl || xl;
    if (!cs)
        return null;
    const _l = () => {
        cs && (Ls(Number(dist$1.toNano(ga))),
        Cn(ModalNames.LIST_GIFT_PRICE),
        as(ModalNames.LIST_GIFT_CONFIRM))
    }
      , El = $l => {
        const Tl = $l.target.value.replace(/[^0-9.,]/g, "").replace(",", ".");
        ba(Tl)
    }
      , Cl = reactExports.useMemo( () => Xs && Xs.length ? Xs.find($l => $l.modelStickerThumbnailKey === cs.modelStickerThumbnailKey) : null, []);
    return jsxRuntimeExports.jsxs("div", {
        className: styles$J.listGiftPrice,
        children: [jsxRuntimeExports.jsx(GiftCard, {
            gift: cs
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$J.inputWrapper,
            children: [jsxRuntimeExports.jsx("h2", {
                className: styles$J.listGiftPriceFormTitle,
                children: xt("text_enter_price")
            }), jsxRuntimeExports.jsx(Input, {
                className: styles$J.priceInput,
                placeholder: xt("input_tooltip_text"),
                icon: jsxRuntimeExports.jsx("img", {
                    src: TonIcon,
                    alt: "TON"
                }),
                value: ga,
                onChange: El,
                autoFocus: !0,
                inputMode: "decimal",
                pattern: "[0-9]*[.,]?[0-9]*",
                maxDecimalDigits: 2
            }), yl && jsxRuntimeExports.jsx("div", {
                className: styles$J.inputError,
                children: xt("text_list_minimum_price", {
                    value: formatNanotons(Cs)
                })
            }), xl && jsxRuntimeExports.jsx("div", {
                className: styles$J.inputError,
                children: xt("text_list_maximum_price", {
                    value: formatNanotons(Vs)
                })
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$J.listGiftPriceFormFloor,
                children: [jsxRuntimeExports.jsxs("span", {
                    children: [xt("text_floor_price"), ":"]
                }), jsxRuntimeExports.jsx("img", {
                    className: styles$J.listGiftPriceFormFloorIcon,
                    alt: "TON",
                    src: TonIcon
                }), jsxRuntimeExports.jsx("span", {
                    children: formatNanotons(Cl && Cl.floorPriceNanoTons ? Cl.floorPriceNanoTons : Cs)
                })]
            }), jsxRuntimeExports.jsx("div", {
                className: styles$J.listGiftPriceFee,
                children: xt("text_market_fee", {
                    value: Ws
                })
            })]
        }), jsxRuntimeExports.jsx(Button, {
            className: styles$J.listGiftPriceButton,
            variant: "primary",
            onClick: _l,
            disabled: wl || !ga,
            children: xt("button_list")
        })]
    })
}
  , listGiftConfirm = "_listGiftConfirm_zt515_1"
  , listGiftConfirmText = "_listGiftConfirmText_zt515_54"
  , listGiftConfirmActions = "_listGiftConfirmActions_zt515_66"
  , listGiftConfirmButton = "_listGiftConfirmButton_zt515_75"
  , styles$I = {
    listGiftConfirm,
    listGiftConfirmText,
    listGiftConfirmActions,
    listGiftConfirmButton
}
  , ListGiftConfirm = () => {
    const {t: xt} = useTranslation()
      , {selectedGiftForListing: Cn, clearSelectedGift: as, listingPrice: cs, setListingPrice: Cs} = useStorage(ba => ba.myGifts)
      , {removeModal: Ls} = useStorage(ba => ba.modal)
      , {mutateAsync: Vs, isPending: Ws} = useListGifts(Cn ? [Cn] : [], ModalNames.LIST_GIFT_CONFIRM)
      , Xs = async () => {
        cs && (await Vs(cs),
        Cs(null),
        as())
    }
      , ga = () => {
        Ls(ModalNames.LIST_GIFT_CONFIRM),
        Cs(null),
        as()
    }
    ;
    return Cn ? jsxRuntimeExports.jsxs("div", {
        className: styles$I.listGiftConfirm,
        children: [jsxRuntimeExports.jsx(GiftCard, {
            gift: Cn
        }), jsxRuntimeExports.jsx("p", {
            className: styles$I.listGiftConfirmText,
            children: xt("text_list_gift_confirm", {
                value: formatNanotons(cs ?? 0)
            })
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$I.listGiftConfirmActions,
            children: [jsxRuntimeExports.jsx(Button, {
                className: styles$I.listGiftConfirmButton,
                onClick: Xs,
                variant: "success",
                loading: Ws,
                children: xt("button_yes")
            }), jsxRuntimeExports.jsx(Button, {
                className: styles$I.listGiftConfirmButton,
                onClick: ga,
                variant: "error",
                disabled: Ws,
                children: xt("button_no")
            })]
        })]
    }) : null
}
  , withdrawGiftConfirm = "_withdrawGiftConfirm_rj3jy_1"
  , withdrawGiftConfirmText = "_withdrawGiftConfirmText_rj3jy_10"
  , withdrawGiftConfirmCost = "_withdrawGiftConfirmCost_rj3jy_19"
  , withdrawGiftConfirmActions = "_withdrawGiftConfirmActions_rj3jy_28"
  , withdrawGiftConfirmButton = "_withdrawGiftConfirmButton_rj3jy_34"
  , styles$H = {
    withdrawGiftConfirm,
    withdrawGiftConfirmText,
    withdrawGiftConfirmCost,
    withdrawGiftConfirmActions,
    withdrawGiftConfirmButton
}
  , GiftWithdrawConfirm = () => {
    const {t: xt} = useTranslation()
      , {selectedItems: Cn, clearSelectedItems: as} = useStorage(ga => ga.myGifts)
      , {removeModal: cs} = useStorage(ga => ga.modal)
      , {returnGiftPrice: Cs} = useStorage(ga => ga.app)
      , {mutateAsync: Ls, isPending: Vs} = useWithdrawGifts();
    reactExports.useEffect( () => () => as(), []);
    const Ws = async () => {
        cs(ModalNames.WITHDRAW_GIFT_CONFIRM),
        await Ls(Cn),
        as()
    }
      , Xs = () => {
        cs(ModalNames.WITHDRAW_GIFT_CONFIRM),
        as()
    }
    ;
    return Cn.length ? jsxRuntimeExports.jsxs("div", {
        className: styles$H.withdrawGiftConfirm,
        children: [jsxRuntimeExports.jsx(GiftCard, {
            gift: Cn[0]
        }), jsxRuntimeExports.jsxs("div", {
            children: [jsxRuntimeExports.jsx("p", {
                className: styles$H.withdrawGiftConfirmText,
                children: xt("text_return_gift_confirm")
            }), !Cn[0].isGiveawayReceived && jsxRuntimeExports.jsx("p", {
                className: styles$H.withdrawGiftConfirmCost,
                children: xt("text_return_fee", {
                    value: formatNanotons(Cs)
                })
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$H.withdrawGiftConfirmActions,
            children: [jsxRuntimeExports.jsx(Button, {
                className: styles$H.withdrawGiftConfirmButton,
                onClick: Ws,
                variant: "success",
                loading: Vs,
                children: xt("button_yes")
            }), jsxRuntimeExports.jsx(Button, {
                className: styles$H.withdrawGiftConfirmButton,
                onClick: Xs,
                variant: "error",
                loading: Vs,
                children: xt("button_no")
            })]
        })]
    }) : null
}
  , content$3 = "_content_mmps8_1"
  , confirmIcon = "_confirmIcon_mmps8_8"
  , details$3 = "_details_mmps8_13"
  , congratsTitle = "_congratsTitle_mmps8_22"
  , giftInfo$2 = "_giftInfo_mmps8_31"
  , giftText = "_giftText_mmps8_38"
  , confirmButton$2 = "_confirmButton_mmps8_47"
  , styles$G = {
    content: content$3,
    confirmIcon,
    details: details$3,
    congratsTitle,
    giftInfo: giftInfo$2,
    giftText,
    confirmButton: confirmButton$2
}
  , Congrats = () => {
    const {t: xt} = useTranslation()
      , {removeModal: Cn, queue: as} = useStorage(ga => ({
        removeModal: ga.modal.removeModal,
        queue: ga.modal.queue
    }))
      , cs = as.find(ga => ga.name === ModalNames.CONGRATS)
      , {image: Cs="/images/common/confirm.png", title: Ls="Success", message: Vs="", buttonText: Ws="button_ok", clickHandler: Xs} = (cs == null ? void 0 : cs.params) || {};
    return jsxRuntimeExports.jsxs("div", {
        className: styles$G.content,
        children: [jsxRuntimeExports.jsx("img", {
            src: Cs,
            className: styles$G.confirmIcon
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$G.details,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$G.congratsTitle,
                children: xt(Ls)
            }), !!Vs && jsxRuntimeExports.jsx("div", {
                className: styles$G.giftInfo,
                children: jsxRuntimeExports.jsx("div", {
                    className: styles$G.giftText,
                    children: xt(Vs)
                })
            })]
        }), jsxRuntimeExports.jsx(Button, {
            className: styles$G.confirmButton,
            onClick: () => {
                Xs && Xs(),
                Cn(cs == null ? void 0 : cs.name)
            }
            ,
            children: xt(Ws)
        })]
    })
}
  , giftOverview = "_giftOverview_11hg5_1"
  , giftOverviewFooter = "_giftOverviewFooter_11hg5_10"
  , giftIcon$4 = "_giftIcon_11hg5_19"
  , giftDetails = "_giftDetails_11hg5_72"
  , giftDetailsColumn = "_giftDetailsColumn_11hg5_80"
  , giftDetailsValueColumn = "_giftDetailsValueColumn_11hg5_86"
  , giftDetailsRow = "_giftDetailsRow_11hg5_92"
  , giftDetailsValueRow = "_giftDetailsValueRow_11hg5_105"
  , giftDetailsLabel = "_giftDetailsLabel_11hg5_117"
  , giftDetailsValue = "_giftDetailsValue_11hg5_86"
  , rarityBadge = "_rarityBadge_11hg5_131"
  , rarityText = "_rarityText_11hg5_140"
  , giftButton = "_giftButton_11hg5_149"
  , cartIcon = "_cartIcon_11hg5_165"
  , trashIcon = "_trashIcon_11hg5_170"
  , giftButtonText = "_giftButtonText_11hg5_176"
  , actionButton$7 = "_actionButton_11hg5_182"
  , actionButtonListText = "_actionButtonListText_11hg5_186"
  , buyControls = "_buyControls_11hg5_199"
  , buyControlsButton = "_buyControlsButton_11hg5_205"
  , buyControlsButtonPrice = "_buyControlsButtonPrice_11hg5_212"
  , unlistedControls = "_unlistedControls_11hg5_225"
  , listedControls = "_listedControls_11hg5_231"
  , outputButtonIcon = "_outputButtonIcon_11hg5_238"
  , tonIcon = "_tonIcon_11hg5_243"
  , subactionButton = "_subactionButton_11hg5_252"
  , shareButtonIcon = "_shareButtonIcon_11hg5_267"
  , styles$F = {
    giftOverview,
    giftOverviewFooter,
    giftIcon: giftIcon$4,
    giftDetails,
    giftDetailsColumn,
    giftDetailsValueColumn,
    giftDetailsRow,
    giftDetailsValueRow,
    giftDetailsLabel,
    giftDetailsValue,
    rarityBadge,
    rarityText,
    giftButton,
    cartIcon,
    trashIcon,
    giftButtonText,
    actionButton: actionButton$7,
    actionButtonListText,
    buyControls,
    buyControlsButton,
    buyControlsButtonPrice,
    unlistedControls,
    listedControls,
    outputButtonIcon,
    tonIcon,
    subactionButton,
    shareButtonIcon
}
  , SvgWithdraw = xt => reactExports.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("g", {
    id: "Line / Share Icon"
}, reactExports.createElement("path", {
    id: "Vector",
    d: "M19.25 17.125C19.25 11.925 14.2033 9.125 12.0584 9.125V6L5.75 12.25L12.0584 18V14.4615C14.8846 14.4615 18.0304 16.2372 19.25 17.125Z",
    stroke: "#D44326",
    strokeLinecap: "round",
    strokeLinejoin: "round"
})))
  , SvgShare = xt => reactExports.createElement("svg", {
    width: 21,
    height: 19,
    viewBox: "0 0 21 19",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M11.0888 5.66667V6.41667H11.8388V5.66667H11.0888ZM1.5 16.3333H0.75C0.75 16.6155 0.908355 16.8738 1.15981 17.0017C1.41127 17.1297 1.71328 17.1057 1.94139 16.9397L1.5 16.3333ZM11.0888 12.7821H11.8388V12.0321H11.0888V12.7821ZM11.0888 17.5H10.3388C10.3388 17.797 10.5141 18.0661 10.7858 18.1861C11.0575 18.3061 11.3745 18.2544 11.594 18.0543L11.0888 17.5ZM19.5 9.83333L20.0052 10.3876C20.1571 10.2492 20.2456 10.0544 20.2498 9.84894C20.2541 9.64345 20.1739 9.4452 20.0279 9.30054L19.5 9.83333ZM11.0888 1.5L11.6166 0.967209C11.4016 0.754157 11.0796 0.691267 10.8002 0.80776C10.5208 0.924253 10.3388 1.19729 10.3388 1.5L11.0888 1.5ZM11.0888 4.91667C9.42065 4.91667 6.8542 5.95931 4.72571 7.83766C2.56587 9.74366 0.75 12.602 0.75 16.3333H2.25C2.25 13.1313 3.79862 10.6563 5.71822 8.96235C7.66916 7.24069 9.89711 6.41667 11.0888 6.41667V4.91667ZM1.94139 16.9397C2.7101 16.3801 4.11656 15.5203 5.78706 14.8029C7.4638 14.0829 9.34769 13.5321 11.0888 13.5321V12.0321C9.06165 12.0321 6.96423 12.665 5.19519 13.4246C3.41989 14.187 1.91607 15.1028 1.05861 15.727L1.94139 16.9397ZM10.3388 12.7821V17.5H11.8388V12.7821H10.3388ZM20.0279 9.30054L11.6166 0.967209L10.5609 2.03279L18.9721 10.3661L20.0279 9.30054ZM10.3388 1.5V5.66667H11.8388V1.5H10.3388ZM18.9948 9.27904L10.5836 16.9457L11.594 18.0543L20.0052 10.3876L18.9948 9.27904Z",
    fill: "#0A84FF"
}))
  , GiftOverview = () => {
    const {t: xt} = useTranslation()
      , {gift: Cn, isHiSaid: as, relayerBotName: cs, inGameLink: Cs, promotePrice: Ls, startIsHaiPolling: Vs, listGift: Ws, toggleSelectedItem: Xs, addModal: ga, removeModal: ba, cancelSale: yl, setSelectedGiftForOverview: xl, setSelectedGiftForQuickBuy: wl, setSelectedGiftForPromotion: _l, removeFromCart: El, addToCart: Cl, cartGifts: $l} = useStorage(lu => ({
        gift: lu.gifts.selectedGiftForOverview,
        currentTab: lu.myGifts.currentTab,
        isHiSaid: lu.myGifts.isHiSaid,
        relayerBotName: lu.app.relayerBotName,
        inGameLink: lu.app.inGameLink,
        promotePrice: lu.app.promotePrice,
        startIsHaiPolling: lu.myGifts.startIsHaiPolling,
        listGift: lu.myGifts.listGift,
        toggleSelectedItem: lu.myGifts.toggleSelectedItem,
        addModal: lu.modal.addModal,
        removeModal: lu.modal.removeModal,
        cancelSale: lu.myGifts.cancelSale,
        setSelectedGiftForOverview: lu.gifts.setSelectedGiftForOverview,
        setSelectedGiftForQuickBuy: lu.gifts.setSelectedGiftForQuickBuy,
        setSelectedGiftForPromotion: lu.myGifts.setSelectedGiftForPromotion,
        removeFromCart: lu.cart.removeFromCart,
        addToCart: lu.cart.addToCart,
        cartGifts: lu.cart.gifts
    }))
      , [Sl,Tl] = reactExports.useState(300)
      , Rl = reactExports.useRef(null)
      , Il = lu => {
        ba(ModalNames.GIFT_OVERVIEW),
        Ws(lu)
    }
      , Ml = lu => {
        ba(ModalNames.GIFT_OVERVIEW),
        as ? (Xs(lu),
        ga(ModalNames.WITHDRAW_GIFT_CONFIRM)) : (ga(ModalNames.ERROR, 0, {
            title: "text_error",
            message: "text_say_hi",
            onButtonClickHandler: () => Oc(`https://t.me/${cs}`),
            buttonText: "button_say_hi"
        }),
        Vs())
    }
      , Nl = lu => {
        Oc(`https://t.me/share/url?url=${Cs}${lu.id.replace(/-/g, "")}&text=${xt("share_gift_text")}`)
    }
      , Ll = lu => {
        ba(ModalNames.GIFT_OVERVIEW),
        _l(lu),
        ga(ModalNames.GIFT_PROMOTION_CONFIRM)
    }
      , Fl = () => {
        ba(ModalNames.GIFT_OVERVIEW),
        xl(null)
    }
      , Ul = lu => {
        ba(ModalNames.GIFT_OVERVIEW),
        yl(lu),
        ga(ModalNames.CANCEL_SALE_CONFIRM)
    }
      , Dl = lu => {
        ba(ModalNames.GIFT_OVERVIEW),
        wl(lu),
        ga(ModalNames.QUICK_BUY)
    }
      , Zl = reactExports.useCallback( () => Cl(Cn), [Cn, Cl])
      , Gl = reactExports.useCallback( () => El(Cn == null ? void 0 : Cn.id), [Cn, El])
      , Wl = reactExports.useMemo( () => $l.some(lu => lu.id === (Cn == null ? void 0 : Cn.id)), [$l, Cn])
      , Ql = reactExports.useCallback( () => {
        if (!Rl.current)
            return;
        const lu = Rl.current.clientWidth;
        Tl(Math.min(450, lu - 34))
    }
    , [Tl]);
    if (reactExports.useEffect( () => {
        Ql()
    }
    , [Ql]),
    reactExports.useEffect( () => {
        const lu = () => Ql();
        return window.addEventListener("resize", lu),
        () => window.removeEventListener("resize", lu)
    }
    , [Ql]),
    !Cn)
        return null;
    const cu = jsxRuntimeExports.jsxs("div", {
        className: styles$F.unlistedControls,
        children: [jsxRuntimeExports.jsx(Button, {
            className: styles$F.outputButton,
            onClick: () => Ml(Cn),
            "aria-label": xt("Output Gift"),
            iconButton: !0,
            children: jsxRuntimeExports.jsx(SvgWithdraw, {
                className: styles$F.outputButtonIcon
            })
        }), jsxRuntimeExports.jsx(Button, {
            className: styles$F.actionButton,
            onClick: () => Il(Cn),
            "aria-label": xt("button_list"),
            variant: "primary",
            children: xt("button_list")
        }), jsxRuntimeExports.jsx(Button, {
            iconButton: !0,
            onClick: () => Oc(`https://t.me/nft/${Cn.name}`),
            children: jsxRuntimeExports.jsx(SvgTelegramLogo, {})
        })]
    })
      , pu = jsxRuntimeExports.jsxs("div", {
        className: styles$F.listedControls,
        children: [new Date(Cn.promoteEndAt) < new Date && jsxRuntimeExports.jsx(Button, {
            className: styles$F.actionButton,
            onClick: () => Ll(Cn),
            "aria-label": xt("button_promote"),
            variant: "primary",
            size: "medium",
            children: jsxRuntimeExports.jsxs("div", {
                className: styles$F.actionButtonListText,
                children: [xt("button_promote"), jsxRuntimeExports.jsx(SvgTonIcon, {
                    className: styles$F.tonIcon
                }), " ", formatNanotons(Ls)]
            })
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$F.unlistedControls,
            children: [jsxRuntimeExports.jsx(Button, {
                className: styles$F.subactionButton,
                onClick: () => Ul(Cn),
                "aria-label": xt("button_cancel"),
                variant: "warning",
                children: xt("button_cancel")
            }), jsxRuntimeExports.jsx(Button, {
                iconButton: !0,
                onClick: () => Oc(`https://t.me/nft/${Cn.name}`),
                children: jsxRuntimeExports.jsx(SvgTelegramLogo, {})
            }), jsxRuntimeExports.jsx(Button, {
                className: styles$F.outputButton,
                onClick: () => Nl(Cn),
                "aria-label": xt("Share"),
                children: jsxRuntimeExports.jsx(SvgWithdraw, {
                    className: styles$F.shareButtonIcon
                })
            })]
        })]
    })
      , zl = jsxRuntimeExports.jsxs("div", {
        className: styles$F.buyControls,
        children: [jsxRuntimeExports.jsxs(Button, {
            className: styles$F.buyControlsButton,
            onClick: () => Dl(Cn),
            variant: "primary",
            children: [jsxRuntimeExports.jsx("div", {
                children: xt("button_buy")
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$F.buyControlsButtonPrice,
                children: [jsxRuntimeExports.jsx(SvgTonIcon, {}), formatNanotons(Cn.salePrice ?? 0)]
            })]
        }), jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: Wl ? jsxRuntimeExports.jsx(Button, {
                onClick: Gl,
                variant: "secondary",
                iconButton: !0,
                children: jsxRuntimeExports.jsx(SvgTrash, {
                    className: styles$F.trashIcon
                })
            }) : jsxRuntimeExports.jsx(Button, {
                onClick: Zl,
                variant: "secondary",
                iconButton: !0,
                children: jsxRuntimeExports.jsx(SvgCart, {
                    className: styles$F.cartIcon
                })
            })
        }), jsxRuntimeExports.jsx(Button, {
            iconButton: !0,
            onClick: () => Oc(`https://t.me/nft/${Cn.name}`),
            children: jsxRuntimeExports.jsx(SvgTelegramLogo, {})
        }), jsxRuntimeExports.jsx(Button, {
            iconButton: !0,
            onClick: () => Nl(Cn),
            children: jsxRuntimeExports.jsx(SvgShare, {})
        })]
    })
      , Yl = jsxRuntimeExports.jsxs("div", {
        className: styles$F.buyControls,
        children: [jsxRuntimeExports.jsx(Button, {
            className: styles$F.giftButton,
            onClick: Fl,
            children: jsxRuntimeExports.jsx("div", {
                className: styles$F.giftButtonText,
                children: xt("Close")
            })
        }), jsxRuntimeExports.jsx(Button, {
            className: styles$F.buyControlsIconButton,
            iconButton: !0,
            onClick: () => Oc(`https://t.me/nft/${Cn.name}`),
            children: jsxRuntimeExports.jsx(SvgTelegramLogo, {})
        }), jsxRuntimeExports.jsx(Button, {
            className: styles$F.buyControlsIconButton,
            iconButton: !0,
            onClick: () => Nl(Cn),
            children: jsxRuntimeExports.jsx(SvgShare, {})
        })]
    });
    return new Date(Cn.exportDate) < new Date,
    jsxRuntimeExports.jsxs("div", {
        className: styles$F.giftOverview,
        ref: Rl,
        children: [jsxRuntimeExports.jsx("div", {
            className: styles$F.giftIcon,
            children: jsxRuntimeExports.jsx(GiftCard, {
                gift: Cn,
                width: Sl,
                size: "large"
            })
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$F.giftDetails,
            children: [jsxRuntimeExports.jsxs("div", {
                className: styles$F.giftDetailsColumn,
                children: [jsxRuntimeExports.jsx("div", {
                    className: styles$F.giftDetailsRow,
                    children: jsxRuntimeExports.jsx("div", {
                        className: styles$F.giftDetailsLabel,
                        children: xt("gift_model")
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: styles$F.giftDetailsRow,
                    children: jsxRuntimeExports.jsx("div", {
                        className: styles$F.giftDetailsLabel,
                        children: xt("gift_backdrop")
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: styles$F.giftDetailsRow,
                    children: jsxRuntimeExports.jsx("div", {
                        className: styles$F.giftDetailsLabel,
                        children: xt("gift_symbol")
                    })
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$F.giftDetailsValueColumn,
                children: [jsxRuntimeExports.jsxs("div", {
                    className: styles$F.giftDetailsValueRow,
                    children: [jsxRuntimeExports.jsx("div", {
                        className: styles$F.giftDetailsValue,
                        children: Cn.modelName
                    }), jsxRuntimeExports.jsx("div", {
                        className: styles$F.rarityBadge,
                        children: jsxRuntimeExports.jsx("div", {
                            className: styles$F.rarityText,
                            children: formatPerMille(Cn.modelRarityPerMille)
                        })
                    })]
                }), jsxRuntimeExports.jsxs("div", {
                    className: styles$F.giftDetailsValueRow,
                    children: [jsxRuntimeExports.jsx("div", {
                        className: styles$F.giftDetailsValue,
                        children: Cn.backdropName
                    }), jsxRuntimeExports.jsx("div", {
                        className: styles$F.rarityBadge,
                        children: jsxRuntimeExports.jsx("div", {
                            className: styles$F.rarityText,
                            children: formatPerMille(Cn.backdropRarityPerMille)
                        })
                    })]
                }), jsxRuntimeExports.jsxs("div", {
                    className: styles$F.giftDetailsValueRow,
                    children: [jsxRuntimeExports.jsx("div", {
                        className: styles$F.giftDetailsValue,
                        children: Cn.symbolName
                    }), jsxRuntimeExports.jsx("div", {
                        className: styles$F.rarityBadge,
                        children: jsxRuntimeExports.jsx("div", {
                            className: styles$F.rarityText,
                            children: formatPerMille(Cn.symbolRarityPerMille ?? 0)
                        })
                    })]
                })]
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$F.giftOverviewFooter,
            children: [Cn.isMine && Cn.isOnSale && pu, Cn.isMine && !Cn.isOnSale && cu, !Cn.isMine && Cn.isOnSale && jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                children: Cn.isOnSale && !Cn.isMine ? zl : Cn.isOnSale && Cn.isMine ? pu : Yl
            })]
        })]
    })
}
  , multipleContainer = "_multipleContainer_8xsrg_1"
  , multipleButton = "_multipleButton_8xsrg_8"
  , multipleTextWrapper = "_multipleTextWrapper_8xsrg_13"
  , multipleText = "_multipleText_8xsrg_13"
  , multipleTextLink = "_multipleTextLink_8xsrg_29"
  , multipleLabel = "_multipleLabel_8xsrg_38"
  , optionsButtonsWrapper = "_optionsButtonsWrapper_8xsrg_47"
  , actionButton$6 = "_actionButton_8xsrg_54"
  , mainButtonsWrapper = "_mainButtonsWrapper_8xsrg_58"
  , listLabel = "_listLabel_8xsrg_65"
  , buttonsRow = "_buttonsRow_8xsrg_74"
  , styles$E = {
    multipleContainer,
    multipleButton,
    multipleTextWrapper,
    multipleText,
    multipleTextLink,
    multipleLabel,
    optionsButtonsWrapper,
    actionButton: actionButton$6,
    mainButtonsWrapper,
    listLabel,
    buttonsRow
}
  , MyGiftsActions = () => {
    const {t: xt} = useTranslation()
      , {multipleMode: Cn, setMultipleMode: as, selectedItems: cs, addModal: Cs, isHiSaid: Ls, checkIsHiSaid: Vs, relayerBotName: Ws, freeSalesCount: Xs, getMaxSelectableItems: ga} = useStorage(Rl => ({
        multipleMode: Rl.myGifts.multipleMode,
        setMultipleMode: Rl.myGifts.setMultipleMode,
        selectedItems: Rl.myGifts.selectedItems,
        addModal: Rl.modal.addModal,
        isHiSaid: Rl.myGifts.isHiSaid,
        checkIsHiSaid: Rl.myGifts.checkIsHiSaid,
        relayerBotName: Rl.app.relayerBotName,
        freeSalesCount: Rl.app.freeSalesCount,
        getMaxSelectableItems: Rl.myGifts.getMaxSelectableItems
    }))
      , ba = useFilters()
      , yl = reactExports.useMemo( () => myGiftsInfiniteQueryOptions("unlisted", ba), [ba])
      , {data: xl} = useInfiniteQuery(yl)
      , wl = reactExports.useMemo( () => {
        var Rl;
        return ((Rl = xl == null ? void 0 : xl.pages) == null ? void 0 : Rl.flatMap(Il => Il)) ?? []
    }
    , [xl == null ? void 0 : xl.pages])
      , _l = reactExports.useMemo( () => ga(), [Cn])
      , El = () => {
        cs.some(Rl => Rl.salesCount >= Xs) ? Cs(ModalNames.LISTING_SALES_LIMIT) : Cs(ModalNames.MULTIPLE_LISTING_PRICE)
    }
      , Cl = () => {
        Ls ? Cs(ModalNames.MULTIPLE_WITHDRAW_CONFIRM) : (Cs(ModalNames.ERROR, 0, {
            title: "text_error",
            message: "text_say_hi",
            onButtonClickHandler: () => Oc(`https://t.me/${Ws}`),
            buttonText: "button_say_hi"
        }),
        Vs())
    }
      , $l = () => {
        Cs(ModalNames.GA_CREATION, 9)
    }
      , Sl = () => {
        if (cs.length !== 0)
            switch (Cn) {
            case "listing":
                return El();
            case "withdraw":
                return Cl();
            case "giveaway":
                return $l();
            default:
                return
            }
    }
      , Tl = reactExports.useMemo( () => {
        switch (Cn) {
        case "giveaway":
            return "text_create_giveaway";
        case "listing":
            return "button_list_sale";
        case "withdraw":
            return "button_withdraw_gifts";
        default:
            return ""
        }
    }
    , [Cn]);
    return jsxRuntimeExports.jsxs("div", {
        className: styles$E.multipleContainer,
        children: [!!wl.length && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [Cn && jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                children: cs.length ? jsxRuntimeExports.jsxs("span", {
                    className: styles$E.multipleLabel,
                    children: [xt("Gifts Selected:"), ` ${cs.length}`, "/", `${_l}`]
                }) : jsxRuntimeExports.jsx("span", {
                    className: styles$E.multipleLabel,
                    children: xt("text_select_few_gifts")
                })
            }), cs.length && Cn ? jsxRuntimeExports.jsxs("div", {
                className: styles$E.optionsButtonsWrapper,
                children: [jsxRuntimeExports.jsx(Button, {
                    className: styles$E.actionButton,
                    onClick: Sl,
                    variant: "success",
                    children: xt(Tl)
                }), jsxRuntimeExports.jsx(Button, {
                    className: styles$E.actionButton,
                    onClick: () => as(null),
                    variant: "error",
                    children: xt("button_cancel")
                })]
            }) : jsxRuntimeExports.jsxs("div", {
                className: styles$E.mainButtonsWrapper,
                children: [jsxRuntimeExports.jsx(Button, {
                    className: styles$E.multipleButton,
                    onClick: () => as(Cn === "listing" ? null : "listing"),
                    children: jsxRuntimeExports.jsx("span", {
                        className: styles$E.listLabel,
                        children: xt("button_list_multiple")
                    })
                }), jsxRuntimeExports.jsxs("div", {
                    className: styles$E.buttonsRow,
                    children: [jsxRuntimeExports.jsx(Button, {
                        className: styles$E.multipleButton,
                        onClick: () => as(Cn === "withdraw" ? null : "withdraw"),
                        children: xt("button_withdraw_multiple")
                    }), jsxRuntimeExports.jsx(Button, {
                        className: styles$E.multipleButton,
                        onClick: () => as(Cn === "giveaway" ? null : "giveaway"),
                        children: xt("text_create_giveaway")
                    })]
                })]
            })]
        }), jsxRuntimeExports.jsx("div", {
            className: styles$E.multipleTextWrapper,
            children: jsxRuntimeExports.jsxs("div", {
                className: styles$E.multipleText,
                children: [xt("text_howto") + " ", jsxRuntimeExports.jsxs("span", {
                    onClick: () => Oc(`https://t.me/${Ws}`),
                    className: styles$E.multipleTextLink,
                    children: ["@", Ws]
                })]
            })
        })]
    })
}
  , multipleListingPrice = "_multipleListingPrice_re899_1"
  , giftIcon$3 = "_giftIcon_re899_9"
  , title$5 = "_title_re899_22"
  , inputWrapper = "_inputWrapper_re899_31"
  , formTitle = "_formTitle_re899_38"
  , subtitle = "_subtitle_re899_49"
  , priceInput = "_priceInput_re899_58"
  , inputError$1 = "_inputError_re899_63"
  , floor = "_floor_re899_68"
  , floorIcon = "_floorIcon_re899_79"
  , listButton = "_listButton_re899_84"
  , salesFee = "_salesFee_re899_88"
  , styles$D = {
    multipleListingPrice,
    giftIcon: giftIcon$3,
    title: title$5,
    inputWrapper,
    formTitle,
    subtitle,
    priceInput,
    inputError: inputError$1,
    floor,
    floorIcon,
    listButton,
    salesFee
}
  , MultipleListingPrice = () => {
    const {t: xt} = useTranslation()
      , {removeModal: Cn, addModal: as} = useStorage(El => El.modal)
      , {selectedItems: cs, minSalePrice: Cs, setListingPrice: Ls, maxSalePrice: Vs, salesFee: Ws} = useStorage(El => ({
        selectedItems: El.myGifts.selectedItems,
        setListingPrice: El.myGifts.setListingPrice,
        minSalePrice: El.app.minSalePrice,
        maxSalePrice: El.app.maxSalePrice,
        salesFee: El.profile.salesFee
    }))
      , [Xs,ga] = reactExports.useState("")
      , ba = !!Xs && Number(Xs) < Number(dist$1.fromNano(Cs))
      , yl = !!Xs && Number(Xs) > Number(dist$1.fromNano(Vs))
      , xl = ba || yl
      , wl = () => {
        cs.length > 0 && Xs && (Ls(Number(dist$1.toNano(Xs))),
        Cn(ModalNames.MULTIPLE_LISTING_PRICE),
        as(ModalNames.MULTIPLE_LISTING_CONFIRM))
    }
      , _l = El => {
        const $l = El.target.value.replace(/[^0-9.,]/g, "").replace(",", ".");
        ga($l)
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$D.multipleListingPrice,
        children: [jsxRuntimeExports.jsx("div", {
            className: styles$D.giftIcon,
            children: jsxRuntimeExports.jsx("img", {
                src: "/images/common/pack.png",
                alt: "Gift box"
            })
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$D.title,
            children: [xt("text_list_gifts_count"), ": ", cs.length]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$D.inputWrapper,
            children: [jsxRuntimeExports.jsx("h2", {
                className: styles$D.formTitle,
                children: xt("text_enter_price")
            }), jsxRuntimeExports.jsx("div", {
                className: styles$D.subtitle,
                children: xt("text_multiple_list_info")
            }), jsxRuntimeExports.jsx(Input, {
                className: styles$D.priceInput,
                placeholder: xt("input_tooltip_text"),
                icon: jsxRuntimeExports.jsx(SvgTonIcon, {}),
                value: Xs,
                onChange: _l,
                autoFocus: !0,
                inputMode: "decimal",
                pattern: "[0-9]*[.,]?[0-9]*",
                maxDecimalDigits: 2
            }), ba && jsxRuntimeExports.jsx("div", {
                className: styles$D.inputError,
                children: xt("text_list_minimum_price", {
                    value: formatNanotons(Cs)
                })
            }), yl && jsxRuntimeExports.jsx("div", {
                className: styles$D.inputError,
                children: xt("text_list_maximum_price", {
                    value: formatNanotons(Vs)
                })
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$D.floor,
                children: [jsxRuntimeExports.jsxs("span", {
                    children: [xt("text_floor_price"), ":"]
                }), jsxRuntimeExports.jsx(SvgTonIcon, {
                    className: styles$D.floorIcon
                }), jsxRuntimeExports.jsx("span", {
                    children: formatNanotons(Cs)
                })]
            }), jsxRuntimeExports.jsx("div", {
                className: styles$D.salesFee,
                children: xt("text_market_fee", {
                    value: Ws
                })
            })]
        }), jsxRuntimeExports.jsx(Button, {
            className: styles$D.listButton,
            onClick: wl,
            disabled: xl || !Xs || cs.length === 0,
            variant: "primary",
            children: xt("button_list")
        })]
    })
}
  , multipleListingConfirm = "_multipleListingConfirm_choq0_1"
  , giftIcon$2 = "_giftIcon_choq0_9"
  , info$2 = "_info_choq0_19"
  , title$4 = "_title_choq0_24"
  , totalWrapper$1 = "_totalWrapper_choq0_32"
  , confirmText$3 = "_confirmText_choq0_38"
  , inputError = "_inputError_choq0_49"
  , actions$3 = "_actions_choq0_54"
  , actionButton$5 = "_actionButton_choq0_60"
  , styles$C = {
    multipleListingConfirm,
    giftIcon: giftIcon$2,
    info: info$2,
    title: title$4,
    totalWrapper: totalWrapper$1,
    confirmText: confirmText$3,
    inputError,
    actions: actions$3,
    actionButton: actionButton$5
}
  , MultipleListingConfirm = () => {
    const {t: xt} = useTranslation()
      , {selectedItems: Cn, clearSelectedItems: as, setMultipleMode: cs, listingPrice: Cs, setListingPrice: Ls} = useStorage($l => $l.myGifts)
      , {removeModal: Vs, addModal: Ws} = useStorage($l => $l.modal)
      , {minSalePrice: Xs, maxSalePrice: ga} = useStorage($l => ({
        minSalePrice: $l.app.minSalePrice,
        maxSalePrice: $l.app.maxSalePrice
    }))
      , {mutateAsync: ba, isPending: yl} = useListGifts(Cn, ModalNames.MULTIPLE_LISTING_CONFIRM)
      , xl = reactExports.useMemo( () => Cs ? Cs < Xs ? xt("text_list_minimum_price", {
        value: formatNanotons(Xs)
    }) : Cs > ga ? xt("text_list_maximum_price", {
        value: formatNanotons(ga)
    }) : null : null, [Cs, Xs, ga])
      , wl = async () => {
        !Cs || xl || (await ba(Cs),
        as(),
        cs(null),
        Ls(null))
    }
      , _l = () => {
        Vs(ModalNames.MULTIPLE_LISTING_CONFIRM),
        as(),
        cs(null),
        Ls(null)
    }
      , El = () => {
        Vs(ModalNames.MULTIPLE_LISTING_CONFIRM),
        Ws(ModalNames.MULTIPLE_LISTING_PRICE)
    }
    ;
    if (Cn.length === 0)
        return null;
    const Cl = Cn.length * (Cs ?? 0);
    return jsxRuntimeExports.jsxs("div", {
        className: styles$C.multipleListingConfirm,
        children: [jsxRuntimeExports.jsx("div", {
            className: styles$C.giftIcon,
            children: jsxRuntimeExports.jsx("img", {
                src: "/images/common/pack.png",
                alt: "Gift box"
            })
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$C.info,
            children: [jsxRuntimeExports.jsxs("div", {
                className: styles$C.title,
                children: [xt("text_list_gifts_count"), ": ", Cn.length]
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$C.title,
                children: [xt("text_price_for_each_gift"), ": ", formatNanotons(Cs ?? 0), " TON"]
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$C.totalWrapper,
            children: [jsxRuntimeExports.jsx("p", {
                className: styles$C.confirmText,
                children: xt("text_list_gifts_confirm", {
                    value: formatNanotons(Cl)
                })
            }), xl && jsxRuntimeExports.jsx("p", {
                className: styles$C.inputError,
                children: xl
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$C.actions,
            children: [jsxRuntimeExports.jsx(Button, {
                loading: yl,
                className: styles$C.actionButton,
                onClick: wl,
                variant: "success",
                disabled: !!xl,
                children: xt("button_yes")
            }), jsxRuntimeExports.jsx(Button, {
                disabled: yl,
                className: styles$C.actionButton,
                onClick: _l,
                variant: "error",
                children: xt("button_no")
            }), xl && jsxRuntimeExports.jsx(Button, {
                disabled: yl,
                className: styles$C.actionButton,
                onClick: El,
                variant: "primary",
                children: "Edit Price"
            })]
        })]
    })
}
  , content$2 = "_content_1hk2e_1"
  , walletIcon$2 = "_walletIcon_1hk2e_8"
  , details$2 = "_details_1hk2e_14"
  , title$3 = "_title_1hk2e_22"
  , input$3 = "_input_1hk2e_29"
  , inputContainer$2 = "_inputContainer_1hk2e_34"
  , inputIcon$1 = "_inputIcon_1hk2e_38"
  , confirmButton$1 = "_confirmButton_1hk2e_60"
  , styles$B = {
    content: content$2,
    walletIcon: walletIcon$2,
    details: details$2,
    title: title$3,
    input: input$3,
    inputContainer: inputContainer$2,
    inputIcon: inputIcon$1,
    confirmButton: confirmButton$1
}
  , NANO_MULTIPLIER = 1e9
  , Deposit = () => {
    var Tl;
    const {t: xt} = useTranslation()
      , {removeModal: Cn, minDepositAmount: as, payerId: cs, targetWallet: Cs, monitorTransactions: Ls, queue: Vs} = useStorage(Rl => ({
        removeModal: Rl.modal.removeModal,
        minDepositAmount: Rl.app.minDepositAmount,
        payerId: Rl.profile.payerId,
        targetWallet: Rl.app.targetWallet,
        monitorTransactions: Rl.transaction.monitorTransactions,
        queue: Rl.modal.queue
    }))
      , Ws = Vs.find(Rl => Rl.name === ModalNames.DEPOSIT)
      , Xs = ((Tl = Ws == null ? void 0 : Ws.params) == null ? void 0 : Tl.depositAmount) || as
      , [ga] = useTonConnectUI()
      , [ba,yl] = reactExports.useState("")
      , [xl,wl] = reactExports.useState(dist$1.fromNano(Xs))
      , [_l,El] = reactExports.useState(Xs)
      , Cl = Rl => {
        const Ml = Rl.target.value.replace(/[^0-9.,]/g, "").replace(",", ".");
        wl(Ml)
    }
      , $l = async () => {
        const Rl = dist$1.beginCell().storeUint(0, 32).storeStringTail(cs).endCell();
        await ga.sendTransaction({
            validUntil: Math.floor(Date.now() / 1e3) + 360,
            messages: [{
                amount: _l.toString(),
                address: Cs,
                payload: Rl.toBoc().toString("base64")
            }]
        }),
        Cn(ModalNames.DEPOSIT),
        Ls()
    }
      , Sl = Rl => {
        const Ml = Number(Rl.replace(/,/gim, ".")) * NANO_MULTIPLIER;
        if (El(Ml),
        Ml < as) {
            yl(`Minimal amount: ${formatNanotons(as)} TON`);
            return
        } else
            yl("")
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$B.content,
        children: [jsxRuntimeExports.jsx("img", {
            src: "/images/common/wallet.png",
            className: styles$B.walletIcon,
            alt: ""
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$B.details,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$B.title,
                children: xt("text_deposit")
            }), jsxRuntimeExports.jsx(Input, {
                value: xl,
                onChange: Cl,
                placeholder: xt("input_tooltip_amount"),
                error: xt(ba),
                onValidate: Sl,
                className: styles$B.input,
                containerClassName: styles$B.inputContainer,
                icon: jsxRuntimeExports.jsx(SvgTonIcon, {
                    className: styles$B.inputIcon
                }),
                autoFocus: !0,
                inputMode: "decimal",
                pattern: "[0-9]*[.,]?[0-9]*"
            })]
        }), jsxRuntimeExports.jsx(Button, {
            className: classNames$1(styles$B.confirmButton),
            onClick: $l,
            disabled: !!ba,
            variant: "primary",
            children: xt("button_deposit")
        })]
    })
}
  , content$1 = "_content_16912_1"
  , walletIcon$1 = "_walletIcon_16912_8"
  , details$1 = "_details_16912_14"
  , title$2 = "_title_16912_22"
  , input$2 = "_input_16912_29"
  , inputContainer$1 = "_inputContainer_16912_34"
  , inputIcon = "_inputIcon_16912_38"
  , balance$2 = "_balance_16912_44"
  , balanceIcon$1 = "_balanceIcon_16912_52"
  , confirmButton = "_confirmButton_16912_60"
  , balanceAmount = "_balanceAmount_16912_65"
  , minAmount = "_minAmount_16912_74"
  , styles$A = {
    content: content$1,
    walletIcon: walletIcon$1,
    details: details$1,
    title: title$2,
    input: input$2,
    inputContainer: inputContainer$1,
    inputIcon,
    balance: balance$2,
    balanceIcon: balanceIcon$1,
    confirmButton,
    balanceAmount,
    minAmount
}
  , Withdraw = () => {
    const {t: xt} = useTranslation()
      , {removeModal: Cn, addModal: as, hard: cs, minWithdrawAmount: Cs, isWithdrawPending: Ls, requestTonWithdraw: Vs} = useStorage(Sl => ({
        removeModal: Sl.modal.removeModal,
        addModal: Sl.modal.addModal,
        hard: Sl.wallet.balance.hard,
        minWithdrawAmount: Sl.app.minWithdrawAmount,
        isWithdrawPending: Sl.withdraw.isWithdrawPending,
        requestTonWithdraw: Sl.withdraw.requestTonWithdraw
    }))
      , [Ws,Xs] = reactExports.useState("")
      , [ga,ba] = reactExports.useState("")
      , [yl,xl] = reactExports.useState(0)
      , wl = formatNanotons(Cs)
      , _l = useTonAddress(!0)
      , El = Sl => {
        const Rl = Sl.target.value.replace(/[^0-9.,]/g, "").replace(",", ".");
        ba(Rl)
    }
      , Cl = async () => {
        const Sl = await Vs(yl, _l);
        Cn(ModalNames.WITHDRAW),
        Sl && Sl.ok ? as(ModalNames.CONGRATS, 0, {
            image: "/images/common/green-check-mark.png",
            title: "text_success_withdraw",
            message: "text_ton_workload",
            buttonText: "button_nice"
        }) : as(ModalNames.ERROR, 0, {
            title: "text_error",
            message: "text_fail_ton_withdraw"
        })
    }
      , $l = Sl => {
        const Rl = Number(Sl.replace(/,/gim, ".")) * NANO_MULTIPLIER;
        if (xl(Rl),
        Rl < Cs) {
            Xs("text_withdraw_info");
            return
        }
        if (Rl > cs) {
            Xs("text_warning_insufficient");
            return
        }
        Xs("")
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$A.content,
        children: [jsxRuntimeExports.jsx("img", {
            src: "/images/common/wallet.png",
            className: styles$A.walletIcon,
            alt: ""
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$A.details,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$A.title,
                children: xt("text_withdraw")
            }), jsxRuntimeExports.jsx(Input, {
                value: ga,
                onChange: El,
                placeholder: xt("input_tooltip_amount"),
                error: xt(Ws, {
                    value: wl
                }),
                onValidate: $l,
                className: styles$A.input,
                containerClassName: styles$A.inputContainer,
                icon: jsxRuntimeExports.jsx(SvgTonIcon, {
                    className: styles$A.inputIcon
                }),
                autoFocus: !0,
                inputMode: "decimal",
                pattern: "[0-9]*[.,]?[0-9]*",
                disabled: Ls
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$A.balance,
                children: [xt("text_deposit_balance"), " ", jsxRuntimeExports.jsx(SvgTonIcon, {
                    className: styles$A.balanceIcon
                }), " ", jsxRuntimeExports.jsx("span", {
                    className: styles$A.balanceAmount,
                    children: formatNanotons(cs, !0)
                })]
            }), jsxRuntimeExports.jsx("div", {
                className: styles$A.minAmount,
                children: xt("text_withdraw_info", {
                    value: wl
                })
            })]
        }), jsxRuntimeExports.jsx(Button, {
            className: styles$A.confirmButton,
            onClick: Cl,
            disabled: !!Ws || !ga,
            variant: "primary",
            loading: Ls,
            children: xt("button_withdraw")
        })]
    })
}
  , $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document < "u" ? React__default.useLayoutEffect : () => {}
;
function $8ae05eaa5c114e9c$export$7f54fc3180508a52(xt) {
    const Cn = reactExports.useRef(null);
    return $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c( () => {
        Cn.current = xt
    }
    , [xt]),
    reactExports.useCallback( (...as) => {
        const cs = Cn.current;
        return cs == null ? void 0 : cs(...as)
    }
    , [])
}
const $431fbd86ca7dc216$export$b204af158042fbac = xt => {
    var Cn;
    return (Cn = xt == null ? void 0 : xt.ownerDocument) !== null && Cn !== void 0 ? Cn : document
}
  , $431fbd86ca7dc216$export$f21a1ffae260145a = xt => xt && "window"in xt && xt.window === xt ? xt : $431fbd86ca7dc216$export$b204af158042fbac(xt).defaultView || window;
function $431fbd86ca7dc216$var$isNode(xt) {
    return xt !== null && typeof xt == "object" && "nodeType"in xt && typeof xt.nodeType == "number"
}
function $431fbd86ca7dc216$export$af51f0f06c0f328a(xt) {
    return $431fbd86ca7dc216$var$isNode(xt) && xt.nodeType === Node.DOCUMENT_FRAGMENT_NODE && "host"in xt
}
let $f4e2df6bd15f8569$var$_shadowDOM = !1;
function $f4e2df6bd15f8569$export$98658e8c59125e6a() {
    return $f4e2df6bd15f8569$var$_shadowDOM
}
function $d4ee10de306f2510$export$4282f70798064fe0(xt, Cn) {
    if (!$f4e2df6bd15f8569$export$98658e8c59125e6a())
        return Cn && xt ? xt.contains(Cn) : !1;
    if (!xt || !Cn)
        return !1;
    let as = Cn;
    for (; as !== null; ) {
        if (as === xt)
            return !0;
        as.tagName === "SLOT" && as.assignedSlot ? as = as.assignedSlot.parentNode : $431fbd86ca7dc216$export$af51f0f06c0f328a(as) ? as = as.host : as = as.parentNode
    }
    return !1
}
const $d4ee10de306f2510$export$cd4e5573fbe2b576 = (xt=document) => {
    var Cn;
    if (!$f4e2df6bd15f8569$export$98658e8c59125e6a())
        return xt.activeElement;
    let as = xt.activeElement;
    for (; as && "shadowRoot"in as && (!((Cn = as.shadowRoot) === null || Cn === void 0) && Cn.activeElement); )
        as = as.shadowRoot.activeElement;
    return as
}
;
function $d4ee10de306f2510$export$e58f029f0fbfdb29(xt) {
    return $f4e2df6bd15f8569$export$98658e8c59125e6a() && xt.target.shadowRoot && xt.composedPath ? xt.composedPath()[0] : xt.target
}
function $c87311424ea30a05$var$testUserAgent(xt) {
    var Cn;
    return typeof window > "u" || window.navigator == null ? !1 : ((Cn = window.navigator.userAgentData) === null || Cn === void 0 ? void 0 : Cn.brands.some(as => xt.test(as.brand))) || xt.test(window.navigator.userAgent)
}
function $c87311424ea30a05$var$testPlatform(xt) {
    var Cn;
    return typeof window < "u" && window.navigator != null ? xt.test(((Cn = window.navigator.userAgentData) === null || Cn === void 0 ? void 0 : Cn.platform) || window.navigator.platform) : !1
}
function $c87311424ea30a05$var$cached(xt) {
    let Cn = null;
    return () => (Cn == null && (Cn = xt()),
    Cn)
}
const $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$var$testPlatform(/^Mac/i)
})
  , $c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$var$testUserAgent(/Android/i)
});
function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {
    let xt = reactExports.useRef(new Map)
      , Cn = reactExports.useCallback( (Cs, Ls, Vs, Ws) => {
        let Xs = Ws != null && Ws.once ? (...ga) => {
            xt.current.delete(Vs),
            Vs(...ga)
        }
        : Vs;
        xt.current.set(Vs, {
            type: Ls,
            eventTarget: Cs,
            fn: Xs,
            options: Ws
        }),
        Cs.addEventListener(Ls, Xs, Ws)
    }
    , [])
      , as = reactExports.useCallback( (Cs, Ls, Vs, Ws) => {
        var Xs;
        let ga = ((Xs = xt.current.get(Vs)) === null || Xs === void 0 ? void 0 : Xs.fn) || Vs;
        Cs.removeEventListener(Ls, ga, Ws),
        xt.current.delete(Vs)
    }
    , [])
      , cs = reactExports.useCallback( () => {
        xt.current.forEach( (Cs, Ls) => {
            as(Cs.eventTarget, Cs.type, Ls, Cs.options)
        }
        )
    }
    , [as]);
    return reactExports.useEffect( () => cs, [cs]),
    {
        addGlobalListener: Cn,
        removeGlobalListener: as,
        removeAllGlobalListeners: cs
    }
}
function $6a7db85432448f7f$export$60278871457622de(xt) {
    return xt.mozInputSource === 0 && xt.isTrusted ? !0 : $c87311424ea30a05$export$a11b0059900ceec8() && xt.pointerType ? xt.type === "click" && xt.buttons === 1 : xt.detail === 0 && !xt.pointerType
}
function $8a9cb279dc87e130$export$525bc4921d56d4a(xt) {
    let Cn = xt;
    return Cn.nativeEvent = xt,
    Cn.isDefaultPrevented = () => Cn.defaultPrevented,
    Cn.isPropagationStopped = () => Cn.cancelBubble,
    Cn.persist = () => {}
    ,
    Cn
}
function $8a9cb279dc87e130$export$c2b7abe5d61ec696(xt, Cn) {
    Object.defineProperty(xt, "target", {
        value: Cn
    }),
    Object.defineProperty(xt, "currentTarget", {
        value: Cn
    })
}
function $8a9cb279dc87e130$export$715c682d09d639cc(xt) {
    let Cn = reactExports.useRef({
        isFocused: !1,
        observer: null
    });
    $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c( () => {
        const cs = Cn.current;
        return () => {
            cs.observer && (cs.observer.disconnect(),
            cs.observer = null)
        }
    }
    , []);
    let as = $8ae05eaa5c114e9c$export$7f54fc3180508a52(cs => {
        xt == null || xt(cs)
    }
    );
    return reactExports.useCallback(cs => {
        if (cs.target instanceof HTMLButtonElement || cs.target instanceof HTMLInputElement || cs.target instanceof HTMLTextAreaElement || cs.target instanceof HTMLSelectElement) {
            Cn.current.isFocused = !0;
            let Cs = cs.target
              , Ls = Vs => {
                if (Cn.current.isFocused = !1,
                Cs.disabled) {
                    let Ws = $8a9cb279dc87e130$export$525bc4921d56d4a(Vs);
                    as(Ws)
                }
                Cn.current.observer && (Cn.current.observer.disconnect(),
                Cn.current.observer = null)
            }
            ;
            Cs.addEventListener("focusout", Ls, {
                once: !0
            }),
            Cn.current.observer = new MutationObserver( () => {
                if (Cn.current.isFocused && Cs.disabled) {
                    var Vs;
                    (Vs = Cn.current.observer) === null || Vs === void 0 || Vs.disconnect();
                    let Ws = Cs === document.activeElement ? null : document.activeElement;
                    Cs.dispatchEvent(new FocusEvent("blur",{
                        relatedTarget: Ws
                    })),
                    Cs.dispatchEvent(new FocusEvent("focusout",{
                        bubbles: !0,
                        relatedTarget: Ws
                    }))
                }
            }
            ),
            Cn.current.observer.observe(Cs, {
                attributes: !0,
                attributeFilter: ["disabled"]
            })
        }
    }
    , [as])
}
let $8a9cb279dc87e130$export$fda7da73ab5d4c48 = !1
  , $507fabe10e71c6fb$var$currentModality = null
  , $507fabe10e71c6fb$var$changeHandlers = new Set
  , $507fabe10e71c6fb$export$d90243b58daecda7 = new Map
  , $507fabe10e71c6fb$var$hasEventBeforeFocus = !1
  , $507fabe10e71c6fb$var$hasBlurredWindowRecently = !1;
const $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
    Tab: !0,
    Escape: !0
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(xt, Cn) {
    for (let as of $507fabe10e71c6fb$var$changeHandlers)
        as(xt, Cn)
}
function $507fabe10e71c6fb$var$isValidKey(xt) {
    return !(xt.metaKey || !$c87311424ea30a05$export$9ac100e40613ea10() && xt.altKey || xt.ctrlKey || xt.key === "Control" || xt.key === "Shift" || xt.key === "Meta")
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(xt) {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = !0,
    $507fabe10e71c6fb$var$isValidKey(xt) && ($507fabe10e71c6fb$var$currentModality = "keyboard",
    $507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", xt))
}
function $507fabe10e71c6fb$var$handlePointerEvent(xt) {
    $507fabe10e71c6fb$var$currentModality = "pointer",
    (xt.type === "mousedown" || xt.type === "pointerdown") && ($507fabe10e71c6fb$var$hasEventBeforeFocus = !0,
    $507fabe10e71c6fb$var$triggerChangeHandlers("pointer", xt))
}
function $507fabe10e71c6fb$var$handleClickEvent(xt) {
    $6a7db85432448f7f$export$60278871457622de(xt) && ($507fabe10e71c6fb$var$hasEventBeforeFocus = !0,
    $507fabe10e71c6fb$var$currentModality = "virtual")
}
function $507fabe10e71c6fb$var$handleFocusEvent(xt) {
    xt.target === window || xt.target === document || $8a9cb279dc87e130$export$fda7da73ab5d4c48 || !xt.isTrusted || (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently && ($507fabe10e71c6fb$var$currentModality = "virtual",
    $507fabe10e71c6fb$var$triggerChangeHandlers("virtual", xt)),
    $507fabe10e71c6fb$var$hasEventBeforeFocus = !1,
    $507fabe10e71c6fb$var$hasBlurredWindowRecently = !1)
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = !1,
    $507fabe10e71c6fb$var$hasBlurredWindowRecently = !0
}
function $507fabe10e71c6fb$var$setupGlobalFocusEvents(xt) {
    if (typeof window > "u" || $507fabe10e71c6fb$export$d90243b58daecda7.get($431fbd86ca7dc216$export$f21a1ffae260145a(xt)))
        return;
    const Cn = $431fbd86ca7dc216$export$f21a1ffae260145a(xt)
      , as = $431fbd86ca7dc216$export$b204af158042fbac(xt);
    let cs = Cn.HTMLElement.prototype.focus;
    Cn.HTMLElement.prototype.focus = function() {
        $507fabe10e71c6fb$var$hasEventBeforeFocus = !0,
        cs.apply(this, arguments)
    }
    ,
    as.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, !0),
    as.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, !0),
    as.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, !0),
    Cn.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, !0),
    Cn.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, !1),
    typeof PointerEvent < "u" && (as.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, !0),
    as.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, !0),
    as.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, !0)),
    Cn.addEventListener("beforeunload", () => {
        $507fabe10e71c6fb$var$tearDownWindowFocusTracking(xt)
    }
    , {
        once: !0
    }),
    $507fabe10e71c6fb$export$d90243b58daecda7.set(Cn, {
        focus: cs
    })
}
const $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (xt, Cn) => {
    const as = $431fbd86ca7dc216$export$f21a1ffae260145a(xt)
      , cs = $431fbd86ca7dc216$export$b204af158042fbac(xt);
    Cn && cs.removeEventListener("DOMContentLoaded", Cn),
    $507fabe10e71c6fb$export$d90243b58daecda7.has(as) && (as.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(as).focus,
    cs.removeEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, !0),
    cs.removeEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, !0),
    cs.removeEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, !0),
    as.removeEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, !0),
    as.removeEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, !1),
    typeof PointerEvent < "u" && (cs.removeEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, !0),
    cs.removeEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, !0),
    cs.removeEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, !0)),
    $507fabe10e71c6fb$export$d90243b58daecda7.delete(as))
}
;
function $507fabe10e71c6fb$export$2f1888112f558a7d(xt) {
    const Cn = $431fbd86ca7dc216$export$b204af158042fbac(xt);
    let as;
    return Cn.readyState !== "loading" ? $507fabe10e71c6fb$var$setupGlobalFocusEvents(xt) : (as = () => {
        $507fabe10e71c6fb$var$setupGlobalFocusEvents(xt)
    }
    ,
    Cn.addEventListener("DOMContentLoaded", as)),
    () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(xt, as)
}
typeof document < "u" && $507fabe10e71c6fb$export$2f1888112f558a7d();
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
    return $507fabe10e71c6fb$var$currentModality !== "pointer"
}
const $507fabe10e71c6fb$var$nonTextInputTypes = new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);
function $507fabe10e71c6fb$var$isKeyboardFocusEvent(xt, Cn, as) {
    let cs = $431fbd86ca7dc216$export$b204af158042fbac(as == null ? void 0 : as.target);
    const Cs = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(as == null ? void 0 : as.target).HTMLInputElement : HTMLInputElement
      , Ls = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(as == null ? void 0 : as.target).HTMLTextAreaElement : HTMLTextAreaElement
      , Vs = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(as == null ? void 0 : as.target).HTMLElement : HTMLElement
      , Ws = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(as == null ? void 0 : as.target).KeyboardEvent : KeyboardEvent;
    return xt = xt || cs.activeElement instanceof Cs && !$507fabe10e71c6fb$var$nonTextInputTypes.has(cs.activeElement.type) || cs.activeElement instanceof Ls || cs.activeElement instanceof Vs && cs.activeElement.isContentEditable,
    !(xt && Cn === "keyboard" && as instanceof Ws && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[as.key])
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(xt, Cn, as) {
    $507fabe10e71c6fb$var$setupGlobalFocusEvents(),
    reactExports.useEffect( () => {
        let cs = (Cs, Ls) => {
            $507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(as != null && as.isTextInput), Cs, Ls) && xt($507fabe10e71c6fb$export$b9b3dfddab17db27())
        }
        ;
        return $507fabe10e71c6fb$var$changeHandlers.add(cs),
        () => {
            $507fabe10e71c6fb$var$changeHandlers.delete(cs)
        }
    }
    , Cn)
}
function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(xt) {
    let {isDisabled: Cn, onFocus: as, onBlur: cs, onFocusChange: Cs} = xt;
    const Ls = reactExports.useCallback(Xs => {
        if (Xs.target === Xs.currentTarget)
            return cs && cs(Xs),
            Cs && Cs(!1),
            !0
    }
    , [cs, Cs])
      , Vs = $8a9cb279dc87e130$export$715c682d09d639cc(Ls)
      , Ws = reactExports.useCallback(Xs => {
        const ga = $431fbd86ca7dc216$export$b204af158042fbac(Xs.target)
          , ba = ga ? $d4ee10de306f2510$export$cd4e5573fbe2b576(ga) : $d4ee10de306f2510$export$cd4e5573fbe2b576();
        Xs.target === Xs.currentTarget && ba === $d4ee10de306f2510$export$e58f029f0fbfdb29(Xs.nativeEvent) && (as && as(Xs),
        Cs && Cs(!0),
        Vs(Xs))
    }
    , [Cs, as, Vs]);
    return {
        focusProps: {
            onFocus: !Cn && (as || Cs || cs) ? Ws : void 0,
            onBlur: !Cn && (cs || Cs) ? Ls : void 0
        }
    }
}
function $9ab94262bd0047c7$export$420e68273165f4ec(xt) {
    let {isDisabled: Cn, onBlurWithin: as, onFocusWithin: cs, onFocusWithinChange: Cs} = xt
      , Ls = reactExports.useRef({
        isFocusWithin: !1
    })
      , {addGlobalListener: Vs, removeAllGlobalListeners: Ws} = $03deb23ff14920c4$export$4eaf04e54aa8eed6()
      , Xs = reactExports.useCallback(yl => {
        yl.currentTarget.contains(yl.target) && Ls.current.isFocusWithin && !yl.currentTarget.contains(yl.relatedTarget) && (Ls.current.isFocusWithin = !1,
        Ws(),
        as && as(yl),
        Cs && Cs(!1))
    }
    , [as, Cs, Ls, Ws])
      , ga = $8a9cb279dc87e130$export$715c682d09d639cc(Xs)
      , ba = reactExports.useCallback(yl => {
        if (!yl.currentTarget.contains(yl.target))
            return;
        const xl = $431fbd86ca7dc216$export$b204af158042fbac(yl.target)
          , wl = $d4ee10de306f2510$export$cd4e5573fbe2b576(xl);
        if (!Ls.current.isFocusWithin && wl === $d4ee10de306f2510$export$e58f029f0fbfdb29(yl.nativeEvent)) {
            cs && cs(yl),
            Cs && Cs(!0),
            Ls.current.isFocusWithin = !0,
            ga(yl);
            let _l = yl.currentTarget;
            Vs(xl, "focus", El => {
                if (Ls.current.isFocusWithin && !$d4ee10de306f2510$export$4282f70798064fe0(_l, El.target)) {
                    let Cl = new xl.defaultView.FocusEvent("blur",{
                        relatedTarget: El.target
                    });
                    $8a9cb279dc87e130$export$c2b7abe5d61ec696(Cl, _l);
                    let $l = $8a9cb279dc87e130$export$525bc4921d56d4a(Cl);
                    Xs($l)
                }
            }
            , {
                capture: !0
            })
        }
    }
    , [cs, Cs, ga, Vs, Xs]);
    return Cn ? {
        focusWithinProps: {
            onFocus: void 0,
            onBlur: void 0
        }
    } : {
        focusWithinProps: {
            onFocus: ba,
            onBlur: Xs
        }
    }
}
let $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1
  , $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !0,
    setTimeout( () => {
        $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1
    }
    , 50)
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(xt) {
    xt.pointerType === "touch" && $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents()
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
    if (!(typeof document > "u"))
        return typeof PointerEvent < "u" && document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent),
        $6179b936705e76d3$var$hoverCount++,
        () => {
            $6179b936705e76d3$var$hoverCount--,
            !($6179b936705e76d3$var$hoverCount > 0) && typeof PointerEvent < "u" && document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent)
        }
}
function $6179b936705e76d3$export$ae780daf29e6d456(xt) {
    let {onHoverStart: Cn, onHoverChange: as, onHoverEnd: cs, isDisabled: Cs} = xt
      , [Ls,Vs] = reactExports.useState(!1)
      , Ws = reactExports.useRef({
        isHovered: !1,
        ignoreEmulatedMouseEvents: !1,
        pointerType: "",
        target: null
    }).current;
    reactExports.useEffect($6179b936705e76d3$var$setupGlobalTouchEvents, []);
    let {addGlobalListener: Xs, removeAllGlobalListeners: ga} = $03deb23ff14920c4$export$4eaf04e54aa8eed6()
      , {hoverProps: ba, triggerHoverEnd: yl} = reactExports.useMemo( () => {
        let xl = (El, Cl) => {
            if (Ws.pointerType = Cl,
            Cs || Cl === "touch" || Ws.isHovered || !El.currentTarget.contains(El.target))
                return;
            Ws.isHovered = !0;
            let $l = El.currentTarget;
            Ws.target = $l,
            Xs($431fbd86ca7dc216$export$b204af158042fbac(El.target), "pointerover", Sl => {
                Ws.isHovered && Ws.target && !$d4ee10de306f2510$export$4282f70798064fe0(Ws.target, Sl.target) && wl(Sl, Sl.pointerType)
            }
            , {
                capture: !0
            }),
            Cn && Cn({
                type: "hoverstart",
                target: $l,
                pointerType: Cl
            }),
            as && as(!0),
            Vs(!0)
        }
          , wl = (El, Cl) => {
            let $l = Ws.target;
            Ws.pointerType = "",
            Ws.target = null,
            !(Cl === "touch" || !Ws.isHovered || !$l) && (Ws.isHovered = !1,
            ga(),
            cs && cs({
                type: "hoverend",
                target: $l,
                pointerType: Cl
            }),
            as && as(!1),
            Vs(!1))
        }
          , _l = {};
        return typeof PointerEvent < "u" && (_l.onPointerEnter = El => {
            $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && El.pointerType === "mouse" || xl(El, El.pointerType)
        }
        ,
        _l.onPointerLeave = El => {
            !Cs && El.currentTarget.contains(El.target) && wl(El, El.pointerType)
        }
        ),
        {
            hoverProps: _l,
            triggerHoverEnd: wl
        }
    }
    , [Cn, as, cs, Cs, Ws, Xs, ga]);
    return reactExports.useEffect( () => {
        Cs && yl({
            currentTarget: Ws.target
        }, Ws.pointerType)
    }
    , [Cs]),
    {
        hoverProps: ba,
        isHovered: Ls
    }
}
function $f7dceffc5ad7768b$export$4e328f61c538687f(xt={}) {
    let {autoFocus: Cn=!1, isTextInput: as, within: cs} = xt
      , Cs = reactExports.useRef({
        isFocused: !1,
        isFocusVisible: Cn || $507fabe10e71c6fb$export$b9b3dfddab17db27()
    })
      , [Ls,Vs] = reactExports.useState(!1)
      , [Ws,Xs] = reactExports.useState( () => Cs.current.isFocused && Cs.current.isFocusVisible)
      , ga = reactExports.useCallback( () => Xs(Cs.current.isFocused && Cs.current.isFocusVisible), [])
      , ba = reactExports.useCallback(wl => {
        Cs.current.isFocused = wl,
        Vs(wl),
        ga()
    }
    , [ga]);
    $507fabe10e71c6fb$export$ec71b4b83ac08ec3(wl => {
        Cs.current.isFocusVisible = wl,
        ga()
    }
    , [], {
        isTextInput: as
    });
    let {focusProps: yl} = $a1ea59d68270f0dd$export$f8168d8dd8fd66e6({
        isDisabled: cs,
        onFocusChange: ba
    })
      , {focusWithinProps: xl} = $9ab94262bd0047c7$export$420e68273165f4ec({
        isDisabled: !cs,
        onFocusWithinChange: ba
    });
    return {
        isFocused: Ls,
        isFocusVisible: Ws,
        focusProps: cs ? xl : yl
    }
}
var i$5 = Object.defineProperty
  , d$3 = (xt, Cn, as) => Cn in xt ? i$5(xt, Cn, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: as
}) : xt[Cn] = as
  , r$3 = (xt, Cn, as) => (d$3(xt, typeof Cn != "symbol" ? Cn + "" : Cn, as),
as);
let o$8 = class {
    constructor() {
        r$3(this, "current", this.detect()),
        r$3(this, "handoffState", "pending"),
        r$3(this, "currentId", 0)
    }
    set(Cn) {
        this.current !== Cn && (this.handoffState = "pending",
        this.currentId = 0,
        this.current = Cn)
    }
    reset() {
        this.set(this.detect())
    }
    nextId() {
        return ++this.currentId
    }
    get isServer() {
        return this.current === "server"
    }
    get isClient() {
        return this.current === "client"
    }
    detect() {
        return typeof window > "u" || typeof document > "u" ? "server" : "client"
    }
    handoff() {
        this.handoffState === "pending" && (this.handoffState = "complete")
    }
    get isHandoffComplete() {
        return this.handoffState === "complete"
    }
}
  , s$9 = new o$8;
function o$7(xt) {
    var Cn, as;
    return s$9.isServer ? null : xt ? "ownerDocument"in xt ? xt.ownerDocument : "current"in xt ? (as = (Cn = xt.current) == null ? void 0 : Cn.ownerDocument) != null ? as : document : null : document
}
function t$4(xt) {
    typeof queueMicrotask == "function" ? queueMicrotask(xt) : Promise.resolve().then(xt).catch(Cn => setTimeout( () => {
        throw Cn
    }
    ))
}
function o$6() {
    let xt = []
      , Cn = {
        addEventListener(as, cs, Cs, Ls) {
            return as.addEventListener(cs, Cs, Ls),
            Cn.add( () => as.removeEventListener(cs, Cs, Ls))
        },
        requestAnimationFrame(...as) {
            let cs = requestAnimationFrame(...as);
            return Cn.add( () => cancelAnimationFrame(cs))
        },
        nextFrame(...as) {
            return Cn.requestAnimationFrame( () => Cn.requestAnimationFrame(...as))
        },
        setTimeout(...as) {
            let cs = setTimeout(...as);
            return Cn.add( () => clearTimeout(cs))
        },
        microTask(...as) {
            let cs = {
                current: !0
            };
            return t$4( () => {
                cs.current && as[0]()
            }
            ),
            Cn.add( () => {
                cs.current = !1
            }
            )
        },
        style(as, cs, Cs) {
            let Ls = as.style.getPropertyValue(cs);
            return Object.assign(as.style, {
                [cs]: Cs
            }),
            this.add( () => {
                Object.assign(as.style, {
                    [cs]: Ls
                })
            }
            )
        },
        group(as) {
            let cs = o$6();
            return as(cs),
            this.add( () => cs.dispose())
        },
        add(as) {
            return xt.includes(as) || xt.push(as),
            () => {
                let cs = xt.indexOf(as);
                if (cs >= 0)
                    for (let Cs of xt.splice(cs, 1))
                        Cs()
            }
        },
        dispose() {
            for (let as of xt.splice(0))
                as()
        }
    };
    return Cn
}
function p$3() {
    let[xt] = reactExports.useState(o$6);
    return reactExports.useEffect( () => () => xt.dispose(), [xt]),
    xt
}
let n$5 = (xt, Cn) => {
    s$9.isServer ? reactExports.useEffect(xt, Cn) : reactExports.useLayoutEffect(xt, Cn)
}
;
function s$8(xt) {
    let Cn = reactExports.useRef(xt);
    return n$5( () => {
        Cn.current = xt
    }
    , [xt]),
    Cn
}
let o$5 = function(xt) {
    let Cn = s$8(xt);
    return React__default.useCallback( (...as) => Cn.current(...as), [Cn])
};
function E$1(xt) {
    let Cn = xt.width / 2
      , as = xt.height / 2;
    return {
        top: xt.clientY - as,
        right: xt.clientX + Cn,
        bottom: xt.clientY + as,
        left: xt.clientX - Cn
    }
}
function P$3(xt, Cn) {
    return !(!xt || !Cn || xt.right < Cn.left || xt.left > Cn.right || xt.bottom < Cn.top || xt.top > Cn.bottom)
}
function w$2({disabled: xt=!1}={}) {
    let Cn = reactExports.useRef(null)
      , [as,cs] = reactExports.useState(!1)
      , Cs = p$3()
      , Ls = o$5( () => {
        Cn.current = null,
        cs(!1),
        Cs.dispose()
    }
    )
      , Vs = o$5(Ws => {
        if (Cs.dispose(),
        Cn.current === null) {
            Cn.current = Ws.currentTarget,
            cs(!0);
            {
                let Xs = o$7(Ws.currentTarget);
                Cs.addEventListener(Xs, "pointerup", Ls, !1),
                Cs.addEventListener(Xs, "pointermove", ga => {
                    if (Cn.current) {
                        let ba = E$1(ga);
                        cs(P$3(ba, Cn.current.getBoundingClientRect()))
                    }
                }
                , !1),
                Cs.addEventListener(Xs, "pointercancel", Ls, !1)
            }
        }
    }
    );
    return {
        pressed: as,
        pressProps: xt ? {} : {
            onPointerDown: Vs,
            onPointerUp: Ls,
            onClick: Ls
        }
    }
}
let e$5 = reactExports.createContext(void 0);
function a$9() {
    return reactExports.useContext(e$5)
}
function l$5({value: xt, children: Cn}) {
    return React__default.createElement(e$5.Provider, {
        value: xt
    }, Cn)
}
function t$3(...xt) {
    return Array.from(new Set(xt.flatMap(Cn => typeof Cn == "string" ? Cn.split(" ") : []))).filter(Boolean).join(" ")
}
function u$7(xt, Cn, ...as) {
    if (xt in Cn) {
        let Cs = Cn[xt];
        return typeof Cs == "function" ? Cs(...as) : Cs
    }
    let cs = new Error(`Tried to handle "${xt}" but there is no handler defined. Only defined handlers are: ${Object.keys(Cn).map(Cs => `"${Cs}"`).join(", ")}.`);
    throw Error.captureStackTrace && Error.captureStackTrace(cs, u$7),
    cs
}
var O$1 = (xt => (xt[xt.None = 0] = "None",
xt[xt.RenderStrategy = 1] = "RenderStrategy",
xt[xt.Static = 2] = "Static",
xt))(O$1 || {})
  , A$1 = (xt => (xt[xt.Unmount = 0] = "Unmount",
xt[xt.Hidden = 1] = "Hidden",
xt))(A$1 || {});
function L$1() {
    let xt = U$2();
    return reactExports.useCallback(Cn => C$4({
        mergeRefs: xt,
        ...Cn
    }), [xt])
}
function C$4({ourProps: xt, theirProps: Cn, slot: as, defaultTag: cs, features: Cs, visible: Ls=!0, name: Vs, mergeRefs: Ws}) {
    Ws = Ws ?? $;
    let Xs = P$2(Cn, xt);
    if (Ls)
        return F$2(Xs, as, cs, Vs, Ws);
    let ga = Cs ?? 0;
    if (ga & 2) {
        let {static: ba=!1, ...yl} = Xs;
        if (ba)
            return F$2(yl, as, cs, Vs, Ws)
    }
    if (ga & 1) {
        let {unmount: ba=!0, ...yl} = Xs;
        return u$7(ba ? 0 : 1, {
            0() {
                return null
            },
            1() {
                return F$2({
                    ...yl,
                    hidden: !0,
                    style: {
                        display: "none"
                    }
                }, as, cs, Vs, Ws)
            }
        })
    }
    return F$2(Xs, as, cs, Vs, Ws)
}
function F$2(xt, Cn={}, as, cs, Cs) {
    let {as: Ls=as, children: Vs, refName: Ws="ref", ...Xs} = h$2(xt, ["unmount", "static"])
      , ga = xt.ref !== void 0 ? {
        [Ws]: xt.ref
    } : {}
      , ba = typeof Vs == "function" ? Vs(Cn) : Vs;
    "className"in Xs && Xs.className && typeof Xs.className == "function" && (Xs.className = Xs.className(Cn)),
    Xs["aria-labelledby"] && Xs["aria-labelledby"] === Xs.id && (Xs["aria-labelledby"] = void 0);
    let yl = {};
    if (Cn) {
        let xl = !1
          , wl = [];
        for (let[_l,El] of Object.entries(Cn))
            typeof El == "boolean" && (xl = !0),
            El === !0 && wl.push(_l.replace(/([A-Z])/g, Cl => `-${Cl.toLowerCase()}`));
        if (xl) {
            yl["data-headlessui-state"] = wl.join(" ");
            for (let _l of wl)
                yl[`data-${_l}`] = ""
        }
    }
    if (Ls === reactExports.Fragment && (Object.keys(m$3(Xs)).length > 0 || Object.keys(m$3(yl)).length > 0))
        if (!reactExports.isValidElement(ba) || Array.isArray(ba) && ba.length > 1) {
            if (Object.keys(m$3(Xs)).length > 0)
                throw new Error(['Passing props on "Fragment"!', "", `The current component <${cs} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(m$3(Xs)).concat(Object.keys(m$3(yl))).map(xl => `  - ${xl}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map(xl => `  - ${xl}`).join(`
`)].join(`
`))
        } else {
            let xl = ba.props
              , wl = xl == null ? void 0 : xl.className
              , _l = typeof wl == "function" ? (...$l) => t$3(wl(...$l), Xs.className) : t$3(wl, Xs.className)
              , El = _l ? {
                className: _l
            } : {}
              , Cl = P$2(ba.props, m$3(h$2(Xs, ["ref"])));
            for (let $l in yl)
                $l in Cl && delete yl[$l];
            return reactExports.cloneElement(ba, Object.assign({}, Cl, yl, ga, {
                ref: Cs(H$6(ba), ga.ref)
            }, El))
        }
    return reactExports.createElement(Ls, Object.assign({}, h$2(Xs, ["ref"]), Ls !== reactExports.Fragment && ga, Ls !== reactExports.Fragment && yl), ba)
}
function U$2() {
    let xt = reactExports.useRef([])
      , Cn = reactExports.useCallback(as => {
        for (let cs of xt.current)
            cs != null && (typeof cs == "function" ? cs(as) : cs.current = as)
    }
    , []);
    return (...as) => {
        if (!as.every(cs => cs == null))
            return xt.current = as,
            Cn
    }
}
function $(...xt) {
    return xt.every(Cn => Cn == null) ? void 0 : Cn => {
        for (let as of xt)
            as != null && (typeof as == "function" ? as(Cn) : as.current = Cn)
    }
}
function P$2(...xt) {
    if (xt.length === 0)
        return {};
    if (xt.length === 1)
        return xt[0];
    let Cn = {}
      , as = {};
    for (let cs of xt)
        for (let Cs in cs)
            Cs.startsWith("on") && typeof cs[Cs] == "function" ? (as[Cs] != null || (as[Cs] = []),
            as[Cs].push(cs[Cs])) : Cn[Cs] = cs[Cs];
    if (Cn.disabled || Cn["aria-disabled"])
        for (let cs in as)
            /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(cs) && (as[cs] = [Cs => {
                var Ls;
                return (Ls = Cs == null ? void 0 : Cs.preventDefault) == null ? void 0 : Ls.call(Cs)
            }
            ]);
    for (let cs in as)
        Object.assign(Cn, {
            [cs](Cs, ...Ls) {
                let Vs = as[cs];
                for (let Ws of Vs) {
                    if ((Cs instanceof Event || (Cs == null ? void 0 : Cs.nativeEvent)instanceof Event) && Cs.defaultPrevented)
                        return;
                    Ws(Cs, ...Ls)
                }
            }
        });
    return Cn
}
function _$4(...xt) {
    if (xt.length === 0)
        return {};
    if (xt.length === 1)
        return xt[0];
    let Cn = {}
      , as = {};
    for (let cs of xt)
        for (let Cs in cs)
            Cs.startsWith("on") && typeof cs[Cs] == "function" ? (as[Cs] != null || (as[Cs] = []),
            as[Cs].push(cs[Cs])) : Cn[Cs] = cs[Cs];
    for (let cs in as)
        Object.assign(Cn, {
            [cs](...Cs) {
                let Ls = as[cs];
                for (let Vs of Ls)
                    Vs == null || Vs(...Cs)
            }
        });
    return Cn
}
function K$1(xt) {
    var Cn;
    return Object.assign(reactExports.forwardRef(xt), {
        displayName: (Cn = xt.displayName) != null ? Cn : xt.name
    })
}
function m$3(xt) {
    let Cn = Object.assign({}, xt);
    for (let as in Cn)
        Cn[as] === void 0 && delete Cn[as];
    return Cn
}
function h$2(xt, Cn=[]) {
    let as = Object.assign({}, xt);
    for (let cs of Cn)
        cs in as && delete as[cs];
    return as
}
function H$6(xt) {
    return React__default.version.split(".")[0] >= "19" ? xt.props.ref : xt.ref
}
function T$3(xt, Cn, as) {
    let[cs,Cs] = reactExports.useState(as)
      , Ls = xt !== void 0
      , Vs = reactExports.useRef(Ls)
      , Ws = reactExports.useRef(!1)
      , Xs = reactExports.useRef(!1);
    return Ls && !Vs.current && !Ws.current ? (Ws.current = !0,
    Vs.current = Ls,
    console.error("A component is changing from uncontrolled to controlled. This may be caused by the value changing from undefined to a defined value, which should not happen.")) : !Ls && Vs.current && !Xs.current && (Xs.current = !0,
    Vs.current = Ls,
    console.error("A component is changing from controlled to uncontrolled. This may be caused by the value changing from a defined value to undefined, which should not happen.")),
    [Ls ? xt : cs, o$5(ga => (Ls || Cs(ga),
    Cn == null ? void 0 : Cn(ga)))]
}
function l$4(xt) {
    let[Cn] = reactExports.useState(xt);
    return Cn
}
function e$4(xt={}, Cn=null, as=[]) {
    for (let[cs,Cs] of Object.entries(xt))
        o$4(as, f$9(Cn, cs), Cs);
    return as
}
function f$9(xt, Cn) {
    return xt ? xt + "[" + Cn + "]" : Cn
}
function o$4(xt, Cn, as) {
    if (Array.isArray(as))
        for (let[cs,Cs] of as.entries())
            o$4(xt, f$9(Cn, cs.toString()), Cs);
    else
        as instanceof Date ? xt.push([Cn, as.toISOString()]) : typeof as == "boolean" ? xt.push([Cn, as ? "1" : "0"]) : typeof as == "string" ? xt.push([Cn, as]) : typeof as == "number" ? xt.push([Cn, `${as}`]) : as == null ? xt.push([Cn, ""]) : e$4(as, Cn, xt)
}
function p$2(xt) {
    var Cn, as;
    let cs = (Cn = xt == null ? void 0 : xt.form) != null ? Cn : xt.closest("form");
    if (cs) {
        for (let Cs of cs.elements)
            if (Cs !== xt && (Cs.tagName === "INPUT" && Cs.type === "submit" || Cs.tagName === "BUTTON" && Cs.type === "submit" || Cs.nodeName === "INPUT" && Cs.type === "image")) {
                Cs.click();
                return
            }
        (as = cs.requestSubmit) == null || as.call(cs)
    }
}
let a$8 = "span";
var s$7 = (xt => (xt[xt.None = 1] = "None",
xt[xt.Focusable = 2] = "Focusable",
xt[xt.Hidden = 4] = "Hidden",
xt))(s$7 || {});
function l$3(xt, Cn) {
    var as;
    let {features: cs=1, ...Cs} = xt
      , Ls = {
        ref: Cn,
        "aria-hidden": (cs & 2) === 2 ? !0 : (as = Cs["aria-hidden"]) != null ? as : void 0,
        hidden: (cs & 4) === 4 ? !0 : void 0,
        style: {
            position: "fixed",
            top: 1,
            left: 1,
            width: 1,
            height: 0,
            padding: 0,
            margin: -1,
            overflow: "hidden",
            clip: "rect(0, 0, 0, 0)",
            whiteSpace: "nowrap",
            borderWidth: "0",
            ...(cs & 4) === 4 && (cs & 2) !== 2 && {
                display: "none"
            }
        }
    };
    return L$1()({
        ourProps: Ls,
        theirProps: Cs,
        slot: {},
        defaultTag: a$8,
        name: "Hidden"
    })
}
let f$8 = K$1(l$3)
  , f$7 = reactExports.createContext(null);
function W(xt) {
    let[Cn,as] = reactExports.useState(null);
    return React__default.createElement(f$7.Provider, {
        value: {
            target: Cn
        }
    }, xt.children, React__default.createElement(f$8, {
        features: s$7.Hidden,
        ref: as
    }))
}
function c$6({children: xt}) {
    let Cn = reactExports.useContext(f$7);
    if (!Cn)
        return React__default.createElement(React__default.Fragment, null, xt);
    let {target: as} = Cn;
    return as ? reactDomExports.createPortal(React__default.createElement(React__default.Fragment, null, xt), as) : null
}
function j$3({data: xt, form: Cn, disabled: as, onReset: cs, overrides: Cs}) {
    let[Ls,Vs] = reactExports.useState(null)
      , Ws = p$3();
    return reactExports.useEffect( () => {
        if (cs && Ls)
            return Ws.addEventListener(Ls, "reset", cs)
    }
    , [Ls, Cn, cs]),
    React__default.createElement(c$6, null, React__default.createElement(C$3, {
        setForm: Vs,
        formId: Cn
    }), e$4(xt).map( ([Xs,ga]) => React__default.createElement(f$8, {
        features: s$7.Hidden,
        ...m$3({
            key: Xs,
            as: "input",
            type: "hidden",
            hidden: !0,
            readOnly: !0,
            form: Cn,
            disabled: as,
            name: Xs,
            value: ga,
            ...Cs
        })
    })))
}
function C$3({setForm: xt, formId: Cn}) {
    return reactExports.useEffect( () => {
        if (Cn) {
            let as = document.getElementById(Cn);
            as && xt(as)
        }
    }
    , [xt, Cn]),
    Cn ? null : React__default.createElement(f$8, {
        features: s$7.Hidden,
        as: "input",
        type: "hidden",
        hidden: !0,
        readOnly: !0,
        ref: as => {
            if (!as)
                return;
            let cs = as.closest("form");
            cs && xt(cs)
        }
    })
}
let e$3 = reactExports.createContext(void 0);
function u$6() {
    return reactExports.useContext(e$3)
}
function f$6({id: xt, children: Cn}) {
    return React__default.createElement(e$3.Provider, {
        value: xt
    }, Cn)
}
function r$2(xt) {
    let Cn = xt.parentElement
      , as = null;
    for (; Cn && !(Cn instanceof HTMLFieldSetElement); )
        Cn instanceof HTMLLegendElement && (as = Cn),
        Cn = Cn.parentElement;
    let cs = (Cn == null ? void 0 : Cn.getAttribute("disabled")) === "";
    return cs && i$4(as) ? !1 : cs
}
function i$4(xt) {
    if (!xt)
        return !1;
    let Cn = xt.previousElementSibling;
    for (; Cn !== null; ) {
        if (Cn instanceof HTMLLegendElement)
            return !1;
        Cn = Cn.previousElementSibling
    }
    return !0
}
let u$5 = Symbol();
function T$2(xt, Cn=!0) {
    return Object.assign(xt, {
        [u$5]: Cn
    })
}
function y$3(...xt) {
    let Cn = reactExports.useRef(xt);
    reactExports.useEffect( () => {
        Cn.current = xt
    }
    , [xt]);
    let as = o$5(cs => {
        for (let Cs of Cn.current)
            Cs != null && (typeof Cs == "function" ? Cs(cs) : Cs.current = cs)
    }
    );
    return xt.every(cs => cs == null || (cs == null ? void 0 : cs[u$5])) ? void 0 : as
}
let a$7 = reactExports.createContext(null);
a$7.displayName = "DescriptionContext";
function f$5() {
    let xt = reactExports.useContext(a$7);
    if (xt === null) {
        let Cn = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
        throw Error.captureStackTrace && Error.captureStackTrace(Cn, f$5),
        Cn
    }
    return xt
}
function U$1() {
    var xt, Cn;
    return (Cn = (xt = reactExports.useContext(a$7)) == null ? void 0 : xt.value) != null ? Cn : void 0
}
function w$1() {
    let[xt,Cn] = reactExports.useState([]);
    return [xt.length > 0 ? xt.join(" ") : void 0, reactExports.useMemo( () => function(as) {
        let cs = o$5(Ls => (Cn(Vs => [...Vs, Ls]),
        () => Cn(Vs => {
            let Ws = Vs.slice()
              , Xs = Ws.indexOf(Ls);
            return Xs !== -1 && Ws.splice(Xs, 1),
            Ws
        }
        )))
          , Cs = reactExports.useMemo( () => ({
            register: cs,
            slot: as.slot,
            name: as.name,
            props: as.props,
            value: as.value
        }), [cs, as.slot, as.name, as.props, as.value]);
        return React__default.createElement(a$7.Provider, {
            value: Cs
        }, as.children)
    }
    , [Cn])]
}
let S$1 = "p";
function C$2(xt, Cn) {
    let as = reactExports.useId()
      , cs = a$9()
      , {id: Cs=`headlessui-description-${as}`, ...Ls} = xt
      , Vs = f$5()
      , Ws = y$3(Cn);
    n$5( () => Vs.register(Cs), [Cs, Vs.register]);
    let Xs = cs || !1
      , ga = reactExports.useMemo( () => ({
        ...Vs.slot,
        disabled: Xs
    }), [Vs.slot, Xs])
      , ba = {
        ref: Ws,
        ...Vs.props,
        id: Cs
    };
    return L$1()({
        ourProps: ba,
        theirProps: Ls,
        slot: ga,
        defaultTag: S$1,
        name: Vs.name || "Description"
    })
}
let _$3 = K$1(C$2)
  , H$5 = Object.assign(_$3, {});
var o$3 = (xt => (xt.Space = " ",
xt.Enter = "Enter",
xt.Escape = "Escape",
xt.Backspace = "Backspace",
xt.Delete = "Delete",
xt.ArrowLeft = "ArrowLeft",
xt.ArrowUp = "ArrowUp",
xt.ArrowRight = "ArrowRight",
xt.ArrowDown = "ArrowDown",
xt.Home = "Home",
xt.End = "End",
xt.PageUp = "PageUp",
xt.PageDown = "PageDown",
xt.Tab = "Tab",
xt))(o$3 || {});
let c$5 = reactExports.createContext(null);
c$5.displayName = "LabelContext";
function P$1() {
    let xt = reactExports.useContext(c$5);
    if (xt === null) {
        let Cn = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
        throw Error.captureStackTrace && Error.captureStackTrace(Cn, P$1),
        Cn
    }
    return xt
}
function I$1(xt) {
    var Cn, as, cs;
    let Cs = (as = (Cn = reactExports.useContext(c$5)) == null ? void 0 : Cn.value) != null ? as : void 0;
    return ((cs = xt == null ? void 0 : xt.length) != null ? cs : 0) > 0 ? [Cs, ...xt].filter(Boolean).join(" ") : Cs
}
function K({inherit: xt=!1}={}) {
    let Cn = I$1()
      , [as,cs] = reactExports.useState([])
      , Cs = xt ? [Cn, ...as].filter(Boolean) : as;
    return [Cs.length > 0 ? Cs.join(" ") : void 0, reactExports.useMemo( () => function(Ls) {
        let Vs = o$5(Xs => (cs(ga => [...ga, Xs]),
        () => cs(ga => {
            let ba = ga.slice()
              , yl = ba.indexOf(Xs);
            return yl !== -1 && ba.splice(yl, 1),
            ba
        }
        )))
          , Ws = reactExports.useMemo( () => ({
            register: Vs,
            slot: Ls.slot,
            name: Ls.name,
            props: Ls.props,
            value: Ls.value
        }), [Vs, Ls.slot, Ls.name, Ls.props, Ls.value]);
        return React__default.createElement(c$5.Provider, {
            value: Ws
        }, Ls.children)
    }
    , [cs])]
}
let N = "label";
function G(xt, Cn) {
    var as;
    let cs = reactExports.useId()
      , Cs = P$1()
      , Ls = u$6()
      , Vs = a$9()
      , {id: Ws=`headlessui-label-${cs}`, htmlFor: Xs=Ls ?? ((as = Cs.props) == null ? void 0 : as.htmlFor), passive: ga=!1, ...ba} = xt
      , yl = y$3(Cn);
    n$5( () => Cs.register(Ws), [Ws, Cs.register]);
    let xl = o$5(Cl => {
        let $l = Cl.currentTarget;
        if ($l instanceof HTMLLabelElement && Cl.preventDefault(),
        Cs.props && "onClick"in Cs.props && typeof Cs.props.onClick == "function" && Cs.props.onClick(Cl),
        $l instanceof HTMLLabelElement) {
            let Sl = document.getElementById($l.htmlFor);
            if (Sl) {
                let Tl = Sl.getAttribute("disabled");
                if (Tl === "true" || Tl === "")
                    return;
                let Rl = Sl.getAttribute("aria-disabled");
                if (Rl === "true" || Rl === "")
                    return;
                (Sl instanceof HTMLInputElement && (Sl.type === "radio" || Sl.type === "checkbox") || Sl.role === "radio" || Sl.role === "checkbox" || Sl.role === "switch") && Sl.click(),
                Sl.focus({
                    preventScroll: !0
                })
            }
        }
    }
    )
      , wl = Vs || !1
      , _l = reactExports.useMemo( () => ({
        ...Cs.slot,
        disabled: wl
    }), [Cs.slot, wl])
      , El = {
        ref: yl,
        ...Cs.props,
        id: Ws,
        htmlFor: Xs,
        onClick: xl
    };
    return ga && ("onClick"in El && (delete El.htmlFor,
    delete El.onClick),
    "onClick"in ba && delete ba.onClick),
    L$1()({
        ourProps: El,
        theirProps: ba,
        slot: _l,
        defaultTag: Xs ? N : "div",
        name: Cs.name || "Label"
    })
}
let U = K$1(G)
  , Q = Object.assign(U, {})
  , de$1 = "span";
function pe$1(xt, Cn) {
    let as = reactExports.useId()
      , cs = u$6()
      , Cs = a$9()
      , {id: Ls=cs || `headlessui-checkbox-${as}`, disabled: Vs=Cs || !1, autoFocus: Ws=!1, checked: Xs, defaultChecked: ga, onChange: ba, name: yl, value: xl, form: wl, indeterminate: _l=!1, tabIndex: El=0, ...Cl} = xt
      , $l = l$4(ga)
      , [Sl,Tl] = T$3(Xs, ba, $l ?? !1)
      , Rl = I$1()
      , Il = U$1()
      , Ml = p$3()
      , [Nl,Ll] = reactExports.useState(!1)
      , Fl = o$5( () => {
        Ll(!0),
        Tl == null || Tl(!Sl),
        Ml.nextFrame( () => {
            Ll(!1)
        }
        )
    }
    )
      , Ul = o$5(ju => {
        if (r$2(ju.currentTarget))
            return ju.preventDefault();
        ju.preventDefault(),
        Fl()
    }
    )
      , Dl = o$5(ju => {
        ju.key === o$3.Space ? (ju.preventDefault(),
        Fl()) : ju.key === o$3.Enter && p$2(ju.currentTarget)
    }
    )
      , Zl = o$5(ju => ju.preventDefault())
      , {isFocusVisible: Gl, focusProps: Wl} = $f7dceffc5ad7768b$export$4e328f61c538687f({
        autoFocus: Ws
    })
      , {isHovered: Ql, hoverProps: cu} = $6179b936705e76d3$export$ae780daf29e6d456({
        isDisabled: Vs
    })
      , {pressed: pu, pressProps: zl} = w$2({
        disabled: Vs
    })
      , Yl = _$4({
        ref: Cn,
        id: Ls,
        role: "checkbox",
        "aria-checked": _l ? "mixed" : Sl ? "true" : "false",
        "aria-labelledby": Rl,
        "aria-describedby": Il,
        "aria-disabled": Vs ? !0 : void 0,
        indeterminate: _l ? "true" : void 0,
        tabIndex: Vs ? void 0 : El,
        onKeyUp: Vs ? void 0 : Dl,
        onKeyPress: Vs ? void 0 : Zl,
        onClick: Vs ? void 0 : Ul
    }, Wl, cu, zl)
      , lu = reactExports.useMemo( () => ({
        checked: Sl,
        disabled: Vs,
        hover: Ql,
        focus: Gl,
        active: pu,
        indeterminate: _l,
        changing: Nl,
        autofocus: Ws
    }), [Sl, _l, Vs, Ql, Gl, pu, Nl, Ws])
      , mu = reactExports.useCallback( () => {
        if ($l !== void 0)
            return Tl == null ? void 0 : Tl($l)
    }
    , [Tl, $l])
      , Cu = L$1();
    return React__default.createElement(React__default.Fragment, null, yl != null && React__default.createElement(j$3, {
        disabled: Vs,
        data: {
            [yl]: xl || "on"
        },
        overrides: {
            type: "checkbox",
            checked: Sl
        },
        form: wl,
        onReset: mu
    }), Cu({
        ourProps: Yl,
        theirProps: Cl,
        slot: lu,
        defaultTag: de$1,
        name: "Checkbox"
    }))
}
let Fe$2 = K$1(pe$1)
  , e$2 = reactExports.createContext( () => {}
);
function C$1({value: xt, children: Cn}) {
    return React__default.createElement(e$2.Provider, {
        value: xt
    }, Cn)
}
function l$2(xt, Cn) {
    return xt !== null && Cn !== null && typeof xt == "object" && typeof Cn == "object" && "id"in xt && "id"in Cn ? xt.id === Cn.id : xt === Cn
}
function u$4(xt=l$2) {
    return reactExports.useCallback( (Cn, as) => {
        if (typeof xt == "string") {
            let cs = xt;
            return (Cn == null ? void 0 : Cn[cs]) === (as == null ? void 0 : as[cs])
        }
        return xt(Cn, as)
    }
    , [xt])
}
function f$4(xt) {
    if (xt === null)
        return {
            width: 0,
            height: 0
        };
    let {width: Cn, height: as} = xt.getBoundingClientRect();
    return {
        width: Cn,
        height: as
    }
}
function d$2(xt, Cn=!1) {
    let[as,cs] = reactExports.useReducer( () => ({}), {})
      , Cs = reactExports.useMemo( () => f$4(xt), [xt, as]);
    return n$5( () => {
        if (!xt)
            return;
        let Ls = new ResizeObserver(cs);
        return Ls.observe(xt),
        () => {
            Ls.disconnect()
        }
    }
    , [xt]),
    Cn ? {
        width: `${Cs.width}px`,
        height: `${Cs.height}px`
    } : Cs
}
let a$6 = class extends Map {
    constructor(Cn) {
        super(),
        this.factory = Cn
    }
    get(Cn) {
        let as = super.get(Cn);
        return as === void 0 && (as = this.factory(Cn),
        this.set(Cn, as)),
        as
    }
}
;
function a$5(xt, Cn) {
    let as = xt()
      , cs = new Set;
    return {
        getSnapshot() {
            return as
        },
        subscribe(Cs) {
            return cs.add(Cs),
            () => cs.delete(Cs)
        },
        dispatch(Cs, ...Ls) {
            let Vs = Cn[Cs].call(as, ...Ls);
            Vs && (as = Vs,
            cs.forEach(Ws => Ws()))
        }
    }
}
function o$2(xt) {
    return reactExports.useSyncExternalStore(xt.subscribe, xt.getSnapshot, xt.getSnapshot)
}
let p$1 = new a$6( () => a$5( () => [], {
    ADD(xt) {
        return this.includes(xt) ? this : [...this, xt]
    },
    REMOVE(xt) {
        let Cn = this.indexOf(xt);
        if (Cn === -1)
            return this;
        let as = this.slice();
        return as.splice(Cn, 1),
        as
    }
}));
function x$1(xt, Cn) {
    let as = p$1.get(Cn)
      , cs = reactExports.useId()
      , Cs = o$2(as);
    if (n$5( () => {
        if (xt)
            return as.dispatch("ADD", cs),
            () => as.dispatch("REMOVE", cs)
    }
    , [as, xt]),
    !xt)
        return !1;
    let Ls = Cs.indexOf(cs)
      , Vs = Cs.length;
    return Ls === -1 && (Ls = Vs,
    Vs += 1),
    Ls === Vs - 1
}
let f$3 = new Map
  , u$3 = new Map;
function h$1(xt) {
    var Cn;
    let as = (Cn = u$3.get(xt)) != null ? Cn : 0;
    return u$3.set(xt, as + 1),
    as !== 0 ? () => m$2(xt) : (f$3.set(xt, {
        "aria-hidden": xt.getAttribute("aria-hidden"),
        inert: xt.inert
    }),
    xt.setAttribute("aria-hidden", "true"),
    xt.inert = !0,
    () => m$2(xt))
}
function m$2(xt) {
    var Cn;
    let as = (Cn = u$3.get(xt)) != null ? Cn : 1;
    if (as === 1 ? u$3.delete(xt) : u$3.set(xt, as - 1),
    as !== 1)
        return;
    let cs = f$3.get(xt);
    cs && (cs["aria-hidden"] === null ? xt.removeAttribute("aria-hidden") : xt.setAttribute("aria-hidden", cs["aria-hidden"]),
    xt.inert = cs.inert,
    f$3.delete(xt))
}
function y$2(xt, {allowed: Cn, disallowed: as}={}) {
    let cs = x$1(xt, "inert-others");
    n$5( () => {
        var Cs, Ls;
        if (!cs)
            return;
        let Vs = o$6();
        for (let Xs of (Cs = as == null ? void 0 : as()) != null ? Cs : [])
            Xs && Vs.add(h$1(Xs));
        let Ws = (Ls = Cn == null ? void 0 : Cn()) != null ? Ls : [];
        for (let Xs of Ws) {
            if (!Xs)
                continue;
            let ga = o$7(Xs);
            if (!ga)
                continue;
            let ba = Xs.parentElement;
            for (; ba && ba !== ga.body; ) {
                for (let yl of ba.children)
                    Ws.some(xl => yl.contains(xl)) || Vs.add(h$1(yl));
                ba = ba.parentElement
            }
        }
        return Vs.dispose
    }
    , [cs, Cn, as])
}
function m$1(xt, Cn, as) {
    let cs = s$8(Cs => {
        let Ls = Cs.getBoundingClientRect();
        Ls.x === 0 && Ls.y === 0 && Ls.width === 0 && Ls.height === 0 && as()
    }
    );
    reactExports.useEffect( () => {
        if (!xt)
            return;
        let Cs = Cn === null ? null : Cn instanceof HTMLElement ? Cn : Cn.current;
        if (!Cs)
            return;
        let Ls = o$6();
        if (typeof ResizeObserver < "u") {
            let Vs = new ResizeObserver( () => cs.current(Cs));
            Vs.observe(Cs),
            Ls.add( () => Vs.disconnect())
        }
        if (typeof IntersectionObserver < "u") {
            let Vs = new IntersectionObserver( () => cs.current(Cs));
            Vs.observe(Cs),
            Ls.add( () => Vs.disconnect())
        }
        return () => Ls.dispose()
    }
    , [Cn, cs, xt])
}
let f$2 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map(xt => `${xt}:not([tabindex='-1'])`).join(",")
  , p = ["[data-autofocus]"].map(xt => `${xt}:not([tabindex='-1'])`).join(",");
var F$1 = (xt => (xt[xt.First = 1] = "First",
xt[xt.Previous = 2] = "Previous",
xt[xt.Next = 4] = "Next",
xt[xt.Last = 8] = "Last",
xt[xt.WrapAround = 16] = "WrapAround",
xt[xt.NoScroll = 32] = "NoScroll",
xt[xt.AutoFocus = 64] = "AutoFocus",
xt))(F$1 || {})
  , T$1 = (xt => (xt[xt.Error = 0] = "Error",
xt[xt.Overflow = 1] = "Overflow",
xt[xt.Success = 2] = "Success",
xt[xt.Underflow = 3] = "Underflow",
xt))(T$1 || {})
  , y$1 = (xt => (xt[xt.Previous = -1] = "Previous",
xt[xt.Next = 1] = "Next",
xt))(y$1 || {});
function b$1(xt=document.body) {
    return xt == null ? [] : Array.from(xt.querySelectorAll(f$2)).sort( (Cn, as) => Math.sign((Cn.tabIndex || Number.MAX_SAFE_INTEGER) - (as.tabIndex || Number.MAX_SAFE_INTEGER)))
}
function S(xt=document.body) {
    return xt == null ? [] : Array.from(xt.querySelectorAll(p)).sort( (Cn, as) => Math.sign((Cn.tabIndex || Number.MAX_SAFE_INTEGER) - (as.tabIndex || Number.MAX_SAFE_INTEGER)))
}
var h = (xt => (xt[xt.Strict = 0] = "Strict",
xt[xt.Loose = 1] = "Loose",
xt))(h || {});
function A(xt, Cn=0) {
    var as;
    return xt === ((as = o$7(xt)) == null ? void 0 : as.body) ? !1 : u$7(Cn, {
        0() {
            return xt.matches(f$2)
        },
        1() {
            let cs = xt;
            for (; cs !== null; ) {
                if (cs.matches(f$2))
                    return !0;
                cs = cs.parentElement
            }
            return !1
        }
    })
}
var H$4 = (xt => (xt[xt.Keyboard = 0] = "Keyboard",
xt[xt.Mouse = 1] = "Mouse",
xt))(H$4 || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", xt => {
    xt.metaKey || xt.altKey || xt.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "")
}
, !0),
document.addEventListener("click", xt => {
    xt.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : xt.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "")
}
, !0));
let w = ["textarea", "input"].join(",");
function O(xt) {
    var Cn, as;
    return (as = (Cn = xt == null ? void 0 : xt.matches) == null ? void 0 : Cn.call(xt, w)) != null ? as : !1
}
function _$2(xt, Cn=as => as) {
    return xt.slice().sort( (as, cs) => {
        let Cs = Cn(as)
          , Ls = Cn(cs);
        if (Cs === null || Ls === null)
            return 0;
        let Vs = Cs.compareDocumentPosition(Ls);
        return Vs & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : Vs & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0
    }
    )
}
function j$2(xt, Cn) {
    return P(b$1(), Cn, {
        relativeTo: xt
    })
}
function P(xt, Cn, {sorted: as=!0, relativeTo: cs=null, skipElements: Cs=[]}={}) {
    let Ls = Array.isArray(xt) ? xt.length > 0 ? xt[0].ownerDocument : document : xt.ownerDocument
      , Vs = Array.isArray(xt) ? as ? _$2(xt) : xt : Cn & 64 ? S(xt) : b$1(xt);
    Cs.length > 0 && Vs.length > 1 && (Vs = Vs.filter(wl => !Cs.some(_l => _l != null && "current"in _l ? (_l == null ? void 0 : _l.current) === wl : _l === wl))),
    cs = cs ?? Ls.activeElement;
    let Ws = ( () => {
        if (Cn & 5)
            return 1;
        if (Cn & 10)
            return -1;
        throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")
    }
    )(), Xs = ( () => {
        if (Cn & 1)
            return 0;
        if (Cn & 2)
            return Math.max(0, Vs.indexOf(cs)) - 1;
        if (Cn & 4)
            return Math.max(0, Vs.indexOf(cs)) + 1;
        if (Cn & 8)
            return Vs.length - 1;
        throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")
    }
    )(), ga = Cn & 32 ? {
        preventScroll: !0
    } : {}, ba = 0, yl = Vs.length, xl;
    do {
        if (ba >= yl || ba + yl <= 0)
            return 0;
        let wl = Xs + ba;
        if (Cn & 16)
            wl = (wl + yl) % yl;
        else {
            if (wl < 0)
                return 3;
            if (wl >= yl)
                return 1
        }
        xl = Vs[wl],
        xl == null || xl.focus(ga),
        ba += Ws
    } while (xl !== Ls.activeElement);
    return Cn & 6 && O(xl) && xl.select(),
    2
}
function t$2() {
    return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0
}
function i$3() {
    return /Android/gi.test(window.navigator.userAgent)
}
function n$4() {
    return t$2() || i$3()
}
function i$2(xt, Cn, as, cs) {
    let Cs = s$8(as);
    reactExports.useEffect( () => {
        if (!xt)
            return;
        function Ls(Vs) {
            Cs.current(Vs)
        }
        return document.addEventListener(Cn, Ls, cs),
        () => document.removeEventListener(Cn, Ls, cs)
    }
    , [xt, Cn, cs])
}
function s$6(xt, Cn, as, cs) {
    let Cs = s$8(as);
    reactExports.useEffect( () => {
        if (!xt)
            return;
        function Ls(Vs) {
            Cs.current(Vs)
        }
        return window.addEventListener(Cn, Ls, cs),
        () => window.removeEventListener(Cn, Ls, cs)
    }
    , [xt, Cn, cs])
}
const E = 30;
function R$1(xt, Cn, as) {
    let cs = x$1(xt, "outside-click")
      , Cs = s$8(as)
      , Ls = reactExports.useCallback(function(Xs, ga) {
        if (Xs.defaultPrevented)
            return;
        let ba = ga(Xs);
        if (ba === null || !ba.getRootNode().contains(ba) || !ba.isConnected)
            return;
        let yl = function xl(wl) {
            return typeof wl == "function" ? xl(wl()) : Array.isArray(wl) || wl instanceof Set ? wl : [wl]
        }(Cn);
        for (let xl of yl)
            if (xl !== null && (xl.contains(ba) || Xs.composed && Xs.composedPath().includes(xl)))
                return;
        return !A(ba, h.Loose) && ba.tabIndex !== -1 && Xs.preventDefault(),
        Cs.current(Xs, ba)
    }, [Cs, Cn])
      , Vs = reactExports.useRef(null);
    i$2(cs, "pointerdown", Xs => {
        var ga, ba;
        Vs.current = ((ba = (ga = Xs.composedPath) == null ? void 0 : ga.call(Xs)) == null ? void 0 : ba[0]) || Xs.target
    }
    , !0),
    i$2(cs, "mousedown", Xs => {
        var ga, ba;
        Vs.current = ((ba = (ga = Xs.composedPath) == null ? void 0 : ga.call(Xs)) == null ? void 0 : ba[0]) || Xs.target
    }
    , !0),
    i$2(cs, "click", Xs => {
        n$4() || Vs.current && (Ls(Xs, () => Vs.current),
        Vs.current = null)
    }
    , !0);
    let Ws = reactExports.useRef({
        x: 0,
        y: 0
    });
    i$2(cs, "touchstart", Xs => {
        Ws.current.x = Xs.touches[0].clientX,
        Ws.current.y = Xs.touches[0].clientY
    }
    , !0),
    i$2(cs, "touchend", Xs => {
        let ga = {
            x: Xs.changedTouches[0].clientX,
            y: Xs.changedTouches[0].clientY
        };
        if (!(Math.abs(ga.x - Ws.current.x) >= E || Math.abs(ga.y - Ws.current.y) >= E))
            return Ls(Xs, () => Xs.target instanceof HTMLElement ? Xs.target : null)
    }
    , !0),
    s$6(cs, "blur", Xs => Ls(Xs, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0)
}
function n$3(...xt) {
    return reactExports.useMemo( () => o$7(...xt), [...xt])
}
function e$1(xt, Cn) {
    return reactExports.useMemo( () => {
        var as;
        if (xt.type)
            return xt.type;
        let cs = (as = xt.as) != null ? as : "button";
        if (typeof cs == "string" && cs.toLowerCase() === "button" || (Cn == null ? void 0 : Cn.tagName) === "BUTTON" && !Cn.hasAttribute("type"))
            return "button"
    }
    , [xt.type, xt.as, Cn])
}
function d$1() {
    let xt;
    return {
        before({doc: Cn}) {
            var as;
            let cs = Cn.documentElement
              , Cs = (as = Cn.defaultView) != null ? as : window;
            xt = Math.max(0, Cs.innerWidth - cs.clientWidth)
        },
        after({doc: Cn, d: as}) {
            let cs = Cn.documentElement
              , Cs = Math.max(0, cs.clientWidth - cs.offsetWidth)
              , Ls = Math.max(0, xt - Cs);
            as.style(cs, "paddingRight", `${Ls}px`)
        }
    }
}
function d() {
    return t$2() ? {
        before({doc: xt, d: Cn, meta: as}) {
            function cs(Cs) {
                return as.containers.flatMap(Ls => Ls()).some(Ls => Ls.contains(Cs))
            }
            Cn.microTask( () => {
                var Cs;
                if (window.getComputedStyle(xt.documentElement).scrollBehavior !== "auto") {
                    let Ws = o$6();
                    Ws.style(xt.documentElement, "scrollBehavior", "auto"),
                    Cn.add( () => Cn.microTask( () => Ws.dispose()))
                }
                let Ls = (Cs = window.scrollY) != null ? Cs : window.pageYOffset
                  , Vs = null;
                Cn.addEventListener(xt, "click", Ws => {
                    if (Ws.target instanceof HTMLElement)
                        try {
                            let Xs = Ws.target.closest("a");
                            if (!Xs)
                                return;
                            let {hash: ga} = new URL(Xs.href)
                              , ba = xt.querySelector(ga);
                            ba && !cs(ba) && (Vs = ba)
                        } catch {}
                }
                , !0),
                Cn.addEventListener(xt, "touchstart", Ws => {
                    if (Ws.target instanceof HTMLElement)
                        if (cs(Ws.target)) {
                            let Xs = Ws.target;
                            for (; Xs.parentElement && cs(Xs.parentElement); )
                                Xs = Xs.parentElement;
                            Cn.style(Xs, "overscrollBehavior", "contain")
                        } else
                            Cn.style(Ws.target, "touchAction", "none")
                }
                ),
                Cn.addEventListener(xt, "touchmove", Ws => {
                    if (Ws.target instanceof HTMLElement) {
                        if (Ws.target.tagName === "INPUT")
                            return;
                        if (cs(Ws.target)) {
                            let Xs = Ws.target;
                            for (; Xs.parentElement && Xs.dataset.headlessuiPortal !== "" && !(Xs.scrollHeight > Xs.clientHeight || Xs.scrollWidth > Xs.clientWidth); )
                                Xs = Xs.parentElement;
                            Xs.dataset.headlessuiPortal === "" && Ws.preventDefault()
                        } else
                            Ws.preventDefault()
                    }
                }
                , {
                    passive: !1
                }),
                Cn.add( () => {
                    var Ws;
                    let Xs = (Ws = window.scrollY) != null ? Ws : window.pageYOffset;
                    Ls !== Xs && window.scrollTo(0, Ls),
                    Vs && Vs.isConnected && (Vs.scrollIntoView({
                        block: "nearest"
                    }),
                    Vs = null)
                }
                )
            }
            )
        }
    } : {}
}
function r$1() {
    return {
        before({doc: xt, d: Cn}) {
            Cn.style(xt.documentElement, "overflow", "hidden")
        }
    }
}
function m(xt) {
    let Cn = {};
    for (let as of xt)
        Object.assign(Cn, as(Cn));
    return Cn
}
let a$4 = a$5( () => new Map, {
    PUSH(xt, Cn) {
        var as;
        let cs = (as = this.get(xt)) != null ? as : {
            doc: xt,
            count: 0,
            d: o$6(),
            meta: new Set
        };
        return cs.count++,
        cs.meta.add(Cn),
        this.set(xt, cs),
        this
    },
    POP(xt, Cn) {
        let as = this.get(xt);
        return as && (as.count--,
        as.meta.delete(Cn)),
        this
    },
    SCROLL_PREVENT({doc: xt, d: Cn, meta: as}) {
        let cs = {
            doc: xt,
            d: Cn,
            meta: m(as)
        }
          , Cs = [d(), d$1(), r$1()];
        Cs.forEach( ({before: Ls}) => Ls == null ? void 0 : Ls(cs)),
        Cs.forEach( ({after: Ls}) => Ls == null ? void 0 : Ls(cs))
    },
    SCROLL_ALLOW({d: xt}) {
        xt.dispose()
    },
    TEARDOWN({doc: xt}) {
        this.delete(xt)
    }
});
a$4.subscribe( () => {
    let xt = a$4.getSnapshot()
      , Cn = new Map;
    for (let[as] of xt)
        Cn.set(as, as.documentElement.style.overflow);
    for (let as of xt.values()) {
        let cs = Cn.get(as.doc) === "hidden"
          , Cs = as.count !== 0;
        (Cs && !cs || !Cs && cs) && a$4.dispatch(as.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", as),
        as.count === 0 && a$4.dispatch("TEARDOWN", as)
    }
}
);
function a$3(xt, Cn, as= () => ({
    containers: []
})) {
    let cs = o$2(a$4)
      , Cs = Cn ? cs.get(Cn) : void 0
      , Ls = Cs ? Cs.count > 0 : !1;
    return n$5( () => {
        if (!(!Cn || !xt))
            return a$4.dispatch("PUSH", Cn, as),
            () => a$4.dispatch("POP", Cn, as)
    }
    , [xt, Cn]),
    Ls
}
function f$1(xt, Cn, as= () => [document.body]) {
    let cs = x$1(xt, "scroll-lock");
    a$3(cs, Cn, Cs => {
        var Ls;
        return {
            containers: [...(Ls = Cs.containers) != null ? Ls : [], as]
        }
    }
    )
}
function t$1(xt) {
    return [xt.screenX, xt.screenY]
}
function u$2() {
    let xt = reactExports.useRef([-1, -1]);
    return {
        wasMoved(Cn) {
            let as = t$1(Cn);
            return xt.current[0] === as[0] && xt.current[1] === as[1] ? !1 : (xt.current = as,
            !0)
        },
        update(Cn) {
            xt.current = t$1(Cn)
        }
    }
}
function c$4(xt=0) {
    let[Cn,as] = reactExports.useState(xt)
      , cs = reactExports.useCallback(Xs => as(Xs), [Cn])
      , Cs = reactExports.useCallback(Xs => as(ga => ga | Xs), [Cn])
      , Ls = reactExports.useCallback(Xs => (Cn & Xs) === Xs, [Cn])
      , Vs = reactExports.useCallback(Xs => as(ga => ga & ~Xs), [as])
      , Ws = reactExports.useCallback(Xs => as(ga => ga ^ Xs), [as]);
    return {
        flags: Cn,
        setFlag: cs,
        addFlag: Cs,
        hasFlag: Ls,
        removeFlag: Vs,
        toggleFlag: Ws
    }
}
var define_process_env_default = {}, T, b;
typeof process < "u" && typeof globalThis < "u" && typeof Element < "u" && ((T = process == null ? void 0 : define_process_env_default) == null ? void 0 : T.NODE_ENV) === "test" && typeof ((b = Element == null ? void 0 : Element.prototype) == null ? void 0 : b.getAnimations) > "u" && (Element.prototype.getAnimations = function() {
    return console.warn(["Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.", "Please install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.", "", "Example usage:", "```js", "import { mockAnimationsApi } from 'jsdom-testing-mocks'", "mockAnimationsApi()", "```"].join(`
`)),
    []
}
);
var L = (xt => (xt[xt.None = 0] = "None",
xt[xt.Closed = 1] = "Closed",
xt[xt.Enter = 2] = "Enter",
xt[xt.Leave = 4] = "Leave",
xt))(L || {});
function R(xt) {
    let Cn = {};
    for (let as in xt)
        xt[as] === !0 && (Cn[`data-${as}`] = "");
    return Cn
}
function x(xt, Cn, as, cs) {
    let[Cs,Ls] = reactExports.useState(as)
      , {hasFlag: Vs, addFlag: Ws, removeFlag: Xs} = c$4(xt && Cs ? 3 : 0)
      , ga = reactExports.useRef(!1)
      , ba = reactExports.useRef(!1)
      , yl = p$3();
    return n$5( () => {
        var xl;
        if (xt) {
            if (as && Ls(!0),
            !Cn) {
                as && Ws(3);
                return
            }
            return (xl = void 0) == null || xl.call(cs, as),
            C(Cn, {
                inFlight: ga,
                prepare() {
                    ba.current ? ba.current = !1 : ba.current = ga.current,
                    ga.current = !0,
                    !ba.current && (as ? (Ws(3),
                    Xs(4)) : (Ws(4),
                    Xs(2)))
                },
                run() {
                    ba.current ? as ? (Xs(3),
                    Ws(4)) : (Xs(4),
                    Ws(3)) : as ? Xs(1) : Ws(1)
                },
                done() {
                    var wl;
                    ba.current && typeof Cn.getAnimations == "function" && Cn.getAnimations().length > 0 || (ga.current = !1,
                    Xs(7),
                    as || Ls(!1),
                    (wl = void 0) == null || wl.call(cs, as))
                }
            })
        }
    }
    , [xt, as, Cn, yl]),
    xt ? [Cs, {
        closed: Vs(1),
        enter: Vs(2),
        leave: Vs(4),
        transition: Vs(2) || Vs(4)
    }] : [as, {
        closed: void 0,
        enter: void 0,
        leave: void 0,
        transition: void 0
    }]
}
function C(xt, {prepare: Cn, run: as, done: cs, inFlight: Cs}) {
    let Ls = o$6();
    return j$1(xt, {
        prepare: Cn,
        inFlight: Cs
    }),
    Ls.nextFrame( () => {
        as(),
        Ls.requestAnimationFrame( () => {
            Ls.add(M$2(xt, cs))
        }
        )
    }
    ),
    Ls.dispose
}
function M$2(xt, Cn) {
    var as, cs;
    let Cs = o$6();
    if (!xt)
        return Cs.dispose;
    let Ls = !1;
    Cs.add( () => {
        Ls = !0
    }
    );
    let Vs = (cs = (as = xt.getAnimations) == null ? void 0 : as.call(xt).filter(Ws => Ws instanceof CSSTransition)) != null ? cs : [];
    return Vs.length === 0 ? (Cn(),
    Cs.dispose) : (Promise.allSettled(Vs.map(Ws => Ws.finished)).then( () => {
        Ls || Cn()
    }
    ),
    Cs.dispose)
}
function j$1(xt, {inFlight: Cn, prepare: as}) {
    if (Cn != null && Cn.current) {
        as();
        return
    }
    let cs = xt.style.transition;
    xt.style.transition = "none",
    as(),
    xt.offsetHeight,
    xt.style.transition = cs
}
function getUserAgent() {
    const xt = navigator.userAgentData;
    return xt && Array.isArray(xt.brands) ? xt.brands.map(Cn => {
        let {brand: as, version: cs} = Cn;
        return as + "/" + cs
    }
    ).join(" ") : navigator.userAgent
}
const SafeReact = {
    ...t$6
}
  , useInsertionEffect = SafeReact.useInsertionEffect
  , useSafeInsertionEffect = useInsertionEffect || (xt => xt());
function useEffectEvent(xt) {
    const Cn = reactExports.useRef( () => {}
    );
    return useSafeInsertionEffect( () => {
        Cn.current = xt
    }
    ),
    reactExports.useCallback(function() {
        for (var as = arguments.length, cs = new Array(as), Cs = 0; Cs < as; Cs++)
            cs[Cs] = arguments[Cs];
        return Cn.current == null ? void 0 : Cn.current(...cs)
    }, [])
}
var index = typeof document < "u" ? reactExports.useLayoutEffect : reactExports.useEffect;
let serverHandoffComplete = !1
  , count = 0;
const genId = () => "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++;
function useFloatingId() {
    const [xt,Cn] = reactExports.useState( () => serverHandoffComplete ? genId() : void 0);
    return index( () => {
        xt == null && Cn(genId())
    }
    , []),
    reactExports.useEffect( () => {
        serverHandoffComplete = !0
    }
    , []),
    xt
}
const useReactId = SafeReact.useId
  , useId = useReactId || useFloatingId;
function createPubSub() {
    const xt = new Map;
    return {
        emit(Cn, as) {
            var cs;
            (cs = xt.get(Cn)) == null || cs.forEach(Cs => Cs(as))
        },
        on(Cn, as) {
            xt.set(Cn, [...xt.get(Cn) || [], as])
        },
        off(Cn, as) {
            var cs;
            xt.set(Cn, ((cs = xt.get(Cn)) == null ? void 0 : cs.filter(Cs => Cs !== as)) || [])
        }
    }
}
const FloatingNodeContext = reactExports.createContext(null)
  , FloatingTreeContext = reactExports.createContext(null)
  , useFloatingParentNodeId = () => {
    var xt;
    return ((xt = reactExports.useContext(FloatingNodeContext)) == null ? void 0 : xt.id) || null
}
  , useFloatingTree = () => reactExports.useContext(FloatingTreeContext)
  , FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
function useFloatingRootContext(xt) {
    const {open: Cn=!1, onOpenChange: as, elements: cs} = xt
      , Cs = useId()
      , Ls = reactExports.useRef({})
      , [Vs] = reactExports.useState( () => createPubSub())
      , Ws = useFloatingParentNodeId() != null
      , [Xs,ga] = reactExports.useState(cs.reference)
      , ba = useEffectEvent( (wl, _l, El) => {
        Ls.current.openEvent = wl ? _l : void 0,
        Vs.emit("openchange", {
            open: wl,
            event: _l,
            reason: El,
            nested: Ws
        }),
        as == null || as(wl, _l, El)
    }
    )
      , yl = reactExports.useMemo( () => ({
        setPositionReference: ga
    }), [])
      , xl = reactExports.useMemo( () => ({
        reference: Xs || cs.reference || null,
        floating: cs.floating || null,
        domReference: cs.reference
    }), [Xs, cs.reference, cs.floating]);
    return reactExports.useMemo( () => ({
        dataRef: Ls,
        open: Cn,
        onOpenChange: ba,
        elements: xl,
        events: Vs,
        floatingId: Cs,
        refs: yl
    }), [Cn, ba, xl, Vs, Cs, yl])
}
function useFloating(xt) {
    xt === void 0 && (xt = {});
    const {nodeId: Cn} = xt
      , as = useFloatingRootContext({
        ...xt,
        elements: {
            reference: null,
            floating: null,
            ...xt.elements
        }
    })
      , cs = xt.rootContext || as
      , Cs = cs.elements
      , [Ls,Vs] = reactExports.useState(null)
      , [Ws,Xs] = reactExports.useState(null)
      , ba = (Cs == null ? void 0 : Cs.domReference) || Ls
      , yl = reactExports.useRef(null)
      , xl = useFloatingTree();
    index( () => {
        ba && (yl.current = ba)
    }
    , [ba]);
    const wl = useFloating$1({
        ...xt,
        elements: {
            ...Cs,
            ...Ws && {
                reference: Ws
            }
        }
    })
      , _l = reactExports.useCallback(Tl => {
        const Rl = isElement(Tl) ? {
            getBoundingClientRect: () => Tl.getBoundingClientRect(),
            contextElement: Tl
        } : Tl;
        Xs(Rl),
        wl.refs.setReference(Rl)
    }
    , [wl.refs])
      , El = reactExports.useCallback(Tl => {
        (isElement(Tl) || Tl === null) && (yl.current = Tl,
        Vs(Tl)),
        (isElement(wl.refs.reference.current) || wl.refs.reference.current === null || Tl !== null && !isElement(Tl)) && wl.refs.setReference(Tl)
    }
    , [wl.refs])
      , Cl = reactExports.useMemo( () => ({
        ...wl.refs,
        setReference: El,
        setPositionReference: _l,
        domReference: yl
    }), [wl.refs, El, _l])
      , $l = reactExports.useMemo( () => ({
        ...wl.elements,
        domReference: ba
    }), [wl.elements, ba])
      , Sl = reactExports.useMemo( () => ({
        ...wl,
        ...cs,
        refs: Cl,
        elements: $l,
        nodeId: Cn
    }), [wl, Cl, $l, Cn, cs]);
    return index( () => {
        cs.dataRef.current.floatingContext = Sl;
        const Tl = xl == null ? void 0 : xl.nodesRef.current.find(Rl => Rl.id === Cn);
        Tl && (Tl.context = Sl)
    }
    ),
    reactExports.useMemo( () => ({
        ...wl,
        context: Sl,
        refs: Cl,
        elements: $l
    }), [wl, Cl, $l, Sl])
}
const ACTIVE_KEY = "active"
  , SELECTED_KEY = "selected";
function mergeProps(xt, Cn, as) {
    const cs = new Map
      , Cs = as === "item";
    let Ls = xt;
    if (Cs && xt) {
        const {[ACTIVE_KEY]: Vs, [SELECTED_KEY]: Ws, ...Xs} = xt;
        Ls = Xs
    }
    return {
        ...as === "floating" && {
            tabIndex: -1,
            [FOCUSABLE_ATTRIBUTE]: ""
        },
        ...Ls,
        ...Cn.map(Vs => {
            const Ws = Vs ? Vs[as] : null;
            return typeof Ws == "function" ? xt ? Ws(xt) : null : Ws
        }
        ).concat(xt).reduce( (Vs, Ws) => (Ws && Object.entries(Ws).forEach(Xs => {
            let[ga,ba] = Xs;
            if (!(Cs && [ACTIVE_KEY, SELECTED_KEY].includes(ga)))
                if (ga.indexOf("on") === 0) {
                    if (cs.has(ga) || cs.set(ga, []),
                    typeof ba == "function") {
                        var yl;
                        (yl = cs.get(ga)) == null || yl.push(ba),
                        Vs[ga] = function() {
                            for (var xl, wl = arguments.length, _l = new Array(wl), El = 0; El < wl; El++)
                                _l[El] = arguments[El];
                            return (xl = cs.get(ga)) == null ? void 0 : xl.map(Cl => Cl(..._l)).find(Cl => Cl !== void 0)
                        }
                    }
                } else
                    Vs[ga] = ba
        }
        ),
        Vs), {})
    }
}
function useInteractions(xt) {
    xt === void 0 && (xt = []);
    const Cn = xt.map(Ws => Ws == null ? void 0 : Ws.reference)
      , as = xt.map(Ws => Ws == null ? void 0 : Ws.floating)
      , cs = xt.map(Ws => Ws == null ? void 0 : Ws.item)
      , Cs = reactExports.useCallback(Ws => mergeProps(Ws, xt, "reference"), Cn)
      , Ls = reactExports.useCallback(Ws => mergeProps(Ws, xt, "floating"), as)
      , Vs = reactExports.useCallback(Ws => mergeProps(Ws, xt, "item"), cs);
    return reactExports.useMemo( () => ({
        getReferenceProps: Cs,
        getFloatingProps: Ls,
        getItemProps: Vs
    }), [Cs, Ls, Vs])
}
function getArgsWithCustomFloatingHeight(xt, Cn) {
    return {
        ...xt,
        rects: {
            ...xt.rects,
            floating: {
                ...xt.rects.floating,
                height: Cn
            }
        }
    }
}
const inner = xt => ({
    name: "inner",
    options: xt,
    async fn(Cn) {
        const {listRef: as, overflowRef: cs, onFallbackChange: Cs, offset: Ls=0, index: Vs=0, minItemsVisible: Ws=4, referenceOverflowThreshold: Xs=0, scrollRef: ga, ...ba} = evaluate(xt, Cn)
          , {rects: yl, elements: {floating: xl}} = Cn
          , wl = as.current[Vs]
          , _l = (ga == null ? void 0 : ga.current) || xl
          , El = xl.clientTop || _l.clientTop
          , Cl = xl.clientTop !== 0
          , $l = _l.clientTop !== 0
          , Sl = xl === _l;
        if (!wl)
            return {};
        const Tl = {
            ...Cn,
            ...await offset(-wl.offsetTop - xl.clientTop - yl.reference.height / 2 - wl.offsetHeight / 2 - Ls).fn(Cn)
        }
          , Rl = await detectOverflow(getArgsWithCustomFloatingHeight(Tl, _l.scrollHeight + El + xl.clientTop), ba)
          , Il = await detectOverflow(Tl, {
            ...ba,
            elementContext: "reference"
        })
          , Ml = max(0, Rl.top)
          , Nl = Tl.y + Ml
          , Ul = (_l.scrollHeight > _l.clientHeight ? Dl => Dl : round$1)(max(0, _l.scrollHeight + (Cl && Sl || $l ? El * 2 : 0) - Ml - max(0, Rl.bottom)));
        if (_l.style.maxHeight = Ul + "px",
        _l.scrollTop = Ml,
        Cs) {
            const Dl = _l.offsetHeight < wl.offsetHeight * min(Ws, as.current.length) - 1 || Il.top >= -Xs || Il.bottom >= -Xs;
            reactDomExports.flushSync( () => Cs(Dl))
        }
        return cs && (cs.current = await detectOverflow(getArgsWithCustomFloatingHeight({
            ...Tl,
            y: Nl
        }, _l.offsetHeight + El + xl.clientTop), ba)),
        {
            y: Nl
        }
    }
});
function useInnerOffset(xt, Cn) {
    const {open: as, elements: cs} = xt
      , {enabled: Cs=!0, overflowRef: Ls, scrollRef: Vs, onChange: Ws} = Cn
      , Xs = useEffectEvent(Ws)
      , ga = reactExports.useRef(!1)
      , ba = reactExports.useRef(null)
      , yl = reactExports.useRef(null);
    reactExports.useEffect( () => {
        if (!Cs)
            return;
        function wl(El) {
            if (El.ctrlKey || !_l || Ls.current == null)
                return;
            const Cl = El.deltaY
              , $l = Ls.current.top >= -.5
              , Sl = Ls.current.bottom >= -.5
              , Tl = _l.scrollHeight - _l.clientHeight
              , Rl = Cl < 0 ? -1 : 1
              , Il = Cl < 0 ? "max" : "min";
            _l.scrollHeight <= _l.clientHeight || (!$l && Cl > 0 || !Sl && Cl < 0 ? (El.preventDefault(),
            reactDomExports.flushSync( () => {
                Xs(Ml => Ml + Math[Il](Cl, Tl * Rl))
            }
            )) : /firefox/i.test(getUserAgent()) && (_l.scrollTop += Cl))
        }
        const _l = (Vs == null ? void 0 : Vs.current) || cs.floating;
        if (as && _l)
            return _l.addEventListener("wheel", wl),
            requestAnimationFrame( () => {
                ba.current = _l.scrollTop,
                Ls.current != null && (yl.current = {
                    ...Ls.current
                })
            }
            ),
            () => {
                ba.current = null,
                yl.current = null,
                _l.removeEventListener("wheel", wl)
            }
    }
    , [Cs, as, cs.floating, Ls, Vs, Xs]);
    const xl = reactExports.useMemo( () => ({
        onKeyDown() {
            ga.current = !0
        },
        onWheel() {
            ga.current = !1
        },
        onPointerMove() {
            ga.current = !1
        },
        onScroll() {
            const wl = (Vs == null ? void 0 : Vs.current) || cs.floating;
            if (!(!Ls.current || !wl || !ga.current)) {
                if (ba.current !== null) {
                    const _l = wl.scrollTop - ba.current;
                    (Ls.current.bottom < -.5 && _l < -1 || Ls.current.top < -.5 && _l > 1) && reactDomExports.flushSync( () => Xs(El => El + _l))
                }
                requestAnimationFrame( () => {
                    ba.current = wl.scrollTop
                }
                )
            }
        }
    }), [cs.floating, Xs, Ls, Vs]);
    return reactExports.useMemo( () => Cs ? {
        floating: xl
    } : {}, [Cs, xl])
}
let y = reactExports.createContext({
    styles: void 0,
    setReference: () => {}
    ,
    setFloating: () => {}
    ,
    getReferenceProps: () => ({}),
    getFloatingProps: () => ({}),
    slot: {}
});
y.displayName = "FloatingContext";
let H$3 = reactExports.createContext(null);
H$3.displayName = "PlacementContext";
function xe(xt) {
    return reactExports.useMemo( () => xt ? typeof xt == "string" ? {
        to: xt
    } : xt : null, [xt])
}
function ye$1() {
    return reactExports.useContext(y).setReference
}
function Fe$1() {
    return reactExports.useContext(y).getReferenceProps
}
function be$1() {
    let {getFloatingProps: xt, slot: Cn} = reactExports.useContext(y);
    return reactExports.useCallback( (...as) => Object.assign({}, xt(...as), {
        "data-anchor": Cn.anchor
    }), [xt, Cn])
}
function Re$1(xt=null) {
    xt === !1 && (xt = null),
    typeof xt == "string" && (xt = {
        to: xt
    });
    let Cn = reactExports.useContext(H$3)
      , as = reactExports.useMemo( () => xt, [JSON.stringify(xt, (Cs, Ls) => {
        var Vs;
        return (Vs = Ls == null ? void 0 : Ls.outerHTML) != null ? Vs : Ls
    }
    )]);
    n$5( () => {
        Cn == null || Cn(as ?? null)
    }
    , [Cn, as]);
    let cs = reactExports.useContext(y);
    return reactExports.useMemo( () => [cs.setFloating, xt ? cs.styles : {}], [cs.setFloating, xt, cs.styles])
}
let q$1 = 4;
function Me$1({children: xt, enabled: Cn=!0}) {
    let[as,cs] = reactExports.useState(null)
      , [Cs,Ls] = reactExports.useState(0)
      , Vs = reactExports.useRef(null)
      , [Ws,Xs] = reactExports.useState(null);
    pe(Ws);
    let ga = Cn && as !== null && Ws !== null
      , {to: ba="bottom", gap: yl=0, offset: xl=0, padding: wl=0, inner: _l} = ce$1(as, Ws)
      , [El,Cl="center"] = ba.split(" ");
    n$5( () => {
        ga && Ls(0)
    }
    , [ga]);
    let {refs: $l, floatingStyles: Sl, context: Tl} = useFloating({
        open: ga,
        placement: El === "selection" ? Cl === "center" ? "bottom" : `bottom-${Cl}` : Cl === "center" ? `${El}` : `${El}-${Cl}`,
        strategy: "absolute",
        transform: !1,
        middleware: [offset({
            mainAxis: El === "selection" ? 0 : yl,
            crossAxis: xl
        }), shift({
            padding: wl
        }), El !== "selection" && flip({
            padding: wl
        }), El === "selection" && _l ? inner({
            ..._l,
            padding: wl,
            overflowRef: Vs,
            offset: Cs,
            minItemsVisible: q$1,
            referenceOverflowThreshold: wl,
            onFallbackChange(Dl) {
                var Zl, Gl;
                if (!Dl)
                    return;
                let Wl = Tl.elements.floating;
                if (!Wl)
                    return;
                let Ql = parseFloat(getComputedStyle(Wl).scrollPaddingBottom) || 0
                  , cu = Math.min(q$1, Wl.childElementCount)
                  , pu = 0
                  , zl = 0;
                for (let Yl of (Gl = (Zl = Tl.elements.floating) == null ? void 0 : Zl.childNodes) != null ? Gl : [])
                    if (Yl instanceof HTMLElement) {
                        let lu = Yl.offsetTop
                          , mu = lu + Yl.clientHeight + Ql
                          , Cu = Wl.scrollTop
                          , ju = Cu + Wl.clientHeight;
                        if (lu >= Cu && mu <= ju)
                            cu--;
                        else {
                            zl = Math.max(0, Math.min(mu, ju) - Math.max(lu, Cu)),
                            pu = Yl.clientHeight;
                            break
                        }
                    }
                cu >= 1 && Ls(Yl => {
                    let lu = pu * cu - zl + Ql;
                    return Yl >= lu ? Yl : lu
                }
                )
            }
        }) : null, size({
            padding: wl,
            apply({availableWidth: Dl, availableHeight: Zl, elements: Gl}) {
                Object.assign(Gl.floating.style, {
                    overflow: "auto",
                    maxWidth: `${Dl}px`,
                    maxHeight: `min(var(--anchor-max-height, 100vh), ${Zl}px)`
                })
            }
        })].filter(Boolean),
        whileElementsMounted: autoUpdate
    })
      , [Rl=El,Il=Cl] = Tl.placement.split("-");
    El === "selection" && (Rl = "selection");
    let Ml = reactExports.useMemo( () => ({
        anchor: [Rl, Il].filter(Boolean).join(" ")
    }), [Rl, Il])
      , Nl = useInnerOffset(Tl, {
        overflowRef: Vs,
        onChange: Ls
    })
      , {getReferenceProps: Ll, getFloatingProps: Fl} = useInteractions([Nl])
      , Ul = o$5(Dl => {
        Xs(Dl),
        $l.setFloating(Dl)
    }
    );
    return reactExports.createElement(H$3.Provider, {
        value: cs
    }, reactExports.createElement(y.Provider, {
        value: {
            setFloating: Ul,
            setReference: $l.setReference,
            styles: Sl,
            getReferenceProps: Ll,
            getFloatingProps: Fl,
            slot: Ml
        }
    }, xt))
}
function pe(xt) {
    n$5( () => {
        if (!xt)
            return;
        let Cn = new MutationObserver( () => {
            let as = window.getComputedStyle(xt).maxHeight
              , cs = parseFloat(as);
            if (isNaN(cs))
                return;
            let Cs = parseInt(as);
            isNaN(Cs) || cs !== Cs && (xt.style.maxHeight = `${Math.ceil(cs)}px`)
        }
        );
        return Cn.observe(xt, {
            attributes: !0,
            attributeFilter: ["style"]
        }),
        () => {
            Cn.disconnect()
        }
    }
    , [xt])
}
function ce$1(xt, Cn) {
    var as, cs, Cs;
    let Ls = V((as = xt == null ? void 0 : xt.gap) != null ? as : "var(--anchor-gap, 0)", Cn)
      , Vs = V((cs = xt == null ? void 0 : xt.offset) != null ? cs : "var(--anchor-offset, 0)", Cn)
      , Ws = V((Cs = xt == null ? void 0 : xt.padding) != null ? Cs : "var(--anchor-padding, 0)", Cn);
    return {
        ...xt,
        gap: Ls,
        offset: Vs,
        padding: Ws
    }
}
function V(xt, Cn, as=void 0) {
    let cs = p$3()
      , Cs = o$5( (Xs, ga) => {
        if (Xs == null)
            return [as, null];
        if (typeof Xs == "number")
            return [Xs, null];
        if (typeof Xs == "string") {
            if (!ga)
                return [as, null];
            let ba = J$3(Xs, ga);
            return [ba, yl => {
                let xl = D$1(Xs);
                {
                    let wl = xl.map(_l => window.getComputedStyle(ga).getPropertyValue(_l));
                    cs.requestAnimationFrame(function _l() {
                        cs.nextFrame(_l);
                        let El = !1;
                        for (let[$l,Sl] of xl.entries()) {
                            let Tl = window.getComputedStyle(ga).getPropertyValue(Sl);
                            if (wl[$l] !== Tl) {
                                wl[$l] = Tl,
                                El = !0;
                                break
                            }
                        }
                        if (!El)
                            return;
                        let Cl = J$3(Xs, ga);
                        ba !== Cl && (yl(Cl),
                        ba = Cl)
                    })
                }
                return cs.dispose
            }
            ]
        }
        return [as, null]
    }
    )
      , Ls = reactExports.useMemo( () => Cs(xt, Cn)[0], [xt, Cn])
      , [Vs=Ls,Ws] = reactExports.useState();
    return n$5( () => {
        let[Xs,ga] = Cs(xt, Cn);
        if (Ws(Xs),
        !!ga)
            return ga(Ws)
    }
    , [xt, Cn]),
    Vs
}
function D$1(xt) {
    let Cn = /var\((.*)\)/.exec(xt);
    if (Cn) {
        let as = Cn[1].indexOf(",");
        if (as === -1)
            return [Cn[1]];
        let cs = Cn[1].slice(0, as).trim()
          , Cs = Cn[1].slice(as + 1).trim();
        return Cs ? [cs, ...D$1(Cs)] : [cs]
    }
    return []
}
function J$3(xt, Cn) {
    let as = document.createElement("div");
    Cn.appendChild(as),
    as.style.setProperty("margin-top", "0px", "important"),
    as.style.setProperty("margin-top", xt, "important");
    let cs = parseFloat(window.getComputedStyle(as).marginTop) || 0;
    return Cn.removeChild(as),
    cs
}
function l$1(xt, Cn) {
    let[as,cs] = reactExports.useState(Cn);
    return !xt && as !== Cn && cs(Cn),
    xt ? as : Cn
}
let n$2 = reactExports.createContext(null);
n$2.displayName = "OpenClosedContext";
var i$1 = (xt => (xt[xt.Open = 1] = "Open",
xt[xt.Closed = 2] = "Closed",
xt[xt.Closing = 4] = "Closing",
xt[xt.Opening = 8] = "Opening",
xt))(i$1 || {});
function u$1() {
    return reactExports.useContext(n$2)
}
function c$3({value: xt, children: Cn}) {
    return React__default.createElement(n$2.Provider, {
        value: xt
    }, Cn)
}
function s$5({children: xt}) {
    return React__default.createElement(n$2.Provider, {
        value: null
    }, xt)
}
function u(xt) {
    throw new Error("Unexpected object: " + xt)
}
var c$2 = (xt => (xt[xt.First = 0] = "First",
xt[xt.Previous = 1] = "Previous",
xt[xt.Next = 2] = "Next",
xt[xt.Last = 3] = "Last",
xt[xt.Specific = 4] = "Specific",
xt[xt.Nothing = 5] = "Nothing",
xt))(c$2 || {});
function f(xt, Cn) {
    let as = Cn.resolveItems();
    if (as.length <= 0)
        return null;
    let cs = Cn.resolveActiveIndex()
      , Cs = cs ?? -1;
    switch (xt.focus) {
    case 0:
        {
            for (let Ls = 0; Ls < as.length; ++Ls)
                if (!Cn.resolveDisabled(as[Ls], Ls, as))
                    return Ls;
            return cs
        }
    case 1:
        {
            Cs === -1 && (Cs = as.length);
            for (let Ls = Cs - 1; Ls >= 0; --Ls)
                if (!Cn.resolveDisabled(as[Ls], Ls, as))
                    return Ls;
            return cs
        }
    case 2:
        {
            for (let Ls = Cs + 1; Ls < as.length; ++Ls)
                if (!Cn.resolveDisabled(as[Ls], Ls, as))
                    return Ls;
            return cs
        }
    case 3:
        {
            for (let Ls = as.length - 1; Ls >= 0; --Ls)
                if (!Cn.resolveDisabled(as[Ls], Ls, as))
                    return Ls;
            return cs
        }
    case 4:
        {
            for (let Ls = 0; Ls < as.length; ++Ls)
                if (Cn.resolveId(as[Ls], Ls, as) === xt.id)
                    return Ls;
            return cs
        }
    case 5:
        return null;
    default:
        u(xt)
    }
}
function c$1(xt) {
    let Cn = o$5(xt)
      , as = reactExports.useRef(!1);
    reactExports.useEffect( () => (as.current = !1,
    () => {
        as.current = !0,
        t$4( () => {
            as.current && Cn()
        }
        )
    }
    ), [Cn])
}
function s$4() {
    let xt = typeof document > "u";
    return "useSyncExternalStore"in t$6 ? (Cn => Cn.useSyncExternalStore)(t$6)( () => () => {}
    , () => !1, () => !xt) : !1
}
function l() {
    let xt = s$4()
      , [Cn,as] = reactExports.useState(s$9.isHandoffComplete);
    return Cn && s$9.isHandoffComplete === !1 && as(!1),
    reactExports.useEffect( () => {
        Cn !== !0 && as(!0)
    }
    , [Cn]),
    reactExports.useEffect( () => s$9.handoff(), []),
    xt ? !1 : Cn
}
let e = reactExports.createContext(!1);
function a$2() {
    return reactExports.useContext(e)
}
function j(xt) {
    let Cn = a$2()
      , as = reactExports.useContext(H$2)
      , [cs,Cs] = reactExports.useState( () => {
        var Ls;
        if (!Cn && as !== null)
            return (Ls = as.current) != null ? Ls : null;
        if (s$9.isServer)
            return null;
        let Vs = xt == null ? void 0 : xt.getElementById("headlessui-portal-root");
        if (Vs)
            return Vs;
        if (xt === null)
            return null;
        let Ws = xt.createElement("div");
        return Ws.setAttribute("id", "headlessui-portal-root"),
        xt.body.appendChild(Ws)
    }
    );
    return reactExports.useEffect( () => {
        cs !== null && (xt != null && xt.body.contains(cs) || xt == null || xt.body.appendChild(cs))
    }
    , [cs, xt]),
    reactExports.useEffect( () => {
        Cn || as !== null && Cs(as.current)
    }
    , [as, Cs, Cn]),
    cs
}
let M$1 = reactExports.Fragment
  , I = K$1(function(xt, Cn) {
    let {ownerDocument: as=null, ...cs} = xt
      , Cs = reactExports.useRef(null)
      , Ls = y$3(T$2(wl => {
        Cs.current = wl
    }
    ), Cn)
      , Vs = n$3(Cs)
      , Ws = as ?? Vs
      , Xs = j(Ws)
      , [ga] = reactExports.useState( () => {
        var wl;
        return s$9.isServer ? null : (wl = Ws == null ? void 0 : Ws.createElement("div")) != null ? wl : null
    }
    )
      , ba = reactExports.useContext(g$1)
      , yl = l();
    n$5( () => {
        !Xs || !ga || Xs.contains(ga) || (ga.setAttribute("data-headlessui-portal", ""),
        Xs.appendChild(ga))
    }
    , [Xs, ga]),
    n$5( () => {
        if (ga && ba)
            return ba.register(ga)
    }
    , [ba, ga]),
    c$1( () => {
        var wl;
        !Xs || !ga || (ga instanceof Node && Xs.contains(ga) && Xs.removeChild(ga),
        Xs.childNodes.length <= 0 && ((wl = Xs.parentElement) == null || wl.removeChild(Xs)))
    }
    );
    let xl = L$1();
    return yl ? !Xs || !ga ? null : reactDomExports.createPortal(xl({
        ourProps: {
            ref: Ls
        },
        theirProps: cs,
        slot: {},
        defaultTag: M$1,
        name: "Portal"
    }), ga) : null
});
function J$2(xt, Cn) {
    let as = y$3(Cn)
      , {enabled: cs=!0, ownerDocument: Cs, ...Ls} = xt
      , Vs = L$1();
    return cs ? React__default.createElement(I, {
        ...Ls,
        ownerDocument: Cs,
        ref: as
    }) : Vs({
        ourProps: {
            ref: as
        },
        theirProps: Ls,
        slot: {},
        defaultTag: M$1,
        name: "Portal"
    })
}
let X$2 = reactExports.Fragment
  , H$2 = reactExports.createContext(null);
function k(xt, Cn) {
    let {target: as, ...cs} = xt
      , Cs = {
        ref: y$3(Cn)
    }
      , Ls = L$1();
    return React__default.createElement(H$2.Provider, {
        value: as
    }, Ls({
        ourProps: Cs,
        theirProps: cs,
        defaultTag: X$2,
        name: "Popover.Group"
    }))
}
let g$1 = reactExports.createContext(null)
  , B = K$1(J$2)
  , D = K$1(k)
  , oe = Object.assign(B, {
    Group: D
});
var t;
let a$1 = (t = React__default.startTransition) != null ? t : function(xt) {
    xt()
}
;
var ce = (xt => (xt[xt.Open = 0] = "Open",
xt[xt.Closed = 1] = "Closed",
xt))(ce || {})
  , de = (xt => (xt[xt.ToggleDisclosure = 0] = "ToggleDisclosure",
xt[xt.CloseDisclosure = 1] = "CloseDisclosure",
xt[xt.SetButtonId = 2] = "SetButtonId",
xt[xt.SetPanelId = 3] = "SetPanelId",
xt[xt.SetButtonElement = 4] = "SetButtonElement",
xt[xt.SetPanelElement = 5] = "SetPanelElement",
xt))(de || {});
let Te$1 = {
    0: xt => ({
        ...xt,
        disclosureState: u$7(xt.disclosureState, {
            0: 1,
            1: 0
        })
    }),
    1: xt => xt.disclosureState === 1 ? xt : {
        ...xt,
        disclosureState: 1
    },
    2(xt, Cn) {
        return xt.buttonId === Cn.buttonId ? xt : {
            ...xt,
            buttonId: Cn.buttonId
        }
    },
    3(xt, Cn) {
        return xt.panelId === Cn.panelId ? xt : {
            ...xt,
            panelId: Cn.panelId
        }
    },
    4(xt, Cn) {
        return xt.buttonElement === Cn.element ? xt : {
            ...xt,
            buttonElement: Cn.element
        }
    },
    5(xt, Cn) {
        return xt.panelElement === Cn.element ? xt : {
            ...xt,
            panelElement: Cn.element
        }
    }
}
  , _$1 = reactExports.createContext(null);
_$1.displayName = "DisclosureContext";
function M(xt) {
    let Cn = reactExports.useContext(_$1);
    if (Cn === null) {
        let as = new Error(`<${xt} /> is missing a parent <Disclosure /> component.`);
        throw Error.captureStackTrace && Error.captureStackTrace(as, M),
        as
    }
    return Cn
}
let F = reactExports.createContext(null);
F.displayName = "DisclosureAPIContext";
function J$1(xt) {
    let Cn = reactExports.useContext(F);
    if (Cn === null) {
        let as = new Error(`<${xt} /> is missing a parent <Disclosure /> component.`);
        throw Error.captureStackTrace && Error.captureStackTrace(as, J$1),
        as
    }
    return Cn
}
let H$1 = reactExports.createContext(null);
H$1.displayName = "DisclosurePanelContext";
function fe() {
    return reactExports.useContext(H$1)
}
function me$1(xt, Cn) {
    return u$7(Cn.type, Te$1, xt, Cn)
}
let De = reactExports.Fragment;
function ye(xt, Cn) {
    let {defaultOpen: as=!1, ...cs} = xt
      , Cs = reactExports.useRef(null)
      , Ls = y$3(Cn, T$2(El => {
        Cs.current = El
    }
    , xt.as === void 0 || xt.as === reactExports.Fragment))
      , Vs = reactExports.useReducer(me$1, {
        disclosureState: as ? 0 : 1,
        buttonElement: null,
        panelElement: null,
        buttonId: null,
        panelId: null
    })
      , [{disclosureState: Ws, buttonId: Xs},ga] = Vs
      , ba = o$5(El => {
        ga({
            type: 1
        });
        let Cl = o$7(Cs);
        if (!Cl || !Xs)
            return;
        let $l = El ? El instanceof HTMLElement ? El : El.current instanceof HTMLElement ? El.current : Cl.getElementById(Xs) : Cl.getElementById(Xs);
        $l == null || $l.focus()
    }
    )
      , yl = reactExports.useMemo( () => ({
        close: ba
    }), [ba])
      , xl = reactExports.useMemo( () => ({
        open: Ws === 0,
        close: ba
    }), [Ws, ba])
      , wl = {
        ref: Ls
    }
      , _l = L$1();
    return React__default.createElement(_$1.Provider, {
        value: Vs
    }, React__default.createElement(F.Provider, {
        value: yl
    }, React__default.createElement(C$1, {
        value: ba
    }, React__default.createElement(c$3, {
        value: u$7(Ws, {
            0: i$1.Open,
            1: i$1.Closed
        })
    }, _l({
        ourProps: wl,
        theirProps: cs,
        slot: xl,
        defaultTag: De,
        name: "Disclosure"
    })))))
}
let Pe = "button";
function Ee$1(xt, Cn) {
    let as = reactExports.useId()
      , {id: cs=`headlessui-disclosure-button-${as}`, disabled: Cs=!1, autoFocus: Ls=!1, ...Vs} = xt
      , [Ws,Xs] = M("Disclosure.Button")
      , ga = fe()
      , ba = ga === null ? !1 : ga === Ws.panelId
      , yl = reactExports.useRef(null)
      , xl = y$3(yl, Cn, o$5(Fl => {
        if (!ba)
            return Xs({
                type: 4,
                element: Fl
            })
    }
    ));
    reactExports.useEffect( () => {
        if (!ba)
            return Xs({
                type: 2,
                buttonId: cs
            }),
            () => {
                Xs({
                    type: 2,
                    buttonId: null
                })
            }
    }
    , [cs, Xs, ba]);
    let wl = o$5(Fl => {
        var Ul;
        if (ba) {
            if (Ws.disclosureState === 1)
                return;
            switch (Fl.key) {
            case o$3.Space:
            case o$3.Enter:
                Fl.preventDefault(),
                Fl.stopPropagation(),
                Xs({
                    type: 0
                }),
                (Ul = Ws.buttonElement) == null || Ul.focus();
                break
            }
        } else
            switch (Fl.key) {
            case o$3.Space:
            case o$3.Enter:
                Fl.preventDefault(),
                Fl.stopPropagation(),
                Xs({
                    type: 0
                });
                break
            }
    }
    )
      , _l = o$5(Fl => {
        switch (Fl.key) {
        case o$3.Space:
            Fl.preventDefault();
            break
        }
    }
    )
      , El = o$5(Fl => {
        var Ul;
        r$2(Fl.currentTarget) || Cs || (ba ? (Xs({
            type: 0
        }),
        (Ul = Ws.buttonElement) == null || Ul.focus()) : Xs({
            type: 0
        }))
    }
    )
      , {isFocusVisible: Cl, focusProps: $l} = $f7dceffc5ad7768b$export$4e328f61c538687f({
        autoFocus: Ls
    })
      , {isHovered: Sl, hoverProps: Tl} = $6179b936705e76d3$export$ae780daf29e6d456({
        isDisabled: Cs
    })
      , {pressed: Rl, pressProps: Il} = w$2({
        disabled: Cs
    })
      , Ml = reactExports.useMemo( () => ({
        open: Ws.disclosureState === 0,
        hover: Sl,
        active: Rl,
        disabled: Cs,
        focus: Cl,
        autofocus: Ls
    }), [Ws, Sl, Rl, Cl, Cs, Ls])
      , Nl = e$1(xt, Ws.buttonElement)
      , Ll = _$4(ba ? {
        ref: xl,
        type: Nl,
        disabled: Cs || void 0,
        autoFocus: Ls,
        onKeyDown: wl,
        onClick: El
    } : {
        ref: xl,
        id: cs,
        type: Nl,
        "aria-expanded": Ws.disclosureState === 0,
        "aria-controls": Ws.panelElement ? Ws.panelId : void 0,
        disabled: Cs || void 0,
        autoFocus: Ls,
        onKeyDown: wl,
        onKeyUp: _l,
        onClick: El
    }, $l, Tl, Il);
    return L$1()({
        ourProps: Ll,
        theirProps: Vs,
        slot: Ml,
        defaultTag: Pe,
        name: "Disclosure.Button"
    })
}
let Se$1 = "div"
  , ge = O$1.RenderStrategy | O$1.Static;
function Ae(xt, Cn) {
    let as = reactExports.useId()
      , {id: cs=`headlessui-disclosure-panel-${as}`, transition: Cs=!1, ...Ls} = xt
      , [Vs,Ws] = M("Disclosure.Panel")
      , {close: Xs} = J$1("Disclosure.Panel")
      , [ga,ba] = reactExports.useState(null)
      , yl = y$3(Cn, o$5(Sl => {
        a$1( () => Ws({
            type: 5,
            element: Sl
        }))
    }
    ), ba);
    reactExports.useEffect( () => (Ws({
        type: 3,
        panelId: cs
    }),
    () => {
        Ws({
            type: 3,
            panelId: null
        })
    }
    ), [cs, Ws]);
    let xl = u$1()
      , [wl,_l] = x(Cs, ga, xl !== null ? (xl & i$1.Open) === i$1.Open : Vs.disclosureState === 0)
      , El = reactExports.useMemo( () => ({
        open: Vs.disclosureState === 0,
        close: Xs
    }), [Vs.disclosureState, Xs])
      , Cl = {
        ref: yl,
        id: cs,
        ...R(_l)
    }
      , $l = L$1();
    return React__default.createElement(s$5, null, React__default.createElement(H$1.Provider, {
        value: Vs.panelId
    }, $l({
        ourProps: Cl,
        theirProps: Ls,
        slot: El,
        defaultTag: Se$1,
        features: ge,
        visible: wl,
        name: "Disclosure.Panel"
    })))
}
let be = K$1(ye)
  , Ce = K$1(Ee$1)
  , Re = K$1(Ae)
  , je$1 = Object.assign(be, {
    Button: Ce,
    Panel: Re
})
  , _ = "div";
function c(xt, Cn) {
    let as = `headlessui-control-${reactExports.useId()}`
      , [cs,Cs] = K()
      , [Ls,Vs] = w$1()
      , Ws = a$9()
      , {disabled: Xs=Ws || !1, ...ga} = xt
      , ba = reactExports.useMemo( () => ({
        disabled: Xs
    }), [Xs])
      , yl = {
        ref: Cn,
        disabled: Xs || void 0,
        "aria-disabled": Xs || void 0
    }
      , xl = L$1();
    return React__default.createElement(l$5, {
        value: Xs
    }, React__default.createElement(Cs, {
        value: cs
    }, React__default.createElement(Vs, {
        value: Ls
    }, React__default.createElement(f$6, {
        id: as
    }, xl({
        ourProps: yl,
        theirProps: {
            ...ga,
            children: React__default.createElement(W, null, typeof ga.children == "function" ? ga.children(ba) : ga.children)
        },
        slot: ba,
        defaultTag: _,
        name: "Field"
    })))))
}
let H = K$1(c);
function s$3(xt, Cn) {
    let as = reactExports.useRef({
        left: 0,
        top: 0
    });
    if (n$5( () => {
        if (!Cn)
            return;
        let Cs = Cn.getBoundingClientRect();
        Cs && (as.current = Cs)
    }
    , [xt, Cn]),
    Cn == null || !xt || Cn === document.activeElement)
        return !1;
    let cs = Cn.getBoundingClientRect();
    return cs.top !== as.current.top || cs.left !== as.current.left
}
let a = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o$1(xt) {
    var Cn, as;
    let cs = (Cn = xt.innerText) != null ? Cn : ""
      , Cs = xt.cloneNode(!0);
    if (!(Cs instanceof HTMLElement))
        return cs;
    let Ls = !1;
    for (let Ws of Cs.querySelectorAll('[hidden],[aria-hidden],[role="img"]'))
        Ws.remove(),
        Ls = !0;
    let Vs = Ls ? (as = Cs.innerText) != null ? as : "" : cs;
    return a.test(Vs) && (Vs = Vs.replace(a, "")),
    Vs
}
function g(xt) {
    let Cn = xt.getAttribute("aria-label");
    if (typeof Cn == "string")
        return Cn.trim();
    let as = xt.getAttribute("aria-labelledby");
    if (as) {
        let cs = as.split(" ").map(Cs => {
            let Ls = document.getElementById(Cs);
            if (Ls) {
                let Vs = Ls.getAttribute("aria-label");
                return typeof Vs == "string" ? Vs.trim() : o$1(Ls).trim()
            }
            return null
        }
        ).filter(Boolean);
        if (cs.length > 0)
            return cs.join(", ")
    }
    return o$1(xt).trim()
}
function s$2(xt) {
    let Cn = reactExports.useRef("")
      , as = reactExports.useRef("");
    return o$5( () => {
        let cs = xt.current;
        if (!cs)
            return "";
        let Cs = cs.innerText;
        if (Cn.current === Cs)
            return as.current;
        let Ls = g(cs).trim().toLowerCase();
        return Cn.current = Cs,
        as.current = Ls,
        Ls
    }
    )
}
var gt = (xt => (xt[xt.Open = 0] = "Open",
xt[xt.Closed = 1] = "Closed",
xt))(gt || {})
  , Lt = (xt => (xt[xt.Single = 0] = "Single",
xt[xt.Multi = 1] = "Multi",
xt))(Lt || {})
  , St = (xt => (xt[xt.Pointer = 0] = "Pointer",
xt[xt.Other = 1] = "Other",
xt))(St || {})
  , Et = (xt => (xt[xt.OpenListbox = 0] = "OpenListbox",
xt[xt.CloseListbox = 1] = "CloseListbox",
xt[xt.GoToOption = 2] = "GoToOption",
xt[xt.Search = 3] = "Search",
xt[xt.ClearSearch = 4] = "ClearSearch",
xt[xt.RegisterOption = 5] = "RegisterOption",
xt[xt.UnregisterOption = 6] = "UnregisterOption",
xt[xt.SetButtonElement = 7] = "SetButtonElement",
xt[xt.SetOptionsElement = 8] = "SetOptionsElement",
xt))(Et || {});
function Te(xt, Cn=as => as) {
    let as = xt.activeOptionIndex !== null ? xt.options[xt.activeOptionIndex] : null
      , cs = _$2(Cn(xt.options.slice()), Ls => Ls.dataRef.current.domRef.current)
      , Cs = as ? cs.indexOf(as) : null;
    return Cs === -1 && (Cs = null),
    {
        options: cs,
        activeOptionIndex: Cs
    }
}
let Pt = {
    1(xt) {
        return xt.dataRef.current.disabled || xt.listboxState === 1 ? xt : {
            ...xt,
            activeOptionIndex: null,
            listboxState: 1,
            __demoMode: !1
        }
    },
    0(xt) {
        if (xt.dataRef.current.disabled || xt.listboxState === 0)
            return xt;
        let Cn = xt.activeOptionIndex
          , {isSelected: as} = xt.dataRef.current
          , cs = xt.options.findIndex(Cs => as(Cs.dataRef.current.value));
        return cs !== -1 && (Cn = cs),
        {
            ...xt,
            listboxState: 0,
            activeOptionIndex: Cn,
            __demoMode: !1
        }
    },
    2(xt, Cn) {
        var as, cs, Cs, Ls, Vs;
        if (xt.dataRef.current.disabled || xt.listboxState === 1)
            return xt;
        let Ws = {
            ...xt,
            searchQuery: "",
            activationTrigger: (as = Cn.trigger) != null ? as : 1,
            __demoMode: !1
        };
        if (Cn.focus === c$2.Nothing)
            return {
                ...Ws,
                activeOptionIndex: null
            };
        if (Cn.focus === c$2.Specific)
            return {
                ...Ws,
                activeOptionIndex: xt.options.findIndex(ba => ba.id === Cn.id)
            };
        if (Cn.focus === c$2.Previous) {
            let ba = xt.activeOptionIndex;
            if (ba !== null) {
                let yl = xt.options[ba].dataRef.current.domRef
                  , xl = f(Cn, {
                    resolveItems: () => xt.options,
                    resolveActiveIndex: () => xt.activeOptionIndex,
                    resolveId: wl => wl.id,
                    resolveDisabled: wl => wl.dataRef.current.disabled
                });
                if (xl !== null) {
                    let wl = xt.options[xl].dataRef.current.domRef;
                    if (((cs = yl.current) == null ? void 0 : cs.previousElementSibling) === wl.current || ((Cs = wl.current) == null ? void 0 : Cs.previousElementSibling) === null)
                        return {
                            ...Ws,
                            activeOptionIndex: xl
                        }
                }
            }
        } else if (Cn.focus === c$2.Next) {
            let ba = xt.activeOptionIndex;
            if (ba !== null) {
                let yl = xt.options[ba].dataRef.current.domRef
                  , xl = f(Cn, {
                    resolveItems: () => xt.options,
                    resolveActiveIndex: () => xt.activeOptionIndex,
                    resolveId: wl => wl.id,
                    resolveDisabled: wl => wl.dataRef.current.disabled
                });
                if (xl !== null) {
                    let wl = xt.options[xl].dataRef.current.domRef;
                    if (((Ls = yl.current) == null ? void 0 : Ls.nextElementSibling) === wl.current || ((Vs = wl.current) == null ? void 0 : Vs.nextElementSibling) === null)
                        return {
                            ...Ws,
                            activeOptionIndex: xl
                        }
                }
            }
        }
        let Xs = Te(xt)
          , ga = f(Cn, {
            resolveItems: () => Xs.options,
            resolveActiveIndex: () => Xs.activeOptionIndex,
            resolveId: ba => ba.id,
            resolveDisabled: ba => ba.dataRef.current.disabled
        });
        return {
            ...Ws,
            ...Xs,
            activeOptionIndex: ga
        }
    },
    3: (xt, Cn) => {
        if (xt.dataRef.current.disabled || xt.listboxState === 1)
            return xt;
        let as = xt.searchQuery !== "" ? 0 : 1
          , cs = xt.searchQuery + Cn.value.toLowerCase()
          , Cs = (xt.activeOptionIndex !== null ? xt.options.slice(xt.activeOptionIndex + as).concat(xt.options.slice(0, xt.activeOptionIndex + as)) : xt.options).find(Vs => {
            var Ws;
            return !Vs.dataRef.current.disabled && ((Ws = Vs.dataRef.current.textValue) == null ? void 0 : Ws.startsWith(cs))
        }
        )
          , Ls = Cs ? xt.options.indexOf(Cs) : -1;
        return Ls === -1 || Ls === xt.activeOptionIndex ? {
            ...xt,
            searchQuery: cs
        } : {
            ...xt,
            searchQuery: cs,
            activeOptionIndex: Ls,
            activationTrigger: 1
        }
    }
    ,
    4(xt) {
        return xt.dataRef.current.disabled || xt.listboxState === 1 || xt.searchQuery === "" ? xt : {
            ...xt,
            searchQuery: ""
        }
    },
    5: (xt, Cn) => {
        let as = {
            id: Cn.id,
            dataRef: Cn.dataRef
        }
          , cs = Te(xt, Cs => [...Cs, as]);
        return xt.activeOptionIndex === null && xt.dataRef.current.isSelected(Cn.dataRef.current.value) && (cs.activeOptionIndex = cs.options.indexOf(as)),
        {
            ...xt,
            ...cs
        }
    }
    ,
    6: (xt, Cn) => {
        let as = Te(xt, cs => {
            let Cs = cs.findIndex(Ls => Ls.id === Cn.id);
            return Cs !== -1 && cs.splice(Cs, 1),
            cs
        }
        );
        return {
            ...xt,
            ...as,
            activationTrigger: 1
        }
    }
    ,
    7: (xt, Cn) => xt.buttonElement === Cn.element ? xt : {
        ...xt,
        buttonElement: Cn.element
    },
    8: (xt, Cn) => xt.optionsElement === Cn.element ? xt : {
        ...xt,
        optionsElement: Cn.element
    }
}
  , me = reactExports.createContext(null);
me.displayName = "ListboxActionsContext";
function Y(xt) {
    let Cn = reactExports.useContext(me);
    if (Cn === null) {
        let as = new Error(`<${xt} /> is missing a parent <Listbox /> component.`);
        throw Error.captureStackTrace && Error.captureStackTrace(as, Y),
        as
    }
    return Cn
}
let Z = reactExports.createContext(null);
Z.displayName = "ListboxDataContext";
function X$1(xt) {
    let Cn = reactExports.useContext(Z);
    if (Cn === null) {
        let as = new Error(`<${xt} /> is missing a parent <Listbox /> component.`);
        throw Error.captureStackTrace && Error.captureStackTrace(as, X$1),
        as
    }
    return Cn
}
function Rt(xt, Cn) {
    return u$7(Cn.type, Pt, xt, Cn)
}
let At = reactExports.Fragment;
function ht(xt, Cn) {
    var as;
    let cs = a$9()
      , {value: Cs, defaultValue: Ls, form: Vs, name: Ws, onChange: Xs, by: ga, invalid: ba=!1, disabled: yl=cs || !1, horizontal: xl=!1, multiple: wl=!1, __demoMode: _l=!1, ...El} = xt;
    const Cl = xl ? "horizontal" : "vertical";
    let $l = y$3(Cn)
      , Sl = l$4(Ls)
      , [Tl=wl ? [] : void 0,Rl] = T$3(Cs, Xs, Sl)
      , [Il,Ml] = reactExports.useReducer(Rt, {
        dataRef: reactExports.createRef(),
        listboxState: _l ? 0 : 1,
        options: [],
        searchQuery: "",
        activeOptionIndex: null,
        activationTrigger: 1,
        optionsVisible: !1,
        buttonElement: null,
        optionsElement: null,
        __demoMode: _l
    })
      , Nl = reactExports.useRef({
        static: !1,
        hold: !1
    })
      , Ll = reactExports.useRef(new Map)
      , Fl = u$4(ga)
      , Ul = reactExports.useCallback(xu => u$7(Dl.mode, {
        1: () => Tl.some(Ru => Fl(Ru, xu)),
        0: () => Fl(Tl, xu)
    }), [Tl])
      , Dl = reactExports.useMemo( () => ({
        ...Il,
        value: Tl,
        disabled: yl,
        invalid: ba,
        mode: wl ? 1 : 0,
        orientation: Cl,
        compare: Fl,
        isSelected: Ul,
        optionsPropsRef: Nl,
        listRef: Ll
    }), [Tl, yl, ba, wl, Il, Ll]);
    n$5( () => {
        Il.dataRef.current = Dl
    }
    , [Dl]);
    let Zl = Dl.listboxState === 0;
    R$1(Zl, [Dl.buttonElement, Dl.optionsElement], (xu, Ru) => {
        var Iu;
        Ml({
            type: 1
        }),
        A(Ru, h.Loose) || (xu.preventDefault(),
        (Iu = Dl.buttonElement) == null || Iu.focus())
    }
    );
    let Gl = reactExports.useMemo( () => ({
        open: Dl.listboxState === 0,
        disabled: yl,
        invalid: ba,
        value: Tl
    }), [Dl, yl, Tl, ba])
      , Wl = o$5(xu => {
        let Ru = Dl.options.find(Iu => Iu.id === xu);
        Ru && mu(Ru.dataRef.current.value)
    }
    )
      , Ql = o$5( () => {
        if (Dl.activeOptionIndex !== null) {
            let {dataRef: xu, id: Ru} = Dl.options[Dl.activeOptionIndex];
            mu(xu.current.value),
            Ml({
                type: 2,
                focus: c$2.Specific,
                id: Ru
            })
        }
    }
    )
      , cu = o$5( () => Ml({
        type: 0
    }))
      , pu = o$5( () => Ml({
        type: 1
    }))
      , zl = p$3()
      , Yl = o$5( (xu, Ru, Iu) => {
        zl.dispose(),
        zl.microTask( () => xu === c$2.Specific ? Ml({
            type: 2,
            focus: c$2.Specific,
            id: Ru,
            trigger: Iu
        }) : Ml({
            type: 2,
            focus: xu,
            trigger: Iu
        }))
    }
    )
      , lu = o$5( (xu, Ru) => (Ml({
        type: 5,
        id: xu,
        dataRef: Ru
    }),
    () => Ml({
        type: 6,
        id: xu
    })))
      , mu = o$5(xu => u$7(Dl.mode, {
        0() {
            return Rl == null ? void 0 : Rl(xu)
        },
        1() {
            let Ru = Dl.value.slice()
              , Iu = Ru.findIndex(Ku => Fl(Ku, xu));
            return Iu === -1 ? Ru.push(xu) : Ru.splice(Iu, 1),
            Rl == null ? void 0 : Rl(Ru)
        }
    }))
      , Cu = o$5(xu => Ml({
        type: 3,
        value: xu
    }))
      , ju = o$5( () => Ml({
        type: 4
    }))
      , Lu = o$5(xu => {
        Ml({
            type: 7,
            element: xu
        })
    }
    )
      , Au = o$5(xu => {
        Ml({
            type: 8,
            element: xu
        })
    }
    )
      , Du = reactExports.useMemo( () => ({
        onChange: mu,
        registerOption: lu,
        goToOption: Yl,
        closeListbox: pu,
        openListbox: cu,
        selectActiveOption: Ql,
        selectOption: Wl,
        search: Cu,
        clearSearch: ju,
        setButtonElement: Lu,
        setOptionsElement: Au
    }), [])
      , [Qu,fu] = K({
        inherit: !0
    })
      , yu = {
        ref: $l
    }
      , vu = reactExports.useCallback( () => {
        if (Sl !== void 0)
            return Rl == null ? void 0 : Rl(Sl)
    }
    , [Rl, Sl])
      , _u = L$1();
    return React__default.createElement(fu, {
        value: Qu,
        props: {
            htmlFor: (as = Dl.buttonElement) == null ? void 0 : as.id
        },
        slot: {
            open: Dl.listboxState === 0,
            disabled: yl
        }
    }, React__default.createElement(Me$1, null, React__default.createElement(me.Provider, {
        value: Du
    }, React__default.createElement(Z.Provider, {
        value: Dl
    }, React__default.createElement(c$3, {
        value: u$7(Dl.listboxState, {
            0: i$1.Open,
            1: i$1.Closed
        })
    }, Ws != null && Tl != null && React__default.createElement(j$3, {
        disabled: yl,
        data: {
            [Ws]: Tl
        },
        form: Vs,
        onReset: vu
    }), _u({
        ourProps: yu,
        theirProps: El,
        slot: Gl,
        defaultTag: At,
        name: "Listbox"
    }))))))
}
let Dt = "button";
function _t(xt, Cn) {
    var as;
    let cs = X$1("Listbox.Button")
      , Cs = Y("Listbox.Button")
      , Ls = reactExports.useId()
      , Vs = u$6()
      , {id: Ws=Vs || `headlessui-listbox-button-${Ls}`, disabled: Xs=cs.disabled || !1, autoFocus: ga=!1, ...ba} = xt
      , yl = y$3(Cn, ye$1(), Cs.setButtonElement)
      , xl = Fe$1()
      , wl = o$5(Dl => {
        switch (Dl.key) {
        case o$3.Enter:
            p$2(Dl.currentTarget);
            break;
        case o$3.Space:
        case o$3.ArrowDown:
            Dl.preventDefault(),
            reactDomExports.flushSync( () => Cs.openListbox()),
            cs.value || Cs.goToOption(c$2.First);
            break;
        case o$3.ArrowUp:
            Dl.preventDefault(),
            reactDomExports.flushSync( () => Cs.openListbox()),
            cs.value || Cs.goToOption(c$2.Last);
            break
        }
    }
    )
      , _l = o$5(Dl => {
        switch (Dl.key) {
        case o$3.Space:
            Dl.preventDefault();
            break
        }
    }
    )
      , El = o$5(Dl => {
        var Zl;
        if (r$2(Dl.currentTarget))
            return Dl.preventDefault();
        cs.listboxState === 0 ? (reactDomExports.flushSync( () => Cs.closeListbox()),
        (Zl = cs.buttonElement) == null || Zl.focus({
            preventScroll: !0
        })) : (Dl.preventDefault(),
        Cs.openListbox())
    }
    )
      , Cl = o$5(Dl => Dl.preventDefault())
      , $l = I$1([Ws])
      , Sl = U$1()
      , {isFocusVisible: Tl, focusProps: Rl} = $f7dceffc5ad7768b$export$4e328f61c538687f({
        autoFocus: ga
    })
      , {isHovered: Il, hoverProps: Ml} = $6179b936705e76d3$export$ae780daf29e6d456({
        isDisabled: Xs
    })
      , {pressed: Nl, pressProps: Ll} = w$2({
        disabled: Xs
    })
      , Fl = reactExports.useMemo( () => ({
        open: cs.listboxState === 0,
        active: Nl || cs.listboxState === 0,
        disabled: Xs,
        invalid: cs.invalid,
        value: cs.value,
        hover: Il,
        focus: Tl,
        autofocus: ga
    }), [cs.listboxState, cs.value, Xs, Il, Tl, Nl, cs.invalid, ga])
      , Ul = _$4(xl(), {
        ref: yl,
        id: Ws,
        type: e$1(xt, cs.buttonElement),
        "aria-haspopup": "listbox",
        "aria-controls": (as = cs.optionsElement) == null ? void 0 : as.id,
        "aria-expanded": cs.listboxState === 0,
        "aria-labelledby": $l,
        "aria-describedby": Sl,
        disabled: Xs || void 0,
        autoFocus: ga,
        onKeyDown: wl,
        onKeyUp: _l,
        onKeyPress: Cl,
        onClick: El
    }, Rl, Ml, Ll);
    return L$1()({
        ourProps: Ul,
        theirProps: ba,
        slot: Fl,
        defaultTag: Dt,
        name: "Listbox.Button"
    })
}
let Ee = reactExports.createContext(!1)
  , It = "div"
  , Ct = O$1.RenderStrategy | O$1.Static;
function Ft(xt, Cn) {
    var as, cs;
    let Cs = reactExports.useId()
      , {id: Ls=`headlessui-listbox-options-${Cs}`, anchor: Vs, portal: Ws=!1, modal: Xs=!0, transition: ga=!1, ...ba} = xt
      , yl = xe(Vs)
      , [xl,wl] = reactExports.useState(null);
    yl && (Ws = !0);
    let _l = X$1("Listbox.Options")
      , El = Y("Listbox.Options")
      , Cl = n$3(_l.buttonElement)
      , $l = n$3(_l.optionsElement)
      , Sl = u$1()
      , [Tl,Rl] = x(ga, xl, Sl !== null ? (Sl & i$1.Open) === i$1.Open : _l.listboxState === 0);
    m$1(Tl, _l.buttonElement, El.closeListbox);
    let Il = _l.__demoMode ? !1 : Xs && _l.listboxState === 0;
    f$1(Il, $l);
    let Ml = _l.__demoMode ? !1 : Xs && _l.listboxState === 0;
    y$2(Ml, {
        allowed: reactExports.useCallback( () => [_l.buttonElement, _l.optionsElement], [_l.buttonElement, _l.optionsElement])
    });
    let Nl = _l.listboxState !== 0
      , Ll = s$3(Nl, _l.buttonElement) ? !1 : Tl
      , Fl = Tl && _l.listboxState === 1
      , Ul = l$1(Fl, _l.value)
      , Dl = o$5(Lu => _l.compare(Ul, Lu))
      , Zl = reactExports.useMemo( () => {
        var Lu;
        if (yl == null || !((Lu = yl == null ? void 0 : yl.to) != null && Lu.includes("selection")))
            return null;
        let Au = _l.options.findIndex(Du => Dl(Du.dataRef.current.value));
        return Au === -1 && (Au = 0),
        Au
    }
    , [yl, _l.options])
      , Gl = ( () => {
        if (yl == null)
            return;
        if (Zl === null)
            return {
                ...yl,
                inner: void 0
            };
        let Lu = Array.from(_l.listRef.current.values());
        return {
            ...yl,
            inner: {
                listRef: {
                    current: Lu
                },
                index: Zl
            }
        }
    }
    )()
      , [Wl,Ql] = Re$1(Gl)
      , cu = be$1()
      , pu = y$3(Cn, yl ? Wl : null, El.setOptionsElement, wl)
      , zl = p$3();
    reactExports.useEffect( () => {
        var Lu;
        let Au = _l.optionsElement;
        Au && _l.listboxState === 0 && Au !== ((Lu = o$7(Au)) == null ? void 0 : Lu.activeElement) && (Au == null || Au.focus({
            preventScroll: !0
        }))
    }
    , [_l.listboxState, _l.optionsElement]);
    let Yl = o$5(Lu => {
        var Au, Du;
        switch (zl.dispose(),
        Lu.key) {
        case o$3.Space:
            if (_l.searchQuery !== "")
                return Lu.preventDefault(),
                Lu.stopPropagation(),
                El.search(Lu.key);
        case o$3.Enter:
            if (Lu.preventDefault(),
            Lu.stopPropagation(),
            _l.activeOptionIndex !== null) {
                let {dataRef: Qu} = _l.options[_l.activeOptionIndex];
                El.onChange(Qu.current.value)
            }
            _l.mode === 0 && (reactDomExports.flushSync( () => El.closeListbox()),
            (Au = _l.buttonElement) == null || Au.focus({
                preventScroll: !0
            }));
            break;
        case u$7(_l.orientation, {
            vertical: o$3.ArrowDown,
            horizontal: o$3.ArrowRight
        }):
            return Lu.preventDefault(),
            Lu.stopPropagation(),
            El.goToOption(c$2.Next);
        case u$7(_l.orientation, {
            vertical: o$3.ArrowUp,
            horizontal: o$3.ArrowLeft
        }):
            return Lu.preventDefault(),
            Lu.stopPropagation(),
            El.goToOption(c$2.Previous);
        case o$3.Home:
        case o$3.PageUp:
            return Lu.preventDefault(),
            Lu.stopPropagation(),
            El.goToOption(c$2.First);
        case o$3.End:
        case o$3.PageDown:
            return Lu.preventDefault(),
            Lu.stopPropagation(),
            El.goToOption(c$2.Last);
        case o$3.Escape:
            Lu.preventDefault(),
            Lu.stopPropagation(),
            reactDomExports.flushSync( () => El.closeListbox()),
            (Du = _l.buttonElement) == null || Du.focus({
                preventScroll: !0
            });
            return;
        case o$3.Tab:
            Lu.preventDefault(),
            Lu.stopPropagation(),
            reactDomExports.flushSync( () => El.closeListbox()),
            j$2(_l.buttonElement, Lu.shiftKey ? F$1.Previous : F$1.Next);
            break;
        default:
            Lu.key.length === 1 && (El.search(Lu.key),
            zl.setTimeout( () => El.clearSearch(), 350));
            break
        }
    }
    )
      , lu = (as = _l.buttonElement) == null ? void 0 : as.id
      , mu = reactExports.useMemo( () => ({
        open: _l.listboxState === 0
    }), [_l.listboxState])
      , Cu = _$4(yl ? cu() : {}, {
        id: Ls,
        ref: pu,
        "aria-activedescendant": _l.activeOptionIndex === null || (cs = _l.options[_l.activeOptionIndex]) == null ? void 0 : cs.id,
        "aria-multiselectable": _l.mode === 1 ? !0 : void 0,
        "aria-labelledby": lu,
        "aria-orientation": _l.orientation,
        onKeyDown: Yl,
        role: "listbox",
        tabIndex: _l.listboxState === 0 ? 0 : void 0,
        style: {
            ...ba.style,
            ...Ql,
            "--button-width": d$2(_l.buttonElement, !0).width
        },
        ...R(Rl)
    })
      , ju = L$1();
    return React__default.createElement(oe, {
        enabled: Ws ? xt.static || Tl : !1,
        ownerDocument: Cl
    }, React__default.createElement(Z.Provider, {
        value: _l.mode === 1 ? _l : {
            ..._l,
            isSelected: Dl
        }
    }, ju({
        ourProps: Cu,
        theirProps: ba,
        slot: mu,
        defaultTag: It,
        features: Ct,
        visible: Ll,
        name: "Listbox.Options"
    })))
}
let Mt = "div";
function Bt(xt, Cn) {
    let as = reactExports.useId()
      , {id: cs=`headlessui-listbox-option-${as}`, disabled: Cs=!1, value: Ls, ...Vs} = xt
      , Ws = reactExports.useContext(Ee) === !0
      , Xs = X$1("Listbox.Option")
      , ga = Y("Listbox.Option")
      , ba = Xs.activeOptionIndex !== null ? Xs.options[Xs.activeOptionIndex].id === cs : !1
      , yl = Xs.isSelected(Ls)
      , xl = reactExports.useRef(null)
      , wl = s$2(xl)
      , _l = s$8({
        disabled: Cs,
        value: Ls,
        domRef: xl,
        get textValue() {
            return wl()
        }
    })
      , El = y$3(Cn, xl, Fl => {
        Fl ? Xs.listRef.current.set(cs, Fl) : Xs.listRef.current.delete(cs)
    }
    );
    n$5( () => {
        if (!Xs.__demoMode && Xs.listboxState === 0 && ba && Xs.activationTrigger !== 0)
            return o$6().requestAnimationFrame( () => {
                var Fl, Ul;
                (Ul = (Fl = xl.current) == null ? void 0 : Fl.scrollIntoView) == null || Ul.call(Fl, {
                    block: "nearest"
                })
            }
            )
    }
    , [xl, ba, Xs.__demoMode, Xs.listboxState, Xs.activationTrigger, Xs.activeOptionIndex]),
    n$5( () => {
        if (!Ws)
            return ga.registerOption(cs, _l)
    }
    , [_l, cs, Ws]);
    let Cl = o$5(Fl => {
        var Ul;
        if (Cs)
            return Fl.preventDefault();
        ga.onChange(Ls),
        Xs.mode === 0 && (reactDomExports.flushSync( () => ga.closeListbox()),
        (Ul = Xs.buttonElement) == null || Ul.focus({
            preventScroll: !0
        }))
    }
    )
      , $l = o$5( () => {
        if (Cs)
            return ga.goToOption(c$2.Nothing);
        ga.goToOption(c$2.Specific, cs)
    }
    )
      , Sl = u$2()
      , Tl = o$5(Fl => {
        Sl.update(Fl),
        !Cs && (ba || ga.goToOption(c$2.Specific, cs, 0))
    }
    )
      , Rl = o$5(Fl => {
        Sl.wasMoved(Fl) && (Cs || ba || ga.goToOption(c$2.Specific, cs, 0))
    }
    )
      , Il = o$5(Fl => {
        Sl.wasMoved(Fl) && (Cs || ba && ga.goToOption(c$2.Nothing))
    }
    )
      , Ml = reactExports.useMemo( () => ({
        active: ba,
        focus: ba,
        selected: yl,
        disabled: Cs,
        selectedOption: yl && Ws
    }), [ba, yl, Cs, Ws])
      , Nl = Ws ? {} : {
        id: cs,
        ref: El,
        role: "option",
        tabIndex: Cs === !0 ? void 0 : -1,
        "aria-disabled": Cs === !0 ? !0 : void 0,
        "aria-selected": yl,
        disabled: void 0,
        onClick: Cl,
        onFocus: $l,
        onPointerEnter: Tl,
        onMouseEnter: Tl,
        onPointerMove: Rl,
        onMouseMove: Rl,
        onPointerLeave: Il,
        onMouseLeave: Il
    }
      , Ll = L$1();
    return !yl && Ws ? null : Ll({
        ourProps: Nl,
        theirProps: Vs,
        slot: Ml,
        defaultTag: Mt,
        name: "Listbox.Option"
    })
}
let wt = reactExports.Fragment;
function kt(xt, Cn) {
    let {options: as, placeholder: cs, ...Cs} = xt
      , Ls = {
        ref: y$3(Cn)
    }
      , Vs = X$1("ListboxSelectedOption")
      , Ws = reactExports.useMemo( () => ({}), [])
      , Xs = Vs.value === void 0 || Vs.value === null || Vs.mode === 1 && Array.isArray(Vs.value) && Vs.value.length === 0
      , ga = L$1();
    return React__default.createElement(Ee.Provider, {
        value: !0
    }, ga({
        ourProps: Ls,
        theirProps: {
            ...Cs,
            children: React__default.createElement(React__default.Fragment, null, cs && Xs ? cs : as)
        },
        slot: Ws,
        defaultTag: wt,
        name: "ListboxSelectedOption"
    }))
}
let Ut = K$1(ht)
  , Nt = K$1(_t)
  , Ht = Q
  , Gt = K$1(Ft)
  , Vt = K$1(Bt)
  , Kt = K$1(kt)
  , Mo = Object.assign(Ut, {
    Button: Nt,
    Label: Ht,
    Options: Gt,
    Option: Vt,
    SelectedOption: Kt
});
var Ie = (xt => (xt[xt.RegisterOption = 0] = "RegisterOption",
xt[xt.UnregisterOption = 1] = "UnregisterOption",
xt))(Ie || {});
let Fe = {
    0(xt, Cn) {
        let as = [...xt.options, {
            id: Cn.id,
            element: Cn.element,
            propsRef: Cn.propsRef
        }];
        return {
            ...xt,
            options: _$2(as, cs => cs.element.current)
        }
    },
    1(xt, Cn) {
        let as = xt.options.slice()
          , cs = xt.options.findIndex(Cs => Cs.id === Cn.id);
        return cs === -1 ? xt : (as.splice(cs, 1),
        {
            ...xt,
            options: as
        })
    }
}
  , J = reactExports.createContext(null);
J.displayName = "RadioGroupDataContext";
function X(xt) {
    let Cn = reactExports.useContext(J);
    if (Cn === null) {
        let as = new Error(`<${xt} /> is missing a parent <RadioGroup /> component.`);
        throw Error.captureStackTrace && Error.captureStackTrace(as, X),
        as
    }
    return Cn
}
let z = reactExports.createContext(null);
z.displayName = "RadioGroupActionsContext";
function q(xt) {
    let Cn = reactExports.useContext(z);
    if (Cn === null) {
        let as = new Error(`<${xt} /> is missing a parent <RadioGroup /> component.`);
        throw Error.captureStackTrace && Error.captureStackTrace(as, q),
        as
    }
    return Cn
}
function Ue(xt, Cn) {
    return u$7(Cn.type, Fe, xt, Cn)
}
let Me = "div";
function Se(xt, Cn) {
    let as = reactExports.useId()
      , cs = a$9()
      , {id: Cs=`headlessui-radiogroup-${as}`, value: Ls, form: Vs, name: Ws, onChange: Xs, by: ga, disabled: ba=cs || !1, defaultValue: yl, tabIndex: xl=0, ...wl} = xt
      , _l = u$4(ga)
      , [El,Cl] = reactExports.useReducer(Ue, {
        options: []
    })
      , $l = El.options
      , [Sl,Tl] = K()
      , [Rl,Il] = w$1()
      , Ml = reactExports.useRef(null)
      , Nl = y$3(Ml, Cn)
      , Ll = l$4(yl)
      , [Fl,Ul] = T$3(Ls, Xs, Ll)
      , Dl = reactExports.useMemo( () => $l.find(Cu => !Cu.propsRef.current.disabled), [$l])
      , Zl = reactExports.useMemo( () => $l.some(Cu => _l(Cu.propsRef.current.value, Fl)), [$l, Fl])
      , Gl = o$5(Cu => {
        var ju;
        if (ba || _l(Cu, Fl))
            return !1;
        let Lu = (ju = $l.find(Au => _l(Au.propsRef.current.value, Cu))) == null ? void 0 : ju.propsRef.current;
        return Lu != null && Lu.disabled ? !1 : (Ul == null || Ul(Cu),
        !0)
    }
    )
      , Wl = o$5(Cu => {
        let ju = Ml.current;
        if (!ju)
            return;
        let Lu = o$7(ju)
          , Au = $l.filter(Du => Du.propsRef.current.disabled === !1).map(Du => Du.element.current);
        switch (Cu.key) {
        case o$3.Enter:
            p$2(Cu.currentTarget);
            break;
        case o$3.ArrowLeft:
        case o$3.ArrowUp:
            if (Cu.preventDefault(),
            Cu.stopPropagation(),
            P(Au, F$1.Previous | F$1.WrapAround) === T$1.Success) {
                let Du = $l.find(Qu => Qu.element.current === (Lu == null ? void 0 : Lu.activeElement));
                Du && Gl(Du.propsRef.current.value)
            }
            break;
        case o$3.ArrowRight:
        case o$3.ArrowDown:
            if (Cu.preventDefault(),
            Cu.stopPropagation(),
            P(Au, F$1.Next | F$1.WrapAround) === T$1.Success) {
                let Du = $l.find(Qu => Qu.element.current === (Lu == null ? void 0 : Lu.activeElement));
                Du && Gl(Du.propsRef.current.value)
            }
            break;
        case o$3.Space:
            {
                Cu.preventDefault(),
                Cu.stopPropagation();
                let Du = $l.find(Qu => Qu.element.current === (Lu == null ? void 0 : Lu.activeElement));
                Du && Gl(Du.propsRef.current.value)
            }
            break
        }
    }
    )
      , Ql = o$5(Cu => (Cl({
        type: 0,
        ...Cu
    }),
    () => Cl({
        type: 1,
        id: Cu.id
    })))
      , cu = reactExports.useMemo( () => ({
        value: Fl,
        firstOption: Dl,
        containsCheckedOption: Zl,
        disabled: ba,
        compare: _l,
        tabIndex: xl,
        ...El
    }), [Fl, Dl, Zl, ba, _l, xl, El])
      , pu = reactExports.useMemo( () => ({
        registerOption: Ql,
        change: Gl
    }), [Ql, Gl])
      , zl = {
        ref: Nl,
        id: Cs,
        role: "radiogroup",
        "aria-labelledby": Sl,
        "aria-describedby": Rl,
        onKeyDown: Wl
    }
      , Yl = reactExports.useMemo( () => ({
        value: Fl
    }), [Fl])
      , lu = reactExports.useCallback( () => {
        if (Ll !== void 0)
            return Gl(Ll)
    }
    , [Gl, Ll])
      , mu = L$1();
    return React__default.createElement(Il, {
        name: "RadioGroup.Description"
    }, React__default.createElement(Tl, {
        name: "RadioGroup.Label"
    }, React__default.createElement(z.Provider, {
        value: pu
    }, React__default.createElement(J.Provider, {
        value: cu
    }, Ws != null && React__default.createElement(j$3, {
        disabled: ba,
        data: {
            [Ws]: Fl || "on"
        },
        overrides: {
            type: "radio",
            checked: Fl != null
        },
        form: Vs,
        onReset: lu
    }), mu({
        ourProps: zl,
        theirProps: wl,
        slot: Yl,
        defaultTag: Me,
        name: "RadioGroup"
    })))))
}
let He = "div";
function we(xt, Cn) {
    var as;
    let cs = X("RadioGroup.Option")
      , Cs = q("RadioGroup.Option")
      , Ls = reactExports.useId()
      , {id: Vs=`headlessui-radiogroup-option-${Ls}`, value: Ws, disabled: Xs=cs.disabled || !1, autoFocus: ga=!1, ...ba} = xt
      , yl = reactExports.useRef(null)
      , xl = y$3(yl, Cn)
      , [wl,_l] = K()
      , [El,Cl] = w$1()
      , $l = s$8({
        value: Ws,
        disabled: Xs
    });
    n$5( () => Cs.registerOption({
        id: Vs,
        element: yl,
        propsRef: $l
    }), [Vs, Cs, yl, $l]);
    let Sl = o$5(Zl => {
        var Gl;
        if (r$2(Zl.currentTarget))
            return Zl.preventDefault();
        Cs.change(Ws) && ((Gl = yl.current) == null || Gl.focus())
    }
    )
      , Tl = ((as = cs.firstOption) == null ? void 0 : as.id) === Vs
      , {isFocusVisible: Rl, focusProps: Il} = $f7dceffc5ad7768b$export$4e328f61c538687f({
        autoFocus: ga
    })
      , {isHovered: Ml, hoverProps: Nl} = $6179b936705e76d3$export$ae780daf29e6d456({
        isDisabled: Xs
    })
      , Ll = cs.compare(cs.value, Ws)
      , Fl = _$4({
        ref: xl,
        id: Vs,
        role: "radio",
        "aria-checked": Ll ? "true" : "false",
        "aria-labelledby": wl,
        "aria-describedby": El,
        "aria-disabled": Xs ? !0 : void 0,
        tabIndex: Xs ? -1 : Ll || !cs.containsCheckedOption && Tl ? cs.tabIndex : -1,
        onClick: Xs ? void 0 : Sl,
        autoFocus: ga
    }, Il, Nl)
      , Ul = reactExports.useMemo( () => ({
        checked: Ll,
        disabled: Xs,
        active: Rl,
        hover: Ml,
        focus: Rl,
        autofocus: ga
    }), [Ll, Xs, Ml, Rl, ga])
      , Dl = L$1();
    return React__default.createElement(Cl, {
        name: "RadioGroup.Description"
    }, React__default.createElement(_l, {
        name: "RadioGroup.Label"
    }, Dl({
        ourProps: Fl,
        theirProps: ba,
        slot: Ul,
        defaultTag: He,
        name: "RadioGroup.Option"
    })))
}
let Ne = "span";
function We(xt, Cn) {
    var as;
    let cs = X("Radio")
      , Cs = q("Radio")
      , Ls = reactExports.useId()
      , Vs = u$6()
      , Ws = a$9()
      , {id: Xs=Vs || `headlessui-radio-${Ls}`, value: ga, disabled: ba=cs.disabled || Ws || !1, autoFocus: yl=!1, ...xl} = xt
      , wl = reactExports.useRef(null)
      , _l = y$3(wl, Cn)
      , El = I$1()
      , Cl = U$1()
      , $l = s$8({
        value: ga,
        disabled: ba
    });
    n$5( () => Cs.registerOption({
        id: Xs,
        element: wl,
        propsRef: $l
    }), [Xs, Cs, wl, $l]);
    let Sl = o$5(Dl => {
        var Zl;
        if (r$2(Dl.currentTarget))
            return Dl.preventDefault();
        Cs.change(ga) && ((Zl = wl.current) == null || Zl.focus())
    }
    )
      , {isFocusVisible: Tl, focusProps: Rl} = $f7dceffc5ad7768b$export$4e328f61c538687f({
        autoFocus: yl
    })
      , {isHovered: Il, hoverProps: Ml} = $6179b936705e76d3$export$ae780daf29e6d456({
        isDisabled: ba
    })
      , Nl = ((as = cs.firstOption) == null ? void 0 : as.id) === Xs
      , Ll = cs.compare(cs.value, ga)
      , Fl = _$4({
        ref: _l,
        id: Xs,
        role: "radio",
        "aria-checked": Ll ? "true" : "false",
        "aria-labelledby": El,
        "aria-describedby": Cl,
        "aria-disabled": ba ? !0 : void 0,
        tabIndex: ba ? -1 : Ll || !cs.containsCheckedOption && Nl ? cs.tabIndex : -1,
        autoFocus: yl,
        onClick: ba ? void 0 : Sl
    }, Rl, Ml)
      , Ul = reactExports.useMemo( () => ({
        checked: Ll,
        disabled: ba,
        hover: Il,
        focus: Tl,
        autofocus: yl
    }), [Ll, ba, Il, Tl, yl]);
    return L$1()({
        ourProps: Fl,
        theirProps: xl,
        slot: Ul,
        defaultTag: Ne,
        name: "Radio"
    })
}
let Be = K$1(Se)
  , Ve = K$1(we)
  , Ke = K$1(We)
  , $e = Q
  , je = H$5
  , mt = Object.assign(Be, {
    Option: Ve,
    Radio: Ke,
    Label: $e,
    Description: je
});
const disclosureButton = "_disclosureButton_1hy3p_1"
  , disclosureButtonIcon = "_disclosureButtonIcon_1hy3p_13"
  , disclosurePanel = "_disclosurePanel_1hy3p_21"
  , styles$z = {
    disclosureButton,
    disclosureButtonIcon,
    disclosurePanel
}
  , Disclosure = ({title: xt, children: Cn, ...as}) => jsxRuntimeExports.jsx("div", {
    children: jsxRuntimeExports.jsx(je$1, {
        ...as,
        children: ({open: cs}) => jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [jsxRuntimeExports.jsxs(Ce, {
                className: styles$z.disclosureButton,
                children: [xt, jsxRuntimeExports.jsx("img", {
                    src: "/icons/common/chevron-down.svg",
                    alt: "",
                    className: styles$z.disclosureButtonIcon
                })]
            }), jsxRuntimeExports.jsx(AnimatePresence, {
                initial: !1,
                children: cs && jsxRuntimeExports.jsx(Re, {
                    as: reactExports.Fragment,
                    static: !0,
                    children: jsxRuntimeExports.jsx(motion.div, {
                        layout: !0,
                        initial: {
                            marginTop: 0,
                            opacity: 0,
                            height: 0
                        },
                        animate: {
                            marginTop: 5,
                            opacity: 1,
                            height: "auto"
                        },
                        exit: {
                            marginTop: 0,
                            opacity: 0,
                            height: 0
                        },
                        className: styles$z.disclosurePanel,
                        children: jsxRuntimeExports.jsx(AnimatePresence, {
                            initial: !1,
                            children: Cn
                        })
                    })
                })
            })]
        })
    })
})
  , container$f = "_container_lkm9h_1"
  , divider$3 = "_divider_lkm9h_8"
  , subheader$1 = "_subheader_lkm9h_12"
  , styles$y = {
    container: container$f,
    divider: divider$3,
    subheader: subheader$1
}
  , divider$2 = "_divider_1rfus_1"
  , styles$x = {
    divider: divider$2
}
  , Divider = ({className: xt}) => jsxRuntimeExports.jsx("div", {
    className: classNames$1(styles$x.divider, xt)
});
var isCheckBoxInput = xt => xt.type === "checkbox"
  , isDateObject = xt => xt instanceof Date
  , isNullOrUndefined = xt => xt == null;
const isObjectType = xt => typeof xt == "object";
var isObject = xt => !isNullOrUndefined(xt) && !Array.isArray(xt) && isObjectType(xt) && !isDateObject(xt)
  , getEventValue = xt => isObject(xt) && xt.target ? isCheckBoxInput(xt.target) ? xt.target.checked : xt.target.value : xt
  , getNodeParentName = xt => xt.substring(0, xt.search(/\.\d+(\.|$)/)) || xt
  , isNameInFieldArray = (xt, Cn) => xt.has(getNodeParentName(Cn))
  , isPlainObject = xt => {
    const Cn = xt.constructor && xt.constructor.prototype;
    return isObject(Cn) && Cn.hasOwnProperty("isPrototypeOf")
}
  , isWeb = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function cloneObject(xt) {
    let Cn;
    const as = Array.isArray(xt)
      , cs = typeof FileList < "u" ? xt instanceof FileList : !1;
    if (xt instanceof Date)
        Cn = new Date(xt);
    else if (xt instanceof Set)
        Cn = new Set(xt);
    else if (!(isWeb && (xt instanceof Blob || cs)) && (as || isObject(xt)))
        if (Cn = as ? [] : {},
        !as && !isPlainObject(xt))
            Cn = xt;
        else
            for (const Cs in xt)
                xt.hasOwnProperty(Cs) && (Cn[Cs] = cloneObject(xt[Cs]));
    else
        return xt;
    return Cn
}
var compact = xt => Array.isArray(xt) ? xt.filter(Boolean) : []
  , isUndefined = xt => xt === void 0
  , get = (xt, Cn, as) => {
    if (!Cn || !isObject(xt))
        return as;
    const cs = compact(Cn.split(/[,[\].]+?/)).reduce( (Cs, Ls) => isNullOrUndefined(Cs) ? Cs : Cs[Ls], xt);
    return isUndefined(cs) || cs === xt ? isUndefined(xt[Cn]) ? as : xt[Cn] : cs
}
  , isBoolean = xt => typeof xt == "boolean"
  , isKey = xt => /^\w*$/.test(xt)
  , stringToPath = xt => compact(xt.replace(/["|']|\]/g, "").split(/\.|\[/))
  , set = (xt, Cn, as) => {
    let cs = -1;
    const Cs = isKey(Cn) ? [Cn] : stringToPath(Cn)
      , Ls = Cs.length
      , Vs = Ls - 1;
    for (; ++cs < Ls; ) {
        const Ws = Cs[cs];
        let Xs = as;
        if (cs !== Vs) {
            const ga = xt[Ws];
            Xs = isObject(ga) || Array.isArray(ga) ? ga : isNaN(+Cs[cs + 1]) ? {} : []
        }
        if (Ws === "__proto__" || Ws === "constructor" || Ws === "prototype")
            return;
        xt[Ws] = Xs,
        xt = xt[Ws]
    }
}
;
const EVENTS = {
    BLUR: "blur",
    FOCUS_OUT: "focusout",
    CHANGE: "change"
}
  , VALIDATION_MODE = {
    onBlur: "onBlur",
    onChange: "onChange",
    onSubmit: "onSubmit",
    onTouched: "onTouched",
    all: "all"
}
  , INPUT_VALIDATION_RULES = {
    max: "max",
    min: "min",
    maxLength: "maxLength",
    minLength: "minLength",
    pattern: "pattern",
    required: "required",
    validate: "validate"
}
  , HookFormContext = React__default.createContext(null)
  , useFormContext = () => React__default.useContext(HookFormContext)
  , FormProvider = xt => {
    const {children: Cn, ...as} = xt;
    return React__default.createElement(HookFormContext.Provider, {
        value: as
    }, Cn)
}
;
var getProxyFormState = (xt, Cn, as, cs=!0) => {
    const Cs = {
        defaultValues: Cn._defaultValues
    };
    for (const Ls in xt)
        Object.defineProperty(Cs, Ls, {
            get: () => {
                const Vs = Ls;
                return Cn._proxyFormState[Vs] !== VALIDATION_MODE.all && (Cn._proxyFormState[Vs] = !cs || VALIDATION_MODE.all),
                as && (as[Vs] = !0),
                xt[Vs]
            }
        });
    return Cs
}
  , isPrimitive = xt => isNullOrUndefined(xt) || !isObjectType(xt);
function deepEqual(xt, Cn) {
    if (isPrimitive(xt) || isPrimitive(Cn))
        return xt === Cn;
    if (isDateObject(xt) && isDateObject(Cn))
        return xt.getTime() === Cn.getTime();
    const as = Object.keys(xt)
      , cs = Object.keys(Cn);
    if (as.length !== cs.length)
        return !1;
    for (const Cs of as) {
        const Ls = xt[Cs];
        if (!cs.includes(Cs))
            return !1;
        if (Cs !== "ref") {
            const Vs = Cn[Cs];
            if (isDateObject(Ls) && isDateObject(Vs) || isObject(Ls) && isObject(Vs) || Array.isArray(Ls) && Array.isArray(Vs) ? !deepEqual(Ls, Vs) : Ls !== Vs)
                return !1
        }
    }
    return !0
}
const useDeepEqualEffect = (xt, Cn) => {
    const as = reactExports.useRef(Cn);
    deepEqual(Cn, as.current) || (as.current = Cn),
    reactExports.useEffect(xt, as.current)
}
;
function useFormState(xt) {
    const Cn = useFormContext()
      , {control: as=Cn.control, disabled: cs, name: Cs, exact: Ls} = xt || {}
      , [Vs,Ws] = React__default.useState(as._formState)
      , Xs = React__default.useRef({
        isDirty: !1,
        isLoading: !1,
        dirtyFields: !1,
        touchedFields: !1,
        validatingFields: !1,
        isValidating: !1,
        isValid: !1,
        errors: !1
    });
    return useDeepEqualEffect( () => as._subscribe({
        name: Cs,
        formState: Xs.current,
        exact: Ls,
        callback: ga => {
            !cs && Ws({
                ...as._formState,
                ...ga
            })
        }
    }), [Cs, cs, Ls]),
    React__default.useEffect( () => {
        Xs.current.isValid && as._setValid(!0)
    }
    , [as]),
    React__default.useMemo( () => getProxyFormState(Vs, as, Xs.current, !1), [Vs, as])
}
var isString = xt => typeof xt == "string"
  , generateWatchOutput = (xt, Cn, as, cs, Cs) => isString(xt) ? (cs && Cn.watch.add(xt),
get(as, xt, Cs)) : Array.isArray(xt) ? xt.map(Ls => (cs && Cn.watch.add(Ls),
get(as, Ls))) : (cs && (Cn.watchAll = !0),
as);
function useWatch(xt) {
    const Cn = useFormContext()
      , {control: as=Cn.control, name: cs, defaultValue: Cs, disabled: Ls, exact: Vs} = xt || {}
      , [Ws,Xs] = React__default.useState(as._getWatch(cs, Cs));
    return useDeepEqualEffect( () => as._subscribe({
        name: cs,
        formState: {
            values: !0
        },
        exact: Vs,
        callback: ga => !Ls && Xs(generateWatchOutput(cs, as._names, ga.values || as._formValues, !1, Cs))
    }), [cs, Cs, Ls, Vs]),
    React__default.useEffect( () => as._removeUnmounted()),
    Ws
}
function useController(xt) {
    const Cn = useFormContext()
      , {name: as, disabled: cs, control: Cs=Cn.control, shouldUnregister: Ls} = xt
      , Vs = isNameInFieldArray(Cs._names.array, as)
      , Ws = useWatch({
        control: Cs,
        name: as,
        defaultValue: get(Cs._formValues, as, get(Cs._defaultValues, as, xt.defaultValue)),
        exact: !0
    })
      , Xs = useFormState({
        control: Cs,
        name: as,
        exact: !0
    })
      , ga = React__default.useRef(xt)
      , ba = React__default.useRef(Cs.register(as, {
        ...xt.rules,
        value: Ws,
        ...isBoolean(xt.disabled) ? {
            disabled: xt.disabled
        } : {}
    }))
      , yl = React__default.useMemo( () => Object.defineProperties({}, {
        invalid: {
            enumerable: !0,
            get: () => !!get(Xs.errors, as)
        },
        isDirty: {
            enumerable: !0,
            get: () => !!get(Xs.dirtyFields, as)
        },
        isTouched: {
            enumerable: !0,
            get: () => !!get(Xs.touchedFields, as)
        },
        isValidating: {
            enumerable: !0,
            get: () => !!get(Xs.validatingFields, as)
        },
        error: {
            enumerable: !0,
            get: () => get(Xs.errors, as)
        }
    }), [Xs, as])
      , xl = React__default.useCallback(Cl => ba.current.onChange({
        target: {
            value: getEventValue(Cl),
            name: as
        },
        type: EVENTS.CHANGE
    }), [as])
      , wl = React__default.useCallback( () => ba.current.onBlur({
        target: {
            value: get(Cs._formValues, as),
            name: as
        },
        type: EVENTS.BLUR
    }), [as, Cs._formValues])
      , _l = React__default.useCallback(Cl => {
        const $l = get(Cs._fields, as);
        $l && Cl && ($l._f.ref = {
            focus: () => Cl.focus(),
            select: () => Cl.select(),
            setCustomValidity: Sl => Cl.setCustomValidity(Sl),
            reportValidity: () => Cl.reportValidity()
        })
    }
    , [Cs._fields, as])
      , El = React__default.useMemo( () => ({
        name: as,
        value: Ws,
        ...isBoolean(cs) || Xs.disabled ? {
            disabled: Xs.disabled || cs
        } : {},
        onChange: xl,
        onBlur: wl,
        ref: _l
    }), [as, cs, Xs.disabled, xl, wl, _l, Ws]);
    return React__default.useEffect( () => {
        const Cl = Cs._options.shouldUnregister || Ls;
        Cs.register(as, {
            ...ga.current.rules,
            ...isBoolean(ga.current.disabled) ? {
                disabled: ga.current.disabled
            } : {}
        });
        const $l = (Sl, Tl) => {
            const Rl = get(Cs._fields, Sl);
            Rl && Rl._f && (Rl._f.mount = Tl)
        }
        ;
        if ($l(as, !0),
        Cl) {
            const Sl = cloneObject(get(Cs._options.defaultValues, as));
            set(Cs._defaultValues, as, Sl),
            isUndefined(get(Cs._formValues, as)) && set(Cs._formValues, as, Sl)
        }
        return !Vs && Cs.register(as),
        () => {
            (Vs ? Cl && !Cs._state.action : Cl) ? Cs.unregister(as) : $l(as, !1)
        }
    }
    , [as, Cs, Vs, Ls]),
    React__default.useEffect( () => {
        Cs._setDisabledField({
            disabled: cs,
            name: as
        })
    }
    , [cs, as, Cs]),
    React__default.useMemo( () => ({
        field: El,
        formState: Xs,
        fieldState: yl
    }), [El, Xs, yl])
}
const Controller = xt => xt.render(useController(xt));
var appendErrors = (xt, Cn, as, cs, Cs) => Cn ? {
    ...as[xt],
    types: {
        ...as[xt] && as[xt].types ? as[xt].types : {},
        [cs]: Cs || !0
    }
} : {}
  , convertToArrayPayload = xt => Array.isArray(xt) ? xt : [xt]
  , createSubject = () => {
    let xt = [];
    return {
        get observers() {
            return xt
        },
        next: Cs => {
            for (const Ls of xt)
                Ls.next && Ls.next(Cs)
        }
        ,
        subscribe: Cs => (xt.push(Cs),
        {
            unsubscribe: () => {
                xt = xt.filter(Ls => Ls !== Cs)
            }
        }),
        unsubscribe: () => {
            xt = []
        }
    }
}
  , isEmptyObject = xt => isObject(xt) && !Object.keys(xt).length
  , isFileInput = xt => xt.type === "file"
  , isFunction = xt => typeof xt == "function"
  , isHTMLElement = xt => {
    if (!isWeb)
        return !1;
    const Cn = xt ? xt.ownerDocument : 0;
    return xt instanceof (Cn && Cn.defaultView ? Cn.defaultView.HTMLElement : HTMLElement)
}
  , isMultipleSelect = xt => xt.type === "select-multiple"
  , isRadioInput = xt => xt.type === "radio"
  , isRadioOrCheckbox = xt => isRadioInput(xt) || isCheckBoxInput(xt)
  , live = xt => isHTMLElement(xt) && xt.isConnected;
function baseGet(xt, Cn) {
    const as = Cn.slice(0, -1).length;
    let cs = 0;
    for (; cs < as; )
        xt = isUndefined(xt) ? cs++ : xt[Cn[cs++]];
    return xt
}
function isEmptyArray(xt) {
    for (const Cn in xt)
        if (xt.hasOwnProperty(Cn) && !isUndefined(xt[Cn]))
            return !1;
    return !0
}
function unset(xt, Cn) {
    const as = Array.isArray(Cn) ? Cn : isKey(Cn) ? [Cn] : stringToPath(Cn)
      , cs = as.length === 1 ? xt : baseGet(xt, as)
      , Cs = as.length - 1
      , Ls = as[Cs];
    return cs && delete cs[Ls],
    Cs !== 0 && (isObject(cs) && isEmptyObject(cs) || Array.isArray(cs) && isEmptyArray(cs)) && unset(xt, as.slice(0, -1)),
    xt
}
var objectHasFunction = xt => {
    for (const Cn in xt)
        if (isFunction(xt[Cn]))
            return !0;
    return !1
}
;
function markFieldsDirty(xt, Cn={}) {
    const as = Array.isArray(xt);
    if (isObject(xt) || as)
        for (const cs in xt)
            Array.isArray(xt[cs]) || isObject(xt[cs]) && !objectHasFunction(xt[cs]) ? (Cn[cs] = Array.isArray(xt[cs]) ? [] : {},
            markFieldsDirty(xt[cs], Cn[cs])) : isNullOrUndefined(xt[cs]) || (Cn[cs] = !0);
    return Cn
}
function getDirtyFieldsFromDefaultValues(xt, Cn, as) {
    const cs = Array.isArray(xt);
    if (isObject(xt) || cs)
        for (const Cs in xt)
            Array.isArray(xt[Cs]) || isObject(xt[Cs]) && !objectHasFunction(xt[Cs]) ? isUndefined(Cn) || isPrimitive(as[Cs]) ? as[Cs] = Array.isArray(xt[Cs]) ? markFieldsDirty(xt[Cs], []) : {
                ...markFieldsDirty(xt[Cs])
            } : getDirtyFieldsFromDefaultValues(xt[Cs], isNullOrUndefined(Cn) ? {} : Cn[Cs], as[Cs]) : as[Cs] = !deepEqual(xt[Cs], Cn[Cs]);
    return as
}
var getDirtyFields = (xt, Cn) => getDirtyFieldsFromDefaultValues(xt, Cn, markFieldsDirty(Cn));
const defaultResult = {
    value: !1,
    isValid: !1
}
  , validResult = {
    value: !0,
    isValid: !0
};
var getCheckboxValue = xt => {
    if (Array.isArray(xt)) {
        if (xt.length > 1) {
            const Cn = xt.filter(as => as && as.checked && !as.disabled).map(as => as.value);
            return {
                value: Cn,
                isValid: !!Cn.length
            }
        }
        return xt[0].checked && !xt[0].disabled ? xt[0].attributes && !isUndefined(xt[0].attributes.value) ? isUndefined(xt[0].value) || xt[0].value === "" ? validResult : {
            value: xt[0].value,
            isValid: !0
        } : validResult : defaultResult
    }
    return defaultResult
}
  , getFieldValueAs = (xt, {valueAsNumber: Cn, valueAsDate: as, setValueAs: cs}) => isUndefined(xt) ? xt : Cn ? xt === "" ? NaN : xt && +xt : as && isString(xt) ? new Date(xt) : cs ? cs(xt) : xt;
const defaultReturn = {
    isValid: !1,
    value: null
};
var getRadioValue = xt => Array.isArray(xt) ? xt.reduce( (Cn, as) => as && as.checked && !as.disabled ? {
    isValid: !0,
    value: as.value
} : Cn, defaultReturn) : defaultReturn;
function getFieldValue(xt) {
    const Cn = xt.ref;
    return isFileInput(Cn) ? Cn.files : isRadioInput(Cn) ? getRadioValue(xt.refs).value : isMultipleSelect(Cn) ? [...Cn.selectedOptions].map( ({value: as}) => as) : isCheckBoxInput(Cn) ? getCheckboxValue(xt.refs).value : getFieldValueAs(isUndefined(Cn.value) ? xt.ref.value : Cn.value, xt)
}
var getResolverOptions = (xt, Cn, as, cs) => {
    const Cs = {};
    for (const Ls of xt) {
        const Vs = get(Cn, Ls);
        Vs && set(Cs, Ls, Vs._f)
    }
    return {
        criteriaMode: as,
        names: [...xt],
        fields: Cs,
        shouldUseNativeValidation: cs
    }
}
  , isRegex = xt => xt instanceof RegExp
  , getRuleValue = xt => isUndefined(xt) ? xt : isRegex(xt) ? xt.source : isObject(xt) ? isRegex(xt.value) ? xt.value.source : xt.value : xt
  , getValidationModes = xt => ({
    isOnSubmit: !xt || xt === VALIDATION_MODE.onSubmit,
    isOnBlur: xt === VALIDATION_MODE.onBlur,
    isOnChange: xt === VALIDATION_MODE.onChange,
    isOnAll: xt === VALIDATION_MODE.all,
    isOnTouch: xt === VALIDATION_MODE.onTouched
});
const ASYNC_FUNCTION = "AsyncFunction";
var hasPromiseValidation = xt => !!xt && !!xt.validate && !!(isFunction(xt.validate) && xt.validate.constructor.name === ASYNC_FUNCTION || isObject(xt.validate) && Object.values(xt.validate).find(Cn => Cn.constructor.name === ASYNC_FUNCTION))
  , hasValidation = xt => xt.mount && (xt.required || xt.min || xt.max || xt.maxLength || xt.minLength || xt.pattern || xt.validate)
  , isWatched = (xt, Cn, as) => !as && (Cn.watchAll || Cn.watch.has(xt) || [...Cn.watch].some(cs => xt.startsWith(cs) && /^\.\w+/.test(xt.slice(cs.length))));
const iterateFieldsByAction = (xt, Cn, as, cs) => {
    for (const Cs of as || Object.keys(xt)) {
        const Ls = get(xt, Cs);
        if (Ls) {
            const {_f: Vs, ...Ws} = Ls;
            if (Vs) {
                if (Vs.refs && Vs.refs[0] && Cn(Vs.refs[0], Cs) && !cs)
                    return !0;
                if (Vs.ref && Cn(Vs.ref, Vs.name) && !cs)
                    return !0;
                if (iterateFieldsByAction(Ws, Cn))
                    break
            } else if (isObject(Ws) && iterateFieldsByAction(Ws, Cn))
                break
        }
    }
}
;
function schemaErrorLookup(xt, Cn, as) {
    const cs = get(xt, as);
    if (cs || isKey(as))
        return {
            error: cs,
            name: as
        };
    const Cs = as.split(".");
    for (; Cs.length; ) {
        const Ls = Cs.join(".")
          , Vs = get(Cn, Ls)
          , Ws = get(xt, Ls);
        if (Vs && !Array.isArray(Vs) && as !== Ls)
            return {
                name: as
            };
        if (Ws && Ws.type)
            return {
                name: Ls,
                error: Ws
            };
        Cs.pop()
    }
    return {
        name: as
    }
}
var shouldRenderFormState = (xt, Cn, as, cs) => {
    as(xt);
    const {name: Cs, ...Ls} = xt;
    return isEmptyObject(Ls) || Object.keys(Ls).length >= Object.keys(Cn).length || Object.keys(Ls).find(Vs => Cn[Vs] === (!cs || VALIDATION_MODE.all))
}
  , shouldSubscribeByName = (xt, Cn, as) => !xt || !Cn || xt === Cn || convertToArrayPayload(xt).some(cs => cs && (as ? cs === Cn : cs.startsWith(Cn) || Cn.startsWith(cs)))
  , skipValidation = (xt, Cn, as, cs, Cs) => Cs.isOnAll ? !1 : !as && Cs.isOnTouch ? !(Cn || xt) : (as ? cs.isOnBlur : Cs.isOnBlur) ? !xt : (as ? cs.isOnChange : Cs.isOnChange) ? xt : !0
  , unsetEmptyArray = (xt, Cn) => !compact(get(xt, Cn)).length && unset(xt, Cn)
  , updateFieldArrayRootError = (xt, Cn, as) => {
    const cs = convertToArrayPayload(get(xt, as));
    return set(cs, "root", Cn[as]),
    set(xt, as, cs),
    xt
}
  , isMessage = xt => isString(xt);
function getValidateError(xt, Cn, as="validate") {
    if (isMessage(xt) || Array.isArray(xt) && xt.every(isMessage) || isBoolean(xt) && !xt)
        return {
            type: as,
            message: isMessage(xt) ? xt : "",
            ref: Cn
        }
}
var getValueAndMessage = xt => isObject(xt) && !isRegex(xt) ? xt : {
    value: xt,
    message: ""
}
  , validateField = async (xt, Cn, as, cs, Cs, Ls) => {
    const {ref: Vs, refs: Ws, required: Xs, maxLength: ga, minLength: ba, min: yl, max: xl, pattern: wl, validate: _l, name: El, valueAsNumber: Cl, mount: $l} = xt._f
      , Sl = get(as, El);
    if (!$l || Cn.has(El))
        return {};
    const Tl = Ws ? Ws[0] : Vs
      , Rl = Zl => {
        Cs && Tl.reportValidity && (Tl.setCustomValidity(isBoolean(Zl) ? "" : Zl || ""),
        Tl.reportValidity())
    }
      , Il = {}
      , Ml = isRadioInput(Vs)
      , Nl = isCheckBoxInput(Vs)
      , Ll = Ml || Nl
      , Fl = (Cl || isFileInput(Vs)) && isUndefined(Vs.value) && isUndefined(Sl) || isHTMLElement(Vs) && Vs.value === "" || Sl === "" || Array.isArray(Sl) && !Sl.length
      , Ul = appendErrors.bind(null, El, cs, Il)
      , Dl = (Zl, Gl, Wl, Ql=INPUT_VALIDATION_RULES.maxLength, cu=INPUT_VALIDATION_RULES.minLength) => {
        const pu = Zl ? Gl : Wl;
        Il[El] = {
            type: Zl ? Ql : cu,
            message: pu,
            ref: Vs,
            ...Ul(Zl ? Ql : cu, pu)
        }
    }
    ;
    if (Ls ? !Array.isArray(Sl) || !Sl.length : Xs && (!Ll && (Fl || isNullOrUndefined(Sl)) || isBoolean(Sl) && !Sl || Nl && !getCheckboxValue(Ws).isValid || Ml && !getRadioValue(Ws).isValid)) {
        const {value: Zl, message: Gl} = isMessage(Xs) ? {
            value: !!Xs,
            message: Xs
        } : getValueAndMessage(Xs);
        if (Zl && (Il[El] = {
            type: INPUT_VALIDATION_RULES.required,
            message: Gl,
            ref: Tl,
            ...Ul(INPUT_VALIDATION_RULES.required, Gl)
        },
        !cs))
            return Rl(Gl),
            Il
    }
    if (!Fl && (!isNullOrUndefined(yl) || !isNullOrUndefined(xl))) {
        let Zl, Gl;
        const Wl = getValueAndMessage(xl)
          , Ql = getValueAndMessage(yl);
        if (!isNullOrUndefined(Sl) && !isNaN(Sl)) {
            const cu = Vs.valueAsNumber || Sl && +Sl;
            isNullOrUndefined(Wl.value) || (Zl = cu > Wl.value),
            isNullOrUndefined(Ql.value) || (Gl = cu < Ql.value)
        } else {
            const cu = Vs.valueAsDate || new Date(Sl)
              , pu = lu => new Date(new Date().toDateString() + " " + lu)
              , zl = Vs.type == "time"
              , Yl = Vs.type == "week";
            isString(Wl.value) && Sl && (Zl = zl ? pu(Sl) > pu(Wl.value) : Yl ? Sl > Wl.value : cu > new Date(Wl.value)),
            isString(Ql.value) && Sl && (Gl = zl ? pu(Sl) < pu(Ql.value) : Yl ? Sl < Ql.value : cu < new Date(Ql.value))
        }
        if ((Zl || Gl) && (Dl(!!Zl, Wl.message, Ql.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min),
        !cs))
            return Rl(Il[El].message),
            Il
    }
    if ((ga || ba) && !Fl && (isString(Sl) || Ls && Array.isArray(Sl))) {
        const Zl = getValueAndMessage(ga)
          , Gl = getValueAndMessage(ba)
          , Wl = !isNullOrUndefined(Zl.value) && Sl.length > +Zl.value
          , Ql = !isNullOrUndefined(Gl.value) && Sl.length < +Gl.value;
        if ((Wl || Ql) && (Dl(Wl, Zl.message, Gl.message),
        !cs))
            return Rl(Il[El].message),
            Il
    }
    if (wl && !Fl && isString(Sl)) {
        const {value: Zl, message: Gl} = getValueAndMessage(wl);
        if (isRegex(Zl) && !Sl.match(Zl) && (Il[El] = {
            type: INPUT_VALIDATION_RULES.pattern,
            message: Gl,
            ref: Vs,
            ...Ul(INPUT_VALIDATION_RULES.pattern, Gl)
        },
        !cs))
            return Rl(Gl),
            Il
    }
    if (_l) {
        if (isFunction(_l)) {
            const Zl = await _l(Sl, as)
              , Gl = getValidateError(Zl, Tl);
            if (Gl && (Il[El] = {
                ...Gl,
                ...Ul(INPUT_VALIDATION_RULES.validate, Gl.message)
            },
            !cs))
                return Rl(Gl.message),
                Il
        } else if (isObject(_l)) {
            let Zl = {};
            for (const Gl in _l) {
                if (!isEmptyObject(Zl) && !cs)
                    break;
                const Wl = getValidateError(await _l[Gl](Sl, as), Tl, Gl);
                Wl && (Zl = {
                    ...Wl,
                    ...Ul(Gl, Wl.message)
                },
                Rl(Wl.message),
                cs && (Il[El] = Zl))
            }
            if (!isEmptyObject(Zl) && (Il[El] = {
                ref: Tl,
                ...Zl
            },
            !cs))
                return Il
        }
    }
    return Rl(!0),
    Il
}
;
const defaultOptions = {
    mode: VALIDATION_MODE.onSubmit,
    reValidateMode: VALIDATION_MODE.onChange,
    shouldFocusError: !0
};
function createFormControl(xt={}) {
    let Cn = {
        ...defaultOptions,
        ...xt
    }
      , as = {
        submitCount: 0,
        isDirty: !1,
        isReady: !1,
        isLoading: isFunction(Cn.defaultValues),
        isValidating: !1,
        isSubmitted: !1,
        isSubmitting: !1,
        isSubmitSuccessful: !1,
        isValid: !1,
        touchedFields: {},
        dirtyFields: {},
        validatingFields: {},
        errors: Cn.errors || {},
        disabled: Cn.disabled || !1
    };
    const cs = {};
    let Cs = isObject(Cn.defaultValues) || isObject(Cn.values) ? cloneObject(Cn.values || Cn.defaultValues) || {} : {}, Ls = Cn.shouldUnregister ? {} : cloneObject(Cs), Vs = {
        action: !1,
        mount: !1,
        watch: !1
    }, Ws = {
        mount: new Set,
        disabled: new Set,
        unMount: new Set,
        array: new Set,
        watch: new Set
    }, Xs, ga = 0;
    const ba = {
        isDirty: !1,
        dirtyFields: !1,
        validatingFields: !1,
        touchedFields: !1,
        isValidating: !1,
        isValid: !1,
        errors: !1
    };
    let yl = {
        ...ba
    };
    const xl = {
        array: createSubject(),
        state: createSubject()
    }
      , wl = getValidationModes(Cn.mode)
      , _l = getValidationModes(Cn.reValidateMode)
      , El = Cn.criteriaMode === VALIDATION_MODE.all
      , Cl = uu => gu => {
        clearTimeout(ga),
        ga = setTimeout(uu, gu)
    }
      , $l = async uu => {
        if (!Cn.disabled && (ba.isValid || yl.isValid || uu)) {
            const gu = Cn.resolver ? isEmptyObject((await Fl()).errors) : await Dl(cs, !0);
            gu !== as.isValid && xl.state.next({
                isValid: gu
            })
        }
    }
      , Sl = (uu, gu) => {
        !Cn.disabled && (ba.isValidating || ba.validatingFields || yl.isValidating || yl.validatingFields) && ((uu || Array.from(Ws.mount)).forEach(Eu => {
            Eu && (gu ? set(as.validatingFields, Eu, gu) : unset(as.validatingFields, Eu))
        }
        ),
        xl.state.next({
            validatingFields: as.validatingFields,
            isValidating: !isEmptyObject(as.validatingFields)
        }))
    }
      , Tl = (uu, gu=[], Eu, nu, Kl=!0, Bl=!0) => {
        if (nu && Eu && !Cn.disabled) {
            if (Vs.action = !0,
            Bl && Array.isArray(get(cs, uu))) {
                const Pl = Eu(get(cs, uu), nu.argA, nu.argB);
                Kl && set(cs, uu, Pl)
            }
            if (Bl && Array.isArray(get(as.errors, uu))) {
                const Pl = Eu(get(as.errors, uu), nu.argA, nu.argB);
                Kl && set(as.errors, uu, Pl),
                unsetEmptyArray(as.errors, uu)
            }
            if ((ba.touchedFields || yl.touchedFields) && Bl && Array.isArray(get(as.touchedFields, uu))) {
                const Pl = Eu(get(as.touchedFields, uu), nu.argA, nu.argB);
                Kl && set(as.touchedFields, uu, Pl)
            }
            (ba.dirtyFields || yl.dirtyFields) && (as.dirtyFields = getDirtyFields(Cs, Ls)),
            xl.state.next({
                name: uu,
                isDirty: Gl(uu, gu),
                dirtyFields: as.dirtyFields,
                errors: as.errors,
                isValid: as.isValid
            })
        } else
            set(Ls, uu, gu)
    }
      , Rl = (uu, gu) => {
        set(as.errors, uu, gu),
        xl.state.next({
            errors: as.errors
        })
    }
      , Il = uu => {
        as.errors = uu,
        xl.state.next({
            errors: as.errors,
            isValid: !1
        })
    }
      , Ml = (uu, gu, Eu, nu) => {
        const Kl = get(cs, uu);
        if (Kl) {
            const Bl = get(Ls, uu, isUndefined(Eu) ? get(Cs, uu) : Eu);
            isUndefined(Bl) || nu && nu.defaultChecked || gu ? set(Ls, uu, gu ? Bl : getFieldValue(Kl._f)) : cu(uu, Bl),
            Vs.mount && $l()
        }
    }
      , Nl = (uu, gu, Eu, nu, Kl) => {
        let Bl = !1
          , Pl = !1;
        const Al = {
            name: uu
        };
        if (!Cn.disabled) {
            if (!Eu || nu) {
                (ba.isDirty || yl.isDirty) && (Pl = as.isDirty,
                as.isDirty = Al.isDirty = Gl(),
                Bl = Pl !== Al.isDirty);
                const Vl = deepEqual(get(Cs, uu), gu);
                Pl = !!get(as.dirtyFields, uu),
                Vl ? unset(as.dirtyFields, uu) : set(as.dirtyFields, uu, !0),
                Al.dirtyFields = as.dirtyFields,
                Bl = Bl || (ba.dirtyFields || yl.dirtyFields) && Pl !== !Vl
            }
            if (Eu) {
                const Vl = get(as.touchedFields, uu);
                Vl || (set(as.touchedFields, uu, Eu),
                Al.touchedFields = as.touchedFields,
                Bl = Bl || (ba.touchedFields || yl.touchedFields) && Vl !== Eu)
            }
            Bl && Kl && xl.state.next(Al)
        }
        return Bl ? Al : {}
    }
      , Ll = (uu, gu, Eu, nu) => {
        const Kl = get(as.errors, uu)
          , Bl = (ba.isValid || yl.isValid) && isBoolean(gu) && as.isValid !== gu;
        if (Cn.delayError && Eu ? (Xs = Cl( () => Rl(uu, Eu)),
        Xs(Cn.delayError)) : (clearTimeout(ga),
        Xs = null,
        Eu ? set(as.errors, uu, Eu) : unset(as.errors, uu)),
        (Eu ? !deepEqual(Kl, Eu) : Kl) || !isEmptyObject(nu) || Bl) {
            const Pl = {
                ...nu,
                ...Bl && isBoolean(gu) ? {
                    isValid: gu
                } : {},
                errors: as.errors,
                name: uu
            };
            as = {
                ...as,
                ...Pl
            },
            xl.state.next(Pl)
        }
    }
      , Fl = async uu => {
        Sl(uu, !0);
        const gu = await Cn.resolver(Ls, Cn.context, getResolverOptions(uu || Ws.mount, cs, Cn.criteriaMode, Cn.shouldUseNativeValidation));
        return Sl(uu),
        gu
    }
      , Ul = async uu => {
        const {errors: gu} = await Fl(uu);
        if (uu)
            for (const Eu of uu) {
                const nu = get(gu, Eu);
                nu ? set(as.errors, Eu, nu) : unset(as.errors, Eu)
            }
        else
            as.errors = gu;
        return gu
    }
      , Dl = async (uu, gu, Eu={
        valid: !0
    }) => {
        for (const nu in uu) {
            const Kl = uu[nu];
            if (Kl) {
                const {_f: Bl, ...Pl} = Kl;
                if (Bl) {
                    const Al = Ws.array.has(Bl.name)
                      , Vl = Kl._f && hasPromiseValidation(Kl._f);
                    Vl && ba.validatingFields && Sl([nu], !0);
                    const eu = await validateField(Kl, Ws.disabled, Ls, El, Cn.shouldUseNativeValidation && !gu, Al);
                    if (Vl && ba.validatingFields && Sl([nu]),
                    eu[Bl.name] && (Eu.valid = !1,
                    gu))
                        break;
                    !gu && (get(eu, Bl.name) ? Al ? updateFieldArrayRootError(as.errors, eu, Bl.name) : set(as.errors, Bl.name, eu[Bl.name]) : unset(as.errors, Bl.name))
                }
                !isEmptyObject(Pl) && await Dl(Pl, gu, Eu)
            }
        }
        return Eu.valid
    }
      , Zl = () => {
        for (const uu of Ws.unMount) {
            const gu = get(cs, uu);
            gu && (gu._f.refs ? gu._f.refs.every(Eu => !live(Eu)) : !live(gu._f.ref)) && yu(uu)
        }
        Ws.unMount = new Set
    }
      , Gl = (uu, gu) => !Cn.disabled && (uu && gu && set(Ls, uu, gu),
    !deepEqual(Cu(), Cs))
      , Wl = (uu, gu, Eu) => generateWatchOutput(uu, Ws, {
        ...Vs.mount ? Ls : isUndefined(gu) ? Cs : isString(uu) ? {
            [uu]: gu
        } : gu
    }, Eu, gu)
      , Ql = uu => compact(get(Vs.mount ? Ls : Cs, uu, Cn.shouldUnregister ? get(Cs, uu, []) : []))
      , cu = (uu, gu, Eu={}) => {
        const nu = get(cs, uu);
        let Kl = gu;
        if (nu) {
            const Bl = nu._f;
            Bl && (!Bl.disabled && set(Ls, uu, getFieldValueAs(gu, Bl)),
            Kl = isHTMLElement(Bl.ref) && isNullOrUndefined(gu) ? "" : gu,
            isMultipleSelect(Bl.ref) ? [...Bl.ref.options].forEach(Pl => Pl.selected = Kl.includes(Pl.value)) : Bl.refs ? isCheckBoxInput(Bl.ref) ? Bl.refs.length > 1 ? Bl.refs.forEach(Pl => (!Pl.defaultChecked || !Pl.disabled) && (Pl.checked = Array.isArray(Kl) ? !!Kl.find(Al => Al === Pl.value) : Kl === Pl.value)) : Bl.refs[0] && (Bl.refs[0].checked = !!Kl) : Bl.refs.forEach(Pl => Pl.checked = Pl.value === Kl) : isFileInput(Bl.ref) ? Bl.ref.value = "" : (Bl.ref.value = Kl,
            Bl.ref.type || xl.state.next({
                name: uu,
                values: cloneObject(Ls)
            })))
        }
        (Eu.shouldDirty || Eu.shouldTouch) && Nl(uu, Kl, Eu.shouldTouch, Eu.shouldDirty, !0),
        Eu.shouldValidate && mu(uu)
    }
      , pu = (uu, gu, Eu) => {
        for (const nu in gu) {
            const Kl = gu[nu]
              , Bl = `${uu}.${nu}`
              , Pl = get(cs, Bl);
            (Ws.array.has(uu) || isObject(Kl) || Pl && !Pl._f) && !isDateObject(Kl) ? pu(Bl, Kl, Eu) : cu(Bl, Kl, Eu)
        }
    }
      , zl = (uu, gu, Eu={}) => {
        const nu = get(cs, uu)
          , Kl = Ws.array.has(uu)
          , Bl = cloneObject(gu);
        set(Ls, uu, Bl),
        Kl ? (xl.array.next({
            name: uu,
            values: cloneObject(Ls)
        }),
        (ba.isDirty || ba.dirtyFields || yl.isDirty || yl.dirtyFields) && Eu.shouldDirty && xl.state.next({
            name: uu,
            dirtyFields: getDirtyFields(Cs, Ls),
            isDirty: Gl(uu, Bl)
        })) : nu && !nu._f && !isNullOrUndefined(Bl) ? pu(uu, Bl, Eu) : cu(uu, Bl, Eu),
        isWatched(uu, Ws) && xl.state.next({
            ...as
        }),
        xl.state.next({
            name: Vs.mount ? uu : void 0,
            values: cloneObject(Ls)
        })
    }
      , Yl = async uu => {
        Vs.mount = !0;
        const gu = uu.target;
        let Eu = gu.name
          , nu = !0;
        const Kl = get(cs, Eu)
          , Bl = Pl => {
            nu = Number.isNaN(Pl) || isDateObject(Pl) && isNaN(Pl.getTime()) || deepEqual(Pl, get(Ls, Eu, Pl))
        }
        ;
        if (Kl) {
            let Pl, Al;
            const Vl = gu.type ? getFieldValue(Kl._f) : getEventValue(uu)
              , eu = uu.type === EVENTS.BLUR || uu.type === EVENTS.FOCUS_OUT
              , iu = !hasValidation(Kl._f) && !Cn.resolver && !get(as.errors, Eu) && !Kl._f.deps || skipValidation(eu, get(as.touchedFields, Eu), as.isSubmitted, _l, wl)
              , ou = isWatched(Eu, Ws, eu);
            set(Ls, Eu, Vl),
            eu ? (Kl._f.onBlur && Kl._f.onBlur(uu),
            Xs && Xs(0)) : Kl._f.onChange && Kl._f.onChange(uu);
            const Tu = Nl(Eu, Vl, eu)
              , Hu = !isEmptyObject(Tu) || ou;
            if (!eu && xl.state.next({
                name: Eu,
                type: uu.type,
                values: cloneObject(Ls)
            }),
            iu)
                return (ba.isValid || yl.isValid) && (Cn.mode === "onBlur" ? eu && $l() : eu || $l()),
                Hu && xl.state.next({
                    name: Eu,
                    ...ou ? {} : Tu
                });
            if (!eu && ou && xl.state.next({
                ...as
            }),
            Cn.resolver) {
                const {errors: Mu} = await Fl([Eu]);
                if (Bl(Vl),
                nu) {
                    const Uu = schemaErrorLookup(as.errors, cs, Eu)
                      , Yu = schemaErrorLookup(Mu, cs, Uu.name || Eu);
                    Pl = Yu.error,
                    Eu = Yu.name,
                    Al = isEmptyObject(Mu)
                }
            } else
                Sl([Eu], !0),
                Pl = (await validateField(Kl, Ws.disabled, Ls, El, Cn.shouldUseNativeValidation))[Eu],
                Sl([Eu]),
                Bl(Vl),
                nu && (Pl ? Al = !1 : (ba.isValid || yl.isValid) && (Al = await Dl(cs, !0)));
            nu && (Kl._f.deps && mu(Kl._f.deps),
            Ll(Eu, Al, Pl, Tu))
        }
    }
      , lu = (uu, gu) => {
        if (get(as.errors, gu) && uu.focus)
            return uu.focus(),
            1
    }
      , mu = async (uu, gu={}) => {
        let Eu, nu;
        const Kl = convertToArrayPayload(uu);
        if (Cn.resolver) {
            const Bl = await Ul(isUndefined(uu) ? uu : Kl);
            Eu = isEmptyObject(Bl),
            nu = uu ? !Kl.some(Pl => get(Bl, Pl)) : Eu
        } else
            uu ? (nu = (await Promise.all(Kl.map(async Bl => {
                const Pl = get(cs, Bl);
                return await Dl(Pl && Pl._f ? {
                    [Bl]: Pl
                } : Pl)
            }
            ))).every(Boolean),
            !(!nu && !as.isValid) && $l()) : nu = Eu = await Dl(cs);
        return xl.state.next({
            ...!isString(uu) || (ba.isValid || yl.isValid) && Eu !== as.isValid ? {} : {
                name: uu
            },
            ...Cn.resolver || !uu ? {
                isValid: Eu
            } : {},
            errors: as.errors
        }),
        gu.shouldFocus && !nu && iterateFieldsByAction(cs, lu, uu ? Kl : Ws.mount),
        nu
    }
      , Cu = uu => {
        const gu = {
            ...Vs.mount ? Ls : Cs
        };
        return isUndefined(uu) ? gu : isString(uu) ? get(gu, uu) : uu.map(Eu => get(gu, Eu))
    }
      , ju = (uu, gu) => ({
        invalid: !!get((gu || as).errors, uu),
        isDirty: !!get((gu || as).dirtyFields, uu),
        error: get((gu || as).errors, uu),
        isValidating: !!get(as.validatingFields, uu),
        isTouched: !!get((gu || as).touchedFields, uu)
    })
      , Lu = uu => {
        uu && convertToArrayPayload(uu).forEach(gu => unset(as.errors, gu)),
        xl.state.next({
            errors: uu ? as.errors : {}
        })
    }
      , Au = (uu, gu, Eu) => {
        const nu = (get(cs, uu, {
            _f: {}
        })._f || {}).ref
          , Kl = get(as.errors, uu) || {}
          , {ref: Bl, message: Pl, type: Al, ...Vl} = Kl;
        set(as.errors, uu, {
            ...Vl,
            ...gu,
            ref: nu
        }),
        xl.state.next({
            name: uu,
            errors: as.errors,
            isValid: !1
        }),
        Eu && Eu.shouldFocus && nu && nu.focus && nu.focus()
    }
      , Du = (uu, gu) => isFunction(uu) ? xl.state.subscribe({
        next: Eu => uu(Wl(void 0, gu), Eu)
    }) : Wl(uu, gu, !0)
      , Qu = uu => xl.state.subscribe({
        next: gu => {
            shouldSubscribeByName(uu.name, gu.name, uu.exact) && shouldRenderFormState(gu, uu.formState || ba, hp, uu.reRenderRoot) && uu.callback({
                values: {
                    ...Ls
                },
                ...as,
                ...gu
            })
        }
    }).unsubscribe
      , fu = uu => (Vs.mount = !0,
    yl = {
        ...yl,
        ...uu.formState
    },
    Qu({
        ...uu,
        formState: yl
    }))
      , yu = (uu, gu={}) => {
        for (const Eu of uu ? convertToArrayPayload(uu) : Ws.mount)
            Ws.mount.delete(Eu),
            Ws.array.delete(Eu),
            gu.keepValue || (unset(cs, Eu),
            unset(Ls, Eu)),
            !gu.keepError && unset(as.errors, Eu),
            !gu.keepDirty && unset(as.dirtyFields, Eu),
            !gu.keepTouched && unset(as.touchedFields, Eu),
            !gu.keepIsValidating && unset(as.validatingFields, Eu),
            !Cn.shouldUnregister && !gu.keepDefaultValue && unset(Cs, Eu);
        xl.state.next({
            values: cloneObject(Ls)
        }),
        xl.state.next({
            ...as,
            ...gu.keepDirty ? {
                isDirty: Gl()
            } : {}
        }),
        !gu.keepIsValid && $l()
    }
      , vu = ({disabled: uu, name: gu}) => {
        (isBoolean(uu) && Vs.mount || uu || Ws.disabled.has(gu)) && (uu ? Ws.disabled.add(gu) : Ws.disabled.delete(gu))
    }
      , _u = (uu, gu={}) => {
        let Eu = get(cs, uu);
        const nu = isBoolean(gu.disabled) || isBoolean(Cn.disabled);
        return set(cs, uu, {
            ...Eu || {},
            _f: {
                ...Eu && Eu._f ? Eu._f : {
                    ref: {
                        name: uu
                    }
                },
                name: uu,
                mount: !0,
                ...gu
            }
        }),
        Ws.mount.add(uu),
        Eu ? vu({
            disabled: isBoolean(gu.disabled) ? gu.disabled : Cn.disabled,
            name: uu
        }) : Ml(uu, !0, gu.value),
        {
            ...nu ? {
                disabled: gu.disabled || Cn.disabled
            } : {},
            ...Cn.progressive ? {
                required: !!gu.required,
                min: getRuleValue(gu.min),
                max: getRuleValue(gu.max),
                minLength: getRuleValue(gu.minLength),
                maxLength: getRuleValue(gu.maxLength),
                pattern: getRuleValue(gu.pattern)
            } : {},
            name: uu,
            onChange: Yl,
            onBlur: Yl,
            ref: Kl => {
                if (Kl) {
                    _u(uu, gu),
                    Eu = get(cs, uu);
                    const Bl = isUndefined(Kl.value) && Kl.querySelectorAll && Kl.querySelectorAll("input,select,textarea")[0] || Kl
                      , Pl = isRadioOrCheckbox(Bl)
                      , Al = Eu._f.refs || [];
                    if (Pl ? Al.find(Vl => Vl === Bl) : Bl === Eu._f.ref)
                        return;
                    set(cs, uu, {
                        _f: {
                            ...Eu._f,
                            ...Pl ? {
                                refs: [...Al.filter(live), Bl, ...Array.isArray(get(Cs, uu)) ? [{}] : []],
                                ref: {
                                    type: Bl.type,
                                    name: uu
                                }
                            } : {
                                ref: Bl
                            }
                        }
                    }),
                    Ml(uu, !1, void 0, Bl)
                } else
                    Eu = get(cs, uu, {}),
                    Eu._f && (Eu._f.mount = !1),
                    (Cn.shouldUnregister || gu.shouldUnregister) && !(isNameInFieldArray(Ws.array, uu) && Vs.action) && Ws.unMount.add(uu)
            }
        }
    }
      , xu = () => Cn.shouldFocusError && iterateFieldsByAction(cs, lu, Ws.mount)
      , Ru = uu => {
        isBoolean(uu) && (xl.state.next({
            disabled: uu
        }),
        iterateFieldsByAction(cs, (gu, Eu) => {
            const nu = get(cs, Eu);
            nu && (gu.disabled = nu._f.disabled || uu,
            Array.isArray(nu._f.refs) && nu._f.refs.forEach(Kl => {
                Kl.disabled = nu._f.disabled || uu
            }
            ))
        }
        , 0, !1))
    }
      , Iu = (uu, gu) => async Eu => {
        let nu;
        Eu && (Eu.preventDefault && Eu.preventDefault(),
        Eu.persist && Eu.persist());
        let Kl = cloneObject(Ls);
        if (xl.state.next({
            isSubmitting: !0
        }),
        Cn.resolver) {
            const {errors: Bl, values: Pl} = await Fl();
            as.errors = Bl,
            Kl = Pl
        } else
            await Dl(cs);
        if (Ws.disabled.size)
            for (const Bl of Ws.disabled)
                set(Kl, Bl, void 0);
        if (unset(as.errors, "root"),
        isEmptyObject(as.errors)) {
            xl.state.next({
                errors: {}
            });
            try {
                await uu(Kl, Eu)
            } catch (Bl) {
                nu = Bl
            }
        } else
            gu && await gu({
                ...as.errors
            }, Eu),
            xu(),
            setTimeout(xu);
        if (xl.state.next({
            isSubmitted: !0,
            isSubmitting: !1,
            isSubmitSuccessful: isEmptyObject(as.errors) && !nu,
            submitCount: as.submitCount + 1,
            errors: as.errors
        }),
        nu)
            throw nu
    }
      , Ku = (uu, gu={}) => {
        get(cs, uu) && (isUndefined(gu.defaultValue) ? zl(uu, cloneObject(get(Cs, uu))) : (zl(uu, gu.defaultValue),
        set(Cs, uu, cloneObject(gu.defaultValue))),
        gu.keepTouched || unset(as.touchedFields, uu),
        gu.keepDirty || (unset(as.dirtyFields, uu),
        as.isDirty = gu.defaultValue ? Gl(uu, cloneObject(get(Cs, uu))) : Gl()),
        gu.keepError || (unset(as.errors, uu),
        ba.isValid && $l()),
        xl.state.next({
            ...as
        }))
    }
      , dp = (uu, gu={}) => {
        const Eu = uu ? cloneObject(uu) : Cs
          , nu = cloneObject(Eu)
          , Kl = isEmptyObject(uu)
          , Bl = Kl ? Cs : nu;
        if (gu.keepDefaultValues || (Cs = Eu),
        !gu.keepValues) {
            if (gu.keepDirtyValues) {
                const Pl = new Set([...Ws.mount, ...Object.keys(getDirtyFields(Cs, Ls))]);
                for (const Al of Array.from(Pl))
                    get(as.dirtyFields, Al) ? set(Bl, Al, get(Ls, Al)) : zl(Al, get(Bl, Al))
            } else {
                if (isWeb && isUndefined(uu))
                    for (const Pl of Ws.mount) {
                        const Al = get(cs, Pl);
                        if (Al && Al._f) {
                            const Vl = Array.isArray(Al._f.refs) ? Al._f.refs[0] : Al._f.ref;
                            if (isHTMLElement(Vl)) {
                                const eu = Vl.closest("form");
                                if (eu) {
                                    eu.reset();
                                    break
                                }
                            }
                        }
                    }
                for (const Pl of Ws.mount)
                    zl(Pl, get(Bl, Pl))
            }
            Ls = cloneObject(Bl),
            xl.array.next({
                values: {
                    ...Bl
                }
            }),
            xl.state.next({
                values: {
                    ...Bl
                }
            })
        }
        Ws = {
            mount: gu.keepDirtyValues ? Ws.mount : new Set,
            unMount: new Set,
            array: new Set,
            disabled: new Set,
            watch: new Set,
            watchAll: !1,
            focus: ""
        },
        Vs.mount = !ba.isValid || !!gu.keepIsValid || !!gu.keepDirtyValues,
        Vs.watch = !!Cn.shouldUnregister,
        xl.state.next({
            submitCount: gu.keepSubmitCount ? as.submitCount : 0,
            isDirty: Kl ? !1 : gu.keepDirty ? as.isDirty : !!(gu.keepDefaultValues && !deepEqual(uu, Cs)),
            isSubmitted: gu.keepIsSubmitted ? as.isSubmitted : !1,
            dirtyFields: Kl ? {} : gu.keepDirtyValues ? gu.keepDefaultValues && Ls ? getDirtyFields(Cs, Ls) : as.dirtyFields : gu.keepDefaultValues && uu ? getDirtyFields(Cs, uu) : gu.keepDirty ? as.dirtyFields : {},
            touchedFields: gu.keepTouched ? as.touchedFields : {},
            errors: gu.keepErrors ? as.errors : {},
            isSubmitSuccessful: gu.keepIsSubmitSuccessful ? as.isSubmitSuccessful : !1,
            isSubmitting: !1
        })
    }
      , lp = (uu, gu) => dp(isFunction(uu) ? uu(Ls) : uu, gu)
      , qu = (uu, gu={}) => {
        const Eu = get(cs, uu)
          , nu = Eu && Eu._f;
        if (nu) {
            const Kl = nu.refs ? nu.refs[0] : nu.ref;
            Kl.focus && (Kl.focus(),
            gu.shouldSelect && isFunction(Kl.select) && Kl.select())
        }
    }
      , hp = uu => {
        as = {
            ...as,
            ...uu
        }
    }
      , Lp = {
        control: {
            register: _u,
            unregister: yu,
            getFieldState: ju,
            handleSubmit: Iu,
            setError: Au,
            _subscribe: Qu,
            _runSchema: Fl,
            _getWatch: Wl,
            _getDirty: Gl,
            _setValid: $l,
            _setFieldArray: Tl,
            _setDisabledField: vu,
            _setErrors: Il,
            _getFieldArray: Ql,
            _reset: dp,
            _resetDefaultValues: () => isFunction(Cn.defaultValues) && Cn.defaultValues().then(uu => {
                lp(uu, Cn.resetOptions),
                xl.state.next({
                    isLoading: !1
                })
            }
            ),
            _removeUnmounted: Zl,
            _disableForm: Ru,
            _subjects: xl,
            _proxyFormState: ba,
            get _fields() {
                return cs
            },
            get _formValues() {
                return Ls
            },
            get _state() {
                return Vs
            },
            set _state(uu) {
                Vs = uu
            },
            get _defaultValues() {
                return Cs
            },
            get _names() {
                return Ws
            },
            set _names(uu) {
                Ws = uu
            },
            get _formState() {
                return as
            },
            get _options() {
                return Cn
            },
            set _options(uu) {
                Cn = {
                    ...Cn,
                    ...uu
                }
            }
        },
        subscribe: fu,
        trigger: mu,
        register: _u,
        handleSubmit: Iu,
        watch: Du,
        setValue: zl,
        getValues: Cu,
        reset: lp,
        resetField: Ku,
        clearErrors: Lu,
        unregister: yu,
        setError: Au,
        setFocus: qu,
        getFieldState: ju
    };
    return {
        ...Lp,
        formControl: Lp
    }
}
const useIsomorphicLayoutEffect = typeof window < "u" ? React__default.useLayoutEffect : React__default.useEffect;
function useForm(xt={}) {
    const Cn = React__default.useRef(void 0)
      , as = React__default.useRef(void 0)
      , [cs,Cs] = React__default.useState({
        isDirty: !1,
        isValidating: !1,
        isLoading: isFunction(xt.defaultValues),
        isSubmitted: !1,
        isSubmitting: !1,
        isSubmitSuccessful: !1,
        isValid: !1,
        submitCount: 0,
        dirtyFields: {},
        touchedFields: {},
        validatingFields: {},
        errors: xt.errors || {},
        disabled: xt.disabled || !1,
        isReady: !1,
        defaultValues: isFunction(xt.defaultValues) ? void 0 : xt.defaultValues
    });
    Cn.current || (Cn.current = {
        ...xt.formControl ? xt.formControl : createFormControl(xt),
        formState: cs
    },
    xt.formControl && xt.defaultValues && !isFunction(xt.defaultValues) && xt.formControl.reset(xt.defaultValues, xt.resetOptions));
    const Ls = Cn.current.control;
    return Ls._options = xt,
    useIsomorphicLayoutEffect( () => {
        const Vs = Ls._subscribe({
            formState: Ls._proxyFormState,
            callback: () => Cs({
                ...Ls._formState
            }),
            reRenderRoot: !0
        });
        return Cs(Ws => ({
            ...Ws,
            isReady: !0
        })),
        Ls._formState.isReady = !0,
        Vs
    }
    , [Ls]),
    React__default.useEffect( () => Ls._disableForm(xt.disabled), [Ls, xt.disabled]),
    React__default.useEffect( () => {
        xt.mode && (Ls._options.mode = xt.mode),
        xt.reValidateMode && (Ls._options.reValidateMode = xt.reValidateMode),
        xt.errors && !isEmptyObject(xt.errors) && Ls._setErrors(xt.errors)
    }
    , [Ls, xt.errors, xt.mode, xt.reValidateMode]),
    React__default.useEffect( () => {
        xt.shouldUnregister && Ls._subjects.state.next({
            values: Ls._getWatch()
        })
    }
    , [Ls, xt.shouldUnregister]),
    React__default.useEffect( () => {
        if (Ls._proxyFormState.isDirty) {
            const Vs = Ls._getDirty();
            Vs !== cs.isDirty && Ls._subjects.state.next({
                isDirty: Vs
            })
        }
    }
    , [Ls, cs.isDirty]),
    React__default.useEffect( () => {
        xt.values && !deepEqual(xt.values, as.current) ? (Ls._reset(xt.values, Ls._options.resetOptions),
        as.current = xt.values,
        Cs(Vs => ({
            ...Vs
        }))) : Ls._resetDefaultValues()
    }
    , [Ls, xt.values]),
    React__default.useEffect( () => {
        Ls._state.mount || (Ls._setValid(),
        Ls._state.mount = !0),
        Ls._state.watch && (Ls._state.watch = !1,
        Ls._subjects.state.next({
            ...Ls._formState
        })),
        Ls._removeUnmounted()
    }
    ),
    Cn.current.formState = getProxyFormState(cs, Ls),
    Cn.current
}
const r = (xt, Cn, as) => {
    if (xt && "reportValidity"in xt) {
        const cs = get(as, Cn);
        xt.setCustomValidity(cs && cs.message || ""),
        xt.reportValidity()
    }
}
  , o = (xt, Cn) => {
    for (const as in Cn.fields) {
        const cs = Cn.fields[as];
        cs && cs.ref && "reportValidity"in cs.ref ? r(cs.ref, as, xt) : cs && cs.refs && cs.refs.forEach(Cs => r(Cs, as, xt))
    }
}
  , s$1 = (xt, Cn) => {
    Cn.shouldUseNativeValidation && o(xt, Cn);
    const as = {};
    for (const cs in xt) {
        const Cs = get(Cn.fields, cs)
          , Ls = Object.assign(xt[cs] || {}, {
            ref: Cs && Cs.ref
        });
        if (i(Cn.names || Object.keys(xt), cs)) {
            const Vs = Object.assign({}, get(as, cs));
            set(Vs, "root", Ls),
            set(as, cs, Vs)
        } else
            set(as, cs, Ls)
    }
    return as
}
  , i = (xt, Cn) => {
    const as = n$1(Cn);
    return xt.some(cs => n$1(cs).match(`^${as}\\.\\d+`))
}
;
function n$1(xt) {
    return xt.replace(/\]|\[/g, "")
}
function n(xt, Cn) {
    for (var as = {}; xt.length; ) {
        var cs = xt[0]
          , Cs = cs.code
          , Ls = cs.message
          , Vs = cs.path.join(".");
        if (!as[Vs])
            if ("unionErrors"in cs) {
                var Ws = cs.unionErrors[0].errors[0];
                as[Vs] = {
                    message: Ws.message,
                    type: Ws.code
                }
            } else
                as[Vs] = {
                    message: Ls,
                    type: Cs
                };
        if ("unionErrors"in cs && cs.unionErrors.forEach(function(ba) {
            return ba.errors.forEach(function(yl) {
                return xt.push(yl)
            })
        }),
        Cn) {
            var Xs = as[Vs].types
              , ga = Xs && Xs[cs.code];
            as[Vs] = appendErrors(Vs, Cn, as, Cs, ga ? [].concat(ga, cs.message) : cs.message)
        }
        xt.shift()
    }
    return as
}
function s(xt, Cn, as) {
    return as === void 0 && (as = {}),
    function(cs, Cs, Ls) {
        try {
            return Promise.resolve(function(Vs, Ws) {
                try {
                    var Xs = Promise.resolve(xt[as.mode === "sync" ? "parse" : "parseAsync"](cs, Cn)).then(function(ga) {
                        return Ls.shouldUseNativeValidation && o({}, Ls),
                        {
                            errors: {},
                            values: as.raw ? Object.assign({}, cs) : ga
                        }
                    })
                } catch (ga) {
                    return Ws(ga)
                }
                return Xs && Xs.then ? Xs.then(void 0, Ws) : Xs
            }(0, function(Vs) {
                if (function(Ws) {
                    return Array.isArray(Ws == null ? void 0 : Ws.errors)
                }(Vs))
                    return {
                        values: {},
                        errors: s$1(n(Vs.errors, !Ls.shouldUseNativeValidation && Ls.criteriaMode === "all"), Ls)
                    };
                throw Vs
            }))
        } catch (Vs) {
            return Promise.reject(Vs)
        }
    }
}
const field$1 = "_field_fpz62_1"
  , checkbox = "_checkbox_fpz62_8"
  , small = "_small_fpz62_15"
  , medium = "_medium_fpz62_20"
  , icon = "_icon_fpz62_33"
  , iconUnchecked = "_iconUnchecked_fpz62_47"
  , label$2 = "_label_fpz62_55"
  , styles$w = {
    field: field$1,
    checkbox,
    small,
    medium,
    icon,
    iconUnchecked,
    label: label$2
}
  , SvgCheckbox = xt => reactExports.createElement("svg", {
    width: 14,
    height: 14,
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M1.96291 13.7999C1.37526 13.7999 0.199951 13.4474 0.199951 12.037V1.96291C0.199951 1.37526 0.552544 0.199951 1.96291 0.199951H12.037C12.6246 0.199951 13.7999 0.552544 13.7999 1.96291V12.037C13.7999 12.6246 13.4474 13.7999 12.037 13.7999H1.96291ZM11.326 4.1858C11.0497 3.90837 10.6017 3.90837 10.3254 4.1858L5.5141 9.02658L3.67448 7.17955C3.39816 6.90213 2.95017 6.90213 2.67385 7.17955C2.39754 7.45698 2.39754 7.90678 2.67385 8.1842L5.06946 10.5894C5.21767 10.7315 5.59901 10.9304 5.93863 10.5894L11.326 5.18035C11.6024 4.90293 11.6024 4.46322 11.326 4.1858Z",
    fill: "#0A84FF"
}))
  , SvgCheckboxUnchecked = xt => reactExports.createElement("svg", {
    width: 14,
    height: 14,
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M0.991618 1.71106C0.991618 1.31372 1.31372 0.991618 1.71106 0.991618H12.2888C12.6862 0.991618 13.0083 1.31372 13.0083 1.71106V12.2888C13.0083 12.6862 12.6862 13.0083 12.2888 13.0083H1.71106C1.31372 13.0083 0.991618 12.6862 0.991618 12.2888V1.71106Z",
    stroke: "#7E7E82",
    strokeWidth: 1.58333
}))
  , Checkbox = ({label: xt, labelClassName: Cn, disabled: as, size: cs="small", ...Cs}) => jsxRuntimeExports.jsxs(H, {
    className: styles$w.field,
    disabled: as,
    children: [jsxRuntimeExports.jsx(Fe$2, {
        className: classNames$1(styles$w.checkbox, styles$w[cs]),
        ...Cs,
        children: ({checked: Ls}) => jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [jsxRuntimeExports.jsx(AnimatePresence, {
                children: Ls && jsxRuntimeExports.jsx(motion.div, {
                    initial: {
                        scale: 0
                    },
                    animate: {
                        scale: 1
                    },
                    exit: {
                        scale: 0
                    },
                    transition: {
                        duration: .15
                    },
                    children: jsxRuntimeExports.jsx(SvgCheckbox, {
                        className: classNames$1(styles$w.icon, styles$w[cs])
                    })
                })
            }), jsxRuntimeExports.jsx(SvgCheckboxUnchecked, {
                className: styles$w.iconUnchecked
            })]
        })
    }), jsxRuntimeExports.jsx(Q, {
        className: classNames$1(Cn ?? styles$w.label, styles$w[cs]),
        children: xt
    })]
})
  , backdropIconContainer = "_backdropIconContainer_mf5f8_1"
  , checkboxArrayContainer = "_checkboxArrayContainer_mf5f8_10"
  , checkboxLabel = "_checkboxLabel_mf5f8_16"
  , emptyDisclosure = "_emptyDisclosure_mf5f8_22"
  , emptyDisclosureError = "_emptyDisclosureError_mf5f8_28"
  , controls$1 = "_controls_mf5f8_32"
  , saveFiltersButton = "_saveFiltersButton_mf5f8_43"
  , backdropLabel = "_backdropLabel_mf5f8_47"
  , backdropLabelColorWrapper = "_backdropLabelColorWrapper_mf5f8_52"
  , label$1 = "_label_mf5f8_60"
  , input$1 = "_input_mf5f8_66"
  , inputContainer = "_inputContainer_mf5f8_70"
  , inputIconClear = "_inputIconClear_mf5f8_76"
  , priceWrapper = "_priceWrapper_mf5f8_80"
  , priceDash = "_priceDash_mf5f8_86"
  , nothingFound = "_nothingFound_mf5f8_90"
  , selectAllLabel$1 = "_selectAllLabel_mf5f8_97"
  , styles$v = {
    backdropIconContainer,
    checkboxArrayContainer,
    checkboxLabel,
    emptyDisclosure,
    emptyDisclosureError,
    controls: controls$1,
    saveFiltersButton,
    backdropLabel,
    backdropLabelColorWrapper,
    label: label$1,
    input: input$1,
    inputContainer,
    inputIconClear,
    priceWrapper,
    priceDash,
    nothingFound,
    selectAllLabel: selectAllLabel$1
}
  , useCheckboxArray = () => {
    const xt = reactExports.useCallback( (as, cs) => as.includes(cs), [])
      , Cn = reactExports.useCallback( (as, cs, Cs) => Cs ? [...as, cs] : as.filter(Ls => Ls !== cs), []);
    return {
        isChecked: xt,
        toggle: Cn
    }
}
  , CheckboxArrayContainer = ({children: xt}) => jsxRuntimeExports.jsx("div", {
    className: styles$v.checkboxArrayContainer,
    children: xt
})
  , CollectionsCheckboxArray = ({options: xt}) => {
    const {control: Cn} = useFormContext()
      , {isChecked: as, toggle: cs} = useCheckboxArray();
    return jsxRuntimeExports.jsx(Controller, {
        control: Cn,
        name: "collectionNames",
        render: ({field: Cs}) => jsxRuntimeExports.jsx(CheckboxArrayContainer, {
            children: xt == null ? void 0 : xt.map(Ls => jsxRuntimeExports.jsx(motion.div, {
                initial: {
                    opacity: 0,
                    height: 0
                },
                exit: {
                    opacity: 0,
                    height: 0
                },
                animate: {
                    opacity: 1,
                    height: 20
                },
                layout: !0,
                children: jsxRuntimeExports.jsx(Checkbox, {
                    size: "small",
                    label: jsxRuntimeExports.jsxs("div", {
                        className: styles$v.checkboxLabel,
                        children: [jsxRuntimeExports.jsx("img", {
                            src: Ls.modelStickerThumbnailKey,
                            width: 20,
                            height: 20,
                            alt: ""
                        }), Ls.name]
                    }),
                    checked: as(Cs.value, Ls.name),
                    onChange: Vs => {
                        Cs.onChange(cs(Cs.value, Ls.name, Vs))
                    }
                })
            }, Ls.name))
        })
    })
}
  , ModelsCheckboxArray = ({options: xt, loading: Cn}) => {
    const {t: as} = useTranslation()
      , {control: cs} = useFormContext()
      , {isChecked: Cs, toggle: Ls} = useCheckboxArray();
    return jsxRuntimeExports.jsx(Controller, {
        control: cs,
        name: "modelNames",
        render: ({field: Vs}) => {
            var Ws;
            return jsxRuntimeExports.jsxs(CheckboxArrayContainer, {
                children: [((Ws = xt ?? []) == null ? void 0 : Ws.length) === 0 && jsxRuntimeExports.jsx(motion.div, {
                    className: styles$v.emptyDisclosure,
                    layoutScroll: !0,
                    initial: {
                        opacity: 0,
                        height: 0
                    },
                    exit: {
                        opacity: 0,
                        height: 0
                    },
                    animate: {
                        opacity: 1,
                        height: "auto"
                    },
                    children: Cn ? as("Loading...") : jsxRuntimeExports.jsx("div", {
                        className: styles$v.emptyDisclosureError,
                        children: as("filter_choose_nft")
                    })
                }), xt == null ? void 0 : xt.map(Xs => jsxRuntimeExports.jsx(motion.div, {
                    initial: {
                        opacity: 0,
                        height: 0
                    },
                    exit: {
                        opacity: 0,
                        height: 0
                    },
                    animate: {
                        opacity: 1,
                        height: 20
                    },
                    layout: !0,
                    children: jsxRuntimeExports.jsx(Checkbox, {
                        size: "small",
                        label: jsxRuntimeExports.jsxs("div", {
                            className: styles$v.checkboxLabel,
                            children: [jsxRuntimeExports.jsx("img", {
                                src: Xs.modelStickerThumbnailKey,
                                width: 20,
                                height: 20,
                                alt: ""
                            }), `${Xs.modelName} ${Xs.rarityPerMille ? `(${formatPerMille(Xs.rarityPerMille)})` : ""}`]
                        }),
                        checked: Cs(Vs.value, Xs.modelName),
                        onChange: ga => {
                            Vs.onChange(Ls(Vs.value, Xs.modelName, ga))
                        }
                    }, Xs.modelName)
                }, Xs.modelName))]
            })
        }
    })
}
  , BackdropIcon = ({backdrop: xt}) => {
    const Cn = xt.backdropName.split(" ").join("");
    return jsxRuntimeExports.jsx("div", {
        className: styles$v.backdropIconContainer,
        children: jsxRuntimeExports.jsxs("svg", {
            width: "100%",
            height: "100%",
            viewBox: "0 0 420 420",
            xmlns: "http://www.w3.org/2000/svg",
            preserveAspectRatio: "xMidYMid slice",
            children: [jsxRuntimeExports.jsx("defs", {
                children: jsxRuntimeExports.jsxs("radialGradient", {
                    id: Cn,
                    cx: "50%",
                    cy: "50%",
                    fx: "50%",
                    fy: "50%",
                    r: "69.65%",
                    gradientTransform: "translate(0.5, 0.5), scale(0.6667, 1), rotate(90), translate(-0.5, -0.5)",
                    children: [jsxRuntimeExports.jsx("stop", {
                        stopColor: `#${xt.colorsCenterColor.toString(16).padStart(6, "0")}`,
                        offset: "0%"
                    }), jsxRuntimeExports.jsx("stop", {
                        stopColor: `#${xt.colorsEdgeColor.toString(16).padStart(6, "0")}`,
                        offset: "100%"
                    })]
                })
            }), jsxRuntimeExports.jsx("rect", {
                x: "0",
                y: "0",
                width: "420",
                height: "420",
                fill: `url(#${Cn})`
            })]
        })
    })
}
  , BackdropsCheckboxArray = ({options: xt}) => {
    const {control: Cn} = useFormContext()
      , {isChecked: as, toggle: cs} = useCheckboxArray();
    return jsxRuntimeExports.jsx(Controller, {
        control: Cn,
        name: "backdropNames",
        render: ({field: Cs}) => jsxRuntimeExports.jsx(CheckboxArrayContainer, {
            children: xt == null ? void 0 : xt.map(Ls => jsxRuntimeExports.jsx(motion.div, {
                initial: {
                    opacity: 0,
                    height: 0
                },
                exit: {
                    opacity: 0,
                    height: 0
                },
                animate: {
                    opacity: 1,
                    height: 20
                },
                layout: !0,
                children: jsxRuntimeExports.jsx(Checkbox, {
                    size: "small",
                    label: jsxRuntimeExports.jsxs("div", {
                        className: styles$v.backdropLabel,
                        children: [jsxRuntimeExports.jsx("div", {
                            className: styles$v.backdropLabelColorWrapper,
                            children: jsxRuntimeExports.jsx(BackdropIcon, {
                                backdrop: Ls
                            })
                        }), `${Ls.backdropName} ${Ls.rarityPerMille ? `(${formatPerMille(Ls.rarityPerMille)})` : ""}`]
                    }),
                    checked: as(Cs.value, Ls.backdropName),
                    onChange: Vs => {
                        Cs.onChange(cs(Cs.value, Ls.backdropName, Vs))
                    }
                })
            }, Ls.backdropName))
        })
    })
}
  , SymbolsCheckboxArray = ({options: xt}) => {
    const {control: Cn} = useFormContext()
      , {isChecked: as, toggle: cs} = useCheckboxArray();
    return jsxRuntimeExports.jsx(Controller, {
        control: Cn,
        name: "symbolNames",
        render: ({field: Cs}) => jsxRuntimeExports.jsx(CheckboxArrayContainer, {
            children: xt == null ? void 0 : xt.map(Ls => jsxRuntimeExports.jsx(motion.div, {
                initial: {
                    opacity: 0,
                    height: 0
                },
                exit: {
                    opacity: 0,
                    height: 0
                },
                animate: {
                    opacity: 1,
                    height: 20
                },
                layout: !0,
                children: jsxRuntimeExports.jsx(Checkbox, {
                    size: "small",
                    label: `${Ls.symbolName} ${Ls.rarityPerMille ? `(${formatPerMille(Ls.rarityPerMille)})` : ""}`,
                    checked: as(Cs.value || [], Ls.symbolName),
                    onChange: Vs => {
                        Cs.onChange(cs(Cs.value || [], Ls.symbolName, Vs))
                    }
                })
            }, Ls.symbolName))
        })
    })
}
  , FiltersControls = ({onReset: xt, disabled: Cn}) => {
    const {t: as} = useTranslation();
    return jsxRuntimeExports.jsxs("div", {
        className: styles$v.controls,
        children: [jsxRuntimeExports.jsx(Button, {
            iconButton: !0,
            onClick: xt,
            children: jsxRuntimeExports.jsx("img", {
                src: "/icons/common/trash.svg",
                alt: "reset"
            })
        }), jsxRuntimeExports.jsx(Button, {
            disabled: Cn,
            type: "submit",
            className: styles$v.saveFiltersButton,
            variant: "primary",
            children: as("text_done")
        })]
    })
}
  , PriceRangeInput = ({withLabel: xt=!0}) => {
    const {t: Cn} = useTranslation()
      , {control: as} = useFormContext();
    return jsxRuntimeExports.jsx("div", {
        className: styles$v.inputContainer,
        children: jsxRuntimeExports.jsxs("div", {
            className: styles$v.priceWrapper,
            children: [xt && jsxRuntimeExports.jsx("label", {
                className: styles$v.label,
                children: Cn("filter_price")
            }), jsxRuntimeExports.jsx("img", {
                src: "/icons/common/ton-icon.svg",
                alt: "TON"
            }), jsxRuntimeExports.jsx(Controller, {
                name: "minPrice",
                control: as,
                render: ({field: cs}) => jsxRuntimeExports.jsx(Input, {
                    value: cs.value ?? "",
                    onChange: Cs => cs.onChange(Cs.target.value || null),
                    className: styles$v.input,
                    placeholder: Cn("filter_price_input_tooltip_from"),
                    inputMode: "decimal",
                    pattern: "[0-9]*[.,]?[0-9]*"
                })
            }), jsxRuntimeExports.jsx("span", {
                className: styles$v.priceDash,
                children: ""
            }), jsxRuntimeExports.jsx(Controller, {
                name: "maxPrice",
                control: as,
                render: ({field: cs}) => jsxRuntimeExports.jsx(Input, {
                    value: cs.value ?? "",
                    onChange: Cs => cs.onChange(Cs.target.value || null),
                    className: styles$v.input,
                    placeholder: Cn("filter_price_input_tooltip_to"),
                    inputMode: "decimal",
                    pattern: "[0-9]*[.,]?[0-9]*"
                })
            })]
        })
    })
}
  , FiltersAll = () => {
    const {t: xt} = useTranslation()
      , {filters: Cn, setFilters: as, resetFilters: cs} = useStorage(Ml => Ml.filters)
      , {removeModal: Cs} = useStorage(Ml => Ml.modal)
      , Ls = useStorage(Ml => Ml.myGifts.currentTab)
      , {data: Vs} = useQuery(collectionsQueryOptions())
      , Ws = useForm({
        defaultValues: defaultFilterValues,
        values: Cn,
        resolver: s(filtersSchema),
        resetOptions: {
            keepDefaultValues: !0
        }
    })
      , {control: Xs, handleSubmit: ga, getValues: ba, reset: yl, setValue: xl} = Ws
      , wl = () => {
        as(ba()),
        Cs(ModalNames.FILTERS_ALL)
    }
      , _l = () => {
        yl(defaultFilterValues),
        cs(),
        Cs(ModalNames.FILTERS_ALL)
    }
      , [El,Cl] = useWatch({
        control: Xs,
        name: ["collectionNames", "modelNames"]
    })
      , [$l] = useDebouncedValue(El, 1e3)
      , {data: Sl, isLoading: Tl} = useQuery(modelsQueryOptions($l))
      , {data: Rl} = useQuery(backdropsQueryOptions($l))
      , {data: Il} = useQuery(symbolsQueryOptions($l));
    return reactExports.useEffect( () => {
        Array.isArray(Sl) && xl("modelNames", Cl.filter(Ml => !!Sl.find(Nl => Nl.modelName === Ml)))
    }
    , [Sl]),
    jsxRuntimeExports.jsx(FormProvider, {
        ...Ws,
        children: jsxRuntimeExports.jsxs("form", {
            className: styles$y.container,
            onSubmit: ga(wl),
            children: [jsxRuntimeExports.jsx(Disclosure, {
                title: xt("filter_nft"),
                children: jsxRuntimeExports.jsx(CollectionsCheckboxArray, {
                    options: Vs
                })
            }), jsxRuntimeExports.jsx(Divider, {
                className: styles$y.divider
            }), jsxRuntimeExports.jsx("div", {
                className: styles$y.subheader,
                children: xt("text_traits")
            }), jsxRuntimeExports.jsx(Disclosure, {
                title: xt("filter_model"),
                children: jsxRuntimeExports.jsx(ModelsCheckboxArray, {
                    options: Sl,
                    loading: Tl
                })
            }), jsxRuntimeExports.jsx(Disclosure, {
                title: xt("filter_backdrop"),
                children: jsxRuntimeExports.jsx(BackdropsCheckboxArray, {
                    options: Rl
                })
            }), jsxRuntimeExports.jsx(Disclosure, {
                title: xt("filter_symbol"),
                children: jsxRuntimeExports.jsx(SymbolsCheckboxArray, {
                    options: Il
                })
            }), Ls !== "unlisted" && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [jsxRuntimeExports.jsx(Divider, {
                    className: styles$y.divider
                }), jsxRuntimeExports.jsx(PriceRangeInput, {})]
            }), jsxRuntimeExports.jsx(Divider, {
                className: styles$y.divider
            }), jsxRuntimeExports.jsx(FiltersControls, {
                onReset: _l
            })]
        })
    })
}
  , radioGroup = "_radioGroup_1c3zi_1"
  , field = "_field_1c3zi_7"
  , label = "_label_1c3zi_14"
  , radio = "_radio_1c3zi_1"
  , styles$u = {
    radioGroup,
    field,
    label,
    radio
}
  , RadioGroup = ({children: xt, ...Cn}) => jsxRuntimeExports.jsx(mt, {
    className: styles$u.radioGroup,
    ...Cn,
    children: xt
})
  , Radio = ({label: xt, disabled: Cn, ...as}) => jsxRuntimeExports.jsxs(H, {
    className: styles$u.field,
    disabled: Cn,
    children: [jsxRuntimeExports.jsx(Ke, {
        className: styles$u.radio,
        ...as
    }), jsxRuntimeExports.jsx(Q, {
        className: styles$u.label,
        children: xt
    })]
})
  , wrapper$1 = "_wrapper_lnzvv_1"
  , styles$t = {
    wrapper: wrapper$1
}
  , Sort = () => {
    const {t: xt} = useTranslation()
      , {lowToHigh: Cn, setLowToHigh: as, ordering: cs, setOrdering: Cs} = useStorage(Ls => Ls.filters);
    return jsxRuntimeExports.jsxs("div", {
        className: styles$t.wrapper,
        children: [jsxRuntimeExports.jsxs(RadioGroup, {
            value: cs,
            onChange: Ls => Cs(Ls),
            children: [jsxRuntimeExports.jsx(Radio, {
                value: GiftOrdering.ListingTime,
                label: xt("sort_listing_time")
            }), jsxRuntimeExports.jsx(Radio, {
                value: GiftOrdering.Price,
                label: xt("sort_price")
            }), jsxRuntimeExports.jsx(Radio, {
                value: GiftOrdering.ModelRarity,
                label: xt("sort_model_rarity")
            }), jsxRuntimeExports.jsx(Radio, {
                value: GiftOrdering.BackgroundRarity,
                label: xt("sort_backdrop_rarity")
            }), jsxRuntimeExports.jsx(Radio, {
                value: GiftOrdering.SymbolRarity,
                label: xt("sort_symbol_rarity")
            })]
        }), jsxRuntimeExports.jsx(Divider, {}), jsxRuntimeExports.jsxs(RadioGroup, {
            value: String(Cn),
            onChange: Ls => as(Ls === "true"),
            children: [jsxRuntimeExports.jsx(Radio, {
                value: "true",
                label: xt("sort_low_to_high")
            }), jsxRuntimeExports.jsx(Radio, {
                value: "false",
                label: xt("sort_high_to_low")
            })]
        })]
    })
}
  , walletDisconnectConfirm = "_walletDisconnectConfirm_gmccd_1"
  , walletIcon = "_walletIcon_gmccd_10"
  , walletDisconnectConfirmText = "_walletDisconnectConfirmText_gmccd_22"
  , walletDisconnectConfirmActions = "_walletDisconnectConfirmActions_gmccd_31"
  , walletDisconnectConfirmButton = "_walletDisconnectConfirmButton_gmccd_37"
  , wallet = "_wallet_gmccd_1"
  , walletSmallIcon = "_walletSmallIcon_gmccd_52"
  , walletAddress = "_walletAddress_gmccd_60"
  , styles$s = {
    walletDisconnectConfirm,
    walletIcon,
    walletDisconnectConfirmText,
    walletDisconnectConfirmActions,
    walletDisconnectConfirmButton,
    wallet,
    walletSmallIcon,
    walletAddress
}
  , WalletDiconnectConfirm = () => {
    const {t: xt} = useTranslation()
      , {removeModal: Cn} = useStorage(Vs => Vs.modal)
      , as = useTonAddress(!0)
      , [cs] = useTonConnectUI()
      , Cs = async () => {
        Cn(ModalNames.WALLET_DISCONNECT_COFIRM),
        await cs.disconnect()
    }
      , Ls = () => {
        Cn(ModalNames.WALLET_DISCONNECT_COFIRM)
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$s.walletDisconnectConfirm,
        children: [jsxRuntimeExports.jsx("div", {
            className: styles$s.walletIcon,
            children: jsxRuntimeExports.jsx("img", {
                src: "/images/common/wallet-disconnect.png"
            })
        }), jsxRuntimeExports.jsx("div", {
            children: jsxRuntimeExports.jsx("p", {
                className: styles$s.walletDisconnectConfirmText,
                children: xt("text_disconnect_wallet")
            })
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$s.wallet,
            children: [jsxRuntimeExports.jsx(SvgWallet, {
                className: styles$s.walletSmallIcon
            }), jsxRuntimeExports.jsx("div", {
                className: styles$s.walletAddress,
                children: truncateAddress(as, 4)
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$s.walletDisconnectConfirmActions,
            children: [jsxRuntimeExports.jsx(Button, {
                className: styles$s.walletDisconnectConfirmButton,
                onClick: Cs,
                variant: "success",
                children: xt("button_yes")
            }), jsxRuntimeExports.jsx(Button, {
                className: styles$s.walletDisconnectConfirmButton,
                onClick: Ls,
                variant: "error",
                children: xt("button_no")
            })]
        })]
    })
}
  , CartHeading = () => {
    const {t: xt} = useTranslation();
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: xt("text_shopping_cart")
    })
}
  , container$e = "_container_15072_1"
  , information = "_information_15072_8"
  , selectAllLabel = "_selectAllLabel_15072_16"
  , controls = "_controls_15072_22"
  , clearAllWrapper = "_clearAllWrapper_15072_28"
  , clearAllText = "_clearAllText_15072_33"
  , priceClarification = "_priceClarification_15072_39"
  , buttonGroup = "_buttonGroup_15072_48"
  , purchaseButton = "_purchaseButton_15072_54"
  , insufficientFunds$1 = "_insufficientFunds_15072_66"
  , noItems = "_noItems_15072_89"
  , styles$r = {
    container: container$e,
    information,
    selectAllLabel,
    controls,
    clearAllWrapper,
    clearAllText,
    priceClarification,
    buttonGroup,
    purchaseButton,
    insufficientFunds: insufficientFunds$1,
    noItems
}
  , SvgDeposit = xt => reactExports.createElement("svg", {
    width: 29,
    height: 29,
    viewBox: "0 0 29 29",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("rect", {
    x: 5.56836,
    y: 4.56812,
    width: 18.8636,
    height: 18.8636,
    rx: 4.34091,
    stroke: "#F7F7F8",
    strokeWidth: 1.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M16.8809 13.9999C16.8809 12.5397 18.0646 11.356 19.5248 11.356H24.4314V16.6438H19.5248C18.0646 16.6438 16.8809 15.4601 16.8809 13.9999Z",
    stroke: "#F7F7F8",
    strokeWidth: 1.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("circle", {
    cx: 20.0911,
    cy: 14,
    r: .75,
    fill: "#F7F7F8",
    stroke: "#F7F7F8",
    strokeWidth: 1.04545,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M11.1818 22.909C11.1818 23.8636 10.9145 24.7672 10.4436 25.5308C10.1764 25.989 9.83272 26.3963 9.43818 26.7272C8.54727 27.529 7.37636 27.9999 6.09091 27.9999C4.23273 27.9999 2.61637 27.0072 1.73818 25.5308C1.26728 24.7672 1 23.8636 1 22.909C1 21.3054 1.73818 19.8672 2.90909 18.9381C3.78727 18.2381 4.89455 17.8181 6.09091 17.8181C8.90364 17.8181 11.1818 20.0963 11.1818 22.909Z",
    fill: "#0A84FF",
    stroke: "#F7F7F8",
    strokeWidth: 1.5,
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M7.9895 22.8831H4.19678",
    stroke: "#F7F7F8",
    strokeWidth: 1.5,
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M6.09082 21.0249V24.8303",
    stroke: "#F7F7F8",
    strokeWidth: 1.5,
    strokeMiterlimit: 10,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))
  , gift = "_gift_z64wu_1"
  , giftPrice = "_giftPrice_z64wu_10"
  , giftSelected = "_giftSelected_z64wu_24"
  , giftSuccess = "_giftSuccess_z64wu_27"
  , giftFailure = "_giftFailure_z64wu_30"
  , giftInfo$1 = "_giftInfo_z64wu_33"
  , giftIcon$1 = "_giftIcon_z64wu_41"
  , giftHeader = "_giftHeader_z64wu_47"
  , giftFooter = "_giftFooter_z64wu_47"
  , giftName = "_giftName_z64wu_52"
  , giftNumber$1 = "_giftNumber_z64wu_52"
  , statusText = "_statusText_z64wu_64"
  , success = "_success_z64wu_69"
  , failure = "_failure_z64wu_72"
  , footer$1 = "_footer_z64wu_81"
  , money = "_money_z64wu_92"
  , moneyValue = "_moneyValue_z64wu_100"
  , eventDate = "_eventDate_z64wu_114"
  , eventDateIcon = "_eventDateIcon_z64wu_123"
  , styles$q = {
    gift,
    giftPrice,
    giftSelected,
    giftSuccess,
    giftFailure,
    giftInfo: giftInfo$1,
    giftIcon: giftIcon$1,
    giftHeader,
    giftFooter,
    giftName,
    giftNumber: giftNumber$1,
    statusText,
    success,
    failure,
    footer: footer$1,
    money,
    moneyValue,
    eventDate,
    eventDateIcon
}
  , CartGift = ({gift: xt, selected: Cn, variant: as="standard", mode: cs="cart", date: Cs}) => {
    const {t: Ls} = useTranslation()
      , Vs = useStorage(Ws => Ws.cart.removeFromCart);
    return jsxRuntimeExports.jsxs("div", {
        className: classNames$1({
            [styles$q.gift]: !0,
            [styles$q.giftSelected]: Cn,
            [styles$q.giftSuccess]: as === "success",
            [styles$q.giftFailure]: as === "failure"
        }),
        children: [jsxRuntimeExports.jsx("div", {
            className: styles$q.giftIcon,
            children: jsxRuntimeExports.jsx(GiftIcon, {
                gift: xt,
                height: 47,
                width: 47
            })
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$q.giftInfo,
            children: [jsxRuntimeExports.jsxs("div", {
                className: styles$q.giftHeader,
                children: [jsxRuntimeExports.jsx("div", {
                    className: styles$q.giftName,
                    children: xt.title
                }), jsxRuntimeExports.jsxs("div", {
                    className: styles$q.giftNumber,
                    children: ["#", xt.number]
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$q.giftFooter,
                children: [jsxRuntimeExports.jsxs("div", {
                    className: styles$q.giftPrice,
                    children: [jsxRuntimeExports.jsx(SvgTonIcon, {}), formatNanotons(xt.salePrice ?? 0), Cs && jsxRuntimeExports.jsxs("div", {
                        className: styles$q.eventDate,
                        children: [jsxRuntimeExports.jsx(SvgCalendar, {
                            className: styles$q.eventDateIcon
                        }), format(Cs, "dd MMM HH:mm:ss")]
                    })]
                }), cs === "cart" && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                    children: [as === "success" && jsxRuntimeExports.jsx("div", {
                        className: classNames$1(classNames$1(styles$q.statusText, styles$q.success)),
                        children: Ls("text_success_purchase")
                    }), as === "failure" && jsxRuntimeExports.jsx("div", {
                        className: classNames$1(styles$q.statusText, styles$q.failure),
                        children: Ls("text_out_of_stock")
                    }), as === "standard" && jsxRuntimeExports.jsx(Button, {
                        onClick: () => Vs(xt.id),
                        size: "small",
                        iconButton: !0,
                        children: jsxRuntimeExports.jsx("img", {
                            src: "/icons/common/trash.svg",
                            alt: "clear"
                        })
                    })]
                })]
            })]
        })]
    })
}
  , CartFooter = ({children: xt}) => jsxRuntimeExports.jsx("div", {
    className: styles$q.footer,
    children: xt
})
  , CartMoneyLabel = ({label: xt, value: Cn}) => jsxRuntimeExports.jsxs("div", {
    className: styles$q.money,
    children: [jsxRuntimeExports.jsx("div", {
        children: xt
    }), jsxRuntimeExports.jsxs("div", {
        className: styles$q.moneyValue,
        children: [jsxRuntimeExports.jsx(SvgTonIcon, {}), Cn]
    })]
})
  , useBuyGift = xt => {
    const Cn = useQueryClient()
      , {addModal: as, removeModal: cs, updateBalance: Cs, setBoughtGifts: Ls, clearCart: Vs, setSelectedGiftForQuickBuy: Ws} = useStorage(Xs => ({
        addModal: Xs.modal.addModal,
        removeModal: Xs.modal.removeModal,
        updateBalance: Xs.wallet.updateBalance,
        setBoughtGifts: Xs.cart.setBoughtGifts,
        clearCart: Xs.cart.clearCart,
        setSelectedGiftForQuickBuy: Xs.gifts.setSelectedGiftForQuickBuy
    }));
    return useMutation({
        mutationFn: Xs => buyGifts(Xs),
        onSuccess: Xs => {
            Cn.invalidateQueries({
                queryKey: [QueryKeys.gifts]
            }),
            Cn.invalidateQueries({
                queryKey: [QueryKeys.myGifts, "unlisted"]
            }),
            Cn.invalidateQueries({
                queryKey: [QueryKeys.giftsStats]
            }),
            Cs();
            const ga = Xs.giftsForPurchase.length;
            Xs.purchasedGifts.length ? ga === 1 ? (Ws(Xs.purchasedGifts[0].userGift),
            as(ModalNames.QUICK_BUY_PROOF_OF_PURCHASE)) : (Ls(Xs.purchasedGifts.map(yl => yl.userGift.id)),
            as(ModalNames.PROOF_OF_PURCHASE)) : as(ModalNames.OUT_OF_STOCK, 0, {
                multiple: ga
            }),
            Vs()
        }
        ,
        onError: () => {
            as(ModalNames.ERROR, 0, {
                message: "text_purchase_error"
            })
        }
        ,
        onSettled: () => {
            xt && cs(xt)
        }
    })
}
  , Cart = () => {
    const xt = useNavigate()
      , {t: Cn} = useTranslation()
      , {selectGift: as, unselectGift: cs, unselectAll: Cs, selectAll: Ls, selectedGifts: Vs, gifts: Ws, clearCart: Xs} = useStorage(Ll => Ll.cart)
      , {addModal: ga, removeModal: ba} = useStorage(Ll => Ll.modal)
      , yl = useStorage(Ll => Ll.profile.salesFee)
      , {hard: xl} = useStorage(Ll => Ll.wallet.balance)
      , {mutate: wl} = useBuyGift()
      , _l = useTonAddress(!0)
      , [El] = useTonConnectUI();
    reactExports.useEffect( () => {
        Ls()
    }
    , []);
    const Cl = Ll => {
        Ll ? Ls() : Cs()
    }
      , $l = (Ll, Fl) => {
        Ll ? as(Fl) : cs(Fl)
    }
      , Sl = () => {
        ba(ModalNames.CART),
        wl(Vs)
    }
      , Tl = () => {
        _l ? (ba(ModalNames.CART),
        ga(ModalNames.DEPOSIT)) : (ba(ModalNames.CART),
        El.openModal())
    }
      , Rl = () => {
        ba(ModalNames.CART),
        xt("/")
    }
      , Il = reactExports.useMemo( () => Vs.reduce( (Ll, Fl) => Ll + ((Fl == null ? void 0 : Fl.salePrice) ?? 0), 0), [Vs])
      , Ml = reactExports.useMemo( () => Il > xl, [Il, xl]);
    if (Ws.length === 0)
        return jsxRuntimeExports.jsxs("div", {
            className: styles$r.container,
            children: [jsxRuntimeExports.jsxs("div", {
                className: styles$r.noItems,
                children: [Cn("text_shopping_cart_empty"), jsxRuntimeExports.jsx("img", {
                    src: "/images/common/shopping-cart.png",
                    width: 85,
                    height: 85,
                    alt: "Shopping cart"
                })]
            }), jsxRuntimeExports.jsx(CartFooter, {
                children: jsxRuntimeExports.jsx(Button, {
                    onClick: Rl,
                    className: styles$r.purchaseButton,
                    variant: "primary",
                    size: "medium",
                    children: Cn("button_gotrade")
                })
            })]
        });
    const Nl = !!Ws.length && !!Vs.length && !Ml;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$r.container,
        children: [jsxRuntimeExports.jsx("p", {
            className: styles$r.information,
            children: Cn("text_shopping_cart_info")
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$r.controls,
            children: [jsxRuntimeExports.jsx(Checkbox, {
                size: "medium",
                checked: Vs.length === Ws.length && Ws.length !== 0,
                disabled: Ws.length === 0,
                onChange: Cl,
                label: jsxRuntimeExports.jsx("div", {
                    className: styles$r.selectAllLabel,
                    children: Cn("checkbox_select_all")
                })
            }), Ws.length !== 0 && jsxRuntimeExports.jsxs("div", {
                className: styles$r.clearAllWrapper,
                children: [jsxRuntimeExports.jsx("div", {
                    className: styles$r.clearAllText,
                    children: Cn("checkbox_clear_all")
                }), jsxRuntimeExports.jsx(Button, {
                    iconButton: !0,
                    className: styles$r.clearAllButton,
                    size: "small",
                    onClick: Xs,
                    children: jsxRuntimeExports.jsx("img", {
                        src: "/icons/common/trash.svg",
                        alt: "clear"
                    })
                })]
            })]
        }), jsxRuntimeExports.jsx(AnimatePresence, {
            children: Ws.map(Ll => {
                const Fl = Vs.includes(Ll);
                return jsxRuntimeExports.jsx(motion.div, {
                    initial: {
                        opacity: 0
                    },
                    animate: {
                        opacity: 1
                    },
                    exit: {
                        opacity: 0
                    },
                    transition: {
                        duration: .15
                    },
                    layout: !0,
                    children: jsxRuntimeExports.jsx(Checkbox, {
                        size: "medium",
                        checked: Fl,
                        onChange: Ul => $l(Ul, Ll.id),
                        label: jsxRuntimeExports.jsx(CartGift, {
                            selected: Fl,
                            gift: Ll
                        })
                    })
                }, Ll.id)
            }
            )
        }), jsxRuntimeExports.jsxs(CartFooter, {
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$r.priceClarification,
                children: Cn("text_shopping_cart_fee_info", {
                    value: yl
                })
            }), jsxRuntimeExports.jsx(CartMoneyLabel, {
                label: Cn("text_your_balance") + ":",
                value: formatNanotons(xl, !0)
            }), Ml && jsxRuntimeExports.jsx("div", {
                className: styles$r.insufficientFunds,
                children: Cn("text_insufficient_funds")
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$r.buttonGroup,
                children: [jsxRuntimeExports.jsxs(Button, {
                    className: classNames$1({
                        [styles$r.purchaseButton]: !0
                    }),
                    variant: Ml ? "warning" : "primary",
                    onClick: Sl,
                    disabled: !Nl,
                    children: [jsxRuntimeExports.jsx(SvgTonIcon, {}), formatNanotons(Il)]
                }), Ml && jsxRuntimeExports.jsx(Button, {
                    onClick: Tl,
                    variant: "primary",
                    size: "medium",
                    iconButton: !0,
                    children: jsxRuntimeExports.jsx(SvgDeposit, {})
                })]
            })]
        })]
    })
}
  , container$d = "_container_1wvws_1"
  , styles$p = {
    container: container$d
}
  , ProofOfPurchase = () => {
    const {t: xt} = useTranslation()
      , {selectedGifts: Cn, boughtGifts: as} = useStorage(Ls => ({
        boughtGifts: Ls.cart.boughtGifts,
        selectedGifts: Ls.cart.selectedGifts
    }))
      , cs = useStorage(Ls => Ls.modal.removeModal)
      , Cs = Cn.reduce( (Ls, Vs) => Ls + (as.includes(Vs.id) ? Vs.salePrice ?? 0 : 0), 0);
    return jsxRuntimeExports.jsxs("div", {
        className: styles$p.container,
        children: [Cn.map(Ls => jsxRuntimeExports.jsx(CartGift, {
            variant: as.includes(Ls.id) ? "success" : "failure",
            gift: Ls
        }, Ls.id)), jsxRuntimeExports.jsxs(CartFooter, {
            children: [jsxRuntimeExports.jsx(CartMoneyLabel, {
                label: xt("text_total_price") + ":",
                value: formatNanotons(Cs)
            }), jsxRuntimeExports.jsx(Button, {
                onClick: () => cs(ModalNames.PROOF_OF_PURCHASE),
                children: xt("Ok")
            })]
        })]
    })
}
  , content = "_content_1fix9_1"
  , details = "_details_1fix9_9"
  , title$1 = "_title_1fix9_16"
  , info$1 = "_info_1fix9_22"
  , okButton = "_okButton_1fix9_28"
  , styles$o = {
    content,
    details,
    title: title$1,
    info: info$1,
    okButton
}
  , OutOfStock = () => {
    const {t: xt} = useTranslation()
      , {removeModal: Cn, queue: as} = useStorage(Vs => ({
        queue: Vs.modal.queue,
        removeModal: Vs.modal.removeModal
    }))
      , cs = as.find(Vs => Vs.name === ModalNames.OUT_OF_STOCK)
      , {multiple: Cs=!1} = (cs == null ? void 0 : cs.params) || {}
      , Ls = Cs ? "text_gifts_purchased_else" : "text_gift_purchased_else";
    return jsxRuntimeExports.jsxs("div", {
        className: styles$o.content,
        children: [jsxRuntimeExports.jsx("img", {
            src: "/images/common/empty-hole.png",
            width: 115,
            height: 115
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$o.details,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$o.title,
                children: xt("text_oops")
            }), jsxRuntimeExports.jsx("div", {
                className: styles$o.info,
                children: xt(Ls)
            })]
        }), jsxRuntimeExports.jsx(Button, {
            className: styles$o.okButton,
            onClick: () => Cn(ModalNames.OUT_OF_STOCK),
            children: xt("button_ok")
        })]
    })
}
  , sweepConatiner = "_sweepConatiner_l2nzq_1"
  , sweepButtonContainer = "_sweepButtonContainer_l2nzq_7"
  , sweepButtonContent = "_sweepButtonContent_l2nzq_11"
  , sweepButtonValue = "_sweepButtonValue_l2nzq_17"
  , sweepButtonTonIcon = "_sweepButtonTonIcon_l2nzq_23"
  , sweepButtonValueLabel = "_sweepButtonValueLabel_l2nzq_32"
  , styles$n = {
    sweepConatiner,
    sweepButtonContainer,
    sweepButtonContent,
    sweepButtonValue,
    sweepButtonTonIcon,
    sweepButtonValueLabel
}
  , numberInputContainer = "_numberInputContainer_1t5t4_1"
  , numberInputController = "_numberInputController_1t5t4_14"
  , styles$m = {
    numberInputContainer,
    numberInputController
}
  , NumberInput = ({value: xt, onChange: Cn, min: as=0, max: cs=1 / 0, className: Cs="", onFocus: Ls, onBlur: Vs}) => {
    const [Ws,Xs] = reactExports.useState(xt.toString())
      , [ga,ba] = reactExports.useState(!1);
    reactExports.useEffect( () => {
        Xs(xt.toString())
    }
    , [xt]);
    const yl = $l => {
        const Sl = $l.target.value;
        if (/^\d*$/.test(Sl)) {
            Xs(Sl);
            const Tl = Sl === "" ? 0 : parseInt(Sl);
            if (Cn.length === 1)
                Cn(Tl);
            else {
                const Rl = {
                    ...$l,
                    target: {
                        ...$l.target,
                        value: Tl.toString()
                    }
                };
                Cn(Rl)
            }
        }
    }
      , xl = () => {
        let $l = parseInt(Ws || "0");
        if ($l < as && ($l = as),
        $l > cs && ($l = cs),
        Xs($l.toString()),
        Cn.length === 1)
            Cn($l);
        else {
            const Sl = {
                target: {
                    value: $l.toString()
                }
            };
            Cn(Sl)
        }
        Vs && Vs(),
        setTimeout( () => ba(!1), 100)
    }
      , wl = $l => {
        $l.key === "Enter" && xl()
    }
      , _l = () => {
        const $l = parseInt(Ws || "0")
          , Sl = Math.min(($l || 0) + 1, cs);
        if (Xs(Sl.toString()),
        Cn.length === 1)
            Cn(Sl);
        else {
            const Tl = {
                target: {
                    value: Sl.toString()
                }
            };
            Cn(Tl)
        }
    }
      , El = () => {
        const $l = parseInt(Ws || "0")
          , Sl = Math.max(($l || 0) - 1, as);
        if (Xs(Sl.toString()),
        Cn.length === 1)
            Cn(Sl);
        else {
            const Tl = {
                target: {
                    value: Sl.toString()
                }
            };
            Cn(Tl)
        }
    }
      , Cl = () => {
        ba(!0),
        Ls && Ls()
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: classNames$1(styles$m.numberInputContainer, Cs),
        children: [jsxRuntimeExports.jsx("span", {
            className: styles$m.numberInputController,
            onClick: El,
            children: "-"
        }), jsxRuntimeExports.jsx("input", {
            type: "text",
            className: styles$m.numberInputController,
            value: Ws,
            onChange: yl,
            onKeyDown: wl,
            onFocus: Cl,
            onBlur: xl,
            inputMode: "numeric",
            pattern: "[0-9]*"
        }), jsxRuntimeExports.jsx("span", {
            className: styles$m.numberInputController,
            onClick: _l,
            children: "+"
        })]
    })
}
  , Sweep = () => {
    const {t: xt} = useTranslation()
      , {gifts: Cn, addToCart: as, selectGift: cs, unselectGift: Cs, removeFromCart: Ls} = useStorage(Fl => Fl.cart)
      , {addModal: Vs} = useStorage(Fl => Fl.modal)
      , Ws = useStorage(Fl => Fl.app.maxBatchBuy)
      , Xs = useFilters()
      , {data: ga} = useInfiniteQuery(giftsInfiniteQueryOptions(Xs))
      , [ba,yl] = reactExports.useState("0")
      , [xl,wl] = reactExports.useState(!1)
      , [_l,El] = reactExports.useState(0)
      , Cl = reactExports.useMemo( () => (ga == null ? void 0 : ga.pages.flatMap(Fl => Fl).filter(Fl => !Fl.isMine)) ?? [], [ga == null ? void 0 : ga.pages])
      , $l = reactExports.useMemo( () => {
        const Fl = parseInt(ba) || 0;
        return Cl.slice(0, Fl).reduce( (Dl, Zl) => Dl + (Zl.salePrice || 0), 0)
    }
    , [Cl, ba]);
    reactExports.useEffect( () => {
        const Fl = Math.min(Cl.length, Ws);
        El(Fl),
        yl(Fl.toString()),
        parseInt(ba) > Fl && yl(Fl.toString())
    }
    , [Cl.length, Ws]);
    const Sl = Fl => {
        Fl > _l && (Fl = _l),
        yl(Fl.toString())
    }
      , Tl = () => {
        wl(!0)
    }
      , Rl = () => {
        Il()
    }
      , Il = () => {
        const Fl = Math.min(parseInt(ba || "0"), _l);
        yl(Fl.toString()),
        setTimeout( () => wl(!1), 100)
    }
      , Ml = () => {
        const Fl = parseInt(ba || "0")
          , Ul = Fl === 0 ? _l : Fl;
        yl(Ul.toString());
        const Dl = [...Cn];
        if (Ul < Dl.length)
            for (let Zl = Dl.length - 1; Zl >= Ul; Zl--) {
                const Gl = Dl[Zl];
                Cs(Gl.id),
                Ls(Gl.id)
            }
        else if (Ul > Dl.length) {
            let Zl = Dl.length;
            for (let Gl = 0; Gl < Cl.length && Zl < Ul; Gl++) {
                const Wl = Cl[Gl];
                Dl.some(Ql => Ql.id === Wl.id) || (as(Wl),
                cs(Wl.id),
                Zl++)
            }
        }
        Vs(ModalNames.CART)
    }
      , Nl = isIphone()
      , Ll = xl && Nl ? {
        paddingBottom: "291px"
    } : {};
    return jsxRuntimeExports.jsxs("div", {
        className: styles$n.sweepConatiner,
        style: Ll,
        children: [jsxRuntimeExports.jsx(NumberInput, {
            value: ba,
            onChange: Sl,
            min: 0,
            max: _l,
            className: styles$n.sweepControllerBlock,
            onFocus: Tl,
            onBlur: Rl
        }), jsxRuntimeExports.jsx(Button, {
            variant: "primary",
            className: styles$n.sweepButtonContainer,
            onClick: xl ? Il : Ml,
            children: jsxRuntimeExports.jsx("div", {
                className: styles$n.sweepButtonContent,
                children: xl ? jsxRuntimeExports.jsx("span", {
                    className: styles$n.sweepButtonValueLabel,
                    children: xt("text_done")
                }) : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                    children: [jsxRuntimeExports.jsx("span", {
                        className: styles$n.sweepButtonValueLabel,
                        children: xt("button_sweep_buy")
                    }), jsxRuntimeExports.jsxs("div", {
                        className: styles$n.sweepButtonValue,
                        children: [jsxRuntimeExports.jsx(SvgTonIcon, {
                            className: styles$n.sweepButtonTonIcon
                        }), jsxRuntimeExports.jsx("span", {
                            className: styles$n.sweepButtonValueLabel,
                            children: formatNanotons($l)
                        })]
                    })]
                })
            })
        })]
    })
}
  , container$c = "_container_u7ays_1"
  , header = "_header_u7ays_11"
  , description = "_description_u7ays_39"
  , warning = "_warning_u7ays_62"
  , channelSection = "_channelSection_u7ays_77"
  , inputGroup = "_inputGroup_u7ays_84"
  , input = "_input_u7ays_84"
  , addButton = "_addButton_u7ays_103"
  , hint = "_hint_u7ays_115"
  , checkboxGroup = "_checkboxGroup_u7ays_143"
  , separator = "_separator_u7ays_150"
  , joiningFeeWrapper = "_joiningFeeWrapper_u7ays_156"
  , joiningFee = "_joiningFee_u7ays_156"
  , footer = "_footer_u7ays_170"
  , createButton = "_createButton_u7ays_178"
  , price$1 = "_price_u7ays_181"
  , priceTonIcon = "_priceTonIcon_u7ays_187"
  , priceTonIconDisabled = "_priceTonIconDisabled_u7ays_194"
  , select = "_select_u7ays_202"
  , insufficientBalanceLabel$1 = "_insufficientBalanceLabel_u7ays_206"
  , balanceContainer$2 = "_balanceContainer_u7ays_215"
  , styles$l = {
    container: container$c,
    header,
    description,
    warning,
    channelSection,
    inputGroup,
    input,
    addButton,
    hint,
    checkboxGroup,
    separator,
    joiningFeeWrapper,
    joiningFee,
    footer,
    createButton,
    price: price$1,
    priceTonIcon,
    priceTonIconDisabled,
    select,
    insufficientBalanceLabel: insufficientBalanceLabel$1,
    balanceContainer: balanceContainer$2
}
  , SvgDanger = xt => reactExports.createElement("svg", {
    width: 17,
    height: 17,
    viewBox: "0 0 17 17",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M8.5 6.5V9.83333",
    stroke: "#868686",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M8.49955 14.773H4.45955C2.14621 14.773 1.17955 13.1197 2.29955 11.0997L4.37955 7.35303L6.33955 3.83303C7.52621 1.69303 9.47288 1.69303 10.6595 3.83303L12.6195 7.35969L14.6995 11.1064C15.8195 13.1264 14.8462 14.7797 12.5395 14.7797H8.49955V14.773Z",
    stroke: "#868686",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M8.49683 11.8335H8.50281",
    stroke: "#868686",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))
  , SvgAddSquare = xt => reactExports.createElement("svg", {
    width: 24,
    height: 25,
    viewBox: "0 0 24 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M8 12.5H16",
    stroke: "#0A84FF",
    strokeWidth: 1.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M12 16.5V8.5",
    stroke: "#0A84FF",
    strokeWidth: 1.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M9 22.5H15C20 22.5 22 20.5 22 15.5V9.5C22 4.5 20 2.5 15 2.5H9C4 2.5 2 4.5 2 9.5V15.5C2 20.5 4 22.5 9 22.5Z",
    stroke: "#0A84FF",
    strokeWidth: 1.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))
  , SvgDeleteSquare = xt => reactExports.createElement("svg", {
    width: 24,
    height: 25,
    viewBox: "0 0 24 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M8 12.5H16",
    stroke: "#0A84FF",
    strokeWidth: 1.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M9 22.5H15C20 22.5 22 20.5 22 15.5V9.5C22 4.5 20 2.5 15 2.5H9C4 2.5 2 4.5 2 9.5V15.5C2 20.5 4 22.5 9 22.5Z",
    stroke: "#0A84FF",
    strokeWidth: 1.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))
  , selectContainer = "_selectContainer_pucms_1"
  , selectButton = "_selectButton_pucms_6"
  , chevronIcon = "_chevronIcon_pucms_26"
  , optionsList = "_optionsList_pucms_31"
  , option = "_option_pucms_31"
  , styles$k = {
    selectContainer,
    selectButton,
    chevronIcon,
    optionsList,
    option
}
  , Select = ({optionsArr: xt, value: Cn, onChange: as, className: cs}) => {
    var ga, ba;
    const {t: Cs} = useTranslation()
      , [Ls,Vs] = reactExports.useState(Cn || ((ga = xt[0]) == null ? void 0 : ga.value))
      , Ws = yl => {
        Vs(yl),
        as == null || as(yl)
    }
      , Xs = ((ba = xt.find(yl => yl.value === Ls)) == null ? void 0 : ba.label) || "";
    return jsxRuntimeExports.jsx(Mo, {
        value: Ls,
        onChange: Ws,
        children: jsxRuntimeExports.jsxs("div", {
            className: styles$k.selectContainer,
            children: [jsxRuntimeExports.jsxs(Nt, {
                className: classNames$1(styles$k.selectButton, cs),
                children: [jsxRuntimeExports.jsx("span", {
                    children: Cs(Xs)
                }), jsxRuntimeExports.jsx("img", {
                    src: "/icons/common/chevron-down.svg",
                    alt: "",
                    className: styles$k.chevronIcon
                })]
            }), jsxRuntimeExports.jsx(Gt, {
                className: styles$k.optionsList,
                children: xt.map(yl => jsxRuntimeExports.jsx(Vt, {
                    value: yl.value,
                    className: styles$k.option,
                    children: jsxRuntimeExports.jsx("span", {
                        children: Cs(yl.label)
                    })
                }, yl.value))
            })]
        })
    })
}
  , byteToHex = [];
for (let xt = 0; xt < 256; ++xt)
    byteToHex.push((xt + 256).toString(16).slice(1));
function unsafeStringify(xt, Cn=0) {
    return (byteToHex[xt[Cn + 0]] + byteToHex[xt[Cn + 1]] + byteToHex[xt[Cn + 2]] + byteToHex[xt[Cn + 3]] + "-" + byteToHex[xt[Cn + 4]] + byteToHex[xt[Cn + 5]] + "-" + byteToHex[xt[Cn + 6]] + byteToHex[xt[Cn + 7]] + "-" + byteToHex[xt[Cn + 8]] + byteToHex[xt[Cn + 9]] + "-" + byteToHex[xt[Cn + 10]] + byteToHex[xt[Cn + 11]] + byteToHex[xt[Cn + 12]] + byteToHex[xt[Cn + 13]] + byteToHex[xt[Cn + 14]] + byteToHex[xt[Cn + 15]]).toLowerCase()
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    if (!getRandomValues) {
        if (typeof crypto > "u" || !crypto.getRandomValues)
            throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        getRandomValues = crypto.getRandomValues.bind(crypto)
    }
    return getRandomValues(rnds8)
}
const randomUUID = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto)
  , native = {
    randomUUID
};
function v4(xt, Cn, as) {
    var Cs;
    if (native.randomUUID && !xt)
        return native.randomUUID();
    xt = xt || {};
    const cs = xt.random ?? ((Cs = xt.rng) == null ? void 0 : Cs.call(xt)) ?? rng();
    if (cs.length < 16)
        throw new Error("Random bytes length must be >= 16");
    return cs[6] = cs[6] & 15 | 64,
    cs[8] = cs[8] & 63 | 128,
    unsafeStringify(cs)
}
const createGiveawaySchema = xt => z$1.object({
    channelLinks: z$1.array(z$1.object({
        id: z$1.string(),
        value: z$1.string().url().or(z$1.string().min(1))
    })),
    duration: z$1.string(),
    premiumUsers: z$1.boolean(),
    boosters: z$1.boolean(),
    traders: z$1.boolean(),
    privateGiveaway: z$1.boolean(),
    joiningFee: z$1.coerce.number().nonnegative().nullable().transform(Cn => Cn ? Number(dist$1.toNano(Cn)) : null).superRefine( (Cn, as) => {
        const cs = xt;
        Cn !== null && typeof cs == "number" && Cn < cs && as.addIssue({
            code: z$1.ZodIssueCode.custom,
            message: `Joining fee must be at least ${cs} nanoTONs`
        })
    }
    )
})
  , formatDurationLabel = (xt, Cn) => {
    if (/^\d+\.\d{2}:\d{2}:\d{2}$/.test(xt)) {
        const Ls = parseInt(xt.split(".")[0], 10);
        return Cn("text_duration_hours", {
            value: 24 * Ls
        })
    }
    const [as,cs,Cs] = xt.split(":").map(Number);
    return as === 0 && cs > 0 ? Cn("text_duration_minutes", {
        value: cs
    }) : as > 0 && cs === 0 ? as === 1 ? Cn("text_duration_hour") : Cn("text_duration_hours", {
        value: as
    }) : as > 0 && cs > 0 ? `${as > 1 ? Cn("text_duration_hours", {
        value: as
    }) : "text_duration_hour"} ${Cn("text_duration_minutes", {
        value: cs
    })}` : xt
}
  , useCreateGiveawy = xt => {
    const Cn = useNavigate()
      , {addModal: as, removeModal: cs, updateBalance: Cs, clearSelectedGift: Ls, setMultipleMode: Vs, setActiveTab: Ws} = useStorage(ga => ({
        addModal: ga.modal.addModal,
        removeModal: ga.modal.removeModal,
        updateBalance: ga.wallet.updateBalance,
        clearSelectedGift: ga.myGifts.clearSelectedGift,
        setMultipleMode: ga.myGifts.setMultipleMode,
        setActiveTab: ga.giveaways.setActiveTab
    }))
      , Xs = useQueryClient();
    return useMutation({
        mutationFn: ga => createGiveaway(ga),
        onSuccess: async ga => {
            if (ga.isOk)
                Xs.invalidateQueries({
                    queryKey: [QueryKeys.myGifts, "unlisted"]
                }),
                Cs(),
                as(ModalNames.CONGRATS, 0, {
                    image: "/images/common/confetti.png",
                    title: "text_giveaway_created",
                    buttonText: "button_go",
                    clickHandler: () => {
                        Cn("/giveaways"),
                        Ws("Mine")
                    }
                }),
                Ls(),
                Vs(null),
                xt && cs(xt);
            else {
                let ba = "";
                ga.wrongChanels && ga.wrongChanels.length > 0 && (ba += "text_giveaway_failed"),
                ba = ba.trim() || "Unknown error.",
                as(ModalNames.ERROR, 0, {
                    title: "text_error",
                    message: ba
                })
            }
        }
        ,
        onError: () => {
            as(ModalNames.ERROR, 0, {
                title: "text_error",
                message: "There was an error that occurred during the giveaway creation"
            })
        }
    })
}
  , useStartGiveawayTaskValidation = xt => {
    const Cn = useQueryClient();
    return useMutation({
        mutationFn: as => startGiveawayTaskValidation(xt, as.channel, as.type),
        onSuccess: () => {
            Cn.invalidateQueries({
                queryKey: giveawayTasksValidationStatusQueryOptions(xt).queryKey
            })
        }
    })
}
  , useBuyGiveawayTickets = xt => {
    const {addModal: Cn, updateBalance: as} = useStorage(Cs => ({
        addModal: Cs.modal.addModal,
        updateBalance: Cs.wallet.updateBalance
    }))
      , cs = useQueryClient();
    return useMutation({
        mutationFn: Cs => buyGiveawayTickets(xt, Cs),
        onSuccess: Cs => {
            Cs.length ? (as(),
            Cn(ModalNames.CONGRATS, 0, {
                image: "/images/common/confetti.png",
                title: "text_joined_giveaway",
                buttonText: "button_nice"
            }),
            cs.invalidateQueries({
                queryKey: [QueryKeys.giveaways]
            }),
            cs.invalidateQueries({
                queryKey: [QueryKeys.giveawayInfo, xt]
            })) : Cn(ModalNames.ERROR, 0, {
                title: "text_error",
                message: "Try again later"
            })
        }
        ,
        onError: () => {
            Cn(ModalNames.ERROR, 0, {
                title: "text_error",
                message: "Try again later"
            })
        }
    })
}
  , useClaimGiveawayNotification = () => useMutation({
    mutationFn: xt => claimGiveawayNotification(xt)
})
  , telegramLink = "_telegramLink_g47jv_1"
  , styles$j = {
    telegramLink
}
  , TelegramLink = ({name: xt}) => jsxRuntimeExports.jsxs("span", {
    className: styles$j.telegramLink,
    onClick: () => Oc(`https://t.me/${xt}`),
    children: ["@", xt]
})
  , balance$1 = "_balance_1vwfw_1"
  , amount = "_amount_1vwfw_13"
  , balanceTonIcon = "_balanceTonIcon_1vwfw_26"
  , styles$i = {
    balance: balance$1,
    amount,
    balanceTonIcon
}
  , BalanceLabel = () => {
    const {t: xt} = useTranslation()
      , {hard: Cn} = useStorage(as => ({
        hard: as.wallet.balance.hard
    }));
    return jsxRuntimeExports.jsxs("div", {
        className: styles$i.balance,
        children: [jsxRuntimeExports.jsxs("span", {
            children: [xt("text_wallet_balance"), ": "]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$i.amount,
            children: [jsxRuntimeExports.jsx(SvgTonIcon, {
                className: styles$i.balanceTonIcon
            }), jsxRuntimeExports.jsx("span", {
                children: formatNanotons(Cn, !0)
            })]
        })]
    })
}
  , getDefaultValues = xt => ({
    channelLinks: [{
        id: v4(),
        value: ""
    }],
    duration: xt,
    premiumUsers: !1,
    boosters: !1,
    traders: !1,
    privateGiveaway: !1,
    joiningFee: null
})
  , GiveawayCreation = () => {
    var Wl;
    const {t: xt} = useTranslation()
      , {appBotName: Cn, giveawayDurations: as, giveawayPrizeFeeCost: cs, privateGiveawayFee: Cs, hard: Ls, selectedGifts: Vs, addModal: Ws, minNonFreeGiveawayPrice: Xs, giveawayTicketFee: ga, discount: ba} = useStorage(Ql => ({
        appBotName: Ql.app.appBotName,
        giveawayDurations: Ql.app.giveawayDurations,
        giveawayPrizeFeeCost: Ql.app.giveawayPrizeFeeCost,
        privateGiveawayFee: Ql.app.privateGiveawayFee,
        hard: Ql.wallet.balance.hard,
        selectedGifts: Ql.myGifts.selectedItems,
        addModal: Ql.modal.addModal,
        minNonFreeGiveawayPrice: Ql.app.minNonFreeGiveawayPrice,
        giveawayTicketFee: Ql.app.giveawayTicketFee,
        discount: Ql.profile.discount
    }))
      , yl = reactExports.useMemo( () => createGiveawaySchema(Xs), [Xs])
      , {control: xl, handleSubmit: wl, setValue: _l, getValues: El} = useForm({
        defaultValues: getDefaultValues(as[0]),
        resolver: s(yl),
        resetOptions: {
            keepDefaultValues: !0
        }
    })
      , {mutateAsync: Cl, isPending: $l} = useCreateGiveawy(ModalNames.GA_CREATION)
      , Sl = useWatch({
        control: xl,
        name: "channelLinks"
    })
      , Tl = useWatch({
        control: xl,
        name: "privateGiveaway"
    })
      , Rl = Ql => {
        if (Vs.length === 0) {
            Ws(ModalNames.ERROR, 0, {
                title: "text_error",
                message: "Please select at least one gift for the giveaway."
            });
            return
        }
        const cu = {
            isPrivate: Ql.privateGiveaway,
            ticketPriceNanoTons: Ql.joiningFee ?? 0,
            isChanelBoostRequired: Ql.boosters,
            isForPremium: Ql.premiumUsers,
            isForActiveTraders: Ql.traders,
            chanels: Ql.channelLinks.map(pu => pu.value),
            gifts: Vs.map(pu => pu.id),
            duration: Ql.duration
        };
        Cl(cu)
    }
      , Il = () => {
        const Ql = El("channelLinks");
        Ql.length >= 3 || (!Ql.length || Ql[Ql.length - 1].value.trim() !== "") && _l("channelLinks", [...Ql, {
            id: v4(),
            value: ""
        }])
    }
      , Ml = Ql => {
        const cu = El("channelLinks");
        _l("channelLinks", cu.filter( (pu, zl) => zl !== Ql))
    }
      , Nl = () => {
        const Ql = Dl - Ls;
        Ws(ModalNames.DEPOSIT, 0, {
            depositAmount: Ql > 0 ? Ql : 0
        })
    }
      , Ll = Vs.length * cs
      , Fl = (Sl == null ? void 0 : Sl.length) || 0
      , Ul = Tl ? Cs * (Ll * Fl) : 0
      , Dl = Ll * Fl + Ul
      , Zl = Ls < Dl
      , Gl = !Sl || !((Wl = Sl[0]) != null && Wl.value) || Vs.length === 0;
    return jsxRuntimeExports.jsxs("form", {
        className: styles$l.container,
        onSubmit: wl(Rl),
        noValidate: !0,
        children: [jsxRuntimeExports.jsx("div", {
            className: styles$l.header,
            children: jsxRuntimeExports.jsx("h2", {
                children: xt("text_create_giveaway")
            })
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$l.description,
            children: [jsxRuntimeExports.jsxs("p", {
                children: [xt("text_giveaway_guide_1"), " ", jsxRuntimeExports.jsx(TelegramLink, {
                    name: Cn
                }), " ", xt("text_giveaway_guide_2")]
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$l.warning,
                children: [jsxRuntimeExports.jsx(SvgDanger, {}), jsxRuntimeExports.jsx("span", {
                    children: xt("text_giveaway_guide_note")
                })]
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$l.channelSection,
            children: [jsxRuntimeExports.jsx(Controller, {
                name: "channelLinks",
                control: xl,
                render: ({field: Ql}) => jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                    children: [Ql.value.map( (cu, pu) => jsxRuntimeExports.jsxs("div", {
                        className: styles$l.inputGroup,
                        children: [jsxRuntimeExports.jsx(Input, {
                            type: "text",
                            placeholder: xt("input_tooltip_channel_name"),
                            className: styles$l.input,
                            value: "@" + cu.value,
                            onChange: zl => {
                                const Yl = zl.target.value.split("@").join("")
                                  , lu = [...Ql.value];
                                lu[pu] = {
                                    ...lu[pu],
                                    value: Yl
                                },
                                Ql.onChange(lu)
                            }
                        }), Ql.value.length > 1 && jsxRuntimeExports.jsx(Button, {
                            className: styles$l.addButton,
                            type: "button",
                            onClick: () => Ml(pu),
                            children: jsxRuntimeExports.jsx(SvgDeleteSquare, {})
                        }), pu === Ql.value.length - 1 && Ql.value.length < 3 && cu.value.trim() !== "" && jsxRuntimeExports.jsx(Button, {
                            className: styles$l.addButton,
                            type: "button",
                            onClick: Il,
                            children: jsxRuntimeExports.jsx(SvgAddSquare, {})
                        })]
                    }, cu.id)), Ql.value.length === 0 && jsxRuntimeExports.jsxs("div", {
                        className: styles$l.inputGroup,
                        children: [jsxRuntimeExports.jsx(Input, {
                            type: "text",
                            placeholder: xt("input_tooltip_channel_name"),
                            className: styles$l.input,
                            value: "@",
                            onChange: cu => {
                                const pu = cu.target.value.split("@").join("");
                                Ql.onChange([{
                                    id: v4(),
                                    value: pu
                                }])
                            }
                        }), jsxRuntimeExports.jsx(Button, {
                            className: styles$l.addButton,
                            type: "button",
                            onClick: Il,
                            children: jsxRuntimeExports.jsx(SvgAddSquare, {})
                        })]
                    })]
                })
            }), jsxRuntimeExports.jsx("span", {
                className: styles$l.hint,
                children: xt("text_adding_chanels")
            })]
        }), jsxRuntimeExports.jsx(Controller, {
            name: "duration",
            control: xl,
            render: ({field: Ql}) => jsxRuntimeExports.jsx(Select, {
                optionsArr: as.map(cu => ({
                    value: cu,
                    label: formatDurationLabel(cu, xt)
                })),
                className: styles$l.select,
                value: Ql.value,
                onChange: cu => Ql.onChange(cu)
            })
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$l.checkboxGroup,
            children: [jsxRuntimeExports.jsx(Controller, {
                name: "premiumUsers",
                control: xl,
                render: ({field: Ql}) => jsxRuntimeExports.jsx(Checkbox, {
                    label: xt("option_premium_user"),
                    checked: Ql.value,
                    onChange: Ql.onChange
                })
            }), jsxRuntimeExports.jsx(Controller, {
                name: "boosters",
                control: xl,
                render: ({field: Ql}) => jsxRuntimeExports.jsx(Checkbox, {
                    label: xt("option_boosters"),
                    checked: Ql.value,
                    onChange: Ql.onChange
                })
            }), jsxRuntimeExports.jsx(Controller, {
                name: "traders",
                control: xl,
                render: ({field: Ql}) => jsxRuntimeExports.jsx(Checkbox, {
                    label: xt("option_active_traders"),
                    checked: Ql.value,
                    onChange: Ql.onChange
                })
            }), jsxRuntimeExports.jsx("div", {
                className: styles$l.separator
            }), jsxRuntimeExports.jsx(Controller, {
                name: "privateGiveaway",
                control: xl,
                render: ({field: Ql}) => jsxRuntimeExports.jsx(Checkbox, {
                    label: `${xt("option_private_giveaway")} ${Cs ? `(+${Cs * 100}%)` : ""}`,
                    checked: Ql.value,
                    onChange: Ql.onChange
                })
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$l.joiningFeeWrapper,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$l.joiningFee,
                children: jsxRuntimeExports.jsx(Controller, {
                    name: "joiningFee",
                    control: xl,
                    render: ({field: Ql}) => jsxRuntimeExports.jsx(Input, {
                        className: styles$l.input,
                        inputMode: "decimal",
                        pattern: "[0-9]*[.,]?[0-9]*",
                        placeholder: xt("input_tooltip_joining_fee"),
                        icon: jsxRuntimeExports.jsx(SvgTonIcon, {}),
                        value: Ql.value ?? "",
                        onChange: cu => Ql.onChange(cu.target.value || null),
                        maxDecimalDigits: 2
                    })
                })
            }), jsxRuntimeExports.jsx("div", {
                className: styles$l.warning,
                children: jsxRuntimeExports.jsx("span", {
                    children: xt("text_giveaway_tickets_fee", {
                        value: ga * 100 - ba
                    })
                })
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$l.footer,
            children: [jsxRuntimeExports.jsxs("div", {
                className: styles$l.balanceContainer,
                children: [Zl && jsxRuntimeExports.jsx("span", {
                    className: styles$l.insufficientBalanceLabel,
                    children: xt("text_insufficient_funds")
                }), jsxRuntimeExports.jsx(BalanceLabel, {})]
            }), Zl ? jsxRuntimeExports.jsx(Button, {
                className: styles$l.createButton,
                onClick: Nl,
                children: jsxRuntimeExports.jsx("div", {
                    className: styles$l.price,
                    children: xt("button_deposit")
                })
            }) : jsxRuntimeExports.jsxs(Button, {
                className: styles$l.createButton,
                size: "medium",
                type: "submit",
                disabled: Gl,
                loading: $l,
                onClick: Ql => {
                    wl(Rl)
                }
                ,
                children: [jsxRuntimeExports.jsx("span", {
                    children: xt("button_create")
                }), jsxRuntimeExports.jsxs("div", {
                    className: styles$l.price,
                    children: [jsxRuntimeExports.jsx(SvgTonIcon, {
                        className: Gl ? styles$l.priceTonIconDisabled : styles$l.priceTonIcon
                    }), jsxRuntimeExports.jsx("span", {
                        children: formatNanotons(Dl)
                    })]
                })]
            })]
        })]
    })
}
  , modal = "_modal_s234l_1"
  , giftsContainer = "_giftsContainer_s234l_18"
  , giftItem = "_giftItem_s234l_28"
  , giftInfo = "_giftInfo_s234l_37"
  , giftTitle = "_giftTitle_s234l_45"
  , giftNumber = "_giftNumber_s234l_51"
  , divider$1 = "_divider_s234l_63"
  , conditionsContainer = "_conditionsContainer_s234l_69"
  , conditionItem = "_conditionItem_s234l_76"
  , conditionIcon = "_conditionIcon_s234l_84"
  , spinnerContainer = "_spinnerContainer_s234l_94"
  , conditionText = "_conditionText_s234l_100"
  , balanceContainer$1 = "_balanceContainer_s234l_107"
  , ticketControls = "_ticketControls_s234l_141"
  , ticketInput = "_ticketInput_s234l_148"
  , buyButton = "_buyButton_s234l_183"
  , actionButtonContent = "_actionButtonContent_s234l_188"
  , buyButtonText = "_buyButtonText_s234l_194"
  , buyButtonPrice = "_buyButtonPrice_s234l_201"
  , insufficientBalanceLabel = "_insufficientBalanceLabel_s234l_223"
  , mainSpinnerWrapper = "_mainSpinnerWrapper_s234l_232"
  , tooltipWrapper = "_tooltipWrapper_s234l_238"
  , additionalConditionsTooltipWrapper = "_additionalConditionsTooltipWrapper_s234l_246"
  , warningTooltipWrapper = "_warningTooltipWrapper_s234l_255"
  , dangerIcon = "_dangerIcon_s234l_263"
  , secondaryButtonText = "_secondaryButtonText_s234l_267"
  , styles$h = {
    modal,
    giftsContainer,
    giftItem,
    giftInfo,
    giftTitle,
    giftNumber,
    divider: divider$1,
    conditionsContainer,
    conditionItem,
    conditionIcon,
    spinnerContainer,
    conditionText,
    balanceContainer: balanceContainer$1,
    ticketControls,
    ticketInput,
    buyButton,
    actionButtonContent,
    buyButtonText,
    buyButtonPrice,
    insufficientBalanceLabel,
    mainSpinnerWrapper,
    tooltipWrapper,
    additionalConditionsTooltipWrapper,
    warningTooltipWrapper,
    dangerIcon,
    secondaryButtonText
}
  , SvgClickSquare = xt => reactExports.createElement("svg", {
    width: 18,
    height: 19,
    viewBox: "0 0 18 19",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M16.5 9.5V7.25C16.5 3.5 15 2 11.25 2H6.75C3 2 1.5 3.5 1.5 7.25V11.75C1.5 15.5 3 17 6.75 17H9",
    stroke: "#0A84FF",
    strokeWidth: 1.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M15.7202 13.8799L14.4978 14.2924C14.1603 14.4049 13.8902 14.6674 13.7777 15.0124L13.3652 16.2349C13.0127 17.2924 11.5277 17.2699 11.1977 16.2124L9.81025 11.7499C9.54025 10.8649 10.3577 10.0399 11.2352 10.3174L15.7053 11.7049C16.7553 12.0349 16.7702 13.5274 15.7202 13.8799Z",
    stroke: "#0A84FF",
    strokeWidth: 1.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))
  , SvgTickCircle = xt => reactExports.createElement("svg", {
    width: 18,
    height: 19,
    viewBox: "0 0 18 19",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M9 17C13.125 17 16.5 13.625 16.5 9.5C16.5 5.375 13.125 2 9 2C4.875 2 1.5 5.375 1.5 9.5C1.5 13.625 4.875 17 9 17Z",
    stroke: "#4CD964",
    strokeWidth: 1.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M5.8125 9.49994L7.935 11.6224L12.1875 7.37744",
    stroke: "#4CD964",
    strokeWidth: 1.5,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))
  , ConditionIcon = ({status: xt, onClickHandler: Cn, showTooltip: as}) => {
    const cs = !xt || xt === "TimeOut";
    return jsxRuntimeExports.jsxs("div", {
        className: styles$h.conditionIcon,
        onClick: cs ? Cn : void 0,
        style: {
            cursor: cs ? "pointer" : "default",
            position: "relative"
        },
        children: [xt ? xt === "Validating" ? jsxRuntimeExports.jsx("div", {
            className: styles$h.spinnerContainer,
            children: jsxRuntimeExports.jsx(Spinner, {
                size: 16
            })
        }) : xt === "Validated" ? jsxRuntimeExports.jsx(SvgTickCircle, {}) : jsxRuntimeExports.jsx(SvgClickSquare, {}) : jsxRuntimeExports.jsx(SvgClickSquare, {}), as && jsxRuntimeExports.jsx("div", {
            className: styles$h.warningTooltipWrapper,
            children: jsxRuntimeExports.jsx(Tooltip, {
                position: "top",
                translationKey: "tooltip_warning",
                postfixIcon: jsxRuntimeExports.jsx(SvgDanger, {
                    className: styles$h.dangerIcon
                })
            })
        })]
    })
}
  , ChannelConditionItem = ({channel: xt, validation: Cn, handleStartValidation: as, isBoostRequired: cs, isFirstTimeoutChannel: Cs, showTooltip: Ls}) => {
    const {t: Vs} = useTranslation()
      , Ws = reactExports.useRef(Cn == null ? void 0 : Cn.isMember)
      , Xs = reactExports.useRef(Cn == null ? void 0 : Cn.isBoosted)
      , [ga,ba] = reactExports.useState(!1)
      , [yl,xl] = reactExports.useState(!1);
    return reactExports.useEffect( () => {
        if (Ws.current === "Validating" && (Cn == null ? void 0 : Cn.isMember) === "TimeOut") {
            ba(!0);
            const wl = setTimeout( () => {
                ba(!1)
            }
            , 3e3);
            return () => clearTimeout(wl)
        }
        Ws.current = Cn == null ? void 0 : Cn.isMember
    }
    , [Cn == null ? void 0 : Cn.isMember]),
    reactExports.useEffect( () => {
        if (Xs.current === "Validating" && (Cn == null ? void 0 : Cn.isBoosted) === "TimeOut") {
            xl(!0);
            const wl = setTimeout( () => {
                xl(!1)
            }
            , 3e3);
            return () => clearTimeout(wl)
        }
        Xs.current = Cn == null ? void 0 : Cn.isBoosted
    }
    , [Cn == null ? void 0 : Cn.isBoosted]),
    jsxRuntimeExports.jsxs("div", {
        className: styles$h.conditionsContainer,
        children: [jsxRuntimeExports.jsxs("div", {
            className: styles$h.conditionItem,
            children: [Cs && Ls && jsxRuntimeExports.jsx("div", {
                className: styles$h.tooltipWrapper,
                children: jsxRuntimeExports.jsx(Tooltip, {
                    position: "top",
                    translationKey: "tooltip_hint"
                })
            }), jsxRuntimeExports.jsx(ConditionIcon, {
                status: Cn == null ? void 0 : Cn.isMember,
                onClickHandler: () => as(xt, "ChannelMember"),
                showTooltip: ga
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$h.conditionText,
                children: [Vs("text_subscribe"), " ", jsxRuntimeExports.jsx(TelegramLink, {
                    name: xt
                })]
            })]
        }), cs && jsxRuntimeExports.jsxs("div", {
            className: styles$h.conditionItem,
            children: [jsxRuntimeExports.jsx(ConditionIcon, {
                status: Cn == null ? void 0 : Cn.isBoosted,
                onClickHandler: () => as(xt, "ChannelBoost"),
                showTooltip: yl
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$h.conditionText,
                children: [Vs("text_boost_user"), " ", jsxRuntimeExports.jsx(TelegramLink, {
                    name: xt
                })]
            })]
        })]
    })
}
  , RequirementConditionItem = ({isValidated: xt, handleCheck: Cn, showConditionTooltip: as, shouldShowTooltip: cs, showGlobalTooltip: Cs, label: Ls}) => jsxRuntimeExports.jsxs("div", {
    className: styles$h.conditionItem,
    children: [jsxRuntimeExports.jsxs("div", {
        className: styles$h.conditionIcon,
        style: {
            position: "relative"
        },
        children: [xt ? jsxRuntimeExports.jsx(SvgTickCircle, {
            onClick: Cn,
            style: {
                cursor: "pointer"
            }
        }) : jsxRuntimeExports.jsx(SvgClickSquare, {
            onClick: Cn,
            style: {
                cursor: "pointer"
            }
        }), as && jsxRuntimeExports.jsx("div", {
            className: styles$h.warningTooltipWrapper,
            children: jsxRuntimeExports.jsx(Tooltip, {
                position: "top",
                translationKey: "tooltip_warning",
                postfixIcon: jsxRuntimeExports.jsx(SvgDanger, {
                    className: styles$h.dangerIcon
                })
            })
        }), cs && Cs && jsxRuntimeExports.jsx("div", {
            className: styles$h.additionalConditionsTooltipWrapper,
            children: jsxRuntimeExports.jsx(Tooltip, {
                position: "top",
                translationKey: "tooltip_hint"
            })
        })]
    }), jsxRuntimeExports.jsx("div", {
        className: styles$h.conditionText,
        children: Ls
    })]
})
  , tooltipTimeout$1 = 3e3
  , useTooltipTimeout = xt => {
    const [Cn,as] = reactExports.useState(!1);
    return reactExports.useEffect( () => {
        if (xt) {
            as(!0);
            const cs = setTimeout( () => {
                as(!1)
            }
            , tooltipTimeout$1);
            return () => clearTimeout(cs)
        }
    }
    , [xt]),
    Cn
}
  , TicketsConrols = ({giveaway: xt, ticketCount: Cn, totalPrice: as, setTicketCount: cs, giveawayTaskStatus: Cs, isGiveawayEnded: Ls}) => {
    const {t: Vs} = useTranslation()
      , {hard: Ws, addModal: Xs, removeModal: ga, giveawayMaxTicketsCount: ba} = useStorage($l => ({
        hard: $l.wallet.balance.hard,
        addModal: $l.modal.addModal,
        removeModal: $l.modal.removeModal,
        giveawayMaxTicketsCount: $l.app.giveawayMaxTicketsCount
    }))
      , yl = useBuyGiveawayTickets(xt.id)
      , xl = $l => {
        cs(Number($l))
    }
      , wl = () => {
        !xt.ticketPriceNanoTons && xt.myTicketsCount || yl.mutate(Cn)
    }
      , _l = () => {
        const $l = as - Ws;
        Xs(ModalNames.DEPOSIT, 0, {
            depositAmount: $l > 0 ? $l : 0
        })
    }
      , El = reactExports.useMemo( () => {
        if (!xt || !Cs || xt.isForPremium && !Cs.isPremium || xt.isForActiveTraders && !Cs.isActiveTrader)
            return !1;
        for (const $l of xt.chanels) {
            const Sl = Cs.channelValidations.find(Tl => Tl.channel === $l);
            if (!Sl || Sl.isMember !== "Validated" || xt.isChanelBoostRequired && Sl.isBoosted !== "Validated")
                return !1
        }
        return !0
    }
    , [xt, Cs])
      , Cl = reactExports.useMemo( () => jsxRuntimeExports.jsx(Button, {
        className: styles$h.buyButton,
        onClick: wl,
        variant: "secondary",
        disabled: !El,
        children: xt.ticketPriceNanoTons ? jsxRuntimeExports.jsxs("div", {
            className: styles$h.actionButtonContent,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$h.buyButtonText,
                children: Vs("button_buy_tickets")
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$h.buyButtonPrice,
                children: [jsxRuntimeExports.jsx(SvgTonIcon, {}), jsxRuntimeExports.jsx("span", {
                    children: formatNanotons(as)
                })]
            })]
        }) : jsxRuntimeExports.jsx("div", {
            className: styles$h.actionButtonContent,
            children: !xt.ticketPriceNanoTons && xt.myTicketsCount ? jsxRuntimeExports.jsx("div", {
                className: styles$h.secondaryButtonText,
                children: Vs("button_take_part")
            }) : jsxRuntimeExports.jsx("div", {
                className: styles$h.buyButtonText,
                children: Vs("button_take_part")
            })
        })
    }), [xt, as, El]);
    return xt.validationStatus === "Validated" && Ls ? jsxRuntimeExports.jsx(Button, {
        className: styles$h.buyButton,
        onClick: () => ga(ModalNames.GA_PARTISIPATION),
        children: Vs("button_ok")
    }) : jsxRuntimeExports.jsxs("div", {
        className: styles$h.ticketControls,
        children: [!!xt.ticketPriceNanoTons && jsxRuntimeExports.jsx(NumberInput, {
            value: Cn,
            onChange: xl,
            min: 1,
            max: ba,
            className: styles$h.ticketInput
        }), Ws < as ? jsxRuntimeExports.jsx(Button, {
            className: styles$h.buyButton,
            onClick: _l,
            variant: "secondary",
            children: jsxRuntimeExports.jsx("div", {
                className: styles$h.actionButtonContent,
                children: jsxRuntimeExports.jsx("div", {
                    className: styles$h.buyButtonText,
                    children: Vs("button_deposit")
                })
            })
        }) : Cl]
    })
}
  , tooltipTimeout = 6e3
  , GiveawayParticipation = () => {
    const {t: xt} = useTranslation()
      , Cn = reactExports.useRef(null)
      , [as,cs] = reactExports.useState(!1)
      , [Cs,Ls] = reactExports.useState(!1)
      , [Vs,Ws] = reactExports.useState(!1)
      , [Xs,ga] = reactExports.useState({})
      , ba = reactExports.useRef(null)
      , {appBotName: yl, removeModal: xl, selectedGiveaway: wl, setSelectedGiveaway: _l, externalGiveawayId: El, hard: Cl} = useStorage(mu => ({
        appBotName: mu.app.appBotName,
        removeModal: mu.modal.removeModal,
        selectedGiveaway: mu.giveaways.selectedGiveaway,
        setSelectedGiveaway: mu.giveaways.setSelectedGiveaway,
        externalGiveawayId: mu.giveaways.externalGiveawayId,
        hard: mu.wallet.balance.hard
    }))
      , $l = (wl == null ? void 0 : wl.id) || El
      , {data: Sl, refetch: Tl} = useQuery(giveawayTasksValidationStatusQueryOptions($l));
    reactExports.useEffect( () => {
        if (!Sl || !ba.current) {
            ba.current = Sl;
            return
        }
        const mu = Sl.channelValidations
          , Cu = ba.current.channelValidations;
        if (mu && Cu) {
            const ju = {
                ...Xs
            };
            let Lu = !1;
            mu.forEach(Au => {
                const Du = Cu.find(Qu => Qu.channel === Au.channel);
                Du && (Du.isMember === "Validating" && Au.isMember === "TimeOut" && (ju[`${Au.channel}_member`] = !0,
                Lu = !0),
                Du.isBoosted === "Validating" && Au.isBoosted === "TimeOut" && (ju[`${Au.channel}_boost`] = !0,
                Lu = !0))
            }
            ),
            Lu && (ga(ju),
            Object.keys(ju).forEach(Au => {
                ju[Au] && setTimeout( () => {
                    ga(Du => ({
                        ...Du,
                        [Au]: !1
                    }))
                }
                , tooltipTimeout)
            }
            ))
        }
        ba.current = Sl
    }
    , [Sl]);
    const {data: Rl, isLoading: Il} = useQuery(giveawayInfoQueryOptions($l))
      , Ml = useStartGiveawayTaskValidation($l || "")
      , Nl = reactExports.useMemo( () => Rl || wl, [Rl, wl]);
    reactExports.useEffect( () => {
        if (!Nl)
            return;
        !Nl.ticketPriceNanoTons && Nl.myTicketsCount && xl(ModalNames.GA_PARTISIPATION);
        const mu = () => {
            const ju = new Date(Nl.endAt).getTime();
            return Date.now() >= ju
        }
        ;
        cs(mu());
        const Cu = setInterval( () => {
            cs(mu())
        }
        , 1e3);
        return () => clearInterval(Cu)
    }
    , [Nl]);
    const Ll = reactExports.useMemo( () => Sl ? Sl.channelValidations.some(mu => mu.isMember === "Validating" || mu.isBoosted === "Validating") : !1, [Sl])
      , Fl = reactExports.useMemo( () => !Sl || !Nl ? !1 : Nl.chanels.some(mu => {
        const Cu = Sl.channelValidations.find(ju => ju.channel === mu);
        return Cu ? !!(Cu.isMember === "TimeOut" || Nl.isChanelBoostRequired && Cu.isBoosted === "TimeOut") : !1
    }
    ), [Sl, Nl])
      , Ul = reactExports.useMemo( () => {
        if (!Sl || !Nl)
            return null;
        const mu = new Set;
        for (const Cu of Nl.chanels) {
            if (mu.has(Cu))
                continue;
            mu.add(Cu);
            const ju = Sl.channelValidations.find(Lu => Lu.channel === Cu);
            if (ju && (ju.isMember === "TimeOut" || Nl.isChanelBoostRequired && ju.isBoosted === "TimeOut"))
                return Cu
        }
        return null
    }
    , [Sl, Nl])
      , Dl = reactExports.useMemo( () => !Sl || !Nl ? !1 : Nl.isForPremium && !Sl.isPremium && !Ul, [Sl, Nl, Ul])
      , Zl = reactExports.useMemo( () => !Sl || !Nl ? !1 : Nl.isForActiveTraders && !Sl.isActiveTrader && !Ul && !Dl, [Sl, Nl, Ul, Dl])
      , Gl = useTooltipTimeout(Fl || Dl || Zl);
    reactExports.useEffect( () => (Ll ? Cn.current || (Cn.current = setInterval( () => {
        Tl()
    }
    , 5e3)) : Cn.current && (clearInterval(Cn.current),
    Cn.current = null),
    () => {
        Cn.current && (clearInterval(Cn.current),
        Cn.current = null)
    }
    ), [Ll, Tl]),
    reactExports.useEffect( () => () => {
        _l(null),
        Cn.current && (clearInterval(Cn.current),
        Cn.current = null)
    }
    , []);
    const [Wl,Ql] = reactExports.useState(1)
      , cu = Wl * ((Nl == null ? void 0 : Nl.ticketPriceNanoTons) || 0)
      , pu = (mu, Cu) => {
        Nl != null && Nl.id && Ml.mutate({
            channel: mu,
            type: Cu
        })
    }
      , zl = async () => {
        await Tl(),
        Sl != null && Sl.isPremium || (Ls(!0),
        setTimeout( () => {
            Ls(!1)
        }
        , tooltipTimeout))
    }
      , Yl = async () => {
        await Tl(),
        Sl != null && Sl.isActiveTrader || (Ws(!0),
        setTimeout( () => {
            Ws(!1)
        }
        , tooltipTimeout))
    }
      , lu = Rl ? Rl.gifts : [Nl == null ? void 0 : Nl.previewGift];
    return Il ? jsxRuntimeExports.jsx("div", {
        className: styles$h.mainSpinnerWrapper,
        children: jsxRuntimeExports.jsx(Spinner, {})
    }) : !Nl || Nl.validationStatus !== "Validated" ? (xl(ModalNames.GA_PARTISIPATION),
    null) : jsxRuntimeExports.jsxs("div", {
        className: styles$h.modal,
        children: [jsxRuntimeExports.jsx("div", {
            className: styles$h.giftsContainer,
            children: lu.map(mu => !!mu && jsxRuntimeExports.jsxs("div", {
                className: styles$h.giftItem,
                children: [jsxRuntimeExports.jsx(GiftIcon, {
                    gift: mu,
                    width: 50,
                    height: 50,
                    isLottie: !1
                }), jsxRuntimeExports.jsxs("div", {
                    className: styles$h.giftInfo,
                    children: [jsxRuntimeExports.jsx("div", {
                        className: styles$h.giftTitle,
                        children: mu.title
                    }), jsxRuntimeExports.jsxs("div", {
                        className: styles$h.giftNumber,
                        children: ["#", mu.number]
                    })]
                })]
            }, mu.id))
        }), jsxRuntimeExports.jsx("div", {
            className: styles$h.divider
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$h.conditionsContainer,
            children: [( () => {
                const mu = new Set;
                return Nl.chanels.map( (Cu, ju) => {
                    const Lu = Sl == null ? void 0 : Sl.channelValidations.find(Du => Du.channel === Cu)
                      , Au = Cu === Ul && !mu.has(Cu);
                    return Au && mu.add(Cu),
                    jsxRuntimeExports.jsx(ChannelConditionItem, {
                        channel: Cu,
                        validation: Lu,
                        handleStartValidation: pu,
                        isBoostRequired: Nl.isChanelBoostRequired,
                        isFirstTimeoutChannel: Au,
                        showTooltip: Gl
                    }, Cu + ju)
                }
                )
            }
            )(), Nl.isForPremium && jsxRuntimeExports.jsx(RequirementConditionItem, {
                isValidated: !!(Sl != null && Sl.isPremium),
                handleCheck: zl,
                showConditionTooltip: Cs,
                shouldShowTooltip: Dl,
                showGlobalTooltip: Gl,
                label: xt("text_premium_user")
            }), Nl.isForActiveTraders && jsxRuntimeExports.jsx(RequirementConditionItem, {
                isValidated: !!(Sl != null && Sl.isActiveTrader),
                handleCheck: Yl,
                showConditionTooltip: Vs,
                shouldShowTooltip: Zl,
                showGlobalTooltip: Gl,
                label: jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                    children: [xt("text_active_trader_1"), " ", jsxRuntimeExports.jsx(TelegramLink, {
                        name: yl
                    }), " ", xt("text_active_trader_2")]
                })
            })]
        }), jsxRuntimeExports.jsx("div", {
            className: styles$h.divider
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$h.balanceContainer,
            children: [!!Nl.ticketPriceNanoTons && jsxRuntimeExports.jsxs("div", {
                className: styles$h.balanceContainer,
                children: [Cl < cu && jsxRuntimeExports.jsx("span", {
                    className: styles$h.insufficientBalanceLabel,
                    children: xt("text_insufficient_funds")
                }), jsxRuntimeExports.jsx(BalanceLabel, {})]
            }), jsxRuntimeExports.jsx(TicketsConrols, {
                giveaway: Nl,
                ticketCount: Wl,
                setTicketCount: Ql,
                totalPrice: cu,
                giveawayTaskStatus: Sl,
                isGiveawayEnded: as
            })]
        })]
    })
}
  , container$b = "_container_1n6tc_1"
  , item = "_item_1n6tc_8"
  , button$1 = "_button_1n6tc_12"
  , buttonLabel = "_buttonLabel_1n6tc_16"
  , win = "_win_1n6tc_16"
  , lose = "_lose_1n6tc_19"
  , loader = "_loader_1n6tc_23"
  , styles$g = {
    container: container$b,
    item,
    button: button$1,
    buttonLabel,
    win,
    lose,
    loader
}
  , GiveawayResultInfo = () => {
    const {t: xt} = useTranslation()
      , {addModal: Cn, removeModal: as, queue: cs} = useStorage(xl => ({
        addModal: xl.modal.addModal,
        removeModal: xl.modal.removeModal,
        queue: xl.modal.queue
    }))
      , Cs = cs.find(xl => xl.name === ModalNames.GA_RESULT_INFO)
      , {state: Ls, giveawayId: Vs, giftsIds: Ws} = (Cs == null ? void 0 : Cs.params) || {}
      , Xs = reactExports.useMemo( () => {
        switch (Ls) {
        case "Win":
            return "button_you_won";
        case "Lose":
            return "button_you_lost";
        default:
            return "button_ok"
        }
    }
    , [Ls])
      , {data: ga, isLoading: ba} = useQuery(giveawayInfoQueryOptions(Vs))
      , yl = () => {
        var xl;
        switch (Ls) {
        case "Win":
            {
                const wl = (xl = ga == null ? void 0 : ga.gifts) == null ? void 0 : xl.find(_l => _l.id === (Ws == null ? void 0 : Ws[0]));
                wl && Cn(ModalNames.GA_REWARD, 0, {
                    gift: wl
                });
                break
            }
        }
        as(ModalNames.GA_RESULT_INFO)
    }
    ;
    return ba ? jsxRuntimeExports.jsx("div", {
        className: styles$g.container,
        children: jsxRuntimeExports.jsx(Spinner, {
            className: styles$g.loader,
            size: 24
        })
    }) : ga ? jsxRuntimeExports.jsxs("div", {
        className: styles$g.container,
        children: [jsxRuntimeExports.jsx("div", {
            className: styles$g.item,
            children: jsxRuntimeExports.jsx(GiveawayItem, {
                winningTickets: Ls === "Finish" ? void 0 : (Ws == null ? void 0 : Ws.length) ?? 0,
                isInModal: !0,
                giveaway: ga,
                withButton: !1
            })
        }), jsxRuntimeExports.jsx(Button, {
            className: styles$g.button,
            onClick: yl,
            children: jsxRuntimeExports.jsx("div", {
                className: classNames$1(styles$g.buttonLabel, {
                    [styles$g.win]: Ls === "Win",
                    [styles$g.lose]: Ls === "Lose"
                }),
                children: xt(Xs)
            })
        })]
    }) : null
}
  , giveawayRewardContainer = "_giveawayRewardContainer_r2nir_1"
  , giveawayRewardTextWrapper = "_giveawayRewardTextWrapper_r2nir_8"
  , giveawayRewardTitle = "_giveawayRewardTitle_r2nir_15"
  , giveawayRewardSubtitle = "_giveawayRewardSubtitle_r2nir_24"
  , giveawayRewardButton = "_giveawayRewardButton_r2nir_32"
  , styles$f = {
    giveawayRewardContainer,
    giveawayRewardTextWrapper,
    giveawayRewardTitle,
    giveawayRewardSubtitle,
    giveawayRewardButton
}
  , GiveawayReward = () => {
    const xt = useNavigate()
      , {t: Cn} = useTranslation()
      , {queue: as, removeModal: cs, setCurrentTab: Cs} = useStorage(Xs => ({
        removeModal: Xs.modal.removeModal,
        queue: Xs.modal.queue,
        setCurrentTab: Xs.myGifts.setCurrentTab
    }))
      , Ls = as.find(Xs => Xs.name === ModalNames.GA_REWARD)
      , {gift: Vs} = (Ls == null ? void 0 : Ls.params) || {}
      , Ws = () => {
        cs(ModalNames.GA_REWARD),
        xt("/my-gifts"),
        Cs("unlisted")
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$f.giveawayRewardContainer,
        children: [jsxRuntimeExports.jsx(GiftCard, {
            gift: Vs
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$f.giveawayRewardTextWrapper,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$f.giveawayRewardTitle,
                children: Cn("text_congratulation")
            }), jsxRuntimeExports.jsx("div", {
                className: styles$f.giveawayRewardSubtitle,
                children: Cn("text_you_won_gift")
            })]
        }), jsxRuntimeExports.jsx(Button, {
            className: styles$f.giveawayRewardButton,
            onClick: Ws,
            children: Cn("button_nice")
        })]
    })
}
  , container$a = "_container_1wfo9_1"
  , scrollContainer = "_scrollContainer_1wfo9_8"
  , multiple = "_multiple_1wfo9_14"
  , hideScrollbar = "_hideScrollbar_1wfo9_18"
  , gifts = "_gifts_1wfo9_25"
  , giftsMiniCard = "_giftsMiniCard_1wfo9_34"
  , giftsMiniCardDetails = "_giftsMiniCardDetails_1wfo9_41"
  , giftsMiniCardDetailsTitle = "_giftsMiniCardDetailsTitle_1wfo9_47"
  , giftsMiniCardDetailsNumber = "_giftsMiniCardDetailsNumber_1wfo9_47"
  , info = "_info_1wfo9_58"
  , infoError = "_infoError_1wfo9_64"
  , infoDetails = "_infoDetails_1wfo9_69"
  , infoFee = "_infoFee_1wfo9_76"
  , infoFeeIcon = "_infoFeeIcon_1wfo9_84"
  , balanceContainer = "_balanceContainer_1wfo9_92"
  , balance = "_balance_1wfo9_92"
  , balanceError = "_balanceError_1wfo9_107"
  , balanceIcon = "_balanceIcon_1wfo9_112"
  , balanceValue = "_balanceValue_1wfo9_119"
  , action$1 = "_action_1wfo9_123"
  , actionIcon = "_actionIcon_1wfo9_123"
  , styles$e = {
    container: container$a,
    scrollContainer,
    multiple,
    hideScrollbar,
    gifts,
    giftsMiniCard,
    giftsMiniCardDetails,
    giftsMiniCardDetailsTitle,
    giftsMiniCardDetailsNumber,
    info,
    infoError,
    infoDetails,
    infoFee,
    infoFeeIcon,
    balanceContainer,
    balance,
    balanceError,
    balanceIcon,
    balanceValue,
    action: action$1,
    actionIcon
}
  , ListingSalesLimit = () => {
    const {t: xt} = useTranslation()
      , {selectedItems: Cn, selectedItem: as, addModal: cs, multipleMode: Cs, freeSalesCount: Ls, removeModal: Vs, balance: Ws, fee: Xs} = useStorage(_l => ({
        balance: _l.wallet.balance.hard,
        selectedItems: _l.myGifts.selectedItems,
        addModal: _l.modal.addModal,
        removeModal: _l.modal.removeModal,
        selectedItem: _l.myGifts.selectedGiftForListing,
        multipleMode: _l.myGifts.multipleMode,
        fee: _l.app.salePrice,
        freeSalesCount: _l.app.freeSalesCount
    }))
      , ga = reactExports.useMemo( () => Cs ? Cn.filter(_l => _l.salesCount >= Ls) : [as], [Cn, as])
      , ba = () => {
        Vs(ModalNames.LISTING_SALES_LIMIT),
        cs(Cs ? ModalNames.MULTIPLE_LISTING_PRICE : ModalNames.LIST_GIFT_PRICE)
    }
    ;
    if (ga.length === 0)
        return null;
    const yl = Xs * ga.length
      , xl = Ws < yl
      , wl = ga.length > 1;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$e.container,
        children: [jsxRuntimeExports.jsx("div", {
            className: classNames$1(styles$e.scrollContainer, {
                [styles$e.multiple]: wl,
                [styles$e.hideScrollbar]: !isMobile()
            }),
            children: jsxRuntimeExports.jsx("div", {
                className: classNames$1(styles$e.gifts, {
                    [styles$e.multiple]: wl
                }),
                children: wl ? ga.map(_l => jsxRuntimeExports.jsxs("div", {
                    className: styles$e.giftsMiniCard,
                    children: [jsxRuntimeExports.jsx(GiftIcon, {
                        gift: _l,
                        width: 47,
                        clicksAvailable: !1
                    }), jsxRuntimeExports.jsxs("div", {
                        className: styles$e.giftsMiniCardDetails,
                        children: [jsxRuntimeExports.jsx("span", {
                            className: styles$e.giftsMiniCardDetailsTitle,
                            children: _l.title
                        }), jsxRuntimeExports.jsxs("span", {
                            className: styles$e.giftsMiniCardDetailsNumber,
                            children: ["#", _l.number]
                        })]
                    })]
                }, _l.id)) : jsxRuntimeExports.jsx(GiftCard, {
                    error: !0,
                    gift: ga[0]
                })
            })
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$e.info,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$e.infoError,
                children: xt("text_error")
            }), jsxRuntimeExports.jsx("div", {
                className: styles$e.infoDetails,
                children: xt("text_too_many_listings", {
                    value: Ls
                })
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$e.infoFee,
                children: [jsxRuntimeExports.jsx(SvgTonIcon, {
                    className: styles$e.infoFeeIcon
                }), formatNanotons(Xs)]
            }), jsxRuntimeExports.jsx("div", {
                className: styles$e.infoDetails,
                children: xt("text_too_many_listings_fee")
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$e.balanceContainer,
            children: [xl && jsxRuntimeExports.jsx("div", {
                className: styles$e.balanceError,
                children: xt("text_insufficient_funds")
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$e.balance,
                children: [jsxRuntimeExports.jsxs("span", {
                    children: [xt("text_balance"), ":"]
                }), jsxRuntimeExports.jsx(SvgTonIcon, {
                    className: styles$e.balanceIcon
                }), jsxRuntimeExports.jsx("span", {
                    className: styles$e.balanceValue,
                    children: formatNanotons(Ws, !0)
                })]
            })]
        }), jsxRuntimeExports.jsx(Button, {
            onClick: ba,
            disabled: xl,
            variant: "primary",
            className: styles$e.action,
            children: wl ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [!xl && "button_pay_fee", " ", jsxRuntimeExports.jsx(SvgTonIcon, {
                    className: styles$e.actionIcon
                }), " ", formatNanotons(yl)]
            }) : xt("button_agree")
        })]
    })
}
  , container$9 = "_container_1qwer_1"
  , giftIcon = "_giftIcon_1qwer_8"
  , title = "_title_1qwer_13"
  , totalWrapper = "_totalWrapper_1qwer_19"
  , confirmText$2 = "_confirmText_1qwer_26"
  , price = "_price_1qwer_31"
  , actions$2 = "_actions_1qwer_37"
  , actionButton$4 = "_actionButton_1qwer_43"
  , styles$d = {
    container: container$9,
    giftIcon,
    title,
    totalWrapper,
    confirmText: confirmText$2,
    price,
    actions: actions$2,
    actionButton: actionButton$4
}
  , MultipleGiftWithdrawConfirm = () => {
    const {t: xt} = useTranslation()
      , {mutateAsync: Cn} = useWithdrawGifts()
      , {selectedItems: as, clearSelectedItems: cs, setMultipleMode: Cs} = useStorage(ga => ga.myGifts)
      , {removeModal: Ls} = useStorage(ga => ga.modal)
      , Vs = async () => {
        Ls(ModalNames.MULTIPLE_WITHDRAW_CONFIRM),
        await Cn(as),
        cs(),
        Cs(null)
    }
      , Ws = () => {
        Ls(ModalNames.MULTIPLE_WITHDRAW_CONFIRM),
        cs(),
        Cs(null)
    }
    ;
    if (as.length === 0)
        return null;
    const Xs = as.filter(ga => !ga.isGiveawayReceived);
    return jsxRuntimeExports.jsxs("div", {
        className: styles$d.container,
        children: [jsxRuntimeExports.jsx("img", {
            className: styles$d.giftIcon,
            src: "/images/common/pack.png",
            alt: "Gift box"
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$d.title,
            children: [xt("text_gifts_return"), " ", as.length]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$d.totalWrapper,
            children: [jsxRuntimeExports.jsx("span", {
                className: styles$d.confirmText,
                children: xt("text_return_gift_confirm")
            }), !!Xs.length && jsxRuntimeExports.jsxs("span", {
                className: styles$d.price,
                children: [xt("text_return_cost"), ": ", (Xs.length * .1).toFixed(1), " TON"]
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$d.actions,
            children: [jsxRuntimeExports.jsx(Button, {
                className: styles$d.actionButton,
                onClick: Vs,
                variant: "success",
                children: xt("button_yes")
            }), jsxRuntimeExports.jsx(Button, {
                className: styles$d.actionButton,
                onClick: Ws,
                variant: "error",
                children: xt("button_no")
            })]
        })]
    })
}
  , container$8 = "_container_hrn1a_1"
  , confirmationText$1 = "_confirmationText_hrn1a_8"
  , actions$1 = "_actions_hrn1a_14"
  , actionButton$3 = "_actionButton_hrn1a_20"
  , insufficientFunds = "_insufficientFunds_hrn1a_24"
  , styles$c = {
    container: container$8,
    confirmationText: confirmationText$1,
    actions: actions$1,
    actionButton: actionButton$3,
    insufficientFunds
}
  , QuickBuy = () => {
    const {t: xt} = useTranslation()
      , {removeModal: Cn, setSelectedGiftForQuickBuy: as, gift: cs, balance: Cs} = useStorage(ga => ({
        removeModal: ga.modal.removeModal,
        gift: ga.gifts.selectedGiftForQuickBuy,
        setSelectedGiftForQuickBuy: ga.gifts.setSelectedGiftForQuickBuy,
        balance: ga.wallet.balance.hard
    }))
      , {mutate: Ls, isPending: Vs} = useBuyGift(ModalNames.QUICK_BUY)
      , Ws = () => {
        Cn(ModalNames.QUICK_BUY),
        as(null)
    }
      , Xs = reactExports.useMemo( () => ((cs == null ? void 0 : cs.salePrice) ?? 0) > Cs, [cs, Cs]);
    return cs ? jsxRuntimeExports.jsxs("div", {
        className: styles$c.container,
        children: [jsxRuntimeExports.jsx(GiftCard, {
            gift: cs
        }), jsxRuntimeExports.jsx("div", {
            className: styles$c.confirmationText,
            children: xt("text_purchase_text")
        }), Xs ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$c.insufficientFunds,
                children: xt("text_insufficient_funds")
            }), jsxRuntimeExports.jsx(Button, {
                className: styles$c.actionButton,
                onClick: Ws,
                children: xt("button_ok")
            })]
        }) : jsxRuntimeExports.jsxs("div", {
            className: styles$c.actions,
            children: [jsxRuntimeExports.jsx(Button, {
                loading: Vs,
                className: styles$c.actionButton,
                variant: "success",
                onClick: () => Ls([cs]),
                children: xt("button_yes")
            }), jsxRuntimeExports.jsx(Button, {
                disabled: Vs,
                className: styles$c.actionButton,
                onClick: Ws,
                variant: "error",
                children: xt("button_no")
            })]
        })]
    }) : null
}
  , container$7 = "_container_6ss8b_1"
  , confirmText$1 = "_confirmText_6ss8b_8"
  , actions = "_actions_6ss8b_18"
  , actionButton$2 = "_actionButton_6ss8b_24"
  , styles$b = {
    container: container$7,
    confirmText: confirmText$1,
    actions,
    actionButton: actionButton$2
}
  , usePromotions = () => {
    const xt = useQueryClient()
      , {addModal: Cn, updateBalance: as} = useStorage(cs => ({
        addModal: cs.modal.addModal,
        updateBalance: cs.wallet.updateBalance
    }));
    return useMutation({
        mutationFn: cs => promoteGift(cs),
        onSuccess: cs => {
            cs.status !== 200 ? Cn(ModalNames.ERROR, 0, {
                title: "Error",
                message: "Failed to promote gift. Please try again later."
            }) : (xt.invalidateQueries({
                queryKey: [QueryKeys.promotions]
            }),
            xt.invalidateQueries({
                queryKey: [QueryKeys.gifts]
            }),
            xt.invalidateQueries({
                queryKey: [QueryKeys.myGifts, "listed"]
            }),
            as(),
            Cn(ModalNames.GIFT_PROMOTION_SUCCESS, 0))
        }
        ,
        onError: cs => {
            console.error("Failed to promote gift:", cs),
            Cn(ModalNames.ERROR, 0, {
                title: "Error",
                message: "Failed to promote gift. Please try again later."
            })
        }
    })
}
  , GiftPromotionConfirm = () => {
    const {t: xt} = useTranslation()
      , {selectedGiftForPromotion: Cn, setSelectedGiftForPromotion: as, promotePrice: cs, removeModal: Cs} = useStorage(Xs => ({
        selectedGiftForPromotion: Xs.myGifts.selectedGiftForPromotion,
        setSelectedGiftForPromotion: Xs.myGifts.setSelectedGiftForPromotion,
        promotePrice: Xs.app.promotePrice,
        removeModal: Xs.modal.removeModal
    }))
      , {mutateAsync: Ls} = usePromotions()
      , Vs = async () => {
        Cs(ModalNames.GIFT_PROMOTION_CONFIRM),
        Cn && await Ls(Cn.id)
    }
      , Ws = () => {
        Cs(ModalNames.GIFT_PROMOTION_CONFIRM),
        as(null)
    }
    ;
    return Cn ? jsxRuntimeExports.jsxs("div", {
        className: styles$b.container,
        children: [jsxRuntimeExports.jsx(GiftCard, {
            gift: Cn
        }), jsxRuntimeExports.jsx("p", {
            className: styles$b.confirmText,
            children: xt("text_promote_gift", {
                value: formatNanotons(cs)
            })
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$b.actions,
            children: [jsxRuntimeExports.jsx(Button, {
                className: styles$b.actionButton,
                onClick: Vs,
                variant: "success",
                children: xt("button_yes")
            }), jsxRuntimeExports.jsx(Button, {
                className: styles$b.actionButton,
                onClick: Ws,
                variant: "error",
                children: xt("button_no")
            })]
        })]
    }) : null
}
  , container$6 = "_container_ezaac_1"
  , confirmText = "_confirmText_ezaac_8"
  , actionButton$1 = "_actionButton_ezaac_16"
  , styles$a = {
    container: container$6,
    confirmText,
    actionButton: actionButton$1
}
  , GiftPromotionSuccess = () => {
    const {t: xt} = useTranslation()
      , {selectedGiftForPromotion: Cn, setSelectedGiftForPromotion: as} = useStorage(Ls => Ls.myGifts)
      , {removeModal: cs} = useStorage(Ls => Ls.modal)
      , Cs = () => {
        cs(ModalNames.GIFT_PROMOTION_SUCCESS),
        as(null)
    }
    ;
    return Cn ? jsxRuntimeExports.jsxs("div", {
        className: styles$a.container,
        children: [jsxRuntimeExports.jsx(GiftCard, {
            gift: Cn
        }), jsxRuntimeExports.jsx("p", {
            className: styles$a.confirmText,
            children: xt("text_success_gift_promoted")
        }), jsxRuntimeExports.jsx(Button, {
            className: styles$a.actionButton,
            onClick: Cs,
            variant: "secondary",
            children: xt("button_nice")
        })]
    }) : null
}
  , container$5 = "_container_1v51b_1"
  , confirmationText = "_confirmationText_1v51b_8"
  , actionButton = "_actionButton_1v51b_14"
  , styles$9 = {
    container: container$5,
    confirmationText,
    actionButton
}
  , QuickBuyProofOfPurchase = () => {
    const {t: xt} = useTranslation()
      , {gift: Cn, removeModal: as, setSelectedGiftForQuickBuy: cs} = useStorage(Ls => ({
        gift: Ls.gifts.selectedGiftForQuickBuy,
        setSelectedGiftForQuickBuy: Ls.gifts.setSelectedGiftForQuickBuy,
        removeModal: Ls.modal.removeModal
    }))
      , Cs = () => {
        cs(null),
        as(ModalNames.QUICK_BUY_PROOF_OF_PURCHASE)
    }
    ;
    return Cn ? jsxRuntimeExports.jsxs("div", {
        className: styles$9.container,
        children: [jsxRuntimeExports.jsx(GiftCard, {
            gift: Cn
        }), jsxRuntimeExports.jsx("div", {
            className: styles$9.confirmationText,
            children: xt("text_gift_purchased")
        }), jsxRuntimeExports.jsx(Button, {
            className: styles$9.actionButton,
            onClick: Cs,
            children: xt("button_nice")
        })]
    }) : null
}
  , container$4 = "_container_1odsg_1"
  , styles$8 = {
    container: container$4
}
  , FiltersSearchbar = ({onClear: xt, ...Cn}) => {
    const {t: as} = useTranslation()
      , cs = () => Cn.value ? jsxRuntimeExports.jsx(SvgCloseIcon, {
        className: styles$v.inputIconClear,
        onClick: xt
    }) : jsxRuntimeExports.jsx(SvgLens, {});
    return jsxRuntimeExports.jsx(Input, {
        ...Cn,
        placeholder: as("Search..."),
        className: styles$v.input,
        containerClassName: styles$v.inputContainer,
        icon: cs()
    })
}
  , SelectAllCheckbox = ({checked: xt, onChange: Cn}) => {
    const {t: as} = useTranslation();
    return jsxRuntimeExports.jsx(Checkbox, {
        size: "small",
        label: jsxRuntimeExports.jsx("span", {
            className: styles$v.selectAllLabel,
            children: as("checkbox_select_all")
        }),
        checked: xt,
        onChange: Cn
    })
}
  , NothingFound = () => {
    const {t: xt} = useTranslation();
    return jsxRuntimeExports.jsx("div", {
        className: styles$v.nothingFound,
        children: xt("Nothing Found")
    })
}
  , defaultValues$4 = {
    collectionNames: []
}
  , FiltersCollection = () => {
    const xt = useQueryClient()
      , {filters: Cn, setFilters: as} = useStorage(Tl => Tl.filters)
      , {removeModal: cs} = useStorage(Tl => Tl.modal)
      , {data: Cs} = useQuery(collectionsQueryOptions())
      , [Ls,Vs] = reactExports.useState("")
      , Ws = useForm({
        defaultValues: defaultValues$4,
        values: {
            collectionNames: Cn.collectionNames
        },
        resolver: s(filtersSchema.pick({
            collectionNames: !0
        })),
        resetOptions: {
            keepDefaultValues: !0
        }
    })
      , {handleSubmit: Xs, getValues: ga, reset: ba, control: yl, setValue: xl} = Ws
      , wl = useWatch({
        control: yl,
        name: "collectionNames"
    })
      , _l = () => {
        as({
            ...Cn,
            ...ga()
        }),
        cs(ModalNames.FILTERS_COLLECTION),
        xt.invalidateQueries({
            queryKey: [QueryKeys.models],
            refetchType: "all"
        })
    }
      , El = () => {
        ba(defaultValues$4),
        as({
            ...Cn,
            ...defaultValues$4
        }),
        cs(ModalNames.FILTERS_COLLECTION),
        xt.invalidateQueries({
            queryKey: [QueryKeys.models],
            refetchType: "all"
        })
    }
      , Cl = reactExports.useMemo( () => Cs == null ? void 0 : Cs.filter(Tl => Ls ? Tl.name.toLowerCase().includes(Ls.toLowerCase()) : !0), [Ls, Cs])
      , $l = reactExports.useMemo( () => !!(Cl != null && Cl.every(Tl => wl.find(Rl => Rl === Tl.name))), [wl, Cl])
      , Sl = reactExports.useCallback(Tl => {
        if (Tl) {
            const Rl = [...new Set([...wl, ...(Cl == null ? void 0 : Cl.map(Il => Il.name)) ?? []])];
            xl("collectionNames", Rl)
        } else {
            const Rl = wl.filter(Il => !(Cl != null && Cl.some(Ml => Ml.name === Il)));
            xl("collectionNames", Rl)
        }
    }
    , [wl, Cl, xl]);
    return jsxRuntimeExports.jsx(FormProvider, {
        ...Ws,
        children: jsxRuntimeExports.jsxs("form", {
            className: styles$8.container,
            onSubmit: Xs(_l),
            children: [jsxRuntimeExports.jsx(FiltersSearchbar, {
                value: Ls,
                onChange: Tl => Vs(Tl.target.value),
                onClear: () => Vs("")
            }), (Cl == null ? void 0 : Cl.length) === 0 ? jsxRuntimeExports.jsx(NothingFound, {}) : jsxRuntimeExports.jsxs(CheckboxArrayContainer, {
                children: [jsxRuntimeExports.jsx(SelectAllCheckbox, {
                    checked: $l,
                    onChange: Sl
                }), jsxRuntimeExports.jsx(CollectionsCheckboxArray, {
                    options: Cl
                })]
            }), jsxRuntimeExports.jsx(FiltersControls, {
                onReset: El
            })]
        })
    })
}
  , container$3 = "_container_1odsg_1"
  , styles$7 = {
    container: container$3
}
  , defaultValues$3 = {
    modelNames: []
}
  , FiltersModel = () => {
    const {filters: xt, setFilters: Cn} = useStorage(Rl => Rl.filters)
      , {removeModal: as} = useStorage(Rl => Rl.modal)
      , [cs,Cs] = reactExports.useState("")
      , {collectionNames: Ls} = useFilters()
      , Vs = useForm({
        defaultValues: defaultValues$3,
        values: {
            modelNames: xt.modelNames
        },
        resolver: s(filtersSchema.pick({
            modelNames: !0
        })),
        resetOptions: {
            keepDefaultValues: !0
        }
    })
      , {handleSubmit: Ws, getValues: Xs, reset: ga, setValue: ba, control: yl} = Vs
      , {data: xl, isLoading: wl} = useQuery(modelsQueryOptions(Ls))
      , _l = useWatch({
        control: yl,
        name: "modelNames"
    });
    reactExports.useEffect( () => {
        Array.isArray(xl) && ba("modelNames", _l.filter(Rl => !!xl.find(Il => Il.modelName === Rl)))
    }
    , [xl]);
    const El = () => {
        Cn({
            ...xt,
            ...Xs()
        }),
        as(ModalNames.FILTERS_MODEL)
    }
      , Cl = () => {
        ga(defaultValues$3),
        Cn({
            ...xt,
            ...defaultValues$3
        }),
        as(ModalNames.FILTERS_MODEL)
    }
      , $l = reactExports.useMemo( () => xl == null ? void 0 : xl.filter(Rl => cs ? Rl.modelName.toLowerCase().includes(cs.toLowerCase()) : !0), [cs, xl])
      , Sl = reactExports.useMemo( () => !!($l != null && $l.every(Rl => _l.find(Il => Il === Rl.modelName))), [_l, $l])
      , Tl = reactExports.useCallback(Rl => {
        if (Rl) {
            const Il = [...new Set([..._l, ...($l == null ? void 0 : $l.map(Ml => Ml.modelName)) ?? []])];
            ba("modelNames", Il)
        } else {
            const Il = _l.filter(Ml => !($l != null && $l.some(Nl => Nl.modelName === Ml)));
            ba("modelNames", Il)
        }
    }
    , [_l, $l, ba]);
    return jsxRuntimeExports.jsx(FormProvider, {
        ...Vs,
        children: jsxRuntimeExports.jsxs("form", {
            className: styles$7.container,
            onSubmit: Ws(El),
            children: [jsxRuntimeExports.jsx(FiltersSearchbar, {
                value: cs,
                onChange: Rl => Cs(Rl.target.value),
                onClear: () => Cs("")
            }), ($l == null ? void 0 : $l.length) === 0 && Ls.length !== 0 ? jsxRuntimeExports.jsx(NothingFound, {}) : jsxRuntimeExports.jsxs(CheckboxArrayContainer, {
                children: [!!($l != null && $l.length) && Ls.length !== 0 && jsxRuntimeExports.jsx(SelectAllCheckbox, {
                    checked: Sl,
                    onChange: Tl
                }), jsxRuntimeExports.jsx(ModelsCheckboxArray, {
                    options: $l,
                    loading: wl
                })]
            }), jsxRuntimeExports.jsx(FiltersControls, {
                onReset: Cl
            })]
        })
    })
}
  , container$2 = "_container_1odsg_1"
  , styles$6 = {
    container: container$2
}
  , defaultValues$2 = {
    backdropNames: []
}
  , FiltersBackdrop = () => {
    const {filters: xt, setFilters: Cn} = useStorage(Tl => Tl.filters)
      , {removeModal: as} = useStorage(Tl => Tl.modal)
      , [cs,Cs] = reactExports.useState("")
      , {collectionNames: Ls} = useFilters()
      , {data: Vs} = useQuery(backdropsQueryOptions(Ls))
      , Ws = useForm({
        defaultValues: defaultValues$2,
        values: {
            backdropNames: xt.backdropNames
        },
        resolver: s(filtersSchema.pick({
            backdropNames: !0
        })),
        resetOptions: {
            keepDefaultValues: !0
        }
    })
      , {handleSubmit: Xs, getValues: ga, reset: ba, control: yl, setValue: xl} = Ws
      , wl = () => {
        Cn({
            ...xt,
            ...ga()
        }),
        as(ModalNames.FILTERS_BACKDROP)
    }
      , _l = () => {
        ba(defaultValues$2),
        Cn({
            ...xt,
            ...defaultValues$2
        }),
        as(ModalNames.FILTERS_BACKDROP)
    }
      , El = useWatch({
        control: yl,
        name: "backdropNames"
    })
      , Cl = reactExports.useMemo( () => Vs == null ? void 0 : Vs.filter(Tl => cs ? Tl.backdropName.toLowerCase().includes(cs.toLowerCase()) : !0), [cs, Vs])
      , $l = reactExports.useMemo( () => !!(Cl != null && Cl.every(Tl => El.find(Rl => Rl === Tl.backdropName))), [El, Cl])
      , Sl = reactExports.useCallback(Tl => {
        if (Tl) {
            const Rl = [...new Set([...El, ...(Cl == null ? void 0 : Cl.map(Il => Il.backdropName)) ?? []])];
            xl("backdropNames", Rl)
        } else {
            const Rl = El.filter(Il => !(Cl != null && Cl.some(Ml => Ml.backdropName === Il)));
            xl("backdropNames", Rl)
        }
    }
    , [El, Cl, xl]);
    return jsxRuntimeExports.jsx(FormProvider, {
        ...Ws,
        children: jsxRuntimeExports.jsxs("form", {
            className: styles$6.container,
            onSubmit: Xs(wl),
            children: [jsxRuntimeExports.jsx(FiltersSearchbar, {
                value: cs,
                onChange: Tl => Cs(Tl.target.value),
                onClear: () => Cs("")
            }), (Cl == null ? void 0 : Cl.length) === 0 ? jsxRuntimeExports.jsx(NothingFound, {}) : jsxRuntimeExports.jsxs(CheckboxArrayContainer, {
                children: [jsxRuntimeExports.jsx(SelectAllCheckbox, {
                    checked: $l,
                    onChange: Sl
                }), jsxRuntimeExports.jsx(BackdropsCheckboxArray, {
                    options: Cl
                })]
            }), jsxRuntimeExports.jsx(FiltersControls, {
                onReset: _l
            })]
        })
    })
}
  , container$1 = "_container_1odsg_1"
  , styles$5 = {
    container: container$1
}
  , defaultValues$1 = {
    symbolNames: []
}
  , FiltersSymbol = () => {
    const {filters: xt, setFilters: Cn} = useStorage(Tl => Tl.filters)
      , {removeModal: as} = useStorage(Tl => Tl.modal)
      , [cs,Cs] = reactExports.useState("")
      , {collectionNames: Ls} = useFilters()
      , {data: Vs} = useQuery(symbolsQueryOptions(Ls))
      , Ws = useForm({
        defaultValues: defaultValues$1,
        values: {
            symbolNames: xt.symbolNames
        },
        resolver: s(filtersSchema.pick({
            symbolNames: !0
        })),
        resetOptions: {
            keepDefaultValues: !0
        }
    })
      , {handleSubmit: Xs, getValues: ga, reset: ba, control: yl, setValue: xl} = Ws
      , wl = () => {
        Cn({
            ...xt,
            ...ga()
        }),
        as(ModalNames.FILTERS_SYMBOL)
    }
      , _l = () => {
        ba(defaultValues$1),
        Cn({
            ...xt,
            ...defaultValues$1
        }),
        as(ModalNames.FILTERS_SYMBOL)
    }
      , El = useWatch({
        control: yl,
        name: "symbolNames"
    })
      , Cl = reactExports.useMemo( () => Vs == null ? void 0 : Vs.filter(Tl => cs ? Tl.symbolName.toLowerCase().includes(cs.toLowerCase()) : !0), [cs, Vs])
      , $l = reactExports.useMemo( () => !!(Cl != null && Cl.every(Tl => El == null ? void 0 : El.find(Rl => Rl === Tl.symbolName))), [El, Cl])
      , Sl = reactExports.useCallback(Tl => {
        if (El != null && El.length)
            if (Tl) {
                const Rl = [...new Set([...El, ...(Cl == null ? void 0 : Cl.map(Il => Il.symbolName)) ?? []])];
                xl("symbolNames", Rl)
            } else {
                const Rl = El.filter(Il => !(Cl != null && Cl.some(Ml => Ml.symbolName === Il)));
                xl("symbolNames", Rl)
            }
    }
    , [El, Cl, xl]);
    return jsxRuntimeExports.jsx(FormProvider, {
        ...Ws,
        children: jsxRuntimeExports.jsxs("form", {
            className: styles$5.container,
            onSubmit: Xs(wl),
            children: [jsxRuntimeExports.jsx(FiltersSearchbar, {
                value: cs,
                onChange: Tl => Cs(Tl.target.value),
                onClear: () => Cs("")
            }), (Cl == null ? void 0 : Cl.length) === 0 ? jsxRuntimeExports.jsx(NothingFound, {}) : jsxRuntimeExports.jsxs(CheckboxArrayContainer, {
                children: [jsxRuntimeExports.jsx(SelectAllCheckbox, {
                    checked: $l,
                    onChange: Sl
                }), jsxRuntimeExports.jsx(SymbolsCheckboxArray, {
                    options: Cl
                })]
            }), jsxRuntimeExports.jsx(FiltersControls, {
                onReset: _l
            })]
        })
    })
}
  , styles$4 = {}
  , defaultValues = {
    minPrice: null,
    maxPrice: null
}
  , FiltersPrice = () => {
    const {filters: xt, setFilters: Cn} = useStorage(xl => xl.filters)
      , {removeModal: as} = useStorage(xl => xl.modal)
      , cs = useForm({
        defaultValues,
        values: {
            minPrice: xt.minPrice,
            maxPrice: xt.maxPrice
        },
        resolver: s(filtersSchema.pick({
            minPrice: !0,
            maxPrice: !0
        })),
        resetOptions: {
            keepDefaultValues: !0
        }
    })
      , {handleSubmit: Cs, getValues: Ls, reset: Vs, control: Ws} = cs
      , [Xs,ga] = useWatch({
        control: Ws,
        name: ["minPrice", "maxPrice"]
    })
      , ba = () => {
        Cn({
            ...xt,
            ...Ls()
        }),
        as(ModalNames.FILTERS_PRICE)
    }
      , yl = () => {
        Vs(defaultValues),
        Cn({
            ...xt,
            ...defaultValues
        }),
        as(ModalNames.FILTERS_PRICE)
    }
    ;
    return jsxRuntimeExports.jsx(FormProvider, {
        ...cs,
        children: jsxRuntimeExports.jsxs("form", {
            className: styles$4.container,
            onSubmit: Cs(ba),
            children: [jsxRuntimeExports.jsx(PriceRangeInput, {
                withLabel: !1
            }), jsxRuntimeExports.jsx(FiltersControls, {
                disabled: !Xs && !ga,
                onReset: yl
            })]
        })
    })
}
  , action = "_action_1joir_1"
  , styles$3 = {
    action
}
  , SvgRotateRight = xt => reactExports.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...xt
}, reactExports.createElement("path", {
    d: "M12.4084 4.23333C11.6834 4.01667 10.8834 3.875 10 3.875C6.00836 3.875 2.77502 7.10833 2.77502 11.1C2.77502 15.1 6.00836 18.3333 10 18.3333C13.9917 18.3333 17.225 15.1 17.225 11.1083C17.225 9.625 16.775 8.24167 16.0084 7.09167",
    stroke: "#0A84FF",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M13.4417 4.43341L11.0333 1.66675",
    stroke: "#0A84FF",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}), reactExports.createElement("path", {
    d: "M13.4416 4.43335L10.6333 6.48335",
    stroke: "#0A84FF",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}))
  , RefreshFeed = () => {
    const xt = useQueryClient()
      , Cn = reactExports.useCallback( () => {
        xt.invalidateQueries({
            queryKey: [QueryKeys.feed]
        })
    }
    , [xt])
      , as = !!useIsFetching({
        queryKey: [QueryKeys.feed]
    });
    return jsxRuntimeExports.jsx("div", {
        className: styles$3.container,
        children: jsxRuntimeExports.jsxs(Button, {
            loading: as,
            onClick: Cn,
            className: styles$3.action,
            children: [jsxRuntimeExports.jsx(SvgRotateRight, {}), "Refresh"]
        })
    })
}
  , wrapper = "_wrapper_lnzvv_1"
  , styles$2 = {
    wrapper
}
  , FeedSort = () => {
    const {t: xt} = useTranslation()
      , {feedLowToHigh: Cn, setFeedLowToHigh: as, feedOrdering: cs, setFeedOrdering: Cs} = useStorage(Ls => Ls.filters);
    return jsxRuntimeExports.jsxs("div", {
        className: styles$2.wrapper,
        children: [jsxRuntimeExports.jsxs(RadioGroup, {
            value: cs,
            onChange: Ls => Cs(Ls),
            children: [jsxRuntimeExports.jsx(Radio, {
                value: FeedOrdering.Latest,
                label: xt("sort_latest")
            }), jsxRuntimeExports.jsx(Radio, {
                value: FeedOrdering.Price,
                label: xt("sort_price")
            }), jsxRuntimeExports.jsx(Radio, {
                value: FeedOrdering.GiftNumber,
                label: xt("sort_gift_number")
            })]
        }), jsxRuntimeExports.jsx(Divider, {}), jsxRuntimeExports.jsxs(RadioGroup, {
            value: cs === FeedOrdering.Latest ? "" : String(Cn),
            onChange: Ls => as(Ls === "true"),
            children: [jsxRuntimeExports.jsx(Radio, {
                disabled: cs === FeedOrdering.Latest,
                value: "true",
                label: xt("sort_low_to_high")
            }), jsxRuntimeExports.jsx(Radio, {
                disabled: cs === FeedOrdering.Latest,
                value: "false",
                label: xt("sort_high_to_low")
            })]
        })]
    })
}
  , container = "_container_lkm9h_1"
  , divider = "_divider_lkm9h_8"
  , subheader = "_subheader_lkm9h_12"
  , styles$1 = {
    container,
    divider,
    subheader
}
  , TypesCheckboxArray = ({options: xt}) => {
    const {t: Cn} = useTranslation()
      , {control: as} = useFormContext()
      , {isChecked: cs, toggle: Cs} = useCheckboxArray()
      , Ls = Vs => {
        switch (Vs) {
        case FeedType.Sale:
            return Cn("type_sale");
        case FeedType.Listing:
            return Cn("type_listing");
        default:
            return ""
        }
    }
    ;
    return jsxRuntimeExports.jsx(Controller, {
        control: as,
        name: "type",
        render: ({field: Vs}) => jsxRuntimeExports.jsx(CheckboxArrayContainer, {
            children: xt == null ? void 0 : xt.map(Ws => jsxRuntimeExports.jsx(motion.div, {
                initial: {
                    opacity: 0,
                    height: 0
                },
                exit: {
                    opacity: 0,
                    height: 0
                },
                animate: {
                    opacity: 1,
                    height: 20
                },
                layout: !0,
                children: jsxRuntimeExports.jsx(Checkbox, {
                    size: "small",
                    label: jsxRuntimeExports.jsx("div", {
                        className: styles$v.backdropLabel,
                        children: Ls(Ws)
                    }),
                    checked: cs(Vs.value || [], Ws),
                    onChange: Xs => {
                        Vs.onChange(Cs(Vs.value || [], Ws, Xs))
                    }
                })
            }, Ws))
        })
    })
}
  , GiftNumberInput = () => {
    const {t: xt} = useTranslation()
      , {control: Cn} = useFormContext();
    return jsxRuntimeExports.jsx("div", {
        className: styles$v.inputContainer,
        children: jsxRuntimeExports.jsxs("div", {
            className: styles$v.priceWrapper,
            children: [jsxRuntimeExports.jsx("label", {
                className: styles$v.label,
                children: xt("sort_gift_number")
            }), jsxRuntimeExports.jsx(Controller, {
                name: "number",
                control: Cn,
                render: ({field: as}) => jsxRuntimeExports.jsx(Input, {
                    value: as.value ?? "",
                    onChange: cs => as.onChange(cs.target.value || null),
                    className: styles$v.input,
                    placeholder: xt("#"),
                    inputMode: "numeric",
                    pattern: "[0-9]*"
                })
            })]
        })
    })
}
  , FeedFiltersAll = () => {
    const {t: xt} = useTranslation()
      , {filters: Cn, setFilters: as, resetFilters: cs} = useStorage(Rl => Rl.filters)
      , {removeModal: Cs} = useStorage(Rl => Rl.modal)
      , {data: Ls} = useQuery(collectionsQueryOptions())
      , Vs = useForm({
        defaultValues: defaultFilterValues,
        values: Cn,
        resolver: s(feedFiltersSchema),
        resetOptions: {
            keepDefaultValues: !0
        }
    })
      , {control: Ws, handleSubmit: Xs, getValues: ga, reset: ba, setValue: yl} = Vs
      , xl = () => {
        as(ga()),
        Cs(ModalNames.FEED_FILTERS_ALL)
    }
      , wl = () => {
        ba(defaultFilterValues),
        cs(),
        Cs(ModalNames.FEED_FILTERS_ALL)
    }
      , [_l,El] = useWatch({
        control: Ws,
        name: ["collectionNames", "modelNames"]
    })
      , [Cl] = useDebouncedValue(_l, 1e3)
      , {data: $l, isLoading: Sl} = useQuery(modelsQueryOptions(Cl))
      , {data: Tl} = useQuery(backdropsQueryOptions(Cl));
    return reactExports.useEffect( () => {
        Array.isArray($l) && yl("modelNames", El.filter(Rl => !!$l.find(Il => Il.modelName === Rl)))
    }
    , [$l]),
    jsxRuntimeExports.jsx(FormProvider, {
        ...Vs,
        children: jsxRuntimeExports.jsxs("form", {
            className: styles$1.container,
            onSubmit: Xs(xl),
            children: [jsxRuntimeExports.jsx(Disclosure, {
                title: xt("filter_nft"),
                children: jsxRuntimeExports.jsx(CollectionsCheckboxArray, {
                    options: Ls
                })
            }), jsxRuntimeExports.jsx(Divider, {
                className: styles$1.divider
            }), jsxRuntimeExports.jsx("div", {
                className: styles$1.subheader,
                children: xt("text_traits")
            }), jsxRuntimeExports.jsx(Disclosure, {
                title: xt("filter_model"),
                children: jsxRuntimeExports.jsx(ModelsCheckboxArray, {
                    options: $l,
                    loading: Sl
                })
            }), jsxRuntimeExports.jsx(Disclosure, {
                title: xt("filter_backdrop"),
                children: jsxRuntimeExports.jsx(BackdropsCheckboxArray, {
                    options: Tl
                })
            }), jsxRuntimeExports.jsx(Disclosure, {
                title: xt("filter_type"),
                children: jsxRuntimeExports.jsx(TypesCheckboxArray, {
                    options: Object.values(FeedType)
                })
            }), jsxRuntimeExports.jsx(Divider, {
                className: styles$1.divider
            }), jsxRuntimeExports.jsx(GiftNumberInput, {}), jsxRuntimeExports.jsx(Divider, {
                className: styles$1.divider
            }), jsxRuntimeExports.jsx(FiltersControls, {
                onReset: wl
            })]
        })
    })
}
  , sweepBundleContainer = "_sweepBundleContainer_1w2qd_1"
  , sweepBundleContentContainer = "_sweepBundleContentContainer_1w2qd_9"
  , sweepBundleContentScroller = "_sweepBundleContentScroller_1w2qd_15"
  , sweepBundleControlsContainer = "_sweepBundleControlsContainer_1w2qd_27"
  , button = "_button_1w2qd_33"
  , styles = {
    sweepBundleContainer,
    sweepBundleContentContainer,
    sweepBundleContentScroller,
    sweepBundleControlsContainer,
    button
}
  , SweepBundle = () => {
    var Vs;
    const {t: xt} = useTranslation()
      , {removeModal: Cn, eventForOverview: as, setEventForOverview: cs, shareEvent: Cs} = useStorage(Ws => ({
        removeModal: Ws.modal.removeModal,
        eventForOverview: Ws.feed.eventForOverview,
        setEventForOverview: Ws.feed.setEventForOverview,
        shareEvent: Ws.feed.shareEvent
    }))
      , Ls = Ws => {
        Cs(Ws, xt)
    }
    ;
    return reactExports.useEffect( () => () => cs(null), []),
    jsxRuntimeExports.jsxs("div", {
        className: styles.sweepBundleContainer,
        children: [jsxRuntimeExports.jsx("div", {
            className: styles.sweepBundleContentContainer,
            children: jsxRuntimeExports.jsx("div", {
                className: styles.sweepBundleContentScroller,
                children: (Vs = as == null ? void 0 : as.gifts) == null ? void 0 : Vs.map( (Ws, Xs) => jsxRuntimeExports.jsx(CartGift, {
                    gift: Ws,
                    mode: "overview",
                    date: new Date
                }, Xs))
            })
        }), jsxRuntimeExports.jsxs("div", {
            className: styles.sweepBundleControlsContainer,
            children: [jsxRuntimeExports.jsx(Button, {
                className: styles.button,
                variant: "primary",
                onClick: () => Cn(ModalNames.SWEEP_BUNDLE),
                children: xt("button_nice")
            }), jsxRuntimeExports.jsx(Button, {
                onClick: () => {
                    as && Ls(as)
                }
                ,
                iconButton: !0,
                children: jsxRuntimeExports.jsx(SvgShare, {})
            })]
        })]
    })
}
  , createPopup = (xt, Cn, as) => function({onClose: Cs, isOpen: Ls}) {
    return jsxRuntimeExports.jsx(Popup, {
        onClose: Cs,
        isOpen: Ls,
        ...as,
        children: xt
    }, Cn)
}
  , createAlert = (xt, Cn, as) => function({onClose: Cs, isOpen: Ls}) {
    return jsxRuntimeExports.jsx(Alert, {
        onClose: Cs,
        isOpen: Ls,
        ...as,
        children: xt
    }, Cn)
}
  , modals = [{
    component: createAlert(jsxRuntimeExports.jsx(CancelSaleConfirm, {}), ModalNames.CANCEL_SALE_CONFIRM, {
        closeButton: !0
    }),
    name: ModalNames.CANCEL_SALE_CONFIRM
}, {
    component: createAlert(jsxRuntimeExports.jsx(Error$1, {}), ModalNames.ERROR, {
        closeButton: !0
    }),
    name: ModalNames.ERROR
}, {
    component: createAlert(jsxRuntimeExports.jsx(Congrats, {}), ModalNames.CONGRATS, {
        closeButton: !0
    }),
    name: ModalNames.CONGRATS
}, {
    component: createAlert(jsxRuntimeExports.jsx(ListGiftPrice, {}), ModalNames.LIST_GIFT_PRICE, {
        closeButton: !0
    }),
    name: ModalNames.LIST_GIFT_PRICE
}, {
    component: createAlert(jsxRuntimeExports.jsx(ListGiftConfirm, {}), ModalNames.LIST_GIFT_CONFIRM, {
        closeButton: !0
    }),
    name: ModalNames.LIST_GIFT_CONFIRM
}, {
    component: createAlert(jsxRuntimeExports.jsx(ListingSalesLimit, {}), ModalNames.LISTING_SALES_LIMIT, {
        closeButton: !0
    }),
    name: ModalNames.LISTING_SALES_LIMIT
}, {
    component: createAlert(jsxRuntimeExports.jsx(GiftWithdrawConfirm, {}), ModalNames.WITHDRAW_GIFT_CONFIRM, {
        closeButton: !0
    }),
    name: ModalNames.WITHDRAW_GIFT_CONFIRM
}, {
    component: createAlert(jsxRuntimeExports.jsx(MultipleGiftWithdrawConfirm, {}), ModalNames.MULTIPLE_WITHDRAW_CONFIRM, {
        closeButton: !0
    }),
    name: ModalNames.MULTIPLE_WITHDRAW_CONFIRM
}, {
    component: createAlert(jsxRuntimeExports.jsx(OutOfStock, {}), ModalNames.OUT_OF_STOCK, {
        closeButton: !0
    }),
    name: ModalNames.OUT_OF_STOCK
}, {
    component: createAlert(jsxRuntimeExports.jsx(QuickBuy, {}), ModalNames.QUICK_BUY, {
        closeButton: !0
    }),
    name: ModalNames.QUICK_BUY
}, {
    component: createAlert(jsxRuntimeExports.jsx(GiftPromotionConfirm, {}), ModalNames.GIFT_PROMOTION_CONFIRM, {
        closeButton: !0
    }),
    name: ModalNames.GIFT_PROMOTION_CONFIRM
}, {
    component: createAlert(jsxRuntimeExports.jsx(GiftPromotionSuccess, {}), ModalNames.GIFT_PROMOTION_SUCCESS, {
        closeButton: !0
    }),
    name: ModalNames.GIFT_PROMOTION_SUCCESS
}, {
    component: createAlert(jsxRuntimeExports.jsx(QuickBuyProofOfPurchase, {}), ModalNames.QUICK_BUY_PROOF_OF_PURCHASE, {
        closeButton: !0
    }),
    name: ModalNames.QUICK_BUY_PROOF_OF_PURCHASE
}, {
    component: createPopup(jsxRuntimeExports.jsx(Cart, {}), ModalNames.CART, {
        heading: jsxRuntimeExports.jsx(CartHeading, {})
    }),
    name: ModalNames.CART
}, {
    component: createPopup(jsxRuntimeExports.jsx(ProofOfPurchase, {}), ModalNames.PROOF_OF_PURCHASE, {
        heading: "text_shopping_results"
    }),
    name: ModalNames.PROOF_OF_PURCHASE
}, {
    component: createPopup(jsxRuntimeExports.jsx(FiltersAll, {}), ModalNames.FILTERS_ALL, {
        heading: "text_filters"
    }),
    name: ModalNames.FILTERS_ALL
}, {
    component: createPopup(jsxRuntimeExports.jsx(FiltersCollection, {}), ModalNames.FILTERS_COLLECTION, {
        heading: "filter_nft",
        fullHeight: !0
    }),
    name: ModalNames.FILTERS_COLLECTION
}, {
    component: createPopup(jsxRuntimeExports.jsx(FiltersModel, {}), ModalNames.FILTERS_MODEL, {
        heading: "filter_model",
        fullHeight: !0
    }),
    name: ModalNames.FILTERS_MODEL
}, {
    component: createPopup(jsxRuntimeExports.jsx(FiltersBackdrop, {}), ModalNames.FILTERS_BACKDROP, {
        heading: "filter_backdrop",
        fullHeight: !0
    }),
    name: ModalNames.FILTERS_BACKDROP
}, {
    component: createPopup(jsxRuntimeExports.jsx(FiltersSymbol, {}), ModalNames.FILTERS_SYMBOL, {
        heading: "filter_symbol",
        fullHeight: !0
    }),
    name: ModalNames.FILTERS_SYMBOL
}, {
    component: createPopup(jsxRuntimeExports.jsx(FiltersPrice, {}), ModalNames.FILTERS_PRICE, {
        heading: "filter_price"
    }),
    name: ModalNames.FILTERS_PRICE
}, {
    component: createPopup(jsxRuntimeExports.jsx(Sort, {}), ModalNames.SORT, {
        heading: "text_sort_by"
    }),
    name: ModalNames.SORT
}, {
    component: createPopup(jsxRuntimeExports.jsx(GiftOverview, {}), ModalNames.GIFT_OVERVIEW),
    name: ModalNames.GIFT_OVERVIEW
}, {
    component: createPopup(jsxRuntimeExports.jsx(MyGiftsActions, {}), ModalNames.MY_GIFTS_ACTIONS, {
        closeButton: !1,
        hasOverlay: !1
    }),
    name: ModalNames.MY_GIFTS_ACTIONS
}, {
    component: createAlert(jsxRuntimeExports.jsx(MultipleListingPrice, {}), ModalNames.MULTIPLE_LISTING_PRICE, {
        closeButton: !0
    }),
    name: ModalNames.MULTIPLE_LISTING_PRICE
}, {
    component: createAlert(jsxRuntimeExports.jsx(MultipleListingConfirm, {}), ModalNames.MULTIPLE_LISTING_CONFIRM, {
        closeButton: !0
    }),
    name: ModalNames.MULTIPLE_LISTING_CONFIRM
}, {
    component: createAlert(jsxRuntimeExports.jsx(Deposit, {}), ModalNames.DEPOSIT, {
        closeButton: !0
    }),
    name: ModalNames.DEPOSIT
}, {
    component: createAlert(jsxRuntimeExports.jsx(Withdraw, {}), ModalNames.WITHDRAW, {
        closeButton: !0
    }),
    name: ModalNames.WITHDRAW
}, {
    component: createAlert(jsxRuntimeExports.jsx(WalletDiconnectConfirm, {}), ModalNames.WALLET_DISCONNECT_COFIRM, {
        closeButton: !0
    }),
    name: ModalNames.WALLET_DISCONNECT_COFIRM
}, {
    component: createPopup(jsxRuntimeExports.jsx(Sweep, {}), ModalNames.SWEEP, {
        closeButton: !1,
        hasOverlay: !1
    }),
    name: ModalNames.SWEEP
}, {
    component: createPopup(jsxRuntimeExports.jsx(RefreshFeed, {}), ModalNames.REFRESH_FEED, {
        closeButton: !1,
        hasOverlay: !1
    }),
    name: ModalNames.REFRESH_FEED
}, {
    component: createAlert(jsxRuntimeExports.jsx(GiveawayCreation, {}), ModalNames.GA_CREATION, {
        closeButton: !0
    }),
    name: ModalNames.GA_CREATION
}, {
    component: createAlert(jsxRuntimeExports.jsx(GiveawayParticipation, {}), ModalNames.GA_PARTISIPATION, {
        closeButton: !0
    }),
    name: ModalNames.GA_PARTISIPATION
}, {
    component: createAlert(jsxRuntimeExports.jsx(GiveawayResultInfo, {}), ModalNames.GA_RESULT_INFO, {
        closeButton: !0
    }),
    name: ModalNames.GA_RESULT_INFO
}, {
    component: createAlert(jsxRuntimeExports.jsx(GiveawayReward, {}), ModalNames.GA_REWARD, {
        closeButton: !0
    }),
    name: ModalNames.GA_REWARD
}, {
    component: createPopup(jsxRuntimeExports.jsx(FeedSort, {}), ModalNames.FEED_SORT, {
        heading: "text_sort_by"
    }),
    name: ModalNames.FEED_SORT
}, {
    component: createPopup(jsxRuntimeExports.jsx(FeedFiltersAll, {}), ModalNames.FEED_FILTERS_ALL, {
        heading: "text_filters"
    }),
    name: ModalNames.FEED_FILTERS_ALL
}, {
    component: createPopup(jsxRuntimeExports.jsx(SweepBundle, {}), ModalNames.SWEEP_BUNDLE, {
        heading: "floor_header"
    }),
    name: ModalNames.SWEEP_BUNDLE
}]
  , ModalProvider = () => {
    const {modal: xt, queue: Cn} = useStorage(Cs => ({
        modal: Cs.modal,
        queue: Cs.modal.queue
    }))
      , as = Cn.reduce( (Cs, Ls) => (Cs[Ls.order] || (Cs[Ls.order] = Ls),
    Cs), {})
      , cs = reactExports.useCallback(Cs => {
        const Ls = Cn.find(Vs => Vs.name === Cs);
        Ls && xt.removeModal(Ls.name)
    }
    , [Cn, xt]);
    return jsxRuntimeExports.jsx("div", {
        children: modals.map(Cs => Cs.component({
            onClose: () => cs(Cs.name),
            isOpen: Object.values(as).some(Ls => Ls.name === Cs.name)
        }))
    })
}
  , GIVEAWAY_NOTIFICATION_ORDER_LAYER = 500
  , useGiveawayNotifications = () => {
    const {data: xt} = useQuery(giveawayNotificationsQueryOptions())
      , {mutate: Cn} = useClaimGiveawayNotification()
      , {addModal: as} = useStorage(cs => cs.modal);
    reactExports.useEffect( () => {
        xt && xt.length && xt.forEach( (cs, Cs) => {
            cs.type !== "Finish" && (as(ModalNames.GA_RESULT_INFO, GIVEAWAY_NOTIFICATION_ORDER_LAYER + Cs, {
                state: cs.type ?? "Win",
                giveawayId: cs.giveawayId,
                giftsIds: cs.giftsIds ?? []
            }),
            Cn(cs.id))
        }
        )
    }
    , [xt])
}
  , useSalesFee = () => {
    const {data: xt} = useQuery(giftsStatsQueryOptions())
      , {setSalesFee: Cn, setDiscount: as, fee: cs} = useStorage(Cs => ({
        setSalesFee: Cs.profile.setSalesFee,
        setDiscount: Cs.profile.setDiscount,
        fee: Cs.app.salesFee
    }));
    reactExports.useEffect( () => {
        const Cs = cs * 100 - ((xt == null ? void 0 : xt.discountPerLevel) || 0);
        Cn(Cs),
        as((xt == null ? void 0 : xt.discountPerLevel) || 0)
    }
    , [xt])
}
  , PrefetchBoundary = () => (useSuspenseQueries({
    queries: [collectionsQueryOptions(), backdropsQueryOptions([]), symbolsQueryOptions([])]
}),
useGiveawayNotifications(),
useSalesFee(),
jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {}));
function AnimatedRoutes() {
    const xt = useLocation();
    return jsxRuntimeExports.jsx(AnimatePresence, {
        mode: "wait",
        initial: !1,
        children: jsxRuntimeExports.jsxs(Routes, {
            location: xt,
            children: [routes.map(Cn => jsxRuntimeExports.jsx(Route, {
                path: Cn.path,
                element: Cn.element
            }, Cn.path)), jsxRuntimeExports.jsx(Route, {
                path: "*",
                element: jsxRuntimeExports.jsx(Navigate, {
                    to: "/"
                })
            })]
        }, xt.pathname)
    })
}
function App() {
    const {maintenance: xt, isAdmin: Cn, state: as, forbidden: cs} = useStorage(Vs => ({
        maintenance: Vs.app.maintenance,
        isAdmin: Vs.app.isAdmin,
        state: Vs.app.state,
        forbidden: Vs.app.forbidden
    }))
      , Cs = Pu()
      , Ls = ku(Xc.isDark);
    return APP_STATE.READY,
    jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: !Cn && xt || cs ? jsxRuntimeExports.jsx(Maintenance, {}) : as !== APP_STATE.READY ? jsxRuntimeExports.jsx(Loading, {}) : jsxRuntimeExports.jsx(AppRoot, {
            appearance: Ls ? "dark" : "light",
            platform: ["macos", "ios"].includes(Cs.platform) ? "ios" : "base",
            children: jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: jsxRuntimeExports.jsx(Loading, {}),
                children: jsxRuntimeExports.jsxs(HashRouter, {
                    children: [jsxRuntimeExports.jsx("div", {
                        className: styles$R.appContainer,
                        children: jsxRuntimeExports.jsx(AnimatedRoutes, {})
                    }), jsxRuntimeExports.jsx(ModalProvider, {}), jsxRuntimeExports.jsx(PrefetchBoundary, {})]
                })
            })
        })
    })
}
class ErrorBoundary extends reactExports.Component {
    constructor() {
        super(...arguments);
        B1(this, "state", {
            hasError: !1
        })
    }
    static getDerivedStateFromError(as) {
        return {
            hasError: !0,
            error: as
        }
    }
    componentDidCatch(as, cs) {
        console.error("Uncaught error:", as, cs)
    }
    render() {
        return this.state.hasError && this.props.fallback ? this.props.fallback(this.state.error) : this.props.children
    }
}
function publicUrl(xt) {
    return new URL(xt.replace(/^\/+/, ""),window.location.origin + "/").toString()
}
function ErrorBoundaryError(xt) {
    return jsxRuntimeExports.jsxs("div", {
        children: [jsxRuntimeExports.jsx("p", {
            children: "An unhandled error occurred:"
        }), jsxRuntimeExports.jsx("blockquote", {
            children: jsxRuntimeExports.jsx("code", {
                children: xt instanceof Error ? xt.message : typeof xt == "string" ? xt : JSON.stringify(xt)
            })
        })]
    })
}
function Root() {
    const {boostrap: xt} = useStorage(Cn => ({
        boostrap: Cn.app.bootstrap
    }));
    return reactExports.useEffect( () => {
        xt()
    }
    , []),
    jsxRuntimeExports.jsx(ErrorBoundary, {
        fallback: ErrorBoundaryError,
        children: jsxRuntimeExports.jsx(QueryProvider, {
            children: jsxRuntimeExports.jsx(TonConnectUIProvider$1, {
                manifestUrl: publicUrl("tonconnect-manifest.json"),
                children: jsxRuntimeExports.jsx(App, {})
            })
        })
    })
}
const scriptRel = "modulepreload"
  , assetsURL = function(xt) {
    return "/" + xt
}
  , seen = {}
  , __vitePreload = function xt(Cn, as, cs) {
    let Cs = Promise.resolve();
    if (as && as.length > 0) {
        document.getElementsByTagName("link");
        const Vs = document.querySelector("meta[property=csp-nonce]")
          , Ws = (Vs == null ? void 0 : Vs.nonce) || (Vs == null ? void 0 : Vs.getAttribute("nonce"));
        Cs = Promise.allSettled(as.map(Xs => {
            if (Xs = assetsURL(Xs),
            Xs in seen)
                return;
            seen[Xs] = !0;
            const ga = Xs.endsWith(".css")
              , ba = ga ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${Xs}"]${ba}`))
                return;
            const yl = document.createElement("link");
            if (yl.rel = ga ? "stylesheet" : scriptRel,
            ga || (yl.as = "script"),
            yl.crossOrigin = "",
            yl.href = Xs,
            Ws && yl.setAttribute("nonce", Ws),
            document.head.appendChild(yl),
            ga)
                return new Promise( (xl, wl) => {
                    yl.addEventListener("load", xl),
                    yl.addEventListener("error", () => wl(new Error(`Unable to preload CSS for ${Xs}`)))
                }
                )
        }
        ))
    }
    function Ls(Vs) {
        const Ws = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (Ws.payload = Vs,
        window.dispatchEvent(Ws),
        !Ws.defaultPrevented)
            throw Vs
    }
    return Cs.then(Vs => {
        for (const Ws of Vs || [])
            Ws.status === "rejected" && Ls(Ws.reason);
        return Cn().catch(Ls)
    }
    )
}
  , logInfo$1 = xt => console.log(`%c ${xt}`, "color: #EDF5FC; background: #077187; font-weight: bold; padding: 8px;")
  , logError = xt => console.log(`%c ${xt}`, "color: #EDF5FC; background: #D62839; font-weight: bold; padding: 8px;");
window.logError = logError;
window.logInfo = logInfo$1;
function init(xt) {
    ds.set(xt),
    Bu(),
    window.Telegram.WebApp && (window.Telegram.WebApp.disableVerticalSwipes(),
    window.Telegram.WebApp.enableClosingConfirmation()),
    Hc.isSupported() && Hc.mount(),
    Xc.mount(),
    su.mount(),
    Yc.restore(),
    au.mount().catch(as => {
        console.error("Something went wrong mounting the viewport", as)
    }
    );
    const Cn = "#000000";
    Xc.bindCssVars(),
    Xc.setHeaderColor(Cn),
    Xc.setBackgroundColor(Cn),
    Xc.setBottomBarColor(Cn),
    su.bindCssVars(),
    window.Telegram.WebApp && (window.Telegram.WebApp.ready(),
    au.requestFullscreen.isAvailable() && !au.isChangingFullscreen() && au.requestFullscreen.ifAvailable()),
    xt && __vitePreload( () => import("./eruda-itkFROAA.js").then(as => as.e), []).then(as => as.default.init()).catch(console.error)
}
init(Y$2().startParam === "debug" || !1);
instance.use(initReactI18next).init({
    ns: "translation",
    resources: {},
    lng: "en",
    fallbackLng: "en",
    debug: !1
});
client.createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(Root, {}));
export {getDefaultExportFromCjs as g};
